import 'dart:core';
import 'package:flutter/cupertino.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/gestures.dart';
import 'package:flutter/material.dart';
import 'package:flutter/physics.dart';
import 'package:flutter/rendering.dart';
import 'package:flutter/scheduler.dart';
import 'package:flutter/services.dart';

//  import 'dart:ui';
//  import 'dart:math';
import 'dart:ui' as ui;
import 'dart:math' as math;

import '../../models/input.dart';
import '../widgets_data.dart';

const double _borderRadius = 40;
const int defaultRowsPerPage = 10;

Widget _defaultContextMenuBuilder(
    BuildContext context, EditableTextState editableTextState) {
  return CupertinoAdaptiveTextSelectionToolbar.editableText(
    editableTextState: editableTextState,
  );
}

const Color _kDefaultTabBarBorderColor = CupertinoDynamicColor.withBrightness(
  color: Color(0x4D000000),
  darkColor: Color(0x29000000),
);

class _DefaultHeroTag {
  const _DefaultHeroTag();
  @override
  String toString() => '<default FloatingActionButton tag>';
}

class _DefaultSnapshotPainter implements SnapshotPainter {
  const _DefaultSnapshotPainter();

  @override
  void addListener(ui.VoidCallback listener) {}

  @override
  void dispose() {}

  @override
  bool get hasListeners => false;

  @override
  void notifyListeners() {}

  @override
  void paint(PaintingContext context, ui.Offset offset, ui.Size size,
      PaintingContextCallback painter) {
    painter(context, offset);
  }

  @override
  void paintSnapshot(PaintingContext context, ui.Offset offset, ui.Size size,
      ui.Image image, Size sourceSize, double pixelRatio) {
    final Rect src = Rect.fromLTWH(0, 0, sourceSize.width, sourceSize.height);
    final Rect dst =
        Rect.fromLTWH(offset.dx, offset.dy, size.width, size.height);
    final Paint paint = Paint()..filterQuality = FilterQuality.low;
    context.canvas.drawImageRect(image, src, dst, paint);
  }

  @override
  void removeListener(ui.VoidCallback listener) {}

  @override
  bool shouldRepaint(covariant _DefaultSnapshotPainter oldPainter) => false;
}

dynamic allclassConstructors<
        T extends Object,
        D extends Diagnosticable,
        S extends State,
        H extends HitTestTarget,
        K extends KeyboardKey,
        L extends Layer,
        E extends Enum,
        N extends num,
        M extends Element?,
        J,
        V>(String className, List<String> parameters,
    Map<String, List<InputData>> datas, String type,
    [List<Map<String, dynamic>> vars = const [],
    List<Map<String, String>> props = const []]) {
  Map<String, String> maps = {};
  if (parameters.isNotEmpty) {
    print("inputParameters = $parameters, length = ${parameters.length}");

    for (int i = 0; i < parameters.length; i++) {
      final parameter = parameters[i];
      String key, value;
      if (parameter.isNotEmpty) {
        final strings = customBracedSplitting(parameter, ": () {");
        if (strings.length > 1) {
          key = strings[0];
          final colIndex = parameter.indexOf(": () {");
          value = parameter.substring(colIndex + 1).trim();
        } else {
          key = "$i";
          value = parameter;
        }
        print("key = $key, value = $value");
        maps[key] = value;
      }
    }
  }
  return {
    "AboutDialog": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final applicationName =
          getValue(maps["applicationName"], datas, "String?", vars, props);
      final applicationVersion =
          getValue(maps["applicationVersion"], datas, "String?", vars, props);
      final applicationIcon =
          getValue(maps["applicationIcon"], datas, "Widget?", vars, props);
      final applicationLegalese =
          getValue(maps["applicationLegalese"], datas, "String?", vars, props);
      final children =
          getValue(maps["children"], datas, "List<Widget>?", vars, props);
      return AboutDialog(
          key: key,
          applicationName: applicationName,
          applicationVersion: applicationVersion,
          applicationIcon: applicationIcon,
          applicationLegalese: applicationLegalese,
          children: children != null ? List<Widget>.from(children) : null);
    },
    "AboutListTile": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final icon = getValue(maps["icon"], datas, "Widget?", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      final applicationName =
          getValue(maps["applicationName"], datas, "String?", vars, props);
      final applicationVersion =
          getValue(maps["applicationVersion"], datas, "String?", vars, props);
      final applicationIcon =
          getValue(maps["applicationIcon"], datas, "Widget?", vars, props);
      final applicationLegalese =
          getValue(maps["applicationLegalese"], datas, "String?", vars, props);
      final aboutBoxChildren = getValue(
          maps["aboutBoxChildren"], datas, "List<Widget>?", vars, props);
      final dense = getValue(maps["dense"], datas, "bool?", vars, props);
      return AboutListTile(
          key: key,
          icon: icon,
          child: child,
          applicationName: applicationName,
          applicationVersion: applicationVersion,
          applicationIcon: applicationIcon,
          applicationLegalese: applicationLegalese,
          aboutBoxChildren: aboutBoxChildren != null
              ? List<Widget>.from(aboutBoxChildren)
              : null,
          dense: dense);
    },
    "AbsorbPointer": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final absorbing = getValue(maps["absorbing"], datas, "bool", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      final ignoringSemantics =
          getValue(maps["ignoringSemantics"], datas, "bool?", vars, props);
      return AbsorbPointer(
          key: key,
          absorbing: absorbing ?? true,
          child: child,
          ignoringSemantics: ignoringSemantics);
    },
    "Accumulator": () {
      final _value = getValue(maps["0"], datas, "int", vars, props);
      return Accumulator(_value ?? 0);
    },
    "Action.overridable": () {
      final defaultAction =
          getValue(maps["defaultAction"], datas, "Action<T>", vars, props);
      final context =
          getValue(maps["context"], datas, "BuildContext", vars, props);
      if (defaultAction == null || context == null) {
        return null;
      }
      return Action.overridable(
          defaultAction: defaultAction!, context: context!);
    },
    "ActionChip": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final avatar = getValue(maps["avatar"], datas, "Widget?", vars, props);
      final label = getValue(maps["label"], datas, "Widget", vars, props);
      final labelStyle =
          getValue(maps["labelStyle"], datas, "TextStyle?", vars, props);
      final labelPadding = getValue(
          maps["labelPadding"], datas, "EdgeInsetsGeometry?", vars, props);
      final onPressed =
          getValue(maps["onPressed"], datas, "VoidCallback?", vars, props);
      final pressElevation =
          getValue(maps["pressElevation"], datas, "double?", vars, props);
      final tooltip = getValue(maps["tooltip"], datas, "String?", vars, props);
      final side = getValue(maps["side"], datas, "BorderSide?", vars, props);
      final shape =
          getValue(maps["shape"], datas, "OutlinedBorder?", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      final focusNode =
          getValue(maps["focusNode"], datas, "FocusNode?", vars, props);
      final autofocus = getValue(maps["autofocus"], datas, "bool", vars, props);
      final backgroundColor =
          getValue(maps["backgroundColor"], datas, "Color?", vars, props);
      final disabledColor =
          getValue(maps["disabledColor"], datas, "Color?", vars, props);
      final padding =
          getValue(maps["padding"], datas, "EdgeInsetsGeometry?", vars, props);
      final visualDensity =
          getValue(maps["visualDensity"], datas, "VisualDensity?", vars, props);
      final materialTapTargetSize = getValue(maps["materialTapTargetSize"],
          datas, "MaterialTapTargetSize?", vars, props);
      final elevation =
          getValue(maps["elevation"], datas, "double?", vars, props);
      final shadowColor =
          getValue(maps["shadowColor"], datas, "Color?", vars, props);
      final surfaceTintColor =
          getValue(maps["surfaceTintColor"], datas, "Color?", vars, props);
      final iconTheme =
          getValue(maps["iconTheme"], datas, "IconThemeData?", vars, props);
      if (label == null) {
        return null;
      }
      return ActionChip(
          key: key,
          avatar: avatar,
          label: label!,
          labelStyle: labelStyle,
          labelPadding: labelPadding,
          onPressed: onPressed,
          pressElevation: pressElevation,
          tooltip: tooltip,
          side: side,
          shape: shape,
          clipBehavior: clipBehavior ?? Clip.none,
          focusNode: focusNode,
          autofocus: autofocus ?? false,
          backgroundColor: backgroundColor,
          disabledColor: disabledColor,
          padding: padding,
          visualDensity: visualDensity,
          materialTapTargetSize: materialTapTargetSize,
          elevation: elevation,
          shadowColor: shadowColor,
          surfaceTintColor: surfaceTintColor,
          iconTheme: iconTheme);
    },
    "ActionDispatcher": () {
      return const ActionDispatcher();
    },
    "ActionIconTheme": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final data =
          getValue(maps["data"], datas, "ActionIconThemeData", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (data == null || child == null) {
        return null;
      }
      return ActionIconTheme(key: key, data: data!, child: child!);
    },
    "ActionIconThemeData": () {
      final backButtonIconBuilder = getValue(
          maps["backButtonIconBuilder"], datas, "WidgetBuilder?", vars, props);
      final closeButtonIconBuilder = getValue(
          maps["closeButtonIconBuilder"], datas, "WidgetBuilder?", vars, props);
      final drawerButtonIconBuilder = getValue(maps["drawerButtonIconBuilder"],
          datas, "WidgetBuilder?", vars, props);
      final endDrawerButtonIconBuilder = getValue(
          maps["endDrawerButtonIconBuilder"],
          datas,
          "WidgetBuilder?",
          vars,
          props);
      return ActionIconThemeData(
          backButtonIconBuilder: backButtonIconBuilder,
          closeButtonIconBuilder: closeButtonIconBuilder,
          drawerButtonIconBuilder: drawerButtonIconBuilder,
          endDrawerButtonIconBuilder: endDrawerButtonIconBuilder);
    },
    "ActionListener": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final listener = getValue(
          maps["listener"], datas, "ActionListenerCallback", vars, props);
      final action =
          getValue(maps["action"], datas, "Action<Intent>", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (listener == null || action == null || child == null) {
        return null;
      }
      return ActionListener(
          key: key, listener: listener!, action: action!, child: child!);
    },
    "Actions": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final dispatcher =
          getValue(maps["dispatcher"], datas, "ActionDispatcher?", vars, props);
      final actions = getValue(
          maps["actions"], datas, "Map<Type, Action<Intent>>", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (actions == null || child == null) {
        return null;
      }
      return Actions(
          key: key,
          dispatcher: dispatcher,
          actions: Map<Type, Action<Intent>>.from(actions!),
          child: child!);
    },
    "ActivateIntent": () {
      return const ActivateIntent();
    },
    "AdaptiveTextSelectionToolbar": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final children =
          getValue(maps["children"], datas, "List<Widget>?", vars, props);
      final anchors = getValue(
          maps["anchors"], datas, "TextSelectionToolbarAnchors", vars, props);
      if (children == null || anchors == null) {
        return null;
      }
      return AdaptiveTextSelectionToolbar(
          key: key, anchors: anchors!, children: List<Widget>.from(children!));
    },
    "AdaptiveTextSelectionToolbar.buttonItems": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final buttonItems = getValue(maps["buttonItems"], datas,
          "List<ContextMenuButtonItem>?", vars, props);
      final anchors = getValue(
          maps["anchors"], datas, "TextSelectionToolbarAnchors", vars, props);
      if (buttonItems == null || anchors == null) {
        return null;
      }
      return AdaptiveTextSelectionToolbar.buttonItems(
          key: key,
          buttonItems: List<ContextMenuButtonItem>.from(buttonItems!),
          anchors: anchors!);
    },
    "AdaptiveTextSelectionToolbar.editable": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final clipboardStatus = getValue(
          maps["clipboardStatus"], datas, "ClipboardStatus", vars, props);
      final onCopy =
          getValue(maps["onCopy"], datas, "VoidCallback?", vars, props);
      final onCut =
          getValue(maps["onCut"], datas, "VoidCallback?", vars, props);
      final onPaste =
          getValue(maps["onPaste"], datas, "VoidCallback?", vars, props);
      final onSelectAll =
          getValue(maps["onSelectAll"], datas, "VoidCallback?", vars, props);
      final onLookUp =
          getValue(maps["onLookUp"], datas, "VoidCallback?", vars, props);

      final onSearchWeb =
          getValue(maps["onSearchWeb"], datas, "VoidCallback?", vars, props);

      final onShare =
          getValue(maps["onShare"], datas, "VoidCallback?", vars, props);

      final onLiveTextInput = getValue(
          maps["onLiveTextInput"], datas, "VoidCallback?", vars, props);
      final anchors = getValue(
          maps["anchors"], datas, "TextSelectionToolbarAnchors", vars, props);
      if (clipboardStatus == null ||
          onCopy == null ||
          onCut == null ||
          onPaste == null ||
          onSelectAll == null ||
          anchors == null ||
          onShare == null ||
          onSearchWeb == null ||
          onLookUp == null ||
          onLiveTextInput == null) {
        return null;
      }
      return AdaptiveTextSelectionToolbar.editable(
        key: key,
        clipboardStatus: clipboardStatus!,
        onCopy: onCopy!,
        onCut: onCut!,
        onPaste: onPaste!,
        onSelectAll: onSelectAll!,
        anchors: anchors!,
        onLookUp: onLookUp,
        onSearchWeb: onSearchWeb,
        onShare: onShare,
        onLiveTextInput: onLiveTextInput,
      );
    },
    "AdaptiveTextSelectionToolbar.editableText": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final editableTextState = getValue(
          maps["editableTextState"], datas, "EditableTextState", vars, props);
      if (editableTextState == null) {
        return null;
      }
      return AdaptiveTextSelectionToolbar.editableText(
          key: key, editableTextState: editableTextState!);
    },
    "AdaptiveTextSelectionToolbar.selectable": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final onCopy =
          getValue(maps["onCopy"], datas, "VoidCallback", vars, props);
      final onSelectAll =
          getValue(maps["onSelectAll"], datas, "VoidCallback", vars, props);

      final onShare =
          getValue(maps["onShare"], datas, "VoidCallback?", vars, props);

      final selectionGeometry = getValue(
          maps["selectionGeometry"], datas, "SelectionGeometry", vars, props);
      final anchors = getValue(
          maps["anchors"], datas, "TextSelectionToolbarAnchors", vars, props);
      if (onCopy == null ||
          onSelectAll == null ||
          selectionGeometry == null ||
          anchors == null) {
        return null;
      }
      return AdaptiveTextSelectionToolbar.selectable(
        key: key,
        onCopy: onCopy!,
        onSelectAll: onSelectAll!,
        selectionGeometry: selectionGeometry!,
        anchors: anchors!,
       // onShare: onShare,
      );
    },
    "AdaptiveTextSelectionToolbar.selectableRegion": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final selectableRegionState = getValue(maps["selectableRegionState"],
          datas, "SelectableRegionState", vars, props);
      if (selectableRegionState == null) {
        return null;
      }
      return AdaptiveTextSelectionToolbar.selectableRegion(
          key: key, selectableRegionState: selectableRegionState!);
    },
    "AlertDialog": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final icon = getValue(maps["icon"], datas, "Widget?", vars, props);
      final iconPadding = getValue(
          maps["iconPadding"], datas, "EdgeInsetsGeometry?", vars, props);
      final iconColor =
          getValue(maps["iconColor"], datas, "Color?", vars, props);
      final title = getValue(maps["title"], datas, "Widget?", vars, props);
      final titlePadding = getValue(
          maps["titlePadding"], datas, "EdgeInsetsGeometry?", vars, props);
      final titleTextStyle =
          getValue(maps["titleTextStyle"], datas, "TextStyle?", vars, props);
      final content = getValue(maps["content"], datas, "Widget?", vars, props);
      final contentPadding = getValue(
          maps["contentPadding"], datas, "EdgeInsetsGeometry?", vars, props);
      final contentTextStyle =
          getValue(maps["contentTextStyle"], datas, "TextStyle?", vars, props);
      final actions =
          getValue(maps["actions"], datas, "List<Widget>?", vars, props);
      final actionsPadding = getValue(
          maps["actionsPadding"], datas, "EdgeInsetsGeometry?", vars, props);
      final actionsAlignment = getValue(
          maps["actionsAlignment"], datas, "MainAxisAlignment?", vars, props);
      final actionsOverflowAlignment = getValue(
          maps["actionsOverflowAlignment"],
          datas,
          "OverflowBarAlignment?",
          vars,
          props);
      final actionsOverflowDirection = getValue(
          maps["actionsOverflowDirection"],
          datas,
          "VerticalDirection?",
          vars,
          props);
      final actionsOverflowButtonSpacing = getValue(
          maps["actionsOverflowButtonSpacing"], datas, "double?", vars, props);
      final buttonPadding = getValue(
          maps["buttonPadding"], datas, "EdgeInsetsGeometry?", vars, props);
      final backgroundColor =
          getValue(maps["backgroundColor"], datas, "Color?", vars, props);
      final elevation =
          getValue(maps["elevation"], datas, "double?", vars, props);
      final shadowColor =
          getValue(maps["shadowColor"], datas, "Color?", vars, props);
      final surfaceTintColor =
          getValue(maps["surfaceTintColor"], datas, "Color?", vars, props);
      final semanticLabel =
          getValue(maps["semanticLabel"], datas, "String?", vars, props);
      final insetPadding =
          getValue(maps["insetPadding"], datas, "EdgeInsets", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      final shape = getValue(maps["shape"], datas, "ShapeBorder?", vars, props);
      final alignment =
          getValue(maps["alignment"], datas, "AlignmentGeometry?", vars, props);
      final scrollable =
          getValue(maps["scrollable"], datas, "bool", vars, props);
      if (insetPadding != null) {
        return AlertDialog(
            key: key,
            icon: icon,
            iconPadding: iconPadding,
            iconColor: iconColor,
            title: title,
            titlePadding: titlePadding,
            titleTextStyle: titleTextStyle,
            content: content,
            contentPadding: contentPadding,
            contentTextStyle: contentTextStyle,
            actions: actions != null ? List<Widget>.from(actions) : null,
            actionsPadding: actionsPadding,
            actionsAlignment: actionsAlignment,
            actionsOverflowAlignment: actionsOverflowAlignment,
            actionsOverflowDirection: actionsOverflowDirection,
            actionsOverflowButtonSpacing: actionsOverflowButtonSpacing,
            buttonPadding: buttonPadding,
            backgroundColor: backgroundColor,
            elevation: elevation,
            shadowColor: shadowColor,
            surfaceTintColor: surfaceTintColor,
            semanticLabel: semanticLabel,
            clipBehavior: clipBehavior ?? Clip.none,
            shape: shape,
            alignment: alignment,
            scrollable: scrollable ?? false,
            insetPadding: insetPadding);
      }
      return AlertDialog(
          key: key,
          icon: icon,
          iconPadding: iconPadding,
          iconColor: iconColor,
          title: title,
          titlePadding: titlePadding,
          titleTextStyle: titleTextStyle,
          content: content,
          contentPadding: contentPadding,
          contentTextStyle: contentTextStyle,
          actions: actions != null ? List<Widget>.from(actions) : null,
          actionsPadding: actionsPadding,
          actionsAlignment: actionsAlignment,
          actionsOverflowAlignment: actionsOverflowAlignment,
          actionsOverflowDirection: actionsOverflowDirection,
          actionsOverflowButtonSpacing: actionsOverflowButtonSpacing,
          buttonPadding: buttonPadding,
          backgroundColor: backgroundColor,
          elevation: elevation,
          shadowColor: shadowColor,
          surfaceTintColor: surfaceTintColor,
          semanticLabel: semanticLabel,
          clipBehavior: clipBehavior ?? Clip.none,
          shape: shape,
          alignment: alignment,
          scrollable: scrollable ?? false);
    },
    "Align": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final alignment =
          getValue(maps["alignment"], datas, "AlignmentGeometry", vars, props);
      final widthFactor =
          getValue(maps["widthFactor"], datas, "double?", vars, props);
      final heightFactor =
          getValue(maps["heightFactor"], datas, "double?", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      return Align(
          key: key,
          alignment: alignment ?? Alignment.center,
          widthFactor: widthFactor,
          heightFactor: heightFactor,
          child: child);
    },
    "AlignTransition": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final alignment = getValue(maps["alignment"], datas,
          "Animation<AlignmentGeometry>", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      final widthFactor =
          getValue(maps["widthFactor"], datas, "double?", vars, props);
      final heightFactor =
          getValue(maps["heightFactor"], datas, "double?", vars, props);
      if (alignment == null || child == null) {
        return null;
      }
      return AlignTransition(
          key: key,
          alignment: alignment!,
          child: child!,
          widthFactor: widthFactor,
          heightFactor: heightFactor);
    },
    "AlignmentDirectional": () {
      final start = getValue(maps["0"], datas, "double", vars, props);
      final y = getValue(maps["1"], datas, "double", vars, props);
      if (start == null || y == null) {
        return null;
      }
      return AlignmentDirectional(start!, y!);
    },
    "AlignmentGeometryTween": () {
      final begin = getValue(maps["begin"], datas, "T?", vars, props);
      final end = getValue(maps["end"], datas, "T?", vars, props);
      return AlignmentGeometryTween(begin: begin, end: end);
    },
    "AlignmentTween": () {
      final begin = getValue(maps["begin"], datas, "T?", vars, props);
      final end = getValue(maps["end"], datas, "T?", vars, props);
      return AlignmentTween(begin: begin, end: end);
    },
    "AlwaysScrollableScrollPhysics": () {
      final parent =
          getValue(maps["parent"], datas, "ScrollPhysics?", vars, props);
      return AlwaysScrollableScrollPhysics(parent: parent);
    },
    "AlwaysStoppedAnimation": () {
      final value = getValue(maps["0"], datas, "T", vars, props);
      if (value == null) {
        return null;
      }
      return AlwaysStoppedAnimation(value!);
    },
    "AndroidPointerProperties": () {
      final id = getValue(maps["id"], datas, "int", vars, props);
      final toolType = getValue(maps["toolType"], datas, "int", vars, props);
      if (id == null || toolType == null) {
        return null;
      }
      return AndroidPointerProperties(id: id!, toolType: toolType!);
    },
    "AndroidView": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final viewType = getValue(maps["viewType"], datas, "String", vars, props);
      final onPlatformViewCreated = getValue(maps["onPlatformViewCreated"],
          datas, "PlatformViewCreatedCallback?", vars, props);
      final hitTestBehavior = getValue(maps["hitTestBehavior"], datas,
          "PlatformViewHitTestBehavior", vars, props);
      final layoutDirection = getValue(
          maps["layoutDirection"], datas, "TextDirection?", vars, props);
      final gestureRecognizers = getValue(maps["gestureRecognizers"], datas,
          "Set<Factory<OneSequenceGestureRecognizer>>?", vars, props);
      final creationParams =
          getValue(maps["creationParams"], datas, "dynamic", vars, props);
      final creationParamsCodec = getValue(maps["creationParamsCodec"], datas,
          "MessageCodec<dynamic>?", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      if (viewType == null) {
        return null;
      }
      return AndroidView(
          key: key,
          viewType: viewType!,
          onPlatformViewCreated: onPlatformViewCreated,
          hitTestBehavior:
              hitTestBehavior ?? PlatformViewHitTestBehavior.opaque,
          layoutDirection: layoutDirection,
          gestureRecognizers: gestureRecognizers
              ? Set<Factory<OneSequenceGestureRecognizer>>.from(
                  gestureRecognizers)
              : null,
          creationParams: creationParams,
          creationParamsCodec: creationParamsCodec,
          clipBehavior: clipBehavior ?? Clip.hardEdge);
    },
    "AndroidViewSurface": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final controller = getValue(
          maps["controller"], datas, "AndroidViewController", vars, props);
      final hitTestBehavior = getValue(maps["hitTestBehavior"], datas,
          "PlatformViewHitTestBehavior", vars, props);
      final gestureRecognizers = getValue(maps["gestureRecognizers"], datas,
          "Set<Factory<OneSequenceGestureRecognizer>>", vars, props);
      if (controller == null ||
          hitTestBehavior == null ||
          gestureRecognizers == null) {
        return null;
      }
      return AndroidViewSurface(
          key: key,
          controller: controller!,
          hitTestBehavior: hitTestBehavior!,
          gestureRecognizers: Set<Factory<OneSequenceGestureRecognizer>>.from(
              gestureRecognizers!));
    },
    "Animatable.fromCallback": () {
      final callback =
          getValue(maps["0"], datas, "AnimatableCallback<T>", vars, props);
      if (callback == null) {
        return null;
      }
      return Animatable.fromCallback(callback!);
    },
    "AnimatedAlign": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final alignment =
          getValue(maps["alignment"], datas, "AlignmentGeometry", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      final heightFactor =
          getValue(maps["heightFactor"], datas, "double?", vars, props);
      final widthFactor =
          getValue(maps["widthFactor"], datas, "double?", vars, props);
      final curve = getValue(maps["curve"], datas, "Curve", vars, props);
      final duration =
          getValue(maps["duration"], datas, "Duration", vars, props);
      final onEnd =
          getValue(maps["onEnd"], datas, "VoidCallback?", vars, props);
      if (alignment == null || duration == null) {
        return null;
      }
      return AnimatedAlign(
          key: key,
          alignment: alignment!,
          child: child,
          heightFactor: heightFactor,
          widthFactor: widthFactor,
          curve: curve ?? Curves.linear,
          duration: duration!,
          onEnd: onEnd);
    },
    "AnimatedBuilder": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final animation =
          getValue(maps["animation"], datas, "Listenable", vars, props);
      final builder =
          getValue(maps["builder"], datas, "TransitionBuilder", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      if (animation == null || builder == null) {
        return null;
      }
      return AnimatedBuilder(
          key: key, animation: animation!, builder: builder!, child: child);
    },
    "AnimatedContainer": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final alignment =
          getValue(maps["alignment"], datas, "AlignmentGeometry?", vars, props);
      final padding =
          getValue(maps["padding"], datas, "EdgeInsetsGeometry?", vars, props);
      final color = getValue(maps["color"], datas, "Color?", vars, props);
      final decoration =
          getValue(maps["decoration"], datas, "Decoration?", vars, props);
      final foregroundDecoration = getValue(
          maps["foregroundDecoration"], datas, "Decoration?", vars, props);
      final width = getValue(maps["width"], datas, "double?", vars, props);
      final height = getValue(maps["height"], datas, "double?", vars, props);
      final constraints =
          getValue(maps["constraints"], datas, "BoxConstraints?", vars, props);
      final margin =
          getValue(maps["margin"], datas, "EdgeInsetsGeometry?", vars, props);
      final transform =
          getValue(maps["transform"], datas, "Matrix4?", vars, props);
      final transformAlignment = getValue(
          maps["transformAlignment"], datas, "AlignmentGeometry?", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      final curve = getValue(maps["curve"], datas, "Curve", vars, props);
      final duration =
          getValue(maps["duration"], datas, "Duration", vars, props);
      final onEnd =
          getValue(maps["onEnd"], datas, "VoidCallback?", vars, props);
      if (duration == null) {
        return null;
      }
      return AnimatedContainer(
          key: key,
          alignment: alignment,
          padding: padding,
          color: color,
          decoration: decoration,
          foregroundDecoration: foregroundDecoration,
          width: width,
          height: height,
          constraints: constraints,
          margin: margin,
          transform: transform,
          transformAlignment: transformAlignment,
          child: child,
          clipBehavior: clipBehavior ?? Clip.none,
          curve: curve ?? Curves.linear,
          duration: duration!,
          onEnd: onEnd);
    },
    "AnimatedCrossFade": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final firstChild =
          getValue(maps["firstChild"], datas, "Widget", vars, props);
      final secondChild =
          getValue(maps["secondChild"], datas, "Widget", vars, props);
      final firstCurve =
          getValue(maps["firstCurve"], datas, "Curve", vars, props);
      final secondCurve =
          getValue(maps["secondCurve"], datas, "Curve", vars, props);
      final sizeCurve =
          getValue(maps["sizeCurve"], datas, "Curve", vars, props);
      final alignment =
          getValue(maps["alignment"], datas, "AlignmentGeometry", vars, props);
      final crossFadeState = getValue(
          maps["crossFadeState"], datas, "CrossFadeState", vars, props);
      final duration =
          getValue(maps["duration"], datas, "Duration", vars, props);
      final reverseDuration =
          getValue(maps["reverseDuration"], datas, "Duration?", vars, props);
      final layoutBuilder = getValue(maps["layoutBuilder"], datas,
          "AnimatedCrossFadeBuilder", vars, props);
      final excludeBottomFocus =
          getValue(maps["excludeBottomFocus"], datas, "bool", vars, props);
      if (firstChild == null ||
          secondChild == null ||
          crossFadeState == null ||
          duration == null) {
        return null;
      }
      if (layoutBuilder != null) {
        return AnimatedCrossFade(
            key: key,
            firstChild: firstChild!,
            secondChild: secondChild!,
            firstCurve: firstCurve ?? Curves.linear,
            secondCurve: secondCurve ?? Curves.linear,
            sizeCurve: sizeCurve ?? Curves.linear,
            alignment: alignment ?? Alignment.topCenter,
            crossFadeState: crossFadeState!,
            duration: duration!,
            reverseDuration: reverseDuration,
            excludeBottomFocus: excludeBottomFocus ?? true,
            layoutBuilder: layoutBuilder);
      }
      return AnimatedCrossFade(
          key: key,
          firstChild: firstChild!,
          secondChild: secondChild!,
          firstCurve: firstCurve ?? Curves.linear,
          secondCurve: secondCurve ?? Curves.linear,
          sizeCurve: sizeCurve ?? Curves.linear,
          alignment: alignment ?? Alignment.topCenter,
          crossFadeState: crossFadeState!,
          duration: duration!,
          reverseDuration: reverseDuration,
          excludeBottomFocus: excludeBottomFocus ?? true);
    },
    "AnimatedDefaultTextStyle": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      final style = getValue(maps["style"], datas, "TextStyle", vars, props);
      final textAlign =
          getValue(maps["textAlign"], datas, "TextAlign?", vars, props);
      final softWrap = getValue(maps["softWrap"], datas, "bool", vars, props);
      final overflow =
          getValue(maps["overflow"], datas, "TextOverflow", vars, props);
      final maxLines = getValue(maps["maxLines"], datas, "int?", vars, props);
      final textWidthBasis = getValue(
          maps["textWidthBasis"], datas, "TextWidthBasis", vars, props);
      final textHeightBehavior = getValue(maps["textHeightBehavior"], datas,
          "TextHeightBehavior?", vars, props);
      final curve = getValue(maps["curve"], datas, "Curve", vars, props);
      final duration =
          getValue(maps["duration"], datas, "Duration", vars, props);
      final onEnd =
          getValue(maps["onEnd"], datas, "VoidCallback?", vars, props);
      if (child == null || style == null || duration == null) {
        return null;
      }
      return AnimatedDefaultTextStyle(
          key: key,
          child: child!,
          style: style!,
          textAlign: textAlign,
          softWrap: softWrap ?? true,
          overflow: overflow ?? TextOverflow.clip,
          maxLines: maxLines,
          textWidthBasis: textWidthBasis ?? TextWidthBasis.parent,
          textHeightBehavior: textHeightBehavior,
          curve: curve ?? Curves.linear,
          duration: duration!,
          onEnd: onEnd);
    },
    "AnimatedFractionallySizedBox": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final alignment =
          getValue(maps["alignment"], datas, "AlignmentGeometry", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      final heightFactor =
          getValue(maps["heightFactor"], datas, "double?", vars, props);
      final widthFactor =
          getValue(maps["widthFactor"], datas, "double?", vars, props);
      final curve = getValue(maps["curve"], datas, "Curve", vars, props);
      final duration =
          getValue(maps["duration"], datas, "Duration", vars, props);
      final onEnd =
          getValue(maps["onEnd"], datas, "VoidCallback?", vars, props);
      if (duration == null) {
        return null;
      }
      return AnimatedFractionallySizedBox(
          key: key,
          alignment: alignment ?? Alignment.center,
          child: child,
          heightFactor: heightFactor,
          widthFactor: widthFactor,
          curve: curve ?? Curves.linear,
          duration: duration!,
          onEnd: onEnd);
    },
    "AnimatedGrid": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final itemBuilder = getValue(
          maps["itemBuilder"], datas, "AnimatedItemBuilder", vars, props);
      final gridDelegate = getValue(
          maps["gridDelegate"], datas, "SliverGridDelegate", vars, props);
      final initialItemCount =
          getValue(maps["initialItemCount"], datas, "int", vars, props);
      final scrollDirection =
          getValue(maps["scrollDirection"], datas, "Axis", vars, props);
      final reverse = getValue(maps["reverse"], datas, "bool", vars, props);
      final controller =
          getValue(maps["controller"], datas, "ScrollController?", vars, props);
      final primary = getValue(maps["primary"], datas, "bool?", vars, props);
      final physics =
          getValue(maps["physics"], datas, "ScrollPhysics?", vars, props);
      final padding =
          getValue(maps["padding"], datas, "EdgeInsetsGeometry?", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      if (itemBuilder == null || gridDelegate == null) {
        return null;
      }
      return AnimatedGrid(
          key: key,
          itemBuilder: itemBuilder!,
          gridDelegate: gridDelegate!,
          initialItemCount: initialItemCount ?? 0,
          scrollDirection: scrollDirection ?? Axis.vertical,
          reverse: reverse ?? false,
          controller: controller,
          primary: primary,
          physics: physics,
          padding: padding,
          clipBehavior: clipBehavior ?? Clip.hardEdge);
    },
    "AnimatedIcon": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final icon =
          getValue(maps["icon"], datas, "AnimatedIconData", vars, props);
      final progress =
          getValue(maps["progress"], datas, "Animation<double>", vars, props);
      final color = getValue(maps["color"], datas, "Color?", vars, props);
      final size = getValue(maps["size"], datas, "double?", vars, props);
      final semanticLabel =
          getValue(maps["semanticLabel"], datas, "String?", vars, props);
      final textDirection =
          getValue(maps["textDirection"], datas, "TextDirection?", vars, props);
      if (icon == null || progress == null) {
        return null;
      }
      return AnimatedIcon(
          key: key,
          icon: icon!,
          progress: progress!,
          color: color,
          size: size,
          semanticLabel: semanticLabel,
          textDirection: textDirection);
    },
    "AnimatedList": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final itemBuilder = getValue(
          maps["itemBuilder"], datas, "AnimatedItemBuilder", vars, props);
      final initialItemCount =
          getValue(maps["initialItemCount"], datas, "int", vars, props);
      final scrollDirection =
          getValue(maps["scrollDirection"], datas, "Axis", vars, props);
      final reverse = getValue(maps["reverse"], datas, "bool", vars, props);
      final controller =
          getValue(maps["controller"], datas, "ScrollController?", vars, props);
      final primary = getValue(maps["primary"], datas, "bool?", vars, props);
      final physics =
          getValue(maps["physics"], datas, "ScrollPhysics?", vars, props);
      final shrinkWrap =
          getValue(maps["shrinkWrap"], datas, "bool", vars, props);
      final padding =
          getValue(maps["padding"], datas, "EdgeInsetsGeometry?", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      if (itemBuilder == null) {
        return null;
      }
      return AnimatedList(
          key: key,
          itemBuilder: itemBuilder!,
          initialItemCount: initialItemCount ?? 0,
          scrollDirection: scrollDirection ?? Axis.vertical,
          reverse: reverse ?? false,
          controller: controller,
          primary: primary,
          physics: physics,
          shrinkWrap: shrinkWrap ?? false,
          padding: padding,
          clipBehavior: clipBehavior ?? Clip.hardEdge);
    },
    "AnimatedModalBarrier": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final color =
          getValue(maps["color"], datas, "Animation<Color?>", vars, props);
      final dismissible =
          getValue(maps["dismissible"], datas, "bool", vars, props);
      final semanticsLabel =
          getValue(maps["semanticsLabel"], datas, "String?", vars, props);
      final barrierSemanticsDismissible = getValue(
          maps["barrierSemanticsDismissible"], datas, "bool?", vars, props);
      final onDismiss =
          getValue(maps["onDismiss"], datas, "VoidCallback?", vars, props);
      final clipDetailsNotifier = getValue(maps["clipDetailsNotifier"], datas,
          "ValueNotifier<EdgeInsets>?", vars, props);
      final semanticsOnTapHint =
          getValue(maps["semanticsOnTapHint"], datas, "String?", vars, props);
      if (color == null) {
        return null;
      }
      return AnimatedModalBarrier(
          key: key,
          color: color!,
          dismissible: dismissible ?? true,
          semanticsLabel: semanticsLabel,
          barrierSemanticsDismissible: barrierSemanticsDismissible,
          onDismiss: onDismiss,
          clipDetailsNotifier: clipDetailsNotifier,
          semanticsOnTapHint: semanticsOnTapHint);
    },
    "AnimatedOpacity": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      final opacity = getValue(maps["opacity"], datas, "double", vars, props);
      final curve = getValue(maps["curve"], datas, "Curve", vars, props);
      final duration =
          getValue(maps["duration"], datas, "Duration", vars, props);
      final onEnd =
          getValue(maps["onEnd"], datas, "VoidCallback?", vars, props);
      final alwaysIncludeSemantics =
          getValue(maps["alwaysIncludeSemantics"], datas, "bool", vars, props);
      if (opacity == null || duration == null) {
        return null;
      }
      return AnimatedOpacity(
          key: key,
          child: child,
          opacity: opacity!,
          curve: curve ?? Curves.linear,
          duration: duration!,
          onEnd: onEnd,
          alwaysIncludeSemantics: alwaysIncludeSemantics ?? false);
    },
    "AnimatedPadding": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final padding =
          getValue(maps["padding"], datas, "EdgeInsetsGeometry", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      final curve = getValue(maps["curve"], datas, "Curve", vars, props);
      final duration =
          getValue(maps["duration"], datas, "Duration", vars, props);
      final onEnd =
          getValue(maps["onEnd"], datas, "VoidCallback?", vars, props);
      if (padding == null || duration == null) {
        return null;
      }
      return AnimatedPadding(
          key: key,
          padding: padding!,
          child: child,
          curve: curve ?? Curves.linear,
          duration: duration!,
          onEnd: onEnd);
    },
    "AnimatedPhysicalModel": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      final shape = getValue(maps["shape"], datas, "BoxShape", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      final borderRadius =
          getValue(maps["borderRadius"], datas, "BorderRadius", vars, props);
      final elevation =
          getValue(maps["elevation"], datas, "double", vars, props);
      final color = getValue(maps["color"], datas, "Color", vars, props);
      final animateColor =
          getValue(maps["animateColor"], datas, "bool", vars, props);
      final shadowColor =
          getValue(maps["shadowColor"], datas, "Color", vars, props);
      final animateShadowColor =
          getValue(maps["animateShadowColor"], datas, "bool", vars, props);
      final curve = getValue(maps["curve"], datas, "Curve", vars, props);
      final duration =
          getValue(maps["duration"], datas, "Duration", vars, props);
      final onEnd =
          getValue(maps["onEnd"], datas, "VoidCallback?", vars, props);
      if (child == null ||
          shape == null ||
          elevation == null ||
          color == null ||
          shadowColor == null ||
          duration == null) {
        return null;
      }
      return AnimatedPhysicalModel(
          key: key,
          child: child!,
          shape: shape!,
          clipBehavior: clipBehavior ?? Clip.none,
          borderRadius: borderRadius ?? BorderRadius.zero,
          elevation: elevation!,
          color: color!,
          animateColor: animateColor ?? true,
          shadowColor: shadowColor!,
          animateShadowColor: animateShadowColor ?? true,
          curve: curve ?? Curves.linear,
          duration: duration!,
          onEnd: onEnd);
    },
    "AnimatedPositioned": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      final left = getValue(maps["left"], datas, "double?", vars, props);
      final top = getValue(maps["top"], datas, "double?", vars, props);
      final right = getValue(maps["right"], datas, "double?", vars, props);
      final bottom = getValue(maps["bottom"], datas, "double?", vars, props);
      final width = getValue(maps["width"], datas, "double?", vars, props);
      final height = getValue(maps["height"], datas, "double?", vars, props);
      final curve = getValue(maps["curve"], datas, "Curve", vars, props);
      final duration =
          getValue(maps["duration"], datas, "Duration", vars, props);
      final onEnd =
          getValue(maps["onEnd"], datas, "VoidCallback?", vars, props);
      if (child == null || duration == null) {
        return null;
      }
      return AnimatedPositioned(
          key: key,
          child: child!,
          left: left,
          top: top,
          right: right,
          bottom: bottom,
          width: width,
          height: height,
          curve: curve ?? Curves.linear,
          duration: duration!,
          onEnd: onEnd);
    },
    "AnimatedPositioned.fromRect": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      final rect = getValue(maps["rect"], datas, "Rect", vars, props);
      final curve = getValue(maps["curve"], datas, "Curve", vars, props);
      final duration =
          getValue(maps["duration"], datas, "Duration", vars, props);
      final onEnd =
          getValue(maps["onEnd"], datas, "VoidCallback?", vars, props);
      if (child == null || rect == null || duration == null) {
        return null;
      }
      return AnimatedPositioned.fromRect(
          key: key,
          child: child!,
          rect: rect!,
          curve: curve ?? Curves.linear,
          duration: duration!,
          onEnd: onEnd);
    },
    "AnimatedPositionedDirectional": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      final start = getValue(maps["start"], datas, "double?", vars, props);
      final top = getValue(maps["top"], datas, "double?", vars, props);
      final end = getValue(maps["end"], datas, "double?", vars, props);
      final bottom = getValue(maps["bottom"], datas, "double?", vars, props);
      final width = getValue(maps["width"], datas, "double?", vars, props);
      final height = getValue(maps["height"], datas, "double?", vars, props);
      final curve = getValue(maps["curve"], datas, "Curve", vars, props);
      final duration =
          getValue(maps["duration"], datas, "Duration", vars, props);
      final onEnd =
          getValue(maps["onEnd"], datas, "VoidCallback?", vars, props);
      if (child == null || duration == null) {
        return null;
      }
      return AnimatedPositionedDirectional(
          key: key,
          child: child!,
          start: start,
          top: top,
          end: end,
          bottom: bottom,
          width: width,
          height: height,
          curve: curve ?? Curves.linear,
          duration: duration!,
          onEnd: onEnd);
    },
    "AnimatedRotation": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      final turns = getValue(maps["turns"], datas, "double", vars, props);
      final alignment =
          getValue(maps["alignment"], datas, "Alignment", vars, props);
      final filterQuality =
          getValue(maps["filterQuality"], datas, "FilterQuality?", vars, props);
      final curve = getValue(maps["curve"], datas, "Curve", vars, props);
      final duration =
          getValue(maps["duration"], datas, "Duration", vars, props);
      final onEnd =
          getValue(maps["onEnd"], datas, "VoidCallback?", vars, props);
      if (turns == null || duration == null) {
        return null;
      }
      return AnimatedRotation(
          key: key,
          child: child,
          turns: turns!,
          alignment: alignment ?? Alignment.center,
          filterQuality: filterQuality,
          curve: curve ?? Curves.linear,
          duration: duration!,
          onEnd: onEnd);
    },
    "AnimatedScale": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      final scale = getValue(maps["scale"], datas, "double", vars, props);
      final alignment =
          getValue(maps["alignment"], datas, "Alignment", vars, props);
      final filterQuality =
          getValue(maps["filterQuality"], datas, "FilterQuality?", vars, props);
      final curve = getValue(maps["curve"], datas, "Curve", vars, props);
      final duration =
          getValue(maps["duration"], datas, "Duration", vars, props);
      final onEnd =
          getValue(maps["onEnd"], datas, "VoidCallback?", vars, props);
      if (scale == null || duration == null) {
        return null;
      }
      return AnimatedScale(
          key: key,
          child: child,
          scale: scale!,
          alignment: alignment ?? Alignment.center,
          filterQuality: filterQuality,
          curve: curve ?? Curves.linear,
          duration: duration!,
          onEnd: onEnd);
    },
    "AnimatedSize": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      final alignment =
          getValue(maps["alignment"], datas, "AlignmentGeometry", vars, props);
      final curve = getValue(maps["curve"], datas, "Curve", vars, props);
      final duration =
          getValue(maps["duration"], datas, "Duration", vars, props);
      final reverseDuration =
          getValue(maps["reverseDuration"], datas, "Duration?", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      if (duration == null) {
        return null;
      }
      return AnimatedSize(
          key: key,
          child: child,
          alignment: alignment ?? Alignment.center,
          curve: curve ?? Curves.linear,
          duration: duration!,
          reverseDuration: reverseDuration,
          clipBehavior: clipBehavior ?? Clip.hardEdge);
    },
    "AnimatedSlide": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      final offset = getValue(maps["offset"], datas, "Offset", vars, props);
      final curve = getValue(maps["curve"], datas, "Curve", vars, props);
      final duration =
          getValue(maps["duration"], datas, "Duration", vars, props);
      final onEnd =
          getValue(maps["onEnd"], datas, "VoidCallback?", vars, props);
      if (offset == null || duration == null) {
        return null;
      }
      return AnimatedSlide(
          key: key,
          child: child,
          offset: offset!,
          curve: curve ?? Curves.linear,
          duration: duration!,
          onEnd: onEnd);
    },
    "AnimatedSwitcher": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      final duration =
          getValue(maps["duration"], datas, "Duration", vars, props);
      final reverseDuration =
          getValue(maps["reverseDuration"], datas, "Duration?", vars, props);
      final switchInCurve =
          getValue(maps["switchInCurve"], datas, "Curve", vars, props);
      final switchOutCurve =
          getValue(maps["switchOutCurve"], datas, "Curve", vars, props);
      final transitionBuilder = getValue(maps["transitionBuilder"], datas,
          "AnimatedSwitcherTransitionBuilder", vars, props);
      final layoutBuilder = getValue(maps["layoutBuilder"], datas,
          "AnimatedSwitcherLayoutBuilder", vars, props);
      if (duration == null) {
        return null;
      }
      return AnimatedSwitcher(
          key: key,
          child: child,
          duration: duration!,
          reverseDuration: reverseDuration,
          switchInCurve: switchInCurve ?? Curves.linear,
          switchOutCurve: switchOutCurve ?? Curves.linear,
          transitionBuilder:
              transitionBuilder ?? AnimatedSwitcher.defaultTransitionBuilder,
          layoutBuilder:
              layoutBuilder ?? AnimatedSwitcher.defaultLayoutBuilder);
    },
    "AnimatedTheme": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final data = getValue(maps["data"], datas, "ThemeData", vars, props);
      final curve = getValue(maps["curve"], datas, "Curve", vars, props);
      final duration =
          getValue(maps["duration"], datas, "Duration", vars, props);
      final onEnd =
          getValue(maps["onEnd"], datas, "VoidCallback?", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (data == null || child == null) {
        return null;
      }
      if (duration != null) {
        return AnimatedTheme(
            key: key,
            data: data!,
            curve: curve ?? Curves.linear,
            onEnd: onEnd,
            child: child!,
            duration: duration);
      }
      return AnimatedTheme(
          key: key,
          data: data!,
          curve: curve ?? Curves.linear,
          onEnd: onEnd,
          child: child!);
    },
    "Animation.fromValueListenable": () {
      final listenable =
          getValue(maps["0"], datas, "ValueListenable<T>", vars, props);
      final transformer = getValue(maps["transformer"], datas,
          "ValueListenableTransformer<T>?", vars, props);
      if (listenable == null) {
        return null;
      }
      return Animation.fromValueListenable(listenable!,
          transformer: transformer);
    },
    "AnimationController": () {
      final value = getValue(maps["value"], datas, "double?", vars, props);
      final duration =
          getValue(maps["duration"], datas, "Duration?", vars, props);
      final reverseDuration =
          getValue(maps["reverseDuration"], datas, "Duration?", vars, props);
      final debugLabel =
          getValue(maps["debugLabel"], datas, "String?", vars, props);
      final lowerBound =
          getValue(maps["lowerBound"], datas, "double", vars, props);
      final upperBound =
          getValue(maps["upperBound"], datas, "double", vars, props);
      final animationBehavior = getValue(
          maps["animationBehavior"], datas, "AnimationBehavior", vars, props);
      final vsync =
          getValue(maps["vsync"], datas, "TickerProvider", vars, props);
      if (vsync == null) {
        return null;
      }
      return AnimationController(
          value: value,
          duration: duration,
          reverseDuration: reverseDuration,
          debugLabel: debugLabel,
          lowerBound: lowerBound ?? 0.0,
          upperBound: upperBound ?? 1.0,
          animationBehavior: animationBehavior ?? AnimationBehavior.normal,
          vsync: vsync!);
    },
    "AnimationController.unbounded": () {
      final value = getValue(maps["value"], datas, "double", vars, props);
      final duration =
          getValue(maps["duration"], datas, "Duration?", vars, props);
      final reverseDuration =
          getValue(maps["reverseDuration"], datas, "Duration?", vars, props);
      final debugLabel =
          getValue(maps["debugLabel"], datas, "String?", vars, props);
      final vsync =
          getValue(maps["vsync"], datas, "TickerProvider", vars, props);
      final animationBehavior = getValue(
          maps["animationBehavior"], datas, "AnimationBehavior", vars, props);
      if (vsync == null) {
        return null;
      }
      return AnimationController.unbounded(
          value: value ?? 0.0,
          duration: duration,
          reverseDuration: reverseDuration,
          debugLabel: debugLabel,
          vsync: vsync!,
          animationBehavior: animationBehavior ?? AnimationBehavior.preserve);
    },
    "AnimationMax": () {
      final first = getValue(maps["0"], datas, "Animation<T>", vars, props);
      final next = getValue(maps["1"], datas, "Animation<T>", vars, props);
      if (first == null || next == null) {
        return null;
      }
      return AnimationMax(first!, next!);
    },
    "AnimationMin": () {
      final first = getValue(maps["0"], datas, "Animation<T>", vars, props);
      final next = getValue(maps["1"], datas, "Animation<T>", vars, props);
      if (first == null || next == null) {
        return null;
      }
      return AnimationMin(first!, next!);
    },
    "AnnotatedRegion": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      final value = getValue(maps["value"], datas, "T", vars, props);
      final sized = getValue(maps["sized"], datas, "bool", vars, props);
      if (child == null || value == null) {
        return null;
      }
      return AnnotatedRegion<T>(
          key: key, child: child!, value: value!, sized: sized ?? true);
    },
    "AnnotatedRegionLayer": () {
      final value = getValue(maps["0"], datas, "T", vars, props);
      final size = getValue(maps["size"], datas, "Size?", vars, props);
      final offset = getValue(maps["offset"], datas, "Offset?", vars, props);
      final opaque = getValue(maps["opaque"], datas, "bool", vars, props);
      if (value == null) {
        return null;
      }
      return AnnotatedRegionLayer<T>(value!,
          size: size, offset: offset, opaque: opaque ?? false);
    },
    "AnnotationEntry": () {
      final annotation = getValue(maps["annotation"], datas, "T", vars, props);
      final localPosition =
          getValue(maps["localPosition"], datas, "Offset", vars, props);
      if (annotation == null || localPosition == null) {
        return null;
      }
      return AnnotationEntry(
          annotation: annotation!, localPosition: localPosition!);
    },
    "AnnounceSemanticsEvent": () {
      final message = getValue(maps["0"], datas, "String", vars, props);
      final textDirection =
          getValue(maps["1"], datas, "TextDirection", vars, props);
      final assertiveness =
          getValue(maps["assertiveness"], datas, "Assertiveness", vars, props);
      if (message == null || textDirection == null) {
        return null;
      }
      return AnnounceSemanticsEvent(message!, textDirection!,
          assertiveness: assertiveness ?? Assertiveness.polite);
    },
    "AppBar": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final leading = getValue(maps["leading"], datas, "Widget?", vars, props);
      final automaticallyImplyLeading = getValue(
          maps["automaticallyImplyLeading"], datas, "bool", vars, props);
      final title = getValue(maps["title"], datas, "Widget?", vars, props);
      final actions =
          getValue(maps["actions"], datas, "List<Widget>?", vars, props);
      final flexibleSpace =
          getValue(maps["flexibleSpace"], datas, "Widget?", vars, props);
      final bottom =
          getValue(maps["bottom"], datas, "PreferredSizeWidget?", vars, props);
      final elevation =
          getValue(maps["elevation"], datas, "double?", vars, props);
      final scrolledUnderElevation = getValue(
          maps["scrolledUnderElevation"], datas, "double?", vars, props);
      final notificationPredicate = getValue(maps["notificationPredicate"],
          datas, "ScrollNotificationPredicate", vars, props);
      final shadowColor =
          getValue(maps["shadowColor"], datas, "Color?", vars, props);
      final surfaceTintColor =
          getValue(maps["surfaceTintColor"], datas, "Color?", vars, props);
      final shape = getValue(maps["shape"], datas, "ShapeBorder?", vars, props);
      final backgroundColor =
          getValue(maps["backgroundColor"], datas, "Color?", vars, props);
      final foregroundColor =
          getValue(maps["foregroundColor"], datas, "Color?", vars, props);
      final iconTheme =
          getValue(maps["iconTheme"], datas, "IconThemeData?", vars, props);
      final actionsIconTheme = getValue(
          maps["actionsIconTheme"], datas, "IconThemeData?", vars, props);
      final primary = getValue(maps["primary"], datas, "bool", vars, props);
      final centerTitle =
          getValue(maps["centerTitle"], datas, "bool?", vars, props);
      final excludeHeaderSemantics =
          getValue(maps["excludeHeaderSemantics"], datas, "bool", vars, props);
      final titleSpacing =
          getValue(maps["titleSpacing"], datas, "double?", vars, props);
      final toolbarOpacity =
          getValue(maps["toolbarOpacity"], datas, "double", vars, props);
      final bottomOpacity =
          getValue(maps["bottomOpacity"], datas, "double", vars, props);
      final toolbarHeight =
          getValue(maps["toolbarHeight"], datas, "double?", vars, props);
      final leadingWidth =
          getValue(maps["leadingWidth"], datas, "double?", vars, props);
      final toolbarTextStyle =
          getValue(maps["toolbarTextStyle"], datas, "TextStyle?", vars, props);
      final titleTextStyle =
          getValue(maps["titleTextStyle"], datas, "TextStyle?", vars, props);
      final systemOverlayStyle = getValue(maps["systemOverlayStyle"], datas,
          "SystemUiOverlayStyle?", vars, props);
      final forceMaterialTransparency = getValue(
          maps["forceMaterialTransparency"], datas, "bool", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip?", vars, props);
      return AppBar(
          key: key,
          leading: leading,
          automaticallyImplyLeading: automaticallyImplyLeading ?? true,
          title: title,
          actions: actions != null ? List<Widget>.from(actions) : null,
          flexibleSpace: flexibleSpace,
          bottom: bottom,
          elevation: elevation,
          scrolledUnderElevation: scrolledUnderElevation,
          notificationPredicate:
              notificationPredicate ?? defaultScrollNotificationPredicate,
          shadowColor: shadowColor,
          surfaceTintColor: surfaceTintColor,
          shape: shape,
          backgroundColor: backgroundColor,
          foregroundColor: foregroundColor,
          iconTheme: iconTheme,
          actionsIconTheme: actionsIconTheme,
          primary: primary ?? true,
          centerTitle: centerTitle,
          excludeHeaderSemantics: excludeHeaderSemantics ?? false,
          titleSpacing: titleSpacing,
          toolbarOpacity: toolbarOpacity ?? 1.0,
          bottomOpacity: bottomOpacity ?? 1.0,
          toolbarHeight: toolbarHeight,
          leadingWidth: leadingWidth,
          toolbarTextStyle: toolbarTextStyle,
          titleTextStyle: titleTextStyle,
          systemOverlayStyle: systemOverlayStyle,
          forceMaterialTransparency: forceMaterialTransparency ?? false,
          clipBehavior: clipBehavior);
    },
    "AppBarTheme": () {
      final color = getValue(maps["color"], datas, "Color?", vars, props);
      final backgroundColor =
          getValue(maps["backgroundColor"], datas, "Color?", vars, props);
      final foregroundColor =
          getValue(maps["foregroundColor"], datas, "Color?", vars, props);
      final elevation =
          getValue(maps["elevation"], datas, "double?", vars, props);
      final scrolledUnderElevation = getValue(
          maps["scrolledUnderElevation"], datas, "double?", vars, props);
      final shadowColor =
          getValue(maps["shadowColor"], datas, "Color?", vars, props);
      final surfaceTintColor =
          getValue(maps["surfaceTintColor"], datas, "Color?", vars, props);
      final shape = getValue(maps["shape"], datas, "ShapeBorder?", vars, props);
      final iconTheme =
          getValue(maps["iconTheme"], datas, "IconThemeData?", vars, props);
      final actionsIconTheme = getValue(
          maps["actionsIconTheme"], datas, "IconThemeData?", vars, props);
      final centerTitle =
          getValue(maps["centerTitle"], datas, "bool?", vars, props);
      final titleSpacing =
          getValue(maps["titleSpacing"], datas, "double?", vars, props);
      final toolbarHeight =
          getValue(maps["toolbarHeight"], datas, "double?", vars, props);
      final toolbarTextStyle =
          getValue(maps["toolbarTextStyle"], datas, "TextStyle?", vars, props);
      final titleTextStyle =
          getValue(maps["titleTextStyle"], datas, "TextStyle?", vars, props);
      final systemOverlayStyle = getValue(maps["systemOverlayStyle"], datas,
          "SystemUiOverlayStyle?", vars, props);
      return AppBarTheme(
          color: color,
          backgroundColor: backgroundColor,
          foregroundColor: foregroundColor,
          elevation: elevation,
          scrolledUnderElevation: scrolledUnderElevation,
          shadowColor: shadowColor,
          surfaceTintColor: surfaceTintColor,
          shape: shape,
          iconTheme: iconTheme,
          actionsIconTheme: actionsIconTheme,
          centerTitle: centerTitle,
          titleSpacing: titleSpacing,
          toolbarHeight: toolbarHeight,
          toolbarTextStyle: toolbarTextStyle,
          titleTextStyle: titleTextStyle,
          systemOverlayStyle: systemOverlayStyle);
    },
    "ApplicationSwitcherDescription": () {
      final label = getValue(maps["label"], datas, "String?", vars, props);
      final primaryColor =
          getValue(maps["primaryColor"], datas, "int?", vars, props);
      return ApplicationSwitcherDescription(
          label: label, primaryColor: primaryColor);
    },
    "ArgumentError": () {
      final message = getValue(maps["0"], datas, "dynamic", vars, props);
      final name = getValue(maps["1"], datas, "String?", vars, props);
      return ArgumentError(message, name);
    },
    "ArgumentError.value": () {
      final name = getValue(maps["1"], datas, "String?", vars, props);
      final message = getValue(maps["2"], datas, "dynamic", vars, props);
      return ArgumentError.value(name, message);
    },
    "ArgumentError.notNull": () {
      final name = getValue(maps["0"], datas, "String?", vars, props);
      return ArgumentError.notNull(name);
    },
    "AspectRatio": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final aspectRatio =
          getValue(maps["aspectRatio"], datas, "double", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      if (aspectRatio == null) {
        return null;
      }
      return AspectRatio(key: key, aspectRatio: aspectRatio!, child: child);
    },
    "AssertionError": () {
      final message = getValue(maps["0"], datas, "Object?", vars, props);
      return AssertionError(message);
    },
    "AssetBundleImageKey": () {
      final bundle =
          getValue(maps["bundle"], datas, "AssetBundle", vars, props);
      final name = getValue(maps["name"], datas, "String", vars, props);
      final scale = getValue(maps["scale"], datas, "double", vars, props);
      if (bundle == null || name == null || scale == null) {
        return null;
      }
      return AssetBundleImageKey(bundle: bundle!, name: name!, scale: scale!);
    },
    "AssetImage": () {
      final assetName = getValue(maps["0"], datas, "String", vars, props);
      final bundle =
          getValue(maps["bundle"], datas, "AssetBundle?", vars, props);
      final package = getValue(maps["package"], datas, "String?", vars, props);
      if (assetName == null) {
        return null;
      }
      return AssetImage(assetName!, bundle: bundle, package: package);
    },
    "AssetMetadata": () {
      final key = getValue(maps["key"], datas, "String", vars, props);
      final targetDevicePixelRatio = getValue(
          maps["targetDevicePixelRatio"], datas, "double?", vars, props);
      final main = getValue(maps["main"], datas, "bool", vars, props);
      if (key == null || targetDevicePixelRatio == null || main == null) {
        return null;
      }
      return AssetMetadata(
          key: key!,
          targetDevicePixelRatio: targetDevicePixelRatio!,
          main: main!);
    },
    "AsyncSnapshot.nothing": () {
      return const AsyncSnapshot.nothing();
    },
    "AsyncSnapshot.waiting": () {
      return const AsyncSnapshot.waiting();
    },
    "AsyncSnapshot.withData": () {
      final state = getValue(maps["0"], datas, "ConnectionState", vars, props);
      final data = getValue(maps["1"], datas, "T", vars, props);
      if (state == null || data == null) {
        return null;
      }
      return AsyncSnapshot.withData(state!, data!);
    },
    "AsyncSnapshot.withError": () {
      final state = getValue(maps["0"], datas, "ConnectionState", vars, props);
      final error = getValue(maps["1"], datas, "Object", vars, props);
      final stackTrace = getValue(maps["2"], datas, "StackTrace", vars, props);
      if (state == null || error == null) {
        return null;
      }
      return AsyncSnapshot.withError(
          state!, error!, stackTrace ?? StackTrace.empty);
    },
    "AttributedString": () {
      final string = getValue(maps["0"], datas, "String", vars, props);
      final attributes = getValue(
          maps["attributes"], datas, "List<StringAttribute>", vars, props);
      if (string == null) {
        return null;
      }
      return AttributedString(string!,
          attributes: List<StringAttribute>.from(
              attributes ?? const <StringAttribute>[]));
    },
    "Autocomplete": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final optionsBuilder = getValue(maps["optionsBuilder"], datas,
          "AutocompleteOptionsBuilder<T>", vars, props);
      final displayStringForOption = getValue(maps["displayStringForOption"],
          datas, "AutocompleteOptionToString<T>", vars, props);
      final fieldViewBuilder = getValue(maps["fieldViewBuilder"], datas,
          "AutocompleteFieldViewBuilder", vars, props);
      final onSelected = getValue(
          maps["onSelected"], datas, "AutocompleteOnSelected<T>?", vars, props);
      final optionsMaxHeight =
          getValue(maps["optionsMaxHeight"], datas, "double", vars, props);
      final optionsViewBuilder = getValue(maps["optionsViewBuilder"], datas,
          "AutocompleteOptionsViewBuilder<T>?", vars, props);
      final initialValue = getValue(
          maps["initialValue"], datas, "TextEditingValue?", vars, props);
      if (optionsBuilder == null) {
        return null;
      }
      if (fieldViewBuilder != null) {
        return Autocomplete(
            key: key,
            optionsBuilder: optionsBuilder!,
            displayStringForOption: displayStringForOption ??
                RawAutocomplete.defaultStringForOption,
            onSelected: onSelected,
            optionsMaxHeight: optionsMaxHeight ?? 200.0,
            optionsViewBuilder: optionsViewBuilder,
            initialValue: initialValue,
            fieldViewBuilder: fieldViewBuilder);
      }
      return Autocomplete(
          key: key,
          optionsBuilder: optionsBuilder!,
          displayStringForOption:
              displayStringForOption ?? RawAutocomplete.defaultStringForOption,
          onSelected: onSelected,
          optionsMaxHeight: optionsMaxHeight ?? 200.0,
          optionsViewBuilder: optionsViewBuilder,
          initialValue: initialValue);
    },
    "AutocompleteHighlightedOption": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final highlightIndexNotifier = getValue(maps["highlightIndexNotifier"],
          datas, "ValueNotifier<int>", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (highlightIndexNotifier == null || child == null) {
        return null;
      }
      return AutocompleteHighlightedOption(
          key: key,
          highlightIndexNotifier: highlightIndexNotifier!,
          child: child!);
    },
    "AutocompleteNextOptionIntent": () {
      return const AutocompleteNextOptionIntent();
    },
    "AutocompletePreviousOptionIntent": () {
      return const AutocompletePreviousOptionIntent();
    },
    "AutofillConfiguration": () {
      final uniqueIdentifier =
          getValue(maps["uniqueIdentifier"], datas, "String", vars, props);
      final autofillHints =
          getValue(maps["autofillHints"], datas, "List<String>", vars, props);
      final currentEditingValue = getValue(
          maps["currentEditingValue"], datas, "TextEditingValue", vars, props);
      final hintText =
          getValue(maps["hintText"], datas, "String?", vars, props);
      if (uniqueIdentifier == null ||
          autofillHints == null ||
          currentEditingValue == null) {
        return null;
      }
      return AutofillConfiguration(
          uniqueIdentifier: uniqueIdentifier!,
          autofillHints: List<String>.from(autofillHints!),
          currentEditingValue: currentEditingValue!,
          hintText: hintText);
    },
    "AutofillGroup": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      final onDisposeAction = getValue(
          maps["onDisposeAction"], datas, "AutofillContextAction", vars, props);
      if (child == null) {
        return null;
      }
      return AutofillGroup(
          key: key,
          child: child!,
          onDisposeAction: onDisposeAction ?? AutofillContextAction.commit);
    },
    "AutomaticKeepAlive": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (child == null) {
        return null;
      }
      return AutomaticKeepAlive(key: key, child: child!);
    },
    "AutomaticNotchedShape": () {
      final host = getValue(maps["0"], datas, "ShapeBorder", vars, props);
      final guest = getValue(maps["1"], datas, "ShapeBorder?", vars, props);
      if (host == null) {
        return null;
      }
      return AutomaticNotchedShape(host!, guest);
    },
    "BackButton": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final color = getValue(maps["color"], datas, "Color?", vars, props);
      final style = getValue(maps["style"], datas, "ButtonStyle?", vars, props);
      final onPressed =
          getValue(maps["onPressed"], datas, "VoidCallback?", vars, props);
      return BackButton(
          key: key, color: color, style: style, onPressed: onPressed);
    },
    "BackButtonIcon": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      return BackButtonIcon(key: key);
    },
    "BackButtonListener": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      final onBackButtonPressed = getValue(maps["onBackButtonPressed"], datas,
          "ValueGetter<Future<bool>>", vars, props);
      if (child == null || onBackButtonPressed == null) {
        return null;
      }
      return BackButtonListener(
          key: key, child: child!, onBackButtonPressed: onBackButtonPressed!);
    },
    "BackdropFilter": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final filter =
          getValue(maps["filter"], datas, "ImageFilter", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      final blendMode =
          getValue(maps["blendMode"], datas, "BlendMode", vars, props);
      if (filter == null) {
        return null;
      }
      return BackdropFilter(
          key: key,
          filter: filter!,
          child: child,
          blendMode: blendMode ?? BlendMode.srcOver);
    },
    "BackdropFilterLayer": () {
      final filter =
          getValue(maps["filter"], datas, "ImageFilter?", vars, props);
      final blendMode =
          getValue(maps["blendMode"], datas, "BlendMode", vars, props);
      return BackdropFilterLayer(
          filter: filter, blendMode: blendMode ?? BlendMode.srcOver);
    },
    "Badge": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final backgroundColor =
          getValue(maps["backgroundColor"], datas, "Color?", vars, props);
      final textColor =
          getValue(maps["textColor"], datas, "Color?", vars, props);
      final smallSize =
          getValue(maps["smallSize"], datas, "double?", vars, props);
      final largeSize =
          getValue(maps["largeSize"], datas, "double?", vars, props);
      final textStyle =
          getValue(maps["textStyle"], datas, "TextStyle?", vars, props);
      final padding =
          getValue(maps["padding"], datas, "EdgeInsetsGeometry?", vars, props);
      final alignment =
          getValue(maps["alignment"], datas, "AlignmentGeometry?", vars, props);
      final offset = getValue(maps["offset"], datas, "Offset?", vars, props);
      final label = getValue(maps["label"], datas, "Widget?", vars, props);
      final isLabelVisible =
          getValue(maps["isLabelVisible"], datas, "bool", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      return Badge(
          key: key,
          backgroundColor: backgroundColor,
          textColor: textColor,
          smallSize: smallSize,
          largeSize: largeSize,
          textStyle: textStyle,
          padding: padding,
          alignment: alignment,
          offset: offset,
          label: label,
          isLabelVisible: isLabelVisible ?? true,
          child: child);
    },
    "Badge.count": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final backgroundColor =
          getValue(maps["backgroundColor"], datas, "Color?", vars, props);
      final textColor =
          getValue(maps["textColor"], datas, "Color?", vars, props);
      final smallSize =
          getValue(maps["smallSize"], datas, "double?", vars, props);
      final largeSize =
          getValue(maps["largeSize"], datas, "double?", vars, props);
      final textStyle =
          getValue(maps["textStyle"], datas, "TextStyle?", vars, props);
      final padding =
          getValue(maps["padding"], datas, "EdgeInsetsGeometry?", vars, props);
      final alignment =
          getValue(maps["alignment"], datas, "AlignmentGeometry?", vars, props);
      final offset = getValue(maps["offset"], datas, "Offset?", vars, props);
      final count = getValue(maps["count"], datas, "int", vars, props);
      final isLabelVisible =
          getValue(maps["isLabelVisible"], datas, "bool", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      if (count == null) {
        return null;
      }
      return Badge.count(
          key: key,
          backgroundColor: backgroundColor,
          textColor: textColor,
          smallSize: smallSize,
          largeSize: largeSize,
          textStyle: textStyle,
          padding: padding,
          alignment: alignment,
          offset: offset,
          count: count!,
          isLabelVisible: isLabelVisible ?? true,
          child: child);
    },
    "BadgeTheme": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final data = getValue(maps["data"], datas, "BadgeThemeData", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (data == null || child == null) {
        return null;
      }
      return BadgeTheme(key: key, data: data!, child: child!);
    },
    "BadgeThemeData": () {
      final backgroundColor =
          getValue(maps["backgroundColor"], datas, "Color?", vars, props);
      final textColor =
          getValue(maps["textColor"], datas, "Color?", vars, props);
      final smallSize =
          getValue(maps["smallSize"], datas, "double?", vars, props);
      final largeSize =
          getValue(maps["largeSize"], datas, "double?", vars, props);
      final textStyle =
          getValue(maps["textStyle"], datas, "TextStyle?", vars, props);
      final padding =
          getValue(maps["padding"], datas, "EdgeInsetsGeometry?", vars, props);
      final alignment =
          getValue(maps["alignment"], datas, "AlignmentGeometry?", vars, props);
      final offset = getValue(maps["offset"], datas, "Offset?", vars, props);
      return BadgeThemeData(
          backgroundColor: backgroundColor,
          textColor: textColor,
          smallSize: smallSize,
          largeSize: largeSize,
          textStyle: textStyle,
          padding: padding,
          alignment: alignment,
          offset: offset);
    },
    "BallisticScrollActivity": () {
      final delegate =
          getValue(maps["0"], datas, "ScrollActivityDelegate", vars, props);
      final simulation = getValue(maps["1"], datas, "Simulation", vars, props);
      final vsync = getValue(maps["2"], datas, "TickerProvider", vars, props);
      final shouldIgnorePointer =
          getValue(maps["3"], datas, "bool", vars, props);
      if (delegate == null ||
          simulation == null ||
          vsync == null ||
          shouldIgnorePointer == null) {
        return null;
      }
      return BallisticScrollActivity(
          delegate!, simulation!, vsync!, shouldIgnorePointer!);
    },
    "Banner": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      final message = getValue(maps["message"], datas, "String", vars, props);
      final textDirection =
          getValue(maps["textDirection"], datas, "TextDirection?", vars, props);
      final location =
          getValue(maps["location"], datas, "BannerLocation", vars, props);
      final layoutDirection = getValue(
          maps["layoutDirection"], datas, "TextDirection?", vars, props);
      final color = getValue(maps["color"], datas, "Color", vars, props);
      final textStyle =
          getValue(maps["textStyle"], datas, "TextStyle", vars, props);
      if (message == null || location == null) {
        return null;
      }
      if (color != null && textStyle != null) {
        return Banner(
            key: key,
            child: child,
            message: message!,
            textDirection: textDirection,
            location: location!,
            layoutDirection: layoutDirection,
            color: color,
            textStyle: textStyle);
      }
      if (color != null) {
        return Banner(
            key: key,
            child: child,
            message: message!,
            textDirection: textDirection,
            location: location!,
            layoutDirection: layoutDirection,
            color: color);
      }
      if (textStyle != null) {
        return Banner(
            key: key,
            child: child,
            message: message!,
            textDirection: textDirection,
            location: location!,
            layoutDirection: layoutDirection,
            textStyle: textStyle);
      }
      return Banner(
          key: key,
          child: child,
          message: message!,
          textDirection: textDirection,
          location: location!,
          layoutDirection: layoutDirection);
    },
    "BannerPainter": () {
      final message = getValue(maps["message"], datas, "String", vars, props);
      final textDirection =
          getValue(maps["textDirection"], datas, "TextDirection", vars, props);
      final location =
          getValue(maps["location"], datas, "BannerLocation", vars, props);
      final layoutDirection = getValue(
          maps["layoutDirection"], datas, "TextDirection", vars, props);
      final color = getValue(maps["color"], datas, "Color", vars, props);
      final textStyle =
          getValue(maps["textStyle"], datas, "TextStyle", vars, props);
      if (message == null ||
          textDirection == null ||
          location == null ||
          layoutDirection == null) {
        return null;
      }
      if (color != null && textStyle != null) {
        return BannerPainter(
            message: message!,
            textDirection: textDirection!,
            location: location!,
            layoutDirection: layoutDirection!,
            color: color,
            textStyle: textStyle);
      }
      if (color != null) {
        return BannerPainter(
            message: message!,
            textDirection: textDirection!,
            location: location!,
            layoutDirection: layoutDirection!,
            color: color);
      }
      if (textStyle != null) {
        return BannerPainter(
            message: message!,
            textDirection: textDirection!,
            location: location!,
            layoutDirection: layoutDirection!,
            textStyle: textStyle);
      }
      return BannerPainter(
          message: message!,
          textDirection: textDirection!,
          location: location!,
          layoutDirection: layoutDirection!);
      // "BaseTapAndDragGestureRecognizer": () {
      //   final debugOwner = getValue(maps["debugOwner"], datas, "", vars, props);
      //   final supportedDevices =
      //       getValue(maps["supportedDevices"], datas, "", vars, props);
      //   final allowedButtonsFilter =
      //       getValue(maps["allowedButtonsFilter"], datas, "", vars, props);
      //   return BaseTapAndDragGestureRecognizer(
      //       debugOwner: debugOwner,
      //       supportedDevices: supportedDevices,
      //       allowedButtonsFilter: allowedButtonsFilter);
    },
    "Baseline": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final baseline = getValue(maps["baseline"], datas, "double", vars, props);
      final baselineType =
          getValue(maps["baselineType"], datas, "TextBaseline", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      if (baseline == null || baselineType == null) {
        return null;
      }
      return Baseline(
          key: key,
          baseline: baseline!,
          baselineType: baselineType!,
          child: child);
    },
    "BasicMessageChannel": () {
      final name = getValue(maps["0"], datas, "String", vars, props);
      final codec = getValue(maps["1"], datas, "MessageCodec<T>", vars, props);
      final binaryMessenger = getValue(
          maps["binaryMessenger"], datas, "BinaryMessenger?", vars, props);
      if (name == null || codec == null) {
        return null;
      }
      return BasicMessageChannel(name!, codec!,
          binaryMessenger: binaryMessenger);
    },
    "BeveledRectangleBorder": () {
      final side = getValue(maps["side"], datas, "", vars, props);
      final borderRadius = getValue(
          maps["borderRadius"], datas, "BorderRadiusGeometry", vars, props);
      return BeveledRectangleBorder(
          side: side, borderRadius: borderRadius ?? BorderRadius.zero);
    },
    "BigInt.from": () {
      final value = getValue(maps["0"], datas, "num", vars, props);
      if (value == null) {
        return null;
      }
      return BigInt.from(value!);
    },
    "BinaryCodec": () {
      return const BinaryCodec();
    },
    "BitField.filled": () {
      final length = getValue(maps["0"], datas, "int", vars, props);
      final value = getValue(maps["1"], datas, "bool", vars, props);
      if (length == null || value == null) {
        return null;
      }
      return BitField.filled(length!, value!);
    },
    "BitField": () {
      final length = getValue(maps["0"], datas, "int", vars, props);
      if (length == null) {
        return null;
      }
      return BitField(length!);
    },
    "BitField.filled": () {
      final length = getValue(maps["0"], datas, "int", vars, props);
      final value = getValue(maps["1"], datas, "bool", vars, props);
      if (length == null || value == null) {
        return null;
      }
      return BitField.filled(length!, value!);
    },
    "BitField": () {
      final length = getValue(maps["0"], datas, "int", vars, props);
      if (length == null) {
        return null;
      }
      return BitField(length!);
    },
    "BitField.filled": () {
      final length = getValue(maps["0"], datas, "int", vars, props);
      final value = getValue(maps["1"], datas, "bool", vars, props);
      if (length == null || value == null) {
        return null;
      }
      return BitField.filled(length!, value!);
    },
    "BlockSemantics": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final blocking = getValue(maps["blocking"], datas, "bool", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      return BlockSemantics(key: key, blocking: blocking ?? true, child: child);
    },
    "Border": () {
      final top = getValue(maps["top"], datas, "BorderSide", vars, props);
      final right = getValue(maps["right"], datas, "BorderSide", vars, props);
      final bottom = getValue(maps["bottom"], datas, "BorderSide", vars, props);
      final left = getValue(maps["left"], datas, "BorderSide", vars, props);
      return Border(
          top: top ?? BorderSide.none,
          right: right ?? BorderSide.none,
          bottom: bottom ?? BorderSide.none,
          left: left ?? BorderSide.none);
    },
    "Border.fromBorderSide": () {
      final side = getValue(maps["0"], datas, "BorderSide", vars, props);
      if (side == null) {
        return null;
      }
      return Border.fromBorderSide(side!);
    },
    "Border.symmetric": () {
      final vertical =
          getValue(maps["vertical"], datas, "BorderSide", vars, props);
      final horizontal =
          getValue(maps["horizontal"], datas, "BorderSide", vars, props);
      return Border.symmetric(
          vertical: vertical ?? BorderSide.none,
          horizontal: horizontal ?? BorderSide.none);
    },
    "Border.all": () {
      final color = getValue(maps["color"], datas, "Color", vars, props);
      final width = getValue(maps["width"], datas, "double", vars, props);
      final style = getValue(maps["style"], datas, "BorderStyle", vars, props);
      final strokeAlign =
          getValue(maps["strokeAlign"], datas, "double", vars, props);
      return Border.all(
          color: color ?? const Color(0xFF000000),
          width: width ?? 1.0,
          style: style ?? BorderStyle.solid,
          strokeAlign: strokeAlign ?? BorderSide.strokeAlignInside);
    },
    "BorderRadius.all": () {
      final radius = getValue(maps["0"], datas, "Radius", vars, props);
      if (radius == null) {
        return null;
      }
      return BorderRadius.all(radius!);
    },
    "BorderRadius.circular": () {
      final radius = getValue(maps["0"], datas, "double", vars, props);
      if (radius == null) {
        return null;
      }
      return BorderRadius.circular(radius!);
    },
    "BorderRadius.vertical": () {
      final top = getValue(maps["top"], datas, "Radius", vars, props);
      final bottom = getValue(maps["bottom"], datas, "Radius", vars, props);
      return BorderRadius.vertical(
          top: top ?? Radius.zero, bottom: bottom ?? Radius.zero);
    },
    "BorderRadius.horizontal": () {
      final left = getValue(maps["left"], datas, "Radius", vars, props);
      final right = getValue(maps["right"], datas, "Radius", vars, props);
      return BorderRadius.horizontal(
          left: left ?? Radius.zero, right: right ?? Radius.zero);
    },
    "BorderRadius.only": () {
      final topLeft = getValue(maps["topLeft"], datas, "Radius", vars, props);
      final topRight = getValue(maps["topRight"], datas, "Radius", vars, props);
      final bottomLeft =
          getValue(maps["bottomLeft"], datas, "Radius", vars, props);
      final bottomRight =
          getValue(maps["bottomRight"], datas, "Radius", vars, props);
      return BorderRadius.only(
          topLeft: topLeft ?? Radius.zero,
          topRight: topRight ?? Radius.zero,
          bottomLeft: bottomLeft ?? Radius.zero,
          bottomRight: bottomRight ?? Radius.zero);
    },
    "BorderRadiusDirectional.all": () {
      final radius = getValue(maps["0"], datas, "Radius", vars, props);
      if (radius == null) {
        return null;
      }
      return BorderRadiusDirectional.all(radius!);
    },
    "BorderRadiusDirectional.circular": () {
      final radius = getValue(maps["0"], datas, "double", vars, props);
      if (radius == null) {
        return null;
      }
      return BorderRadiusDirectional.circular(radius!);
    },
    "BorderRadiusDirectional.vertical": () {
      final top = getValue(maps["top"], datas, "Radius", vars, props);
      final bottom = getValue(maps["bottom"], datas, "Radius", vars, props);
      return BorderRadiusDirectional.vertical(
          top: top ?? Radius.zero, bottom: bottom ?? Radius.zero);
    },
    "BorderRadiusDirectional.horizontal": () {
      final start = getValue(maps["start"], datas, "Radius", vars, props);
      final end = getValue(maps["end"], datas, "Radius", vars, props);
      return BorderRadiusDirectional.horizontal(
          start: start ?? Radius.zero, end: end ?? Radius.zero);
    },
    "BorderRadiusDirectional.only": () {
      final topStart = getValue(maps["topStart"], datas, "Radius", vars, props);
      final topEnd = getValue(maps["topEnd"], datas, "Radius", vars, props);
      final bottomStart =
          getValue(maps["bottomStart"], datas, "Radius", vars, props);
      final bottomEnd =
          getValue(maps["bottomEnd"], datas, "Radius", vars, props);
      return BorderRadiusDirectional.only(
          topStart: topStart ?? Radius.zero,
          topEnd: topEnd ?? Radius.zero,
          bottomStart: bottomStart ?? Radius.zero,
          bottomEnd: bottomEnd ?? Radius.zero);
    },
    "BorderRadiusTween": () {
      final begin = getValue(maps["begin"], datas, "T?", vars, props);
      final end = getValue(maps["end"], datas, "T?", vars, props);
      return BorderRadiusTween(begin: begin, end: end);
    },
    "BorderSide": () {
      final color = getValue(maps["color"], datas, "Color", vars, props);
      final width = getValue(maps["width"], datas, "double", vars, props);
      final style = getValue(maps["style"], datas, "BorderStyle", vars, props);
      final strokeAlign =
          getValue(maps["strokeAlign"], datas, "double", vars, props);
      if (strokeAlign != null) {
        return BorderSide(
            color: color ?? const Color(0xFF000000),
            width: width ?? 1.0,
            style: style ?? BorderStyle.solid,
            strokeAlign: strokeAlign);
      }
      return BorderSide(
          color: color ?? const Color(0xFF000000),
          width: width ?? 1.0,
          style: style ?? BorderStyle.solid);
    },
    "BorderTween": () {
      final begin = getValue(maps["begin"], datas, "T?", vars, props);
      final end = getValue(maps["end"], datas, "T?", vars, props);
      return BorderTween(begin: begin, end: end);
    },
    "BottomAppBar": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final color = getValue(maps["color"], datas, "Color?", vars, props);
      final elevation =
          getValue(maps["elevation"], datas, "double?", vars, props);
      final shape =
          getValue(maps["shape"], datas, "NotchedShape?", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      final notchMargin =
          getValue(maps["notchMargin"], datas, "double", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      final padding =
          getValue(maps["padding"], datas, "EdgeInsetsGeometry?", vars, props);
      final surfaceTintColor =
          getValue(maps["surfaceTintColor"], datas, "Color?", vars, props);
      final shadowColor =
          getValue(maps["shadowColor"], datas, "Color?", vars, props);
      final height = getValue(maps["height"], datas, "double?", vars, props);
      return BottomAppBar(
          key: key,
          color: color,
          elevation: elevation,
          shape: shape,
          clipBehavior: clipBehavior ?? Clip.none,
          notchMargin: notchMargin ?? 4.0,
          child: child,
          padding: padding,
          surfaceTintColor: surfaceTintColor,
          shadowColor: shadowColor,
          height: height);
    },
    "BottomAppBarTheme": () {
      final color = getValue(maps["color"], datas, "Color?", vars, props);
      final elevation =
          getValue(maps["elevation"], datas, "double?", vars, props);
      final shape =
          getValue(maps["shape"], datas, "NotchedShape?", vars, props);
      final height = getValue(maps["height"], datas, "double?", vars, props);
      final surfaceTintColor =
          getValue(maps["surfaceTintColor"], datas, "Color?", vars, props);
      final shadowColor =
          getValue(maps["shadowColor"], datas, "Color?", vars, props);
      final padding =
          getValue(maps["padding"], datas, "EdgeInsetsGeometry?", vars, props);
      return BottomAppBarTheme(
          color: color,
          elevation: elevation,
          shape: shape,
          height: height,
          surfaceTintColor: surfaceTintColor,
          shadowColor: shadowColor,
          padding: padding);
    },
    "BottomNavigationBar": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final items = getValue(
          maps["items"], datas, "List<BottomNavigationBarItem>", vars, props);
      final onTap =
          getValue(maps["onTap"], datas, "ValueChanged<int>?", vars, props);
      final currentIndex =
          getValue(maps["currentIndex"], datas, "int", vars, props);
      final elevation =
          getValue(maps["elevation"], datas, "double?", vars, props);
      final type = getValue(
          maps["type"], datas, "BottomNavigationBarType?", vars, props);
      final fixedColor =
          getValue(maps["fixedColor"], datas, "Color?", vars, props);
      final backgroundColor =
          getValue(maps["backgroundColor"], datas, "Color?", vars, props);
      final iconSize = getValue(maps["iconSize"], datas, "double", vars, props);
      final selectedItemColor =
          getValue(maps["selectedItemColor"], datas, "Color?", vars, props);
      final unselectedItemColor =
          getValue(maps["unselectedItemColor"], datas, "Color?", vars, props);
      final selectedIconTheme = getValue(
          maps["selectedIconTheme"], datas, "IconThemeData?", vars, props);
      final unselectedIconTheme = getValue(
          maps["unselectedIconTheme"], datas, "IconThemeData?", vars, props);
      final selectedFontSize =
          getValue(maps["selectedFontSize"], datas, "double", vars, props);
      final unselectedFontSize =
          getValue(maps["unselectedFontSize"], datas, "double", vars, props);
      final selectedLabelStyle = getValue(
          maps["selectedLabelStyle"], datas, "TextStyle?", vars, props);
      final unselectedLabelStyle = getValue(
          maps["unselectedLabelStyle"], datas, "TextStyle?", vars, props);
      final showSelectedLabels =
          getValue(maps["showSelectedLabels"], datas, "bool?", vars, props);
      final showUnselectedLabels =
          getValue(maps["showUnselectedLabels"], datas, "bool?", vars, props);
      final mouseCursor =
          getValue(maps["mouseCursor"], datas, "MouseCursor?", vars, props);
      final enableFeedback =
          getValue(maps["enableFeedback"], datas, "bool?", vars, props);
      final landscapeLayout = getValue(maps["landscapeLayout"], datas,
          "BottomNavigationBarLandscapeLayout?", vars, props);
      final useLegacyColorScheme =
          getValue(maps["useLegacyColorScheme"], datas, "bool", vars, props);
      if (items == null) {
        return null;
      }
      return BottomNavigationBar(
          key: key,
          items: List<BottomNavigationBarItem>.from(items!),
          onTap: onTap,
          currentIndex: currentIndex ?? 0,
          elevation: elevation,
          type: type,
          fixedColor: fixedColor,
          backgroundColor: backgroundColor,
          iconSize: iconSize ?? 24.0,
          selectedItemColor: selectedItemColor,
          unselectedItemColor: unselectedItemColor,
          selectedIconTheme: selectedIconTheme,
          unselectedIconTheme: unselectedIconTheme,
          selectedFontSize: selectedFontSize ?? 14.0,
          unselectedFontSize: unselectedFontSize ?? 12.0,
          selectedLabelStyle: selectedLabelStyle,
          unselectedLabelStyle: unselectedLabelStyle,
          showSelectedLabels: showSelectedLabels,
          showUnselectedLabels: showUnselectedLabels,
          mouseCursor: mouseCursor,
          enableFeedback: enableFeedback,
          landscapeLayout: landscapeLayout,
          useLegacyColorScheme: useLegacyColorScheme ?? true);
    },
    "BottomNavigationBarItem": () {
      final icon = getValue(maps["icon"], datas, "Widget", vars, props);
      final label = getValue(maps["label"], datas, "String?", vars, props);
      final activeIcon =
          getValue(maps["activeIcon"], datas, "Widget?", vars, props);
      final backgroundColor =
          getValue(maps["backgroundColor"], datas, "Color?", vars, props);
      final tooltip = getValue(maps["tooltip"], datas, "String?", vars, props);
      if (icon == null) {
        return null;
      }
      return BottomNavigationBarItem(
          icon: icon!,
          label: label,
          activeIcon: activeIcon,
          backgroundColor: backgroundColor,
          tooltip: tooltip);
    },
    "BottomNavigationBarTheme": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final data = getValue(
          maps["data"], datas, "BottomNavigationBarThemeData", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (data == null || child == null) {
        return null;
      }
      return BottomNavigationBarTheme(key: key, data: data!, child: child!);
    },
    "BottomNavigationBarThemeData": () {
      final backgroundColor =
          getValue(maps["backgroundColor"], datas, "Color?", vars, props);
      final elevation =
          getValue(maps["elevation"], datas, "double?", vars, props);
      final selectedIconTheme = getValue(
          maps["selectedIconTheme"], datas, "IconThemeData?", vars, props);
      final unselectedIconTheme = getValue(
          maps["unselectedIconTheme"], datas, "IconThemeData?", vars, props);
      final selectedItemColor =
          getValue(maps["selectedItemColor"], datas, "Color?", vars, props);
      final unselectedItemColor =
          getValue(maps["unselectedItemColor"], datas, "Color?", vars, props);
      final selectedLabelStyle = getValue(
          maps["selectedLabelStyle"], datas, "TextStyle?", vars, props);
      final unselectedLabelStyle = getValue(
          maps["unselectedLabelStyle"], datas, "TextStyle?", vars, props);
      final showSelectedLabels =
          getValue(maps["showSelectedLabels"], datas, "bool?", vars, props);
      final showUnselectedLabels =
          getValue(maps["showUnselectedLabels"], datas, "bool?", vars, props);
      final type = getValue(
          maps["type"], datas, "BottomNavigationBarType?", vars, props);
      final enableFeedback =
          getValue(maps["enableFeedback"], datas, "bool?", vars, props);
      final landscapeLayout = getValue(maps["landscapeLayout"], datas,
          "BottomNavigationBarLandscapeLayout?", vars, props);
      final mouseCursor = getValue(maps["mouseCursor"], datas,
          "MaterialStateProperty<MouseCursor?>?", vars, props);
      return BottomNavigationBarThemeData(
          backgroundColor: backgroundColor,
          elevation: elevation,
          selectedIconTheme: selectedIconTheme,
          unselectedIconTheme: unselectedIconTheme,
          selectedItemColor: selectedItemColor,
          unselectedItemColor: unselectedItemColor,
          selectedLabelStyle: selectedLabelStyle,
          unselectedLabelStyle: unselectedLabelStyle,
          showSelectedLabels: showSelectedLabels,
          showUnselectedLabels: showUnselectedLabels,
          type: type,
          enableFeedback: enableFeedback,
          landscapeLayout: landscapeLayout,
          mouseCursor: mouseCursor);
    },
    "BottomSheet": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final animationController = getValue(maps["animationController"], datas,
          "AnimationController?", vars, props);
      final enableDrag =
          getValue(maps["enableDrag"], datas, "bool", vars, props);
      final showDragHandle =
          getValue(maps["showDragHandle"], datas, "bool?", vars, props);
      final dragHandleColor =
          getValue(maps["dragHandleColor"], datas, "Color?", vars, props);
      final dragHandleSize =
          getValue(maps["dragHandleSize"], datas, "Size?", vars, props);
      final onDragStart = getValue(maps["onDragStart"], datas,
          "BottomSheetDragStartHandler?", vars, props);
      final onDragEnd = getValue(
          maps["onDragEnd"], datas, "BottomSheetDragEndHandler?", vars, props);
      final backgroundColor =
          getValue(maps["backgroundColor"], datas, "Color?", vars, props);
      final shadowColor =
          getValue(maps["shadowColor"], datas, "Color?", vars, props);
      final elevation =
          getValue(maps["elevation"], datas, "double?", vars, props);
      final shape = getValue(maps["shape"], datas, "ShapeBorder?", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip?", vars, props);
      final constraints =
          getValue(maps["constraints"], datas, "BoxConstraints?", vars, props);
      final onClosing =
          getValue(maps["onClosing"], datas, "VoidCallback", vars, props);
      final builder =
          getValue(maps["builder"], datas, "WidgetBuilder", vars, props);
      if (onClosing == null || builder == null) {
        return null;
      }
      return BottomSheet(
          key: key,
          animationController: animationController,
          enableDrag: enableDrag ?? true,
          showDragHandle: showDragHandle,
          dragHandleColor: dragHandleColor,
          dragHandleSize: dragHandleSize,
          onDragStart: onDragStart,
          onDragEnd: onDragEnd,
          backgroundColor: backgroundColor,
          shadowColor: shadowColor,
          elevation: elevation,
          shape: shape,
          clipBehavior: clipBehavior,
          constraints: constraints,
          onClosing: onClosing!,
          builder: builder!);
    },
    "BottomSheetThemeData": () {
      final backgroundColor =
          getValue(maps["backgroundColor"], datas, "Color?", vars, props);
      final surfaceTintColor =
          getValue(maps["surfaceTintColor"], datas, "Color?", vars, props);
      final elevation =
          getValue(maps["elevation"], datas, "double?", vars, props);
      final modalBackgroundColor =
          getValue(maps["modalBackgroundColor"], datas, "Color?", vars, props);
      final modalBarrierColor =
          getValue(maps["modalBarrierColor"], datas, "Color?", vars, props);
      final shadowColor =
          getValue(maps["shadowColor"], datas, "Color?", vars, props);
      final modalElevation =
          getValue(maps["modalElevation"], datas, "double?", vars, props);
      final shape = getValue(maps["shape"], datas, "ShapeBorder?", vars, props);
      final showDragHandle =
          getValue(maps["showDragHandle"], datas, "bool?", vars, props);
      final dragHandleColor =
          getValue(maps["dragHandleColor"], datas, "Color?", vars, props);
      final dragHandleSize =
          getValue(maps["dragHandleSize"], datas, "Size?", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip?", vars, props);
      final constraints =
          getValue(maps["constraints"], datas, "BoxConstraints?", vars, props);
      return BottomSheetThemeData(
          backgroundColor: backgroundColor,
          surfaceTintColor: surfaceTintColor,
          elevation: elevation,
          modalBackgroundColor: modalBackgroundColor,
          modalBarrierColor: modalBarrierColor,
          shadowColor: shadowColor,
          modalElevation: modalElevation,
          shape: shape,
          showDragHandle: showDragHandle,
          dragHandleColor: dragHandleColor,
          dragHandleSize: dragHandleSize,
          clipBehavior: clipBehavior,
          constraints: constraints);
    },
    "BouncingScrollPhysics": () {
      final decelerationRate = getValue(maps["decelerationRate"], datas,
          "ScrollDecelerationRate", vars, props);
      final parent =
          getValue(maps["parent"], datas, "ScrollPhysics?", vars, props);
      return BouncingScrollPhysics(
          decelerationRate: decelerationRate ?? ScrollDecelerationRate.normal,
          parent: parent);
    },
    "BouncingScrollSimulation": () {
      final position = getValue(maps["position"], datas, "double", vars, props);
      final velocity = getValue(maps["velocity"], datas, "double", vars, props);
      final leadingExtent =
          getValue(maps["leadingExtent"], datas, "double", vars, props);
      final trailingExtent =
          getValue(maps["trailingExtent"], datas, "double", vars, props);
      final spring =
          getValue(maps["spring"], datas, "SpringDescription", vars, props);
      final constantDeceleration =
          getValue(maps["constantDeceleration"], datas, "double", vars, props);
      final tolerance =
          getValue(maps["tolerance"], datas, "Tolerance", vars, props);
      if (position == null ||
          velocity == null ||
          leadingExtent == null ||
          trailingExtent == null ||
          spring == null) {
        return null;
      }
      return BouncingScrollSimulation(
          position: position!,
          velocity: velocity!,
          leadingExtent: leadingExtent!,
          trailingExtent: trailingExtent!,
          spring: spring!,
          constantDeceleration: constantDeceleration ?? 0,
          tolerance: tolerance ?? Tolerance.defaultTolerance);
    },
    "BoxConstraints": () {
      final minWidth = getValue(maps["minWidth"], datas, "double", vars, props);
      final maxWidth = getValue(maps["maxWidth"], datas, "double", vars, props);
      final minHeight =
          getValue(maps["minHeight"], datas, "double", vars, props);
      final maxHeight =
          getValue(maps["maxHeight"], datas, "double", vars, props);
      return BoxConstraints(
          minWidth: minWidth ?? 0.0,
          maxWidth: maxWidth ?? double.infinity,
          minHeight: minHeight ?? 0.0,
          maxHeight: maxHeight ?? double.infinity);
    },
    "BoxConstraints.tight": () {
      final size = getValue(maps["0"], datas, "Size", vars, props);
      if (size == null) {
        return null;
      }
      return BoxConstraints.tight(size!);
    },
    "BoxConstraints.tightFor": () {
      final width = getValue(maps["width"], datas, "double?", vars, props);
      final height = getValue(maps["height"], datas, "double?", vars, props);
      return BoxConstraints.tightFor(width: width, height: height);
    },
    "BoxConstraints.tightForFinite": () {
      final width = getValue(maps["width"], datas, "double", vars, props);
      final height = getValue(maps["height"], datas, "double", vars, props);
      return BoxConstraints.tightForFinite(
          width: width ?? double.infinity, height: height ?? double.infinity);
    },
    "BoxConstraints.loose": () {
      final size = getValue(maps["0"], datas, "Size", vars, props);
      if (size == null) {
        return null;
      }
      return BoxConstraints.loose(size!);
    },
    "BoxConstraints.expand": () {
      final width = getValue(maps["width"], datas, "double?", vars, props);
      final height = getValue(maps["height"], datas, "double?", vars, props);
      return BoxConstraints.expand(width: width, height: height);
    },
    "BoxConstraintsTween": () {
      final begin = getValue(maps["begin"], datas, "T?", vars, props);
      final end = getValue(maps["end"], datas, "T?", vars, props);
      return BoxConstraintsTween(begin: begin, end: end);
    },
    "BoxDecoration": () {
      final color = getValue(maps["color"], datas, "Color?", vars, props);
      final image =
          getValue(maps["image"], datas, "DecorationImage?", vars, props);
      final border = getValue(maps["border"], datas, "BoxBorder?", vars, props);
      final borderRadius = getValue(
          maps["borderRadius"], datas, "BorderRadiusGeometry?", vars, props);
      final boxShadow =
          getValue(maps["boxShadow"], datas, "List<BoxShadow>?", vars, props);
      final gradient =
          getValue(maps["gradient"], datas, "Gradient?", vars, props);
      final backgroundBlendMode = getValue(
          maps["backgroundBlendMode"], datas, "BlendMode?", vars, props);
      final shape = getValue(maps["shape"], datas, "BoxShape", vars, props);
      return BoxDecoration(
          color: color,
          image: image,
          border: border,
          borderRadius: borderRadius,
          boxShadow: boxShadow != null ? List<BoxShadow>.from(boxShadow) : null,
          gradient: gradient,
          backgroundBlendMode: backgroundBlendMode,
          shape: shape ?? BoxShape.rectangle);
    },
    "BoxHitTestEntry": () {
      final target = getValue(maps["0"], datas, "T", vars, props);
      final localPosition = getValue(maps["1"], datas, "Offset", vars, props);
      if (target == null || localPosition == null) {
        return null;
      }
      return BoxHitTestEntry(target!, localPosition!);
    },
    "BoxHitTestResult": () {
      return BoxHitTestResult();
    },
    "BoxHitTestResult.wrap": () {
      final result = getValue(maps["0"], datas, "", vars, props);
      if (result == null) {
        return null;
      }
      return BoxHitTestResult.wrap(result!);
    },
    "BoxShadow": () {
      final color = getValue(maps["color"], datas, "", vars, props);
      final offset = getValue(maps["offset"], datas, "", vars, props);
      final blurRadius = getValue(maps["blurRadius"], datas, "", vars, props);
      final spreadRadius =
          getValue(maps["spreadRadius"], datas, "double", vars, props);
      final blurStyle =
          getValue(maps["blurStyle"], datas, "BlurStyle", vars, props);
      return BoxShadow(
          color: color,
          offset: offset,
          blurRadius: blurRadius,
          spreadRadius: spreadRadius ?? 0.0,
          blurStyle: blurStyle ?? BlurStyle.normal);
    },
    "Builder": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final builder =
          getValue(maps["builder"], datas, "WidgetBuilder", vars, props);
      if (builder == null) {
        return null;
      }
      return Builder(key: key, builder: builder!);
    },
    "ButtonActivateIntent": () {
      return const ButtonActivateIntent();
    },
    "ButtonBar": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final alignment =
          getValue(maps["alignment"], datas, "MainAxisAlignment?", vars, props);
      final mainAxisSize =
          getValue(maps["mainAxisSize"], datas, "MainAxisSize?", vars, props);
      final buttonTextTheme = getValue(
          maps["buttonTextTheme"], datas, "ButtonTextTheme?", vars, props);
      final buttonMinWidth =
          getValue(maps["buttonMinWidth"], datas, "double?", vars, props);
      final buttonHeight =
          getValue(maps["buttonHeight"], datas, "double?", vars, props);
      final buttonPadding = getValue(
          maps["buttonPadding"], datas, "EdgeInsetsGeometry?", vars, props);
      final buttonAlignedDropdown =
          getValue(maps["buttonAlignedDropdown"], datas, "bool?", vars, props);
      final layoutBehavior = getValue(maps["layoutBehavior"], datas,
          "ButtonBarLayoutBehavior?", vars, props);
      final overflowDirection = getValue(
          maps["overflowDirection"], datas, "VerticalDirection?", vars, props);
      final overflowButtonSpacing = getValue(
          maps["overflowButtonSpacing"], datas, "double?", vars, props);
      final children =
          getValue(maps["children"], datas, "List<Widget>", vars, props);
      return ButtonBar(
          key: key,
          alignment: alignment,
          mainAxisSize: mainAxisSize,
          buttonTextTheme: buttonTextTheme,
          buttonMinWidth: buttonMinWidth,
          buttonHeight: buttonHeight,
          buttonPadding: buttonPadding,
          buttonAlignedDropdown: buttonAlignedDropdown,
          layoutBehavior: layoutBehavior,
          overflowDirection: overflowDirection,
          overflowButtonSpacing: overflowButtonSpacing,
          children: List<Widget>.from(children ?? const <Widget>[]));
    },
    "ButtonBarTheme": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final data =
          getValue(maps["data"], datas, "ButtonBarThemeData", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (data == null || child == null) {
        return null;
      }
      return ButtonBarTheme(key: key, data: data!, child: child!);
    },
    "ButtonBarThemeData": () {
      final alignment =
          getValue(maps["alignment"], datas, "MainAxisAlignment?", vars, props);
      final mainAxisSize =
          getValue(maps["mainAxisSize"], datas, "MainAxisSize?", vars, props);
      final buttonTextTheme = getValue(
          maps["buttonTextTheme"], datas, "ButtonTextTheme?", vars, props);
      final buttonMinWidth =
          getValue(maps["buttonMinWidth"], datas, "double?", vars, props);
      final buttonHeight =
          getValue(maps["buttonHeight"], datas, "double?", vars, props);
      final buttonPadding = getValue(
          maps["buttonPadding"], datas, "EdgeInsetsGeometry?", vars, props);
      final buttonAlignedDropdown =
          getValue(maps["buttonAlignedDropdown"], datas, "bool?", vars, props);
      final layoutBehavior = getValue(maps["layoutBehavior"], datas,
          "ButtonBarLayoutBehavior?", vars, props);
      final overflowDirection = getValue(
          maps["overflowDirection"], datas, "VerticalDirection?", vars, props);
      return ButtonBarThemeData(
          alignment: alignment,
          mainAxisSize: mainAxisSize,
          buttonTextTheme: buttonTextTheme,
          buttonMinWidth: buttonMinWidth,
          buttonHeight: buttonHeight,
          buttonPadding: buttonPadding,
          buttonAlignedDropdown: buttonAlignedDropdown,
          layoutBehavior: layoutBehavior,
          overflowDirection: overflowDirection);
    },
    "ButtonSegment": () {
      final value = getValue(maps["value"], datas, "T", vars, props);
      final icon = getValue(maps["icon"], datas, "Widget?", vars, props);
      final label = getValue(maps["label"], datas, "Widget?", vars, props);
      final enabled = getValue(maps["enabled"], datas, "bool", vars, props);
      if (value == null) {
        return null;
      }
      return ButtonSegment(
          value: value!, icon: icon, label: label, enabled: enabled ?? true);
    },
    "ButtonStyle": () {
      final textStyle = getValue(maps["textStyle"], datas,
          "MaterialStateProperty<TextStyle?>?", vars, props);
      final backgroundColor = getValue(maps["backgroundColor"], datas,
          "MaterialStateProperty<Color?>?", vars, props);
      final foregroundColor = getValue(maps["foregroundColor"], datas,
          "MaterialStateProperty<Color?>?", vars, props);
      final overlayColor = getValue(maps["overlayColor"], datas,
          "MaterialStateProperty<Color?>?", vars, props);
      final shadowColor = getValue(maps["shadowColor"], datas,
          "MaterialStateProperty<Color?>?", vars, props);
      final surfaceTintColor = getValue(maps["surfaceTintColor"], datas,
          "MaterialStateProperty<Color?>?", vars, props);
      final elevation = getValue(maps["elevation"], datas,
          "MaterialStateProperty<double?>?", vars, props);
      final padding = getValue(maps["padding"], datas,
          "MaterialStateProperty<EdgeInsetsGeometry?>?", vars, props);
      final minimumSize = getValue(maps["minimumSize"], datas,
          "MaterialStateProperty<Size?>?", vars, props);
      final fixedSize = getValue(maps["fixedSize"], datas,
          "MaterialStateProperty<Size?>?", vars, props);
      final maximumSize = getValue(maps["maximumSize"], datas,
          "MaterialStateProperty<Size?>?", vars, props);
      final iconColor = getValue(maps["iconColor"], datas,
          "MaterialStateProperty<Color?>?", vars, props);
      final iconSize = getValue(maps["iconSize"], datas,
          "MaterialStateProperty<double?>?", vars, props);
      final side = getValue(maps["side"], datas,
          "MaterialStateProperty<BorderSide?>?", vars, props);
      final shape = getValue(maps["shape"], datas,
          "MaterialStateProperty<OutlinedBorder?>?", vars, props);
      final mouseCursor = getValue(maps["mouseCursor"], datas,
          "MaterialStateProperty<MouseCursor?>?", vars, props);
      final visualDensity =
          getValue(maps["visualDensity"], datas, "VisualDensity?", vars, props);
      final tapTargetSize = getValue(
          maps["tapTargetSize"], datas, "MaterialTapTargetSize?", vars, props);
      final animationDuration =
          getValue(maps["animationDuration"], datas, "Duration?", vars, props);
      final enableFeedback =
          getValue(maps["enableFeedback"], datas, "bool?", vars, props);
      final alignment =
          getValue(maps["alignment"], datas, "AlignmentGeometry?", vars, props);
      final splashFactory = getValue(maps["splashFactory"], datas,
          "InteractiveInkFeatureFactory?", vars, props);
      return ButtonStyle(
          textStyle: textStyle,
          backgroundColor: backgroundColor,
          foregroundColor: foregroundColor,
          overlayColor: overlayColor,
          shadowColor: shadowColor,
          surfaceTintColor: surfaceTintColor,
          elevation: elevation,
          padding: padding,
          minimumSize: minimumSize,
          fixedSize: fixedSize,
          maximumSize: maximumSize,
          iconColor: iconColor,
          iconSize: iconSize,
          side: side,
          shape: shape,
          mouseCursor: mouseCursor,
          visualDensity: visualDensity,
          tapTargetSize: tapTargetSize,
          animationDuration: animationDuration,
          enableFeedback: enableFeedback,
          alignment: alignment,
          splashFactory: splashFactory);
    },
    "ButtonTheme": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final textTheme =
          getValue(maps["textTheme"], datas, "ButtonTextTheme", vars, props);
      final layoutBehavior = getValue(maps["layoutBehavior"], datas,
          "ButtonBarLayoutBehavior", vars, props);
      final minWidth = getValue(maps["minWidth"], datas, "double", vars, props);
      final height = getValue(maps["height"], datas, "double", vars, props);
      final padding =
          getValue(maps["padding"], datas, "EdgeInsetsGeometry?", vars, props);
      final shape = getValue(maps["shape"], datas, "ShapeBorder?", vars, props);
      final alignedDropdown =
          getValue(maps["alignedDropdown"], datas, "bool", vars, props);
      final buttonColor =
          getValue(maps["buttonColor"], datas, "Color?", vars, props);
      final disabledColor =
          getValue(maps["disabledColor"], datas, "Color?", vars, props);
      final focusColor =
          getValue(maps["focusColor"], datas, "Color?", vars, props);
      final hoverColor =
          getValue(maps["hoverColor"], datas, "Color?", vars, props);
      final highlightColor =
          getValue(maps["highlightColor"], datas, "Color?", vars, props);
      final splashColor =
          getValue(maps["splashColor"], datas, "Color?", vars, props);
      final colorScheme =
          getValue(maps["colorScheme"], datas, "ColorScheme?", vars, props);
      final materialTapTargetSize = getValue(maps["materialTapTargetSize"],
          datas, "MaterialTapTargetSize?", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (child == null) {
        return null;
      }
      return ButtonTheme(
          key: key,
          textTheme: textTheme ?? ButtonTextTheme.normal,
          layoutBehavior: layoutBehavior ?? ButtonBarLayoutBehavior.padded,
          minWidth: minWidth ?? 88.0,
          height: height ?? 36.0,
          padding: padding,
          shape: shape,
          alignedDropdown: alignedDropdown ?? false,
          buttonColor: buttonColor,
          disabledColor: disabledColor,
          focusColor: focusColor,
          hoverColor: hoverColor,
          highlightColor: highlightColor,
          splashColor: splashColor,
          colorScheme: colorScheme,
          materialTapTargetSize: materialTapTargetSize,
          child: child!);
    },
    "ButtonTheme.fromButtonThemeData": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final data =
          getValue(maps["data"], datas, "ButtonThemeData", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (data == null || child == null) {
        return null;
      }
      return ButtonTheme.fromButtonThemeData(
          key: key, data: data!, child: child!);
    },
    "ButtonThemeData": () {
      final textTheme =
          getValue(maps["textTheme"], datas, "ButtonTextTheme", vars, props);
      final minWidth = getValue(maps["minWidth"], datas, "double", vars, props);
      final height = getValue(maps["height"], datas, "double", vars, props);
      final padding =
          getValue(maps["padding"], datas, "EdgeInsetsGeometry?", vars, props);
      final shape = getValue(maps["shape"], datas, "ShapeBorder?", vars, props);
      final layoutBehavior = getValue(maps["layoutBehavior"], datas,
          "ButtonBarLayoutBehavior", vars, props);
      final alignedDropdown =
          getValue(maps["alignedDropdown"], datas, "bool", vars, props);
      final buttonColor =
          getValue(maps["buttonColor"], datas, "Color?", vars, props);
      final disabledColor =
          getValue(maps["disabledColor"], datas, "Color?", vars, props);
      final focusColor =
          getValue(maps["focusColor"], datas, "Color?", vars, props);
      final hoverColor =
          getValue(maps["hoverColor"], datas, "Color?", vars, props);
      final highlightColor =
          getValue(maps["highlightColor"], datas, "Color?", vars, props);
      final splashColor =
          getValue(maps["splashColor"], datas, "Color?", vars, props);
      final colorScheme =
          getValue(maps["colorScheme"], datas, "ColorScheme?", vars, props);
      final materialTapTargetSize = getValue(maps["materialTapTargetSize"],
          datas, "MaterialTapTargetSize?", vars, props);
      return ButtonThemeData(
          textTheme: textTheme ?? ButtonTextTheme.normal,
          minWidth: minWidth ?? 88.0,
          height: height ?? 36.0,
          padding: padding,
          shape: shape,
          layoutBehavior: layoutBehavior ?? ButtonBarLayoutBehavior.padded,
          alignedDropdown: alignedDropdown ?? false,
          buttonColor: buttonColor,
          disabledColor: disabledColor,
          focusColor: focusColor,
          hoverColor: hoverColor,
          highlightColor: highlightColor,
          splashColor: splashColor,
          colorScheme: colorScheme,
          materialTapTargetSize: materialTapTargetSize);
    },
    "CachingIterable": () {
      final _prefillIterator =
          getValue(maps["0"], datas, "Iterator<E>", vars, props);
      if (_prefillIterator == null) {
        return null;
      }
      return CachingIterable(_prefillIterator!);
    },
    "CalendarDatePicker": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final initialDate =
          getValue(maps["initialDate"], datas, "DateTime", vars, props);
      final firstDate =
          getValue(maps["firstDate"], datas, "DateTime", vars, props);
      final lastDate =
          getValue(maps["lastDate"], datas, "DateTime", vars, props);
      final currentDate =
          getValue(maps["currentDate"], datas, "DateTime?", vars, props);
      final onDateChanged = getValue(
          maps["onDateChanged"], datas, "ValueChanged<DateTime>", vars, props);
      final onDisplayedMonthChanged = getValue(maps["onDisplayedMonthChanged"],
          datas, "ValueChanged<DateTime>?", vars, props);
      final initialCalendarMode = getValue(
          maps["initialCalendarMode"], datas, "DatePickerMode", vars, props);
      final selectableDayPredicate = getValue(maps["selectableDayPredicate"],
          datas, "SelectableDayPredicate?", vars, props);
      if (initialDate == null ||
          firstDate == null ||
          lastDate == null ||
          onDateChanged == null) {
        return null;
      }
      return CalendarDatePicker(
          key: key,
          initialDate: initialDate!,
          firstDate: firstDate!,
          lastDate: lastDate!,
          currentDate: currentDate,
          onDateChanged: onDateChanged!,
          onDisplayedMonthChanged: onDisplayedMonthChanged,
          initialCalendarMode: initialCalendarMode ?? DatePickerMode.day,
          selectableDayPredicate: selectableDayPredicate);
    },
    "CallbackAction": () {
      final onInvoke =
          getValue(maps["onInvoke"], datas, "OnInvokeCallback<T>", vars, props);
      if (onInvoke == null) {
        return null;
      }
      return CallbackAction(onInvoke: onInvoke!);
    },
    "CallbackHandle.fromRawHandle": () {
      final _handle = getValue(maps["0"], datas, "int", vars, props);
      if (_handle == null) {
        return null;
      }
      return ui.CallbackHandle.fromRawHandle(_handle!);
    },
    "CallbackShortcuts": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final bindings = getValue(maps["bindings"], datas,
          "Map<ShortcutActivator, VoidCallback>", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (bindings == null || child == null) {
        return null;
      }
      return CallbackShortcuts(
          key: key,
          bindings: Map<ShortcutActivator, VoidCallback>.from(bindings!),
          child: child!);
    },
    "Canvas": () {
      final recorder =
          getValue(maps["0"], datas, "PictureRecorder", vars, props);
      final cullRect = getValue(maps["1"], datas, "Rect?", vars, props);
      if (recorder == null) {
        return null;
      }
      return Canvas(recorder!, cullRect);
    },
    "Card": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final color = getValue(maps["color"], datas, "Color?", vars, props);
      final shadowColor =
          getValue(maps["shadowColor"], datas, "Color?", vars, props);
      final surfaceTintColor =
          getValue(maps["surfaceTintColor"], datas, "Color?", vars, props);
      final elevation =
          getValue(maps["elevation"], datas, "double?", vars, props);
      final shape = getValue(maps["shape"], datas, "ShapeBorder?", vars, props);
      final borderOnForeground =
          getValue(maps["borderOnForeground"], datas, "bool", vars, props);
      final margin =
          getValue(maps["margin"], datas, "EdgeInsetsGeometry?", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip?", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      final semanticContainer =
          getValue(maps["semanticContainer"], datas, "bool", vars, props);
      return Card(
          key: key,
          color: color,
          shadowColor: shadowColor,
          surfaceTintColor: surfaceTintColor,
          elevation: elevation,
          shape: shape,
          borderOnForeground: borderOnForeground ?? true,
          margin: margin,
          clipBehavior: clipBehavior,
          child: child,
          semanticContainer: semanticContainer ?? true);
    },
    "CardTheme": () {
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip?", vars, props);
      final color = getValue(maps["color"], datas, "Color?", vars, props);
      final shadowColor =
          getValue(maps["shadowColor"], datas, "Color?", vars, props);
      final surfaceTintColor =
          getValue(maps["surfaceTintColor"], datas, "Color?", vars, props);
      final elevation =
          getValue(maps["elevation"], datas, "double?", vars, props);
      final margin =
          getValue(maps["margin"], datas, "EdgeInsetsGeometry?", vars, props);
      final shape = getValue(maps["shape"], datas, "ShapeBorder?", vars, props);
      return CardTheme(
          clipBehavior: clipBehavior,
          color: color,
          shadowColor: shadowColor,
          surfaceTintColor: surfaceTintColor,
          elevation: elevation,
          margin: margin,
          shape: shape);
    },
    "Category": () {
      final sections = getValue(maps["0"], datas, "List<String>", vars, props);
      if (sections == null) {
        return null;
      }
      return Category(List<String>.from(sections!));
    },
    "CatmullRomCurve": () {
      final controlPoints = getValue(maps["0"], datas, "", vars, props);
      final tension = getValue(maps["tension"], datas, "", vars, props);
      if (controlPoints == null) {
        return null;
      }
      return CatmullRomCurve(controlPoints!, tension: tension ?? 0.0);
    },
    "CatmullRomSpline": () {
      final controlPoints =
          getValue(maps["0"], datas, "List<Offset>", vars, props);
      final tension = getValue(maps["tension"], datas, "double", vars, props);
      final startHandle =
          getValue(maps["startHandle"], datas, "Offset?", vars, props);
      final endHandle =
          getValue(maps["endHandle"], datas, "Offset?", vars, props);
      if (controlPoints == null) {
        return null;
      }
      return CatmullRomSpline(List<Offset>.from(controlPoints!),
          tension: tension ?? 0.0,
          startHandle: startHandle,
          endHandle: endHandle);
    },
    "Center": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final widthFactor =
          getValue(maps["widthFactor"], datas, "double?", vars, props);
      final heightFactor =
          getValue(maps["heightFactor"], datas, "double?", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      return Center(
          key: key,
          widthFactor: widthFactor,
          heightFactor: heightFactor,
          child: child);
    },
    "ChannelBuffers": () {
      return ChannelBuffers();
    },
    "CharacterActivator": () {
      final character = getValue(maps["0"], datas, "String", vars, props);
      final alt = getValue(maps["alt"], datas, "bool", vars, props);
      final control = getValue(maps["control"], datas, "bool", vars, props);
      final meta = getValue(maps["meta"], datas, "bool", vars, props);
      final includeRepeats =
          getValue(maps["includeRepeats"], datas, "bool", vars, props);
      if (character == null) {
        return null;
      }
      return CharacterActivator(character!,
          alt: alt ?? false,
          control: control ?? false,
          meta: meta ?? false,
          includeRepeats: includeRepeats ?? true);
    },
    "CharacterBoundary": () {
      final _text = getValue(maps["0"], datas, "String", vars, props);
      if (_text == null) {
        return null;
      }
      return CharacterBoundary(_text!);
    },
    "Checkbox": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final value = getValue(maps["value"], datas, "bool?", vars, props);
      final tristate = getValue(maps["tristate"], datas, "bool", vars, props);
      final onChanged = getValue(
          maps["onChanged"], datas, "ValueChanged<bool?>?", vars, props);
      final mouseCursor =
          getValue(maps["mouseCursor"], datas, "MouseCursor?", vars, props);
      final activeColor =
          getValue(maps["activeColor"], datas, "Color?", vars, props);
      final fillColor = getValue(maps["fillColor"], datas,
          "MaterialStateProperty<Color?>?", vars, props);
      final checkColor =
          getValue(maps["checkColor"], datas, "Color?", vars, props);
      final focusColor =
          getValue(maps["focusColor"], datas, "Color?", vars, props);
      final hoverColor =
          getValue(maps["hoverColor"], datas, "Color?", vars, props);
      final overlayColor = getValue(maps["overlayColor"], datas,
          "MaterialStateProperty<Color?>?", vars, props);
      final splashRadius =
          getValue(maps["splashRadius"], datas, "double?", vars, props);
      final materialTapTargetSize = getValue(maps["materialTapTargetSize"],
          datas, "MaterialTapTargetSize?", vars, props);
      final visualDensity =
          getValue(maps["visualDensity"], datas, "VisualDensity?", vars, props);
      final focusNode =
          getValue(maps["focusNode"], datas, "FocusNode?", vars, props);
      final autofocus = getValue(maps["autofocus"], datas, "bool", vars, props);
      final shape =
          getValue(maps["shape"], datas, "OutlinedBorder?", vars, props);
      final side = getValue(maps["side"], datas, "BorderSide?", vars, props);
      final isError = getValue(maps["isError"], datas, "bool", vars, props);
      if (value == null || onChanged == null) {
        return null;
      }
      return Checkbox(
          key: key,
          value: value!,
          tristate: tristate ?? false,
          onChanged: onChanged!,
          mouseCursor: mouseCursor,
          activeColor: activeColor,
          fillColor: fillColor,
          checkColor: checkColor,
          focusColor: focusColor,
          hoverColor: hoverColor,
          overlayColor: overlayColor,
          splashRadius: splashRadius,
          materialTapTargetSize: materialTapTargetSize,
          visualDensity: visualDensity,
          focusNode: focusNode,
          autofocus: autofocus ?? false,
          shape: shape,
          side: side,
          isError: isError ?? false);
    },
    "Checkbox.adaptive": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final value = getValue(maps["value"], datas, "bool?", vars, props);
      final tristate = getValue(maps["tristate"], datas, "bool", vars, props);
      final onChanged = getValue(
          maps["onChanged"], datas, "ValueChanged<bool?>?", vars, props);
      final mouseCursor =
          getValue(maps["mouseCursor"], datas, "MouseCursor?", vars, props);
      final activeColor =
          getValue(maps["activeColor"], datas, "Color?", vars, props);
      final fillColor = getValue(maps["fillColor"], datas,
          "MaterialStateProperty<Color?>?", vars, props);
      final checkColor =
          getValue(maps["checkColor"], datas, "Color?", vars, props);
      final focusColor =
          getValue(maps["focusColor"], datas, "Color?", vars, props);
      final hoverColor =
          getValue(maps["hoverColor"], datas, "Color?", vars, props);
      final overlayColor = getValue(maps["overlayColor"], datas,
          "MaterialStateProperty<Color?>?", vars, props);
      final splashRadius =
          getValue(maps["splashRadius"], datas, "double?", vars, props);
      final materialTapTargetSize = getValue(maps["materialTapTargetSize"],
          datas, "MaterialTapTargetSize?", vars, props);
      final visualDensity =
          getValue(maps["visualDensity"], datas, "VisualDensity?", vars, props);
      final focusNode =
          getValue(maps["focusNode"], datas, "FocusNode?", vars, props);
      final autofocus = getValue(maps["autofocus"], datas, "bool", vars, props);
      final shape =
          getValue(maps["shape"], datas, "OutlinedBorder?", vars, props);
      final side = getValue(maps["side"], datas, "BorderSide?", vars, props);
      final isError = getValue(maps["isError"], datas, "bool", vars, props);
      if (value == null || onChanged == null) {
        return null;
      }
      return Checkbox.adaptive(
          key: key,
          value: value!,
          tristate: tristate ?? false,
          onChanged: onChanged!,
          mouseCursor: mouseCursor,
          activeColor: activeColor,
          fillColor: fillColor,
          checkColor: checkColor,
          focusColor: focusColor,
          hoverColor: hoverColor,
          overlayColor: overlayColor,
          splashRadius: splashRadius,
          materialTapTargetSize: materialTapTargetSize,
          visualDensity: visualDensity,
          focusNode: focusNode,
          autofocus: autofocus ?? false,
          shape: shape,
          side: side,
          isError: isError ?? false);
    },
    "CheckboxListTile": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final value = getValue(maps["value"], datas, "bool?", vars, props);
      final onChanged = getValue(
          maps["onChanged"], datas, "ValueChanged<bool?>?", vars, props);
      final mouseCursor =
          getValue(maps["mouseCursor"], datas, "MouseCursor?", vars, props);
      final activeColor =
          getValue(maps["activeColor"], datas, "Color?", vars, props);
      final fillColor = getValue(maps["fillColor"], datas,
          "MaterialStateProperty<Color?>?", vars, props);
      final checkColor =
          getValue(maps["checkColor"], datas, "Color?", vars, props);
      final hoverColor =
          getValue(maps["hoverColor"], datas, "Color?", vars, props);
      final overlayColor = getValue(maps["overlayColor"], datas,
          "MaterialStateProperty<Color?>?", vars, props);
      final splashRadius =
          getValue(maps["splashRadius"], datas, "double?", vars, props);
      final materialTapTargetSize = getValue(maps["materialTapTargetSize"],
          datas, "MaterialTapTargetSize?", vars, props);
      final visualDensity =
          getValue(maps["visualDensity"], datas, "VisualDensity?", vars, props);
      final focusNode =
          getValue(maps["focusNode"], datas, "FocusNode?", vars, props);
      final autofocus = getValue(maps["autofocus"], datas, "bool", vars, props);
      final shape = getValue(maps["shape"], datas, "ShapeBorder?", vars, props);
      final side = getValue(maps["side"], datas, "BorderSide?", vars, props);
      final isError = getValue(maps["isError"], datas, "bool", vars, props);
      final enabled = getValue(maps["enabled"], datas, "bool?", vars, props);
      final tileColor =
          getValue(maps["tileColor"], datas, "Color?", vars, props);
      final title = getValue(maps["title"], datas, "Widget?", vars, props);
      final subtitle =
          getValue(maps["subtitle"], datas, "Widget?", vars, props);
      final isThreeLine =
          getValue(maps["isThreeLine"], datas, "bool", vars, props);
      final dense = getValue(maps["dense"], datas, "bool?", vars, props);
      final secondary =
          getValue(maps["secondary"], datas, "Widget?", vars, props);
      final selected = getValue(maps["selected"], datas, "bool", vars, props);
      final controlAffinity = getValue(maps["controlAffinity"], datas,
          "ListTileControlAffinity", vars, props);
      final contentPadding = getValue(
          maps["contentPadding"], datas, "EdgeInsetsGeometry?", vars, props);
      final tristate = getValue(maps["tristate"], datas, "bool", vars, props);
      final checkboxShape = getValue(
          maps["checkboxShape"], datas, "OutlinedBorder?", vars, props);
      final selectedTileColor =
          getValue(maps["selectedTileColor"], datas, "Color?", vars, props);
      final onFocusChange = getValue(
          maps["onFocusChange"], datas, "ValueChanged<bool>?", vars, props);
      final enableFeedback =
          getValue(maps["enableFeedback"], datas, "bool?", vars, props);
      if (value == null || onChanged == null) {
        return null;
      }
      return CheckboxListTile(
          key: key,
          value: value!,
          onChanged: onChanged!,
          mouseCursor: mouseCursor,
          activeColor: activeColor,
          fillColor: fillColor,
          checkColor: checkColor,
          hoverColor: hoverColor,
          overlayColor: overlayColor,
          splashRadius: splashRadius,
          materialTapTargetSize: materialTapTargetSize,
          visualDensity: visualDensity,
          focusNode: focusNode,
          autofocus: autofocus ?? false,
          shape: shape,
          side: side,
          isError: isError ?? false,
          enabled: enabled,
          tileColor: tileColor,
          title: title,
          subtitle: subtitle,
          isThreeLine: isThreeLine ?? false,
          dense: dense,
          secondary: secondary,
          selected: selected ?? false,
          controlAffinity: controlAffinity ?? ListTileControlAffinity.platform,
          contentPadding: contentPadding,
          tristate: tristate ?? false,
          checkboxShape: checkboxShape,
          selectedTileColor: selectedTileColor,
          onFocusChange: onFocusChange,
          enableFeedback: enableFeedback);
    },
    "CheckboxListTile.adaptive": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final value = getValue(maps["value"], datas, "bool?", vars, props);
      final onChanged = getValue(
          maps["onChanged"], datas, "ValueChanged<bool?>?", vars, props);
      final mouseCursor =
          getValue(maps["mouseCursor"], datas, "MouseCursor?", vars, props);
      final activeColor =
          getValue(maps["activeColor"], datas, "Color?", vars, props);
      final fillColor = getValue(maps["fillColor"], datas,
          "MaterialStateProperty<Color?>?", vars, props);
      final checkColor =
          getValue(maps["checkColor"], datas, "Color?", vars, props);
      final hoverColor =
          getValue(maps["hoverColor"], datas, "Color?", vars, props);
      final overlayColor = getValue(maps["overlayColor"], datas,
          "MaterialStateProperty<Color?>?", vars, props);
      final splashRadius =
          getValue(maps["splashRadius"], datas, "double?", vars, props);
      final materialTapTargetSize = getValue(maps["materialTapTargetSize"],
          datas, "MaterialTapTargetSize?", vars, props);
      final visualDensity =
          getValue(maps["visualDensity"], datas, "VisualDensity?", vars, props);
      final focusNode =
          getValue(maps["focusNode"], datas, "FocusNode?", vars, props);
      final autofocus = getValue(maps["autofocus"], datas, "bool", vars, props);
      final shape = getValue(maps["shape"], datas, "ShapeBorder?", vars, props);
      final side = getValue(maps["side"], datas, "BorderSide?", vars, props);
      final isError = getValue(maps["isError"], datas, "bool", vars, props);
      final enabled = getValue(maps["enabled"], datas, "bool?", vars, props);
      final tileColor =
          getValue(maps["tileColor"], datas, "Color?", vars, props);
      final title = getValue(maps["title"], datas, "Widget?", vars, props);
      final subtitle =
          getValue(maps["subtitle"], datas, "Widget?", vars, props);
      final isThreeLine =
          getValue(maps["isThreeLine"], datas, "bool", vars, props);
      final dense = getValue(maps["dense"], datas, "bool?", vars, props);
      final secondary =
          getValue(maps["secondary"], datas, "Widget?", vars, props);
      final selected = getValue(maps["selected"], datas, "bool", vars, props);
      final controlAffinity = getValue(maps["controlAffinity"], datas,
          "ListTileControlAffinity", vars, props);
      final contentPadding = getValue(
          maps["contentPadding"], datas, "EdgeInsetsGeometry?", vars, props);
      final tristate = getValue(maps["tristate"], datas, "bool", vars, props);
      final checkboxShape = getValue(
          maps["checkboxShape"], datas, "OutlinedBorder?", vars, props);
      final selectedTileColor =
          getValue(maps["selectedTileColor"], datas, "Color?", vars, props);
      final onFocusChange = getValue(
          maps["onFocusChange"], datas, "ValueChanged<bool>?", vars, props);
      final enableFeedback =
          getValue(maps["enableFeedback"], datas, "bool?", vars, props);
      if (value == null || onChanged == null) {
        return null;
      }
      return CheckboxListTile.adaptive(
          key: key,
          value: value!,
          onChanged: onChanged!,
          mouseCursor: mouseCursor,
          activeColor: activeColor,
          fillColor: fillColor,
          checkColor: checkColor,
          hoverColor: hoverColor,
          overlayColor: overlayColor,
          splashRadius: splashRadius,
          materialTapTargetSize: materialTapTargetSize,
          visualDensity: visualDensity,
          focusNode: focusNode,
          autofocus: autofocus ?? false,
          shape: shape,
          side: side,
          isError: isError ?? false,
          enabled: enabled,
          tileColor: tileColor,
          title: title,
          subtitle: subtitle,
          isThreeLine: isThreeLine ?? false,
          dense: dense,
          secondary: secondary,
          selected: selected ?? false,
          controlAffinity: controlAffinity ?? ListTileControlAffinity.platform,
          contentPadding: contentPadding,
          tristate: tristate ?? false,
          checkboxShape: checkboxShape,
          selectedTileColor: selectedTileColor,
          onFocusChange: onFocusChange,
          enableFeedback: enableFeedback);
    },
    "CheckboxMenuButton": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final value = getValue(maps["value"], datas, "bool?", vars, props);
      final tristate = getValue(maps["tristate"], datas, "bool", vars, props);
      final isError = getValue(maps["isError"], datas, "bool", vars, props);
      final onChanged = getValue(
          maps["onChanged"], datas, "ValueChanged<bool?>?", vars, props);
      final onHover =
          getValue(maps["onHover"], datas, "ValueChanged<bool>?", vars, props);
      final onFocusChange = getValue(
          maps["onFocusChange"], datas, "ValueChanged<bool>?", vars, props);
      final focusNode =
          getValue(maps["focusNode"], datas, "FocusNode?", vars, props);
      final shortcut = getValue(
          maps["shortcut"], datas, "MenuSerializableShortcut?", vars, props);
      final style = getValue(maps["style"], datas, "ButtonStyle?", vars, props);
      final statesController = getValue(maps["statesController"], datas,
          "MaterialStatesController?", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      final trailingIcon =
          getValue(maps["trailingIcon"], datas, "Widget?", vars, props);
      final closeOnActivate =
          getValue(maps["closeOnActivate"], datas, "bool", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      if (value == null || onChanged == null || child == null) {
        return null;
      }
      return CheckboxMenuButton(
          key: key,
          value: value!,
          tristate: tristate ?? false,
          isError: isError ?? false,
          onChanged: onChanged!,
          onHover: onHover,
          onFocusChange: onFocusChange,
          focusNode: focusNode,
          shortcut: shortcut,
          style: style,
          statesController: statesController,
          clipBehavior: clipBehavior ?? Clip.none,
          trailingIcon: trailingIcon,
          closeOnActivate: closeOnActivate ?? true,
          child: child!);
    },
    "CheckboxTheme": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final data =
          getValue(maps["data"], datas, "CheckboxThemeData", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (data == null || child == null) {
        return null;
      }
      return CheckboxTheme(key: key, data: data!, child: child!);
    },
    "CheckboxThemeData": () {
      final mouseCursor = getValue(maps["mouseCursor"], datas,
          "MaterialStateProperty<MouseCursor?>?", vars, props);
      final fillColor = getValue(maps["fillColor"], datas,
          "MaterialStateProperty<Color?>?", vars, props);
      final checkColor = getValue(maps["checkColor"], datas,
          "MaterialStateProperty<Color?>?", vars, props);
      final overlayColor = getValue(maps["overlayColor"], datas,
          "MaterialStateProperty<Color?>?", vars, props);
      final splashRadius =
          getValue(maps["splashRadius"], datas, "double?", vars, props);
      final materialTapTargetSize = getValue(maps["materialTapTargetSize"],
          datas, "MaterialTapTargetSize?", vars, props);
      final visualDensity =
          getValue(maps["visualDensity"], datas, "VisualDensity?", vars, props);
      final shape =
          getValue(maps["shape"], datas, "OutlinedBorder?", vars, props);
      final side = getValue(maps["side"], datas, "BorderSide?", vars, props);
      return CheckboxThemeData(
          mouseCursor: mouseCursor,
          fillColor: fillColor,
          checkColor: checkColor,
          overlayColor: overlayColor,
          splashRadius: splashRadius,
          materialTapTargetSize: materialTapTargetSize,
          visualDensity: visualDensity,
          shape: shape,
          side: side);
    },
    "CheckedModeBanner": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (child == null) {
        return null;
      }
      return CheckedModeBanner(key: key, child: child!);
    },
    "CheckedPopupMenuItem": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final value = getValue(maps["value"], datas, "T?", vars, props);
      final checked = getValue(maps["checked"], datas, "bool", vars, props);
      final enabled = getValue(maps["enabled"], datas, "bool", vars, props);
      final padding =
          getValue(maps["padding"], datas, "EdgeInsets?", vars, props);
      final height = getValue(maps["height"], datas, "double", vars, props);
      final mouseCursor =
          getValue(maps["mouseCursor"], datas, "MouseCursor?", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      return CheckedPopupMenuItem(
          key: key,
          value: value,
          checked: checked ?? false,
          enabled: enabled ?? true,
          padding: padding,
          height: height ?? kMinInteractiveDimension,
          mouseCursor: mouseCursor,
          child: child);
    },
    "ChildBackButtonDispatcher": () {
      final parent =
          getValue(maps["0"], datas, "BackButtonDispatcher", vars, props);
      if (parent == null) {
        return null;
      }
      return ChildBackButtonDispatcher(parent!);
    },
    "ChildSemanticsConfigurationsResultBuilder": () {
      return ChildSemanticsConfigurationsResultBuilder();
    },
    "Chip": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final avatar = getValue(maps["avatar"], datas, "Widget?", vars, props);
      final label = getValue(maps["label"], datas, "Widget", vars, props);
      final labelStyle =
          getValue(maps["labelStyle"], datas, "TextStyle?", vars, props);
      final labelPadding = getValue(
          maps["labelPadding"], datas, "EdgeInsetsGeometry?", vars, props);
      final deleteIcon =
          getValue(maps["deleteIcon"], datas, "Widget?", vars, props);
      final onDeleted =
          getValue(maps["onDeleted"], datas, "VoidCallback?", vars, props);
      final deleteIconColor =
          getValue(maps["deleteIconColor"], datas, "Color?", vars, props);
      final deleteButtonTooltipMessage = getValue(
          maps["deleteButtonTooltipMessage"], datas, "String?", vars, props);
      final side = getValue(maps["side"], datas, "BorderSide?", vars, props);
      final shape =
          getValue(maps["shape"], datas, "OutlinedBorder?", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      final focusNode =
          getValue(maps["focusNode"], datas, "FocusNode?", vars, props);
      final autofocus = getValue(maps["autofocus"], datas, "bool", vars, props);
      final backgroundColor =
          getValue(maps["backgroundColor"], datas, "Color?", vars, props);
      final padding =
          getValue(maps["padding"], datas, "EdgeInsetsGeometry?", vars, props);
      final visualDensity =
          getValue(maps["visualDensity"], datas, "VisualDensity?", vars, props);
      final materialTapTargetSize = getValue(maps["materialTapTargetSize"],
          datas, "MaterialTapTargetSize?", vars, props);
      final elevation =
          getValue(maps["elevation"], datas, "double?", vars, props);
      final shadowColor =
          getValue(maps["shadowColor"], datas, "Color?", vars, props);
      final surfaceTintColor =
          getValue(maps["surfaceTintColor"], datas, "Color?", vars, props);
      final iconTheme =
          getValue(maps["iconTheme"], datas, "IconThemeData?", vars, props);
      final useDeleteButtonTooltip =
          getValue(maps["useDeleteButtonTooltip"], datas, "bool", vars, props);
      if (label == null) {
        return null;
      }
      return Chip(
        key: key,
        avatar: avatar,
        label: label!,
        labelStyle: labelStyle,
        labelPadding: labelPadding,
        deleteIcon: deleteIcon,
        onDeleted: onDeleted,
        deleteIconColor: deleteIconColor,
        deleteButtonTooltipMessage: deleteButtonTooltipMessage,
        side: side,
        shape: shape,
        clipBehavior: clipBehavior ?? Clip.none,
        focusNode: focusNode,
        autofocus: autofocus ?? false,
        backgroundColor: backgroundColor,
        padding: padding,
        visualDensity: visualDensity,
        materialTapTargetSize: materialTapTargetSize,
        elevation: elevation,
        shadowColor: shadowColor,
        surfaceTintColor: surfaceTintColor,
        iconTheme: iconTheme,
        //useDeleteButtonTooltip: useDeleteButtonTooltip ?? true,
      );
    },
    "ChipTheme": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final data = getValue(maps["data"], datas, "ChipThemeData", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (data == null || child == null) {
        return null;
      }
      return ChipTheme(key: key, data: data!, child: child!);
    },
    "ChipThemeData": () {
      final backgroundColor =
          getValue(maps["backgroundColor"], datas, "Color?", vars, props);
      final deleteIconColor =
          getValue(maps["deleteIconColor"], datas, "Color?", vars, props);
      final disabledColor =
          getValue(maps["disabledColor"], datas, "Color?", vars, props);
      final selectedColor =
          getValue(maps["selectedColor"], datas, "Color?", vars, props);
      final secondarySelectedColor = getValue(
          maps["secondarySelectedColor"], datas, "Color?", vars, props);
      final shadowColor =
          getValue(maps["shadowColor"], datas, "Color?", vars, props);
      final surfaceTintColor =
          getValue(maps["surfaceTintColor"], datas, "Color?", vars, props);
      final selectedShadowColor =
          getValue(maps["selectedShadowColor"], datas, "Color?", vars, props);
      final showCheckmark =
          getValue(maps["showCheckmark"], datas, "bool?", vars, props);
      final checkmarkColor =
          getValue(maps["checkmarkColor"], datas, "Color?", vars, props);
      final labelPadding = getValue(
          maps["labelPadding"], datas, "EdgeInsetsGeometry?", vars, props);
      final padding =
          getValue(maps["padding"], datas, "EdgeInsetsGeometry?", vars, props);
      final side = getValue(maps["side"], datas, "BorderSide?", vars, props);
      final shape =
          getValue(maps["shape"], datas, "OutlinedBorder?", vars, props);
      final labelStyle =
          getValue(maps["labelStyle"], datas, "TextStyle?", vars, props);
      final secondaryLabelStyle = getValue(
          maps["secondaryLabelStyle"], datas, "TextStyle?", vars, props);
      final brightness =
          getValue(maps["brightness"], datas, "Brightness?", vars, props);
      final elevation =
          getValue(maps["elevation"], datas, "double?", vars, props);
      final pressElevation =
          getValue(maps["pressElevation"], datas, "double?", vars, props);
      final iconTheme =
          getValue(maps["iconTheme"], datas, "IconThemeData?", vars, props);
      return ChipThemeData(
          backgroundColor: backgroundColor,
          deleteIconColor: deleteIconColor,
          disabledColor: disabledColor,
          selectedColor: selectedColor,
          secondarySelectedColor: secondarySelectedColor,
          shadowColor: shadowColor,
          surfaceTintColor: surfaceTintColor,
          selectedShadowColor: selectedShadowColor,
          showCheckmark: showCheckmark,
          checkmarkColor: checkmarkColor,
          labelPadding: labelPadding,
          padding: padding,
          side: side,
          shape: shape,
          labelStyle: labelStyle,
          secondaryLabelStyle: secondaryLabelStyle,
          brightness: brightness,
          elevation: elevation,
          pressElevation: pressElevation,
          iconTheme: iconTheme);
    },
    "ChipThemeData.fromDefaults": () {
      final brightness =
          getValue(maps["brightness"], datas, "Brightness?", vars, props);
      final primaryColor =
          getValue(maps["primaryColor"], datas, "Color?", vars, props);
      final secondaryColor =
          getValue(maps["secondaryColor"], datas, "Color", vars, props);
      final labelStyle =
          getValue(maps["labelStyle"], datas, "TextStyle", vars, props);
      if (secondaryColor == null || labelStyle == null) {
        return null;
      }
      return ChipThemeData.fromDefaults(
          brightness: brightness,
          primaryColor: primaryColor,
          secondaryColor: secondaryColor!,
          labelStyle: labelStyle!);
    },
    "ChoiceChip": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final avatar = getValue(maps["avatar"], datas, "Widget?", vars, props);
      final label = getValue(maps["label"], datas, "Widget", vars, props);
      final labelStyle =
          getValue(maps["labelStyle"], datas, "TextStyle?", vars, props);
      final labelPadding = getValue(
          maps["labelPadding"], datas, "EdgeInsetsGeometry?", vars, props);
      final onSelected = getValue(
          maps["onSelected"], datas, "ValueChanged<bool>?", vars, props);
      final pressElevation =
          getValue(maps["pressElevation"], datas, "double?", vars, props);
      final selected = getValue(maps["selected"], datas, "bool", vars, props);
      final selectedColor =
          getValue(maps["selectedColor"], datas, "Color?", vars, props);
      final disabledColor =
          getValue(maps["disabledColor"], datas, "Color?", vars, props);
      final tooltip = getValue(maps["tooltip"], datas, "String?", vars, props);
      final side = getValue(maps["side"], datas, "BorderSide?", vars, props);
      final shape =
          getValue(maps["shape"], datas, "OutlinedBorder?", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      final focusNode =
          getValue(maps["focusNode"], datas, "FocusNode?", vars, props);
      final autofocus = getValue(maps["autofocus"], datas, "bool", vars, props);
      final backgroundColor =
          getValue(maps["backgroundColor"], datas, "Color?", vars, props);
      final padding =
          getValue(maps["padding"], datas, "EdgeInsetsGeometry?", vars, props);
      final visualDensity =
          getValue(maps["visualDensity"], datas, "VisualDensity?", vars, props);
      final materialTapTargetSize = getValue(maps["materialTapTargetSize"],
          datas, "MaterialTapTargetSize?", vars, props);
      final elevation =
          getValue(maps["elevation"], datas, "double?", vars, props);
      final shadowColor =
          getValue(maps["shadowColor"], datas, "Color?", vars, props);
      final surfaceTintColor =
          getValue(maps["surfaceTintColor"], datas, "Color?", vars, props);
      final iconTheme =
          getValue(maps["iconTheme"], datas, "IconThemeData?", vars, props);
      final selectedShadowColor =
          getValue(maps["selectedShadowColor"], datas, "Color?", vars, props);
      final avatarBorder =
          getValue(maps["avatarBorder"], datas, "ShapeBorder", vars, props);
      if (label == null || selected == null) {
        return null;
      }
      return ChoiceChip(
          key: key,
          avatar: avatar,
          label: label!,
          labelStyle: labelStyle,
          labelPadding: labelPadding,
          onSelected: onSelected,
          pressElevation: pressElevation,
          selected: selected!,
          selectedColor: selectedColor,
          disabledColor: disabledColor,
          tooltip: tooltip,
          side: side,
          shape: shape,
          clipBehavior: clipBehavior ?? Clip.none,
          focusNode: focusNode,
          autofocus: autofocus ?? false,
          backgroundColor: backgroundColor,
          padding: padding,
          visualDensity: visualDensity,
          materialTapTargetSize: materialTapTargetSize,
          elevation: elevation,
          shadowColor: shadowColor,
          surfaceTintColor: surfaceTintColor,
          iconTheme: iconTheme,
          selectedShadowColor: selectedShadowColor,
          avatarBorder: avatarBorder ?? const CircleBorder());
    },
    "CircleAvatar": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      final backgroundColor =
          getValue(maps["backgroundColor"], datas, "Color?", vars, props);
      final backgroundImage = getValue(
          maps["backgroundImage"], datas, "ImageProvider?", vars, props);
      final foregroundImage = getValue(
          maps["foregroundImage"], datas, "ImageProvider?", vars, props);
      final onBackgroundImageError = getValue(maps["onBackgroundImageError"],
          datas, "ImageErrorListener?", vars, props);
      final onForegroundImageError = getValue(maps["onForegroundImageError"],
          datas, "ImageErrorListener?", vars, props);
      final foregroundColor =
          getValue(maps["foregroundColor"], datas, "Color?", vars, props);
      final radius = getValue(maps["radius"], datas, "double?", vars, props);
      final minRadius =
          getValue(maps["minRadius"], datas, "double?", vars, props);
      final maxRadius =
          getValue(maps["maxRadius"], datas, "double?", vars, props);
      return CircleAvatar(
          key: key,
          child: child,
          backgroundColor: backgroundColor,
          backgroundImage: backgroundImage,
          foregroundImage: foregroundImage,
          onBackgroundImageError: onBackgroundImageError,
          onForegroundImageError: onForegroundImageError,
          foregroundColor: foregroundColor,
          radius: radius,
          minRadius: minRadius,
          maxRadius: maxRadius);
    },
    "CircleBorder": () {
      final side = getValue(maps["side"], datas, "", vars, props);
      final eccentricity =
          getValue(maps["eccentricity"], datas, "", vars, props);
      return CircleBorder(side: side, eccentricity: eccentricity ?? 0.0);
    },
    "CircularNotchedRectangle": () {
      return const CircularNotchedRectangle();
    },
    "CircularProgressIndicator": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final value = getValue(maps["value"], datas, "double?", vars, props);
      final backgroundColor =
          getValue(maps["backgroundColor"], datas, "Color?", vars, props);
      final color = getValue(maps["color"], datas, "Color?", vars, props);
      final valueColor = getValue(
          maps["valueColor"], datas, "Animation<Color?>?", vars, props);
      final strokeWidth =
          getValue(maps["strokeWidth"], datas, "double", vars, props);
      final semanticsLabel =
          getValue(maps["semanticsLabel"], datas, "String?", vars, props);
      final semanticsValue =
          getValue(maps["semanticsValue"], datas, "String?", vars, props);
      return CircularProgressIndicator(
          key: key,
          value: value,
          backgroundColor: backgroundColor,
          color: color,
          valueColor: valueColor,
          strokeWidth: strokeWidth ?? 4.0,
          semanticsLabel: semanticsLabel,
          semanticsValue: semanticsValue);
    },
    "CircularProgressIndicator.adaptive": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final value = getValue(maps["value"], datas, "double?", vars, props);
      final backgroundColor =
          getValue(maps["backgroundColor"], datas, "Color?", vars, props);
      final valueColor = getValue(
          maps["valueColor"], datas, "Animation<Color?>?", vars, props);
      final strokeWidth =
          getValue(maps["strokeWidth"], datas, "double", vars, props);
      final semanticsLabel =
          getValue(maps["semanticsLabel"], datas, "String?", vars, props);
      final semanticsValue =
          getValue(maps["semanticsValue"], datas, "String?", vars, props);
      return CircularProgressIndicator.adaptive(
          key: key,
          value: value,
          backgroundColor: backgroundColor,
          valueColor: valueColor,
          strokeWidth: strokeWidth ?? 4.0,
          semanticsLabel: semanticsLabel,
          semanticsValue: semanticsValue);
    },
    "ClampedSimulation": () {
      final simulation = getValue(maps["0"], datas, "Simulation", vars, props);
      final xMin = getValue(maps["xMin"], datas, "double", vars, props);
      final xMax = getValue(maps["xMax"], datas, "double", vars, props);
      final dxMin = getValue(maps["dxMin"], datas, "double", vars, props);
      final dxMax = getValue(maps["dxMax"], datas, "double", vars, props);
      if (simulation == null) {
        return null;
      }
      return ClampedSimulation(simulation!,
          xMin: xMin ?? double.negativeInfinity,
          xMax: xMax ?? double.infinity,
          dxMin: dxMin ?? double.negativeInfinity,
          dxMax: dxMax ?? double.infinity);
    },
    "ClampingScrollPhysics": () {
      final parent =
          getValue(maps["parent"], datas, "ScrollPhysics?", vars, props);
      return ClampingScrollPhysics(parent: parent);
    },
    "ClearSelectionEvent": () {
      return const ClearSelectionEvent();
    },
    "ClipOval": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final clipper =
          getValue(maps["clipper"], datas, "CustomClipper<Rect>?", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      return ClipOval(
          key: key,
          clipper: clipper,
          clipBehavior: clipBehavior ?? Clip.antiAlias,
          child: child);
    },
    "ClipPath": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final clipper =
          getValue(maps["clipper"], datas, "CustomClipper<Path>?", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      return ClipPath(
          key: key,
          clipper: clipper,
          clipBehavior: clipBehavior ?? Clip.antiAlias,
          child: child);
    },
    "ClipPathLayer": () {
      final clipPath = getValue(maps["clipPath"], datas, "Path?", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      return ClipPathLayer(
          clipPath: clipPath, clipBehavior: clipBehavior ?? Clip.antiAlias);
    },
    "ClipRRect": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final borderRadius = getValue(
          maps["borderRadius"], datas, "BorderRadiusGeometry?", vars, props);
      final clipper = getValue(
          maps["clipper"], datas, "CustomClipper<RRect>?", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      return ClipRRect(
          key: key,
          borderRadius: borderRadius ?? BorderRadius.zero,
          clipper: clipper,
          clipBehavior: clipBehavior ?? Clip.antiAlias,
          child: child);
    },
    "ClipRRectLayer": () {
      final clipRRect =
          getValue(maps["clipRRect"], datas, "RRect?", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      return ClipRRectLayer(
          clipRRect: clipRRect, clipBehavior: clipBehavior ?? Clip.antiAlias);
    },
    "ClipRect": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final clipper =
          getValue(maps["clipper"], datas, "CustomClipper<Rect>?", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      return ClipRect(
          key: key,
          clipper: clipper,
          clipBehavior: clipBehavior ?? Clip.hardEdge,
          child: child);
    },
    "ClipRectLayer": () {
      final clipRect = getValue(maps["clipRect"], datas, "Rect?", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      return ClipRectLayer(
          clipRect: clipRect, clipBehavior: clipBehavior ?? Clip.hardEdge);
    },
    "ClipboardData": () {
      final text = getValue(maps["text"], datas, "String", vars, props);
      if (text == null) {
        return null;
      }
      return ClipboardData(text: text!);
    },
    "ClipboardStatusNotifier": () {
      final value =
          getValue(maps["value"], datas, "ClipboardStatus", vars, props);
      return ClipboardStatusNotifier(value: value ?? ClipboardStatus.unknown);
    },
    "CloseButton": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final color = getValue(maps["color"], datas, "Color?", vars, props);
      final onPressed =
          getValue(maps["onPressed"], datas, "VoidCallback?", vars, props);
      final style = getValue(maps["style"], datas, "ButtonStyle?", vars, props);
      return CloseButton(
          key: key, color: color, onPressed: onPressed, style: style);
    },
    "CloseButtonIcon": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      return CloseButtonIcon(key: key);
    },
    "Color": () {
      final value = getValue(maps["0"], datas, "int", vars, props);
      if (value == null) {
        return null;
      }
      return Color(value!);
    },
    "Color.fromARGB": () {
      final a = getValue(maps["0"], datas, "int", vars, props);
      final r = getValue(maps["1"], datas, "int", vars, props);
      final g = getValue(maps["2"], datas, "int", vars, props);
      final b = getValue(maps["3"], datas, "int", vars, props);
      if (a == null || r == null || g == null || b == null) {
        return null;
      }
      return Color.fromARGB(a!, r!, g!, b!);
    },
    "Color.fromRGBO": () {
      final r = getValue(maps["0"], datas, "int", vars, props);
      final g = getValue(maps["1"], datas, "int", vars, props);
      final b = getValue(maps["2"], datas, "int", vars, props);
      final opacity = getValue(maps["3"], datas, "double", vars, props);
      if (r == null || g == null || b == null || opacity == null) {
        return null;
      }
      return Color.fromRGBO(r!, g!, b!, opacity!);
    },
    "ColorFilter.mode": () {
      final color = getValue(maps["0"], datas, "Color", vars, props);
      final blendMode = getValue(maps["1"], datas, "BlendMode", vars, props);
      if (color == null || blendMode == null) {
        return null;
      }
      return ColorFilter.mode(color!, blendMode!);
    },
    "ColorFilter.matrix": () {
      final matrix = getValue(maps["0"], datas, "List<double>", vars, props);
      if (matrix == null) {
        return null;
      }
      return ColorFilter.matrix(List<double>.from(matrix!));
    },
    "ColorFilter.linearToSrgbGamma": () {
      return const ColorFilter.linearToSrgbGamma();
    },
    "ColorFilter.srgbToLinearGamma": () {
      return const ColorFilter.srgbToLinearGamma();
    },
    "ColorFilterLayer": () {
      final colorFilter =
          getValue(maps["colorFilter"], datas, "ColorFilter?", vars, props);
      return ColorFilterLayer(colorFilter: colorFilter);
    },
    "ColorFiltered": () {
      final colorFilter =
          getValue(maps["colorFilter"], datas, "ColorFilter", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      if (colorFilter == null) {
        return null;
      }
      return ColorFiltered(colorFilter: colorFilter!, child: child, key: key);
    },
    "ColorScheme": () {
      final brightness =
          getValue(maps["brightness"], datas, "Brightness", vars, props);
      final primary = getValue(maps["primary"], datas, "Color", vars, props);
      final onPrimary =
          getValue(maps["onPrimary"], datas, "Color", vars, props);
      final primaryContainer =
          getValue(maps["primaryContainer"], datas, "Color?", vars, props);
      final onPrimaryContainer =
          getValue(maps["onPrimaryContainer"], datas, "Color?", vars, props);
      final secondary =
          getValue(maps["secondary"], datas, "Color", vars, props);
      final onSecondary =
          getValue(maps["onSecondary"], datas, "Color", vars, props);
      final secondaryContainer =
          getValue(maps["secondaryContainer"], datas, "Color?", vars, props);
      final onSecondaryContainer =
          getValue(maps["onSecondaryContainer"], datas, "Color?", vars, props);
      final tertiary = getValue(maps["tertiary"], datas, "Color?", vars, props);
      final onTertiary =
          getValue(maps["onTertiary"], datas, "Color?", vars, props);
      final tertiaryContainer =
          getValue(maps["tertiaryContainer"], datas, "Color?", vars, props);
      final onTertiaryContainer =
          getValue(maps["onTertiaryContainer"], datas, "Color?", vars, props);
      final error = getValue(maps["error"], datas, "Color", vars, props);
      final onError = getValue(maps["onError"], datas, "Color", vars, props);
      final errorContainer =
          getValue(maps["errorContainer"], datas, "Color?", vars, props);
      final onErrorContainer =
          getValue(maps["onErrorContainer"], datas, "Color?", vars, props);
      final background =
          getValue(maps["background"], datas, "Color", vars, props);
      final onBackground =
          getValue(maps["onBackground"], datas, "Color", vars, props);
      final surface = getValue(maps["surface"], datas, "Color", vars, props);
      final onSurface =
          getValue(maps["onSurface"], datas, "Color", vars, props);
      final surfaceVariant =
          getValue(maps["surfaceVariant"], datas, "Color?", vars, props);
      final onSurfaceVariant =
          getValue(maps["onSurfaceVariant"], datas, "Color?", vars, props);
      final outline = getValue(maps["outline"], datas, "Color?", vars, props);
      final outlineVariant =
          getValue(maps["outlineVariant"], datas, "Color?", vars, props);
      final shadow = getValue(maps["shadow"], datas, "Color?", vars, props);
      final scrim = getValue(maps["scrim"], datas, "Color?", vars, props);
      final inverseSurface =
          getValue(maps["inverseSurface"], datas, "Color?", vars, props);
      final onInverseSurface =
          getValue(maps["onInverseSurface"], datas, "Color?", vars, props);
      final inversePrimary =
          getValue(maps["inversePrimary"], datas, "Color?", vars, props);
      final surfaceTint =
          getValue(maps["surfaceTint"], datas, "Color?", vars, props);
      final primaryVariant =
          getValue(maps["primaryVariant"], datas, "Color?", vars, props);
      final secondaryVariant =
          getValue(maps["secondaryVariant"], datas, "Color?", vars, props);
      if (brightness == null ||
          primary == null ||
          onPrimary == null ||
          secondary == null ||
          onSecondary == null ||
          error == null ||
          onError == null ||
          background == null ||
          onBackground == null ||
          surface == null ||
          onSurface == null) {
        return null;
      }
      return ColorScheme(
        brightness: brightness!,
        primary: primary!,
        onPrimary: onPrimary!,
        primaryContainer: primaryContainer,
        onPrimaryContainer: onPrimaryContainer,
        secondary: secondary!,
        onSecondary: onSecondary!,
        secondaryContainer: secondaryContainer,
        onSecondaryContainer: onSecondaryContainer,
        tertiary: tertiary,
        onTertiary: onTertiary,
        tertiaryContainer: tertiaryContainer,
        onTertiaryContainer: onTertiaryContainer,
        error: error!,
        onError: onError!,
        errorContainer: errorContainer,
        onErrorContainer: onErrorContainer,
        background: background!,
        onBackground: onBackground!,
        surface: surface!,
        onSurface: onSurface!,
        surfaceVariant: surfaceVariant,
        onSurfaceVariant: onSurfaceVariant,
        outline: outline,
        outlineVariant: outlineVariant,
        shadow: shadow,
        scrim: scrim,
        inverseSurface: inverseSurface,
        onInverseSurface: onInverseSurface,
        inversePrimary: inversePrimary,
        surfaceTint: surfaceTint,
        // primaryVariant: primaryVariant,
        // secondaryVariant: secondaryVariant,
      );
    },
    "ColorScheme.fromSeed": () {
      final seedColor =
          getValue(maps["seedColor"], datas, "Color", vars, props);
      final brightness =
          getValue(maps["brightness"], datas, "Brightness", vars, props);
      final primary = getValue(maps["primary"], datas, "Color?", vars, props);
      final onPrimary =
          getValue(maps["onPrimary"], datas, "Color?", vars, props);
      final primaryContainer =
          getValue(maps["primaryContainer"], datas, "Color?", vars, props);
      final onPrimaryContainer =
          getValue(maps["onPrimaryContainer"], datas, "Color?", vars, props);
      final secondary =
          getValue(maps["secondary"], datas, "Color?", vars, props);
      final onSecondary =
          getValue(maps["onSecondary"], datas, "Color?", vars, props);
      final secondaryContainer =
          getValue(maps["secondaryContainer"], datas, "Color?", vars, props);
      final onSecondaryContainer =
          getValue(maps["onSecondaryContainer"], datas, "Color?", vars, props);
      final tertiary = getValue(maps["tertiary"], datas, "Color?", vars, props);
      final onTertiary =
          getValue(maps["onTertiary"], datas, "Color?", vars, props);
      final tertiaryContainer =
          getValue(maps["tertiaryContainer"], datas, "Color?", vars, props);
      final onTertiaryContainer =
          getValue(maps["onTertiaryContainer"], datas, "Color?", vars, props);
      final error = getValue(maps["error"], datas, "Color?", vars, props);
      final onError = getValue(maps["onError"], datas, "Color?", vars, props);
      final errorContainer =
          getValue(maps["errorContainer"], datas, "Color?", vars, props);
      final onErrorContainer =
          getValue(maps["onErrorContainer"], datas, "Color?", vars, props);
      final outline = getValue(maps["outline"], datas, "Color?", vars, props);
      final outlineVariant =
          getValue(maps["outlineVariant"], datas, "Color?", vars, props);
      final background =
          getValue(maps["background"], datas, "Color?", vars, props);
      final onBackground =
          getValue(maps["onBackground"], datas, "Color?", vars, props);
      final surface = getValue(maps["surface"], datas, "Color?", vars, props);
      final onSurface =
          getValue(maps["onSurface"], datas, "Color?", vars, props);
      final surfaceVariant =
          getValue(maps["surfaceVariant"], datas, "Color?", vars, props);
      final onSurfaceVariant =
          getValue(maps["onSurfaceVariant"], datas, "Color?", vars, props);
      final inverseSurface =
          getValue(maps["inverseSurface"], datas, "Color?", vars, props);
      final onInverseSurface =
          getValue(maps["onInverseSurface"], datas, "Color?", vars, props);
      final inversePrimary =
          getValue(maps["inversePrimary"], datas, "Color?", vars, props);
      final shadow = getValue(maps["shadow"], datas, "Color?", vars, props);
      final scrim = getValue(maps["scrim"], datas, "Color?", vars, props);
      final surfaceTint =
          getValue(maps["surfaceTint"], datas, "Color?", vars, props);
      if (seedColor == null) {
        return null;
      }
      return ColorScheme.fromSeed(
          seedColor: seedColor!,
          brightness: brightness ?? Brightness.light,
          primary: primary,
          onPrimary: onPrimary,
          primaryContainer: primaryContainer,
          onPrimaryContainer: onPrimaryContainer,
          secondary: secondary,
          onSecondary: onSecondary,
          secondaryContainer: secondaryContainer,
          onSecondaryContainer: onSecondaryContainer,
          tertiary: tertiary,
          onTertiary: onTertiary,
          tertiaryContainer: tertiaryContainer,
          onTertiaryContainer: onTertiaryContainer,
          error: error,
          onError: onError,
          errorContainer: errorContainer,
          onErrorContainer: onErrorContainer,
          outline: outline,
          outlineVariant: outlineVariant,
          background: background,
          onBackground: onBackground,
          surface: surface,
          onSurface: onSurface,
          surfaceVariant: surfaceVariant,
          onSurfaceVariant: onSurfaceVariant,
          inverseSurface: inverseSurface,
          onInverseSurface: onInverseSurface,
          inversePrimary: inversePrimary,
          shadow: shadow,
          scrim: scrim,
          surfaceTint: surfaceTint);
    },
    "ColorScheme.light": () {
      final brightness =
          getValue(maps["brightness"], datas, "Brightness", vars, props);
      final primary = getValue(maps["primary"], datas, "Color", vars, props);
      final onPrimary =
          getValue(maps["onPrimary"], datas, "Color", vars, props);
      final primaryContainer =
          getValue(maps["primaryContainer"], datas, "Color?", vars, props);
      final onPrimaryContainer =
          getValue(maps["onPrimaryContainer"], datas, "Color?", vars, props);
      final secondary =
          getValue(maps["secondary"], datas, "Color", vars, props);
      final onSecondary =
          getValue(maps["onSecondary"], datas, "Color", vars, props);
      final secondaryContainer =
          getValue(maps["secondaryContainer"], datas, "Color?", vars, props);
      final onSecondaryContainer =
          getValue(maps["onSecondaryContainer"], datas, "Color?", vars, props);
      final tertiary = getValue(maps["tertiary"], datas, "Color?", vars, props);
      final onTertiary =
          getValue(maps["onTertiary"], datas, "Color?", vars, props);
      final tertiaryContainer =
          getValue(maps["tertiaryContainer"], datas, "Color?", vars, props);
      final onTertiaryContainer =
          getValue(maps["onTertiaryContainer"], datas, "Color?", vars, props);
      final error = getValue(maps["error"], datas, "Color", vars, props);
      final onError = getValue(maps["onError"], datas, "Color", vars, props);
      final errorContainer =
          getValue(maps["errorContainer"], datas, "Color?", vars, props);
      final onErrorContainer =
          getValue(maps["onErrorContainer"], datas, "Color?", vars, props);
      final background =
          getValue(maps["background"], datas, "Color", vars, props);
      final onBackground =
          getValue(maps["onBackground"], datas, "Color", vars, props);
      final surface = getValue(maps["surface"], datas, "Color", vars, props);
      final onSurface =
          getValue(maps["onSurface"], datas, "Color", vars, props);
      final surfaceVariant =
          getValue(maps["surfaceVariant"], datas, "Color?", vars, props);
      final onSurfaceVariant =
          getValue(maps["onSurfaceVariant"], datas, "Color?", vars, props);
      final outline = getValue(maps["outline"], datas, "Color?", vars, props);
      final outlineVariant =
          getValue(maps["outlineVariant"], datas, "Color?", vars, props);
      final shadow = getValue(maps["shadow"], datas, "Color?", vars, props);
      final scrim = getValue(maps["scrim"], datas, "Color?", vars, props);
      final inverseSurface =
          getValue(maps["inverseSurface"], datas, "Color?", vars, props);
      final onInverseSurface =
          getValue(maps["onInverseSurface"], datas, "Color?", vars, props);
      final inversePrimary =
          getValue(maps["inversePrimary"], datas, "Color?", vars, props);
      final surfaceTint =
          getValue(maps["surfaceTint"], datas, "Color?", vars, props);
      final primaryVariant =
          getValue(maps["primaryVariant"], datas, "Color?", vars, props);
      final secondaryVariant =
          getValue(maps["secondaryVariant"], datas, "Color?", vars, props);
      return ColorScheme.light(
        brightness: brightness ?? Brightness.light,
        primary: primary ?? const Color(0xff6200ee),
        onPrimary: onPrimary ?? Colors.white,
        primaryContainer: primaryContainer,
        onPrimaryContainer: onPrimaryContainer,
        secondary: secondary ?? const Color(0xff03dac6),
        onSecondary: onSecondary ?? Colors.black,
        secondaryContainer: secondaryContainer,
        onSecondaryContainer: onSecondaryContainer,
        tertiary: tertiary,
        onTertiary: onTertiary,
        tertiaryContainer: tertiaryContainer,
        onTertiaryContainer: onTertiaryContainer,
        error: error ?? const Color(0xffb00020),
        onError: onError ?? Colors.white,
        errorContainer: errorContainer,
        onErrorContainer: onErrorContainer,
        background: background ?? Colors.white,
        onBackground: onBackground ?? Colors.black,
        surface: surface ?? Colors.white,
        onSurface: onSurface ?? Colors.black,
        surfaceVariant: surfaceVariant,
        onSurfaceVariant: onSurfaceVariant,
        outline: outline,
        outlineVariant: outlineVariant,
        shadow: shadow,
        scrim: scrim,
        inverseSurface: inverseSurface,
        onInverseSurface: onInverseSurface,
        inversePrimary: inversePrimary,
        surfaceTint: surfaceTint,
        // primaryVariant: primaryVariant ?? const Color(0xff3700b3),
        // secondaryVariant: secondaryVariant ?? const Color(0xff018786),
      );
    },
    "ColorScheme.dark": () {
      final brightness =
          getValue(maps["brightness"], datas, "Brightness", vars, props);
      final primary = getValue(maps["primary"], datas, "Color", vars, props);
      final onPrimary =
          getValue(maps["onPrimary"], datas, "Color", vars, props);
      final primaryContainer =
          getValue(maps["primaryContainer"], datas, "Color?", vars, props);
      final onPrimaryContainer =
          getValue(maps["onPrimaryContainer"], datas, "Color?", vars, props);
      final secondary =
          getValue(maps["secondary"], datas, "Color", vars, props);
      final onSecondary =
          getValue(maps["onSecondary"], datas, "Color", vars, props);
      final secondaryContainer =
          getValue(maps["secondaryContainer"], datas, "Color?", vars, props);
      final onSecondaryContainer =
          getValue(maps["onSecondaryContainer"], datas, "Color?", vars, props);
      final tertiary = getValue(maps["tertiary"], datas, "Color?", vars, props);
      final onTertiary =
          getValue(maps["onTertiary"], datas, "Color?", vars, props);
      final tertiaryContainer =
          getValue(maps["tertiaryContainer"], datas, "Color?", vars, props);
      final onTertiaryContainer =
          getValue(maps["onTertiaryContainer"], datas, "Color?", vars, props);
      final error = getValue(maps["error"], datas, "Color", vars, props);
      final onError = getValue(maps["onError"], datas, "Color", vars, props);
      final errorContainer =
          getValue(maps["errorContainer"], datas, "Color?", vars, props);
      final onErrorContainer =
          getValue(maps["onErrorContainer"], datas, "Color?", vars, props);
      final background =
          getValue(maps["background"], datas, "Color", vars, props);
      final onBackground =
          getValue(maps["onBackground"], datas, "Color", vars, props);
      final surface = getValue(maps["surface"], datas, "Color", vars, props);
      final onSurface =
          getValue(maps["onSurface"], datas, "Color", vars, props);
      final surfaceVariant =
          getValue(maps["surfaceVariant"], datas, "Color?", vars, props);
      final onSurfaceVariant =
          getValue(maps["onSurfaceVariant"], datas, "Color?", vars, props);
      final outline = getValue(maps["outline"], datas, "Color?", vars, props);
      final outlineVariant =
          getValue(maps["outlineVariant"], datas, "Color?", vars, props);
      final shadow = getValue(maps["shadow"], datas, "Color?", vars, props);
      final scrim = getValue(maps["scrim"], datas, "Color?", vars, props);
      final inverseSurface =
          getValue(maps["inverseSurface"], datas, "Color?", vars, props);
      final onInverseSurface =
          getValue(maps["onInverseSurface"], datas, "Color?", vars, props);
      final inversePrimary =
          getValue(maps["inversePrimary"], datas, "Color?", vars, props);
      final surfaceTint =
          getValue(maps["surfaceTint"], datas, "Color?", vars, props);
      final primaryVariant =
          getValue(maps["primaryVariant"], datas, "Color?", vars, props);
      final secondaryVariant =
          getValue(maps["secondaryVariant"], datas, "Color?", vars, props);
      return ColorScheme.dark(
        brightness: brightness ?? Brightness.dark,
        primary: primary ?? const Color(0xffbb86fc),
        onPrimary: onPrimary ?? Colors.black,
        primaryContainer: primaryContainer,
        onPrimaryContainer: onPrimaryContainer,
        secondary: secondary ?? const Color(0xff03dac6),
        onSecondary: onSecondary ?? Colors.black,
        secondaryContainer: secondaryContainer,
        onSecondaryContainer: onSecondaryContainer,
        tertiary: tertiary,
        onTertiary: onTertiary,
        tertiaryContainer: tertiaryContainer,
        onTertiaryContainer: onTertiaryContainer,
        error: error ?? const Color(0xffcf6679),
        onError: onError ?? Colors.black,
        errorContainer: errorContainer,
        onErrorContainer: onErrorContainer,
        background: background ?? const Color(0xff121212),
        onBackground: onBackground ?? Colors.white,
        surface: surface ?? const Color(0xff121212),
        onSurface: onSurface ?? Colors.white,
        surfaceVariant: surfaceVariant,
        onSurfaceVariant: onSurfaceVariant,
        outline: outline,
        outlineVariant: outlineVariant,
        shadow: shadow,
        scrim: scrim,
        inverseSurface: inverseSurface,
        onInverseSurface: onInverseSurface,
        inversePrimary: inversePrimary,
        surfaceTint: surfaceTint,
        // primaryVariant: primaryVariant ?? const Color(0xff3700B3),
        // secondaryVariant: secondaryVariant ?? const Color(0xff03dac6),
      );
    },
    "ColorScheme.highContrastLight": () {
      final brightness =
          getValue(maps["brightness"], datas, "Brightness", vars, props);
      final primary = getValue(maps["primary"], datas, "Color", vars, props);
      final onPrimary =
          getValue(maps["onPrimary"], datas, "Color", vars, props);
      final primaryContainer =
          getValue(maps["primaryContainer"], datas, "Color?", vars, props);
      final onPrimaryContainer =
          getValue(maps["onPrimaryContainer"], datas, "Color?", vars, props);
      final secondary =
          getValue(maps["secondary"], datas, "Color", vars, props);
      final onSecondary =
          getValue(maps["onSecondary"], datas, "Color", vars, props);
      final secondaryContainer =
          getValue(maps["secondaryContainer"], datas, "Color?", vars, props);
      final onSecondaryContainer =
          getValue(maps["onSecondaryContainer"], datas, "Color?", vars, props);
      final tertiary = getValue(maps["tertiary"], datas, "Color?", vars, props);
      final onTertiary =
          getValue(maps["onTertiary"], datas, "Color?", vars, props);
      final tertiaryContainer =
          getValue(maps["tertiaryContainer"], datas, "Color?", vars, props);
      final onTertiaryContainer =
          getValue(maps["onTertiaryContainer"], datas, "Color?", vars, props);
      final error = getValue(maps["error"], datas, "Color", vars, props);
      final onError = getValue(maps["onError"], datas, "Color", vars, props);
      final errorContainer =
          getValue(maps["errorContainer"], datas, "Color?", vars, props);
      final onErrorContainer =
          getValue(maps["onErrorContainer"], datas, "Color?", vars, props);
      final background =
          getValue(maps["background"], datas, "Color", vars, props);
      final onBackground =
          getValue(maps["onBackground"], datas, "Color", vars, props);
      final surface = getValue(maps["surface"], datas, "Color", vars, props);
      final onSurface =
          getValue(maps["onSurface"], datas, "Color", vars, props);
      final surfaceVariant =
          getValue(maps["surfaceVariant"], datas, "Color?", vars, props);
      final onSurfaceVariant =
          getValue(maps["onSurfaceVariant"], datas, "Color?", vars, props);
      final outline = getValue(maps["outline"], datas, "Color?", vars, props);
      final outlineVariant =
          getValue(maps["outlineVariant"], datas, "Color?", vars, props);
      final shadow = getValue(maps["shadow"], datas, "Color?", vars, props);
      final scrim = getValue(maps["scrim"], datas, "Color?", vars, props);
      final inverseSurface =
          getValue(maps["inverseSurface"], datas, "Color?", vars, props);
      final onInverseSurface =
          getValue(maps["onInverseSurface"], datas, "Color?", vars, props);
      final inversePrimary =
          getValue(maps["inversePrimary"], datas, "Color?", vars, props);
      final surfaceTint =
          getValue(maps["surfaceTint"], datas, "Color?", vars, props);
      final primaryVariant =
          getValue(maps["primaryVariant"], datas, "Color?", vars, props);
      final secondaryVariant =
          getValue(maps["secondaryVariant"], datas, "Color?", vars, props);
      return ColorScheme.highContrastLight(
        brightness: brightness ?? Brightness.light,
        primary: primary ?? const Color(0xff0000ba),
        onPrimary: onPrimary ?? Colors.white,
        primaryContainer: primaryContainer,
        onPrimaryContainer: onPrimaryContainer,
        secondary: secondary ?? const Color(0xff66fff9),
        onSecondary: onSecondary ?? Colors.black,
        secondaryContainer: secondaryContainer,
        onSecondaryContainer: onSecondaryContainer,
        tertiary: tertiary,
        onTertiary: onTertiary,
        tertiaryContainer: tertiaryContainer,
        onTertiaryContainer: onTertiaryContainer,
        error: error ?? const Color(0xff790000),
        onError: onError ?? Colors.white,
        errorContainer: errorContainer,
        onErrorContainer: onErrorContainer,
        background: background ?? Colors.white,
        onBackground: onBackground ?? Colors.black,
        surface: surface ?? Colors.white,
        onSurface: onSurface ?? Colors.black,
        surfaceVariant: surfaceVariant,
        onSurfaceVariant: onSurfaceVariant,
        outline: outline,
        outlineVariant: outlineVariant,
        shadow: shadow,
        scrim: scrim,
        inverseSurface: inverseSurface,
        onInverseSurface: onInverseSurface,
        inversePrimary: inversePrimary,
        surfaceTint: surfaceTint,
        // primaryVariant: primaryVariant ?? const Color(0xff000088),
        // secondaryVariant: secondaryVariant ?? const Color(0xff018786),
      );
    },
    "ColorScheme.highContrastDark": () {
      final brightness =
          getValue(maps["brightness"], datas, "Brightness", vars, props);
      final primary = getValue(maps["primary"], datas, "Color", vars, props);
      final onPrimary =
          getValue(maps["onPrimary"], datas, "Color", vars, props);
      final primaryContainer =
          getValue(maps["primaryContainer"], datas, "Color?", vars, props);
      final onPrimaryContainer =
          getValue(maps["onPrimaryContainer"], datas, "Color?", vars, props);
      final secondary =
          getValue(maps["secondary"], datas, "Color", vars, props);
      final onSecondary =
          getValue(maps["onSecondary"], datas, "Color", vars, props);
      final secondaryContainer =
          getValue(maps["secondaryContainer"], datas, "Color?", vars, props);
      final onSecondaryContainer =
          getValue(maps["onSecondaryContainer"], datas, "Color?", vars, props);
      final tertiary = getValue(maps["tertiary"], datas, "Color?", vars, props);
      final onTertiary =
          getValue(maps["onTertiary"], datas, "Color?", vars, props);
      final tertiaryContainer =
          getValue(maps["tertiaryContainer"], datas, "Color?", vars, props);
      final onTertiaryContainer =
          getValue(maps["onTertiaryContainer"], datas, "Color?", vars, props);
      final error = getValue(maps["error"], datas, "Color", vars, props);
      final onError = getValue(maps["onError"], datas, "Color", vars, props);
      final errorContainer =
          getValue(maps["errorContainer"], datas, "Color?", vars, props);
      final onErrorContainer =
          getValue(maps["onErrorContainer"], datas, "Color?", vars, props);
      final background =
          getValue(maps["background"], datas, "Color", vars, props);
      final onBackground =
          getValue(maps["onBackground"], datas, "Color", vars, props);
      final surface = getValue(maps["surface"], datas, "Color", vars, props);
      final onSurface =
          getValue(maps["onSurface"], datas, "Color", vars, props);
      final surfaceVariant =
          getValue(maps["surfaceVariant"], datas, "Color?", vars, props);
      final onSurfaceVariant =
          getValue(maps["onSurfaceVariant"], datas, "Color?", vars, props);
      final outline = getValue(maps["outline"], datas, "Color?", vars, props);
      final outlineVariant =
          getValue(maps["outlineVariant"], datas, "Color?", vars, props);
      final shadow = getValue(maps["shadow"], datas, "Color?", vars, props);
      final scrim = getValue(maps["scrim"], datas, "Color?", vars, props);
      final inverseSurface =
          getValue(maps["inverseSurface"], datas, "Color?", vars, props);
      final onInverseSurface =
          getValue(maps["onInverseSurface"], datas, "Color?", vars, props);
      final inversePrimary =
          getValue(maps["inversePrimary"], datas, "Color?", vars, props);
      final surfaceTint =
          getValue(maps["surfaceTint"], datas, "Color?", vars, props);
      final primaryVariant =
          getValue(maps["primaryVariant"], datas, "Color?", vars, props);
      final secondaryVariant =
          getValue(maps["secondaryVariant"], datas, "Color?", vars, props);
      return ColorScheme.highContrastDark(
        brightness: brightness ?? Brightness.dark,
        primary: primary ?? const Color(0xffefb7ff),
        onPrimary: onPrimary ?? Colors.black,
        primaryContainer: primaryContainer,
        onPrimaryContainer: onPrimaryContainer,
        secondary: secondary ?? const Color(0xff66fff9),
        onSecondary: onSecondary ?? Colors.black,
        secondaryContainer: secondaryContainer,
        onSecondaryContainer: onSecondaryContainer,
        tertiary: tertiary,
        onTertiary: onTertiary,
        tertiaryContainer: tertiaryContainer,
        onTertiaryContainer: onTertiaryContainer,
        error: error ?? const Color(0xff9b374d),
        onError: onError ?? Colors.black,
        errorContainer: errorContainer,
        onErrorContainer: onErrorContainer,
        background: background ?? const Color(0xff121212),
        onBackground: onBackground ?? Colors.white,
        surface: surface ?? const Color(0xff121212),
        onSurface: onSurface ?? Colors.white,
        surfaceVariant: surfaceVariant,
        onSurfaceVariant: onSurfaceVariant,
        outline: outline,
        outlineVariant: outlineVariant,
        shadow: shadow,
        scrim: scrim,
        inverseSurface: inverseSurface,
        onInverseSurface: onInverseSurface,
        inversePrimary: inversePrimary,
        surfaceTint: surfaceTint,
        // primaryVariant: primaryVariant ?? const Color(0xffbe9eff),
        // secondaryVariant: secondaryVariant ?? const Color(0xff66fff9),
      );
    },
    "ColorScheme.fromSwatch": () {
      final primarySwatch =
          getValue(maps["primarySwatch"], datas, "MaterialColor", vars, props);
      final primaryColorDark =
          getValue(maps["primaryColorDark"], datas, "Color?", vars, props);
      final accentColor =
          getValue(maps["accentColor"], datas, "Color?", vars, props);
      final cardColor =
          getValue(maps["cardColor"], datas, "Color?", vars, props);
      final backgroundColor =
          getValue(maps["backgroundColor"], datas, "Color?", vars, props);
      final errorColor =
          getValue(maps["errorColor"], datas, "Color?", vars, props);
      final brightness =
          getValue(maps["brightness"], datas, "Brightness", vars, props);
      return ColorScheme.fromSwatch(
          primarySwatch: primarySwatch ?? Colors.blue,
          // primaryColorDark: primaryColorDark,
          accentColor: accentColor,
          cardColor: cardColor,
          backgroundColor: backgroundColor,
          errorColor: errorColor,
          brightness: brightness ?? Brightness.light);
    },
    "ColorTween": () {
      final begin = getValue(maps["begin"], datas, "T?", vars, props);
      final end = getValue(maps["end"], datas, "T?", vars, props);
      return ColorTween(begin: begin, end: end);
    },
    "ColoredBox": () {
      final color = getValue(maps["color"], datas, "Color", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      if (color == null) {
        return null;
      }
      return ColoredBox(color: color!, child: child, key: key);
    },
    "Column": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final mainAxisAlignment =
          getValue(maps["mainAxisAlignment"], datas, "", vars, props);
      final mainAxisSize =
          getValue(maps["mainAxisSize"], datas, "", vars, props);
      final crossAxisAlignment =
          getValue(maps["crossAxisAlignment"], datas, "", vars, props);
      final textDirection =
          getValue(maps["textDirection"], datas, "", vars, props);
      final verticalDirection =
          getValue(maps["verticalDirection"], datas, "", vars, props);
      final textBaseline =
          getValue(maps["textBaseline"], datas, "", vars, props);
      final children =
          getValue(maps["children"], datas, "List<Widget>", vars, props);
      return Column(
          key: key,
          mainAxisAlignment: mainAxisAlignment ?? MainAxisAlignment.start,
          mainAxisSize: mainAxisSize ?? MainAxisSize.max,
          crossAxisAlignment: crossAxisAlignment ?? CrossAxisAlignment.center,
          textDirection: textDirection,
          verticalDirection: verticalDirection ?? VerticalDirection.down,
          textBaseline: textBaseline,
          children: List<Widget>.from(children ?? const <Widget>[]));
    },
    "CompositedTransformFollower": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final link = getValue(maps["link"], datas, "LayerLink", vars, props);
      final showWhenUnlinked =
          getValue(maps["showWhenUnlinked"], datas, "bool", vars, props);
      final offset = getValue(maps["offset"], datas, "Offset", vars, props);
      final targetAnchor =
          getValue(maps["targetAnchor"], datas, "Alignment", vars, props);
      final followerAnchor =
          getValue(maps["followerAnchor"], datas, "Alignment", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      if (link == null) {
        return null;
      }
      return CompositedTransformFollower(
          key: key,
          link: link!,
          showWhenUnlinked: showWhenUnlinked ?? true,
          offset: offset ?? Offset.zero,
          targetAnchor: targetAnchor ?? Alignment.topLeft,
          followerAnchor: followerAnchor ?? Alignment.topLeft,
          child: child);
    },
    "CompositedTransformTarget": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final link = getValue(maps["link"], datas, "LayerLink", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      if (link == null) {
        return null;
      }
      return CompositedTransformTarget(key: key, link: link!, child: child);
    },
    "ConcurrentModificationError": () {
      final modifiedObject = getValue(maps["0"], datas, "Object?", vars, props);
      return ConcurrentModificationError(modifiedObject);
    },
    "ConstantTween": () {
      final value = getValue(maps["0"], datas, "T", vars, props);
      if (value == null) {
        return null;
      }
      return ConstantTween(value!);
    },
    "ConstraintsTransformBox": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      final textDirection =
          getValue(maps["textDirection"], datas, "TextDirection?", vars, props);
      final alignment =
          getValue(maps["alignment"], datas, "AlignmentGeometry", vars, props);
      final constraintsTransform = getValue(maps["constraintsTransform"], datas,
          "BoxConstraintsTransform", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      final debugTransformType =
          getValue(maps["debugTransformType"], datas, "String", vars, props);
      if (constraintsTransform == null) {
        return null;
      }
      return ConstraintsTransformBox(
          key: key,
          child: child,
          textDirection: textDirection,
          alignment: alignment ?? Alignment.center,
          constraintsTransform: constraintsTransform!,
          clipBehavior: clipBehavior ?? Clip.none,
          debugTransformType: debugTransformType ?? '');
    },
    "Container": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final alignment =
          getValue(maps["alignment"], datas, "AlignmentGeometry?", vars, props);
      final padding =
          getValue(maps["padding"], datas, "EdgeInsetsGeometry?", vars, props);
      final color = getValue(maps["color"], datas, "Color?", vars, props);
      final decoration =
          getValue(maps["decoration"], datas, "Decoration?", vars, props);
      final foregroundDecoration = getValue(
          maps["foregroundDecoration"], datas, "Decoration?", vars, props);
      final width = getValue(maps["width"], datas, "double?", vars, props);
      final height = getValue(maps["height"], datas, "double?", vars, props);
      final constraints =
          getValue(maps["constraints"], datas, "BoxConstraints?", vars, props);
      final margin =
          getValue(maps["margin"], datas, "EdgeInsetsGeometry?", vars, props);
      final transform =
          getValue(maps["transform"], datas, "Matrix4?", vars, props);
      final transformAlignment = getValue(
          maps["transformAlignment"], datas, "AlignmentGeometry?", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      return Container(
          key: key,
          alignment: alignment,
          padding: padding,
          color: color,
          decoration: decoration,
          foregroundDecoration: foregroundDecoration,
          width: width,
          height: height,
          constraints: constraints,
          margin: margin,
          transform: transform,
          transformAlignment: transformAlignment,
          child: child,
          clipBehavior: clipBehavior ?? Clip.none);
    },
    "ContentInsertionConfiguration": () {
      final onContentInserted = getValue(maps["onContentInserted"], datas,
          "ValueChanged<KeyboardInsertedContent>", vars, props);
      final allowedMimeTypes = getValue(
          maps["allowedMimeTypes"], datas, "List<String>", vars, props);
      if (onContentInserted == null) {
        return null;
      }
      if (allowedMimeTypes != null) {
        return ContentInsertionConfiguration(
            onContentInserted: onContentInserted!,
            allowedMimeTypes: List<String>.from(allowedMimeTypes));
      }
      return ContentInsertionConfiguration(
          onContentInserted: onContentInserted!);
    },
    "ContextMenuButtonItem": () {
      final onPressed =
          getValue(maps["onPressed"], datas, "VoidCallback", vars, props);
      final type =
          getValue(maps["type"], datas, "ContextMenuButtonType", vars, props);
      final label = getValue(maps["label"], datas, "String?", vars, props);
      if (onPressed == null) {
        return null;
      }
      return ContextMenuButtonItem(
          onPressed: onPressed!,
          type: type ?? ContextMenuButtonType.custom,
          label: label);
    },
    "ContextMenuController": () {
      final onRemove =
          getValue(maps["onRemove"], datas, "VoidCallback?", vars, props);
      return ContextMenuController(onRemove: onRemove);
    },
    "ContinuousRectangleBorder": () {
      final side = getValue(maps["side"], datas, "", vars, props);
      final borderRadius = getValue(
          maps["borderRadius"], datas, "BorderRadiusGeometry", vars, props);
      return ContinuousRectangleBorder(
          side: side, borderRadius: borderRadius ?? BorderRadius.zero);
    },
    "ControlsDetails": () {
      final currentStep =
          getValue(maps["currentStep"], datas, "int", vars, props);
      final stepIndex = getValue(maps["stepIndex"], datas, "int", vars, props);
      final onStepCancel =
          getValue(maps["onStepCancel"], datas, "VoidCallback?", vars, props);
      final onStepContinue =
          getValue(maps["onStepContinue"], datas, "VoidCallback?", vars, props);
      if (currentStep == null || stepIndex == null) {
        return null;
      }
      return ControlsDetails(
          currentStep: currentStep!,
          stepIndex: stepIndex!,
          onStepCancel: onStepCancel,
          onStepContinue: onStepContinue);
    },
    "CopySelectionTextIntent.cut": () {
      final cause =
          getValue(maps["0"], datas, "SelectionChangedCause", vars, props);
      if (cause == null) {
        return null;
      }
      return CopySelectionTextIntent.cut(cause!);
    },
    "Cubic": () {
      final a = getValue(maps["0"], datas, "double", vars, props);
      final b = getValue(maps["1"], datas, "double", vars, props);
      final c = getValue(maps["2"], datas, "double", vars, props);
      final d = getValue(maps["3"], datas, "double", vars, props);
      if (a == null || b == null || c == null || d == null) {
        return null;
      }
      return Cubic(a!, b!, c!, d!);
    },
    "CupertinoActionSheet": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final title = getValue(maps["title"], datas, "Widget?", vars, props);
      final message = getValue(maps["message"], datas, "Widget?", vars, props);
      final actions =
          getValue(maps["actions"], datas, "List<Widget>?", vars, props);
      final messageScrollController = getValue(maps["messageScrollController"],
          datas, "ScrollController?", vars, props);
      final actionScrollController = getValue(maps["actionScrollController"],
          datas, "ScrollController?", vars, props);
      final cancelButton =
          getValue(maps["cancelButton"], datas, "Widget?", vars, props);
      return CupertinoActionSheet(
          key: key,
          title: title,
          message: message,
          actions: actions != null ? List<Widget>.from(actions) : null,
          messageScrollController: messageScrollController,
          actionScrollController: actionScrollController,
          cancelButton: cancelButton);
    },
    "CupertinoActionSheetAction": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final onPressed =
          getValue(maps["onPressed"], datas, "VoidCallback", vars, props);
      final isDefaultAction =
          getValue(maps["isDefaultAction"], datas, "bool", vars, props);
      final isDestructiveAction =
          getValue(maps["isDestructiveAction"], datas, "bool", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (onPressed == null || child == null) {
        return null;
      }
      return CupertinoActionSheetAction(
          key: key,
          onPressed: onPressed!,
          isDefaultAction: isDefaultAction ?? false,
          isDestructiveAction: isDestructiveAction ?? false,
          child: child!);
    },
    "CupertinoActivityIndicator": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final color = getValue(maps["color"], datas, "Color?", vars, props);
      final animating = getValue(maps["animating"], datas, "bool", vars, props);
      final radius = getValue(maps["radius"], datas, "double", vars, props);
      if (radius != null) {
        return CupertinoActivityIndicator(
            key: key,
            color: color,
            animating: animating ?? true,
            radius: radius);
      }
      return CupertinoActivityIndicator(
          key: key, color: color, animating: animating ?? true);
    },
    "CupertinoActivityIndicator.partiallyRevealed": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final color = getValue(maps["color"], datas, "Color?", vars, props);
      final radius = getValue(maps["radius"], datas, "double", vars, props);
      final progress = getValue(maps["progress"], datas, "double", vars, props);
      if (radius != null) {
        return CupertinoActivityIndicator.partiallyRevealed(
            key: key, color: color, progress: progress ?? 1.0, radius: radius);
      }
      return CupertinoActivityIndicator.partiallyRevealed(
          key: key, color: color, progress: progress ?? 1.0);
    },
    "CupertinoAdaptiveTextSelectionToolbar": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final children =
          getValue(maps["children"], datas, "List<Widget>?", vars, props);
      final anchors = getValue(
          maps["anchors"], datas, "TextSelectionToolbarAnchors", vars, props);
      if (children == null || anchors == null) {
        return null;
      }
      return CupertinoAdaptiveTextSelectionToolbar(
          key: key, anchors: anchors!, children: List<Widget>.from(children!));
    },
    "CupertinoAdaptiveTextSelectionToolbar.buttonItems": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final buttonItems = getValue(maps["buttonItems"], datas,
          "List<ContextMenuButtonItem>?", vars, props);
      final anchors = getValue(
          maps["anchors"], datas, "TextSelectionToolbarAnchors", vars, props);
      if (buttonItems == null || anchors == null) {
        return null;
      }
      return CupertinoAdaptiveTextSelectionToolbar.buttonItems(
          key: key,
          buttonItems: List<ContextMenuButtonItem>.from(buttonItems!),
          anchors: anchors!);
    },
    "CupertinoAdaptiveTextSelectionToolbar.editable": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final clipboardStatus = getValue(
          maps["clipboardStatus"], datas, "ClipboardStatus", vars, props);
      final onCopy =
          getValue(maps["onCopy"], datas, "VoidCallback?", vars, props);
      final onCut =
          getValue(maps["onCut"], datas, "VoidCallback?", vars, props);
      final onPaste =
          getValue(maps["onPaste"], datas, "VoidCallback?", vars, props);
      final onSelectAll =
          getValue(maps["onSelectAll"], datas, "VoidCallback?", vars, props);
      final anchors = getValue(
          maps["anchors"], datas, "TextSelectionToolbarAnchors", vars, props);
      final onLookUp =
          getValue(maps["onLookUp"], datas, "VoidCallback?", vars, props);

      final onSearchWeb =
          getValue(maps["onSearchWeb"], datas, "VoidCallback?", vars, props);

      final onShare =
          getValue(maps["onShare"], datas, "VoidCallback?", vars, props);

      final onLiveTextInput = getValue(
          maps["onLiveTextInput"], datas, "VoidCallback?", vars, props);
      if (clipboardStatus == null ||
          onCopy == null ||
          onCut == null ||
          onPaste == null ||
          onSelectAll == null ||
          anchors == null) {
        return null;
      }
      return CupertinoAdaptiveTextSelectionToolbar.editable(
        key: key,
        clipboardStatus: clipboardStatus!,
        onCopy: onCopy!,
        onCut: onCut!,
        onPaste: onPaste!,
        onSelectAll: onSelectAll!,
        anchors: anchors!,
        onLookUp: onLookUp,
        onSearchWeb: onSearchWeb,
        onShare: onShare,
        onLiveTextInput: onLiveTextInput,
      );
    },
    "CupertinoAdaptiveTextSelectionToolbar.editableText": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final editableTextState = getValue(
          maps["editableTextState"], datas, "EditableTextState", vars, props);
      if (editableTextState == null) {
        return null;
      }
      return CupertinoAdaptiveTextSelectionToolbar.editableText(
          key: key, editableTextState: editableTextState!);
    },
    "CupertinoAdaptiveTextSelectionToolbar.selectable": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final onCopy =
          getValue(maps["onCopy"], datas, "VoidCallback", vars, props);
      final onSelectAll =
          getValue(maps["onSelectAll"], datas, "VoidCallback", vars, props);
      final selectionGeometry = getValue(
          maps["selectionGeometry"], datas, "SelectionGeometry", vars, props);
      final anchors = getValue(
          maps["anchors"], datas, "TextSelectionToolbarAnchors", vars, props);
      if (onCopy == null ||
          onSelectAll == null ||
          selectionGeometry == null ||
          anchors == null) {
        return null;
      }
      return CupertinoAdaptiveTextSelectionToolbar.selectable(
          key: key,
          onCopy: onCopy!,
          onSelectAll: onSelectAll!,
          selectionGeometry: selectionGeometry!,
          anchors: anchors!);
    },
    "CupertinoAlertDialog": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final title = getValue(maps["title"], datas, "Widget?", vars, props);
      final content = getValue(maps["content"], datas, "Widget?", vars, props);
      final actions =
          getValue(maps["actions"], datas, "List<Widget>", vars, props);
      final scrollController = getValue(
          maps["scrollController"], datas, "ScrollController?", vars, props);
      final actionScrollController = getValue(maps["actionScrollController"],
          datas, "ScrollController?", vars, props);
      final insetAnimationDuration = getValue(
          maps["insetAnimationDuration"], datas, "Duration", vars, props);
      final insetAnimationCurve =
          getValue(maps["insetAnimationCurve"], datas, "Curve", vars, props);
      return CupertinoAlertDialog(
          key: key,
          title: title,
          content: content,
          actions: List<Widget>.from(actions ?? const <Widget>[]),
          scrollController: scrollController,
          actionScrollController: actionScrollController,
          insetAnimationDuration:
              insetAnimationDuration ?? const Duration(milliseconds: 100),
          insetAnimationCurve: insetAnimationCurve ?? Curves.decelerate);
    },
    "CupertinoApp": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final navigatorKey = getValue(maps["navigatorKey"], datas,
          "GlobalKey<NavigatorState>?", vars, props);
      final home = getValue(maps["home"], datas, "Widget?", vars, props);
      final theme =
          getValue(maps["theme"], datas, "CupertinoThemeData?", vars, props);
      final routes = getValue(maps["routes"], datas,
          "Map<String,   Widget Function(BuildContext)>", vars, props);
      final initialRoute =
          getValue(maps["initialRoute"], datas, "String?", vars, props);
      final onGenerateRoute = getValue(
          maps["onGenerateRoute"], datas, "RouteFactory?", vars, props);
      final onGenerateInitialRoutes = getValue(maps["onGenerateInitialRoutes"],
          datas, "InitialRouteListFactory?", vars, props);
      final onUnknownRoute =
          getValue(maps["onUnknownRoute"], datas, "RouteFactory?", vars, props);
      final navigatorObservers = getValue(maps["navigatorObservers"], datas,
          "List<NavigatorObserver>", vars, props);
      final builder =
          getValue(maps["builder"], datas, "TransitionBuilder?", vars, props);
      final title = getValue(maps["title"], datas, "String", vars, props);
      final onGenerateTitle = getValue(
          maps["onGenerateTitle"], datas, "GenerateAppTitle?", vars, props);
      final color = getValue(maps["color"], datas, "Color?", vars, props);
      final locale = getValue(maps["locale"], datas, "Locale?", vars, props);
      final localizationsDelegates = getValue(maps["localizationsDelegates"],
          datas, "Iterable<LocalizationsDelegate<dynamic>>?", vars, props);
      final localeListResolutionCallback = getValue(
          maps["localeListResolutionCallback"],
          datas,
          "LocaleListResolutionCallback?",
          vars,
          props);
      final localeResolutionCallback = getValue(
          maps["localeResolutionCallback"],
          datas,
          "LocaleResolutionCallback?",
          vars,
          props);
      final supportedLocales = getValue(
          maps["supportedLocales"], datas, "Iterable<Locale>", vars, props);
      final showPerformanceOverlay =
          getValue(maps["showPerformanceOverlay"], datas, "bool", vars, props);
      final checkerboardRasterCacheImages = getValue(
          maps["checkerboardRasterCacheImages"], datas, "bool", vars, props);
      final checkerboardOffscreenLayers = getValue(
          maps["checkerboardOffscreenLayers"], datas, "bool", vars, props);
      final showSemanticsDebugger =
          getValue(maps["showSemanticsDebugger"], datas, "bool", vars, props);
      final debugShowCheckedModeBanner = getValue(
          maps["debugShowCheckedModeBanner"], datas, "bool", vars, props);
      final shortcuts = getValue(maps["shortcuts"], datas,
          "Map<ShortcutActivator, Intent>?", vars, props);
      final actions = getValue(
          maps["actions"], datas, "Map<Type, Action<Intent>>?", vars, props);
      final restorationScopeId =
          getValue(maps["restorationScopeId"], datas, "String?", vars, props);
      final scrollBehavior = getValue(
          maps["scrollBehavior"], datas, "ScrollBehavior?", vars, props);
      final useInheritedMediaQuery =
          getValue(maps["useInheritedMediaQuery"], datas, "bool", vars, props);
      return CupertinoApp(
          key: key,
          navigatorKey: navigatorKey,
          home: home,
          theme: theme,
          routes: routes ?? const <String, WidgetBuilder>{},
          initialRoute: initialRoute,
          onGenerateRoute: onGenerateRoute,
          onGenerateInitialRoutes: onGenerateInitialRoutes,
          onUnknownRoute: onUnknownRoute,
          navigatorObservers: List<NavigatorObserver>.from(
              navigatorObservers ?? const <NavigatorObserver>[]),
          builder: builder,
          title: title ?? '',
          onGenerateTitle: onGenerateTitle,
          color: color,
          locale: locale,
          localizationsDelegates: localizationsDelegates,
          localeListResolutionCallback: localeListResolutionCallback,
          localeResolutionCallback: localeResolutionCallback,
          supportedLocales:
              supportedLocales ?? const <Locale>[Locale('en', 'US')],
          showPerformanceOverlay: showPerformanceOverlay ?? false,
          checkerboardRasterCacheImages: checkerboardRasterCacheImages ?? false,
          checkerboardOffscreenLayers: checkerboardOffscreenLayers ?? false,
          showSemanticsDebugger: showSemanticsDebugger ?? false,
          debugShowCheckedModeBanner: debugShowCheckedModeBanner ?? true,
          shortcuts:
              shortcuts ? Map<ShortcutActivator, Intent>.from(shortcuts) : null,
          actions: actions ? Map<Type, Action<Intent>>.from(actions) : null,
          restorationScopeId: restorationScopeId,
          scrollBehavior: scrollBehavior,
          useInheritedMediaQuery: useInheritedMediaQuery ?? false);
    },
    "CupertinoApp.router": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final routeInformationProvider = getValue(
          maps["routeInformationProvider"],
          datas,
          "RouteInformationProvider?",
          vars,
          props);
      final routeInformationParser = getValue(maps["routeInformationParser"],
          datas, "RouteInformationParser<Object>?", vars, props);
      final routerDelegate = getValue(maps["routerDelegate"], datas,
          "RouterDelegate<Object>?", vars, props);
      final backButtonDispatcher = getValue(maps["backButtonDispatcher"], datas,
          "BackButtonDispatcher?", vars, props);
      final routerConfig = getValue(
          maps["routerConfig"], datas, "RouterConfig<Object>?", vars, props);
      final theme =
          getValue(maps["theme"], datas, "CupertinoThemeData?", vars, props);
      final builder =
          getValue(maps["builder"], datas, "TransitionBuilder?", vars, props);
      final title = getValue(maps["title"], datas, "String", vars, props);
      final onGenerateTitle = getValue(
          maps["onGenerateTitle"], datas, "GenerateAppTitle?", vars, props);
      final color = getValue(maps["color"], datas, "Color?", vars, props);
      final locale = getValue(maps["locale"], datas, "Locale?", vars, props);
      final localizationsDelegates = getValue(maps["localizationsDelegates"],
          datas, "Iterable<LocalizationsDelegate<dynamic>>?", vars, props);
      final localeListResolutionCallback = getValue(
          maps["localeListResolutionCallback"],
          datas,
          "LocaleListResolutionCallback?",
          vars,
          props);
      final localeResolutionCallback = getValue(
          maps["localeResolutionCallback"],
          datas,
          "LocaleResolutionCallback?",
          vars,
          props);
      final supportedLocales = getValue(
          maps["supportedLocales"], datas, "Iterable<Locale>", vars, props);
      final showPerformanceOverlay =
          getValue(maps["showPerformanceOverlay"], datas, "bool", vars, props);
      final checkerboardRasterCacheImages = getValue(
          maps["checkerboardRasterCacheImages"], datas, "bool", vars, props);
      final checkerboardOffscreenLayers = getValue(
          maps["checkerboardOffscreenLayers"], datas, "bool", vars, props);
      final showSemanticsDebugger =
          getValue(maps["showSemanticsDebugger"], datas, "bool", vars, props);
      final debugShowCheckedModeBanner = getValue(
          maps["debugShowCheckedModeBanner"], datas, "bool", vars, props);
      final shortcuts = getValue(maps["shortcuts"], datas,
          "Map<ShortcutActivator, Intent>?", vars, props);
      final actions = getValue(
          maps["actions"], datas, "Map<Type, Action<Intent>>?", vars, props);
      final restorationScopeId =
          getValue(maps["restorationScopeId"], datas, "String?", vars, props);
      final scrollBehavior = getValue(
          maps["scrollBehavior"], datas, "ScrollBehavior?", vars, props);
      final useInheritedMediaQuery =
          getValue(maps["useInheritedMediaQuery"], datas, "bool", vars, props);
      return CupertinoApp.router(
          key: key,
          routeInformationProvider: routeInformationProvider,
          routeInformationParser: routeInformationParser,
          routerDelegate: routerDelegate,
          backButtonDispatcher: backButtonDispatcher,
          routerConfig: routerConfig,
          theme: theme,
          builder: builder,
          title: title ?? '',
          onGenerateTitle: onGenerateTitle,
          color: color,
          locale: locale,
          localizationsDelegates: localizationsDelegates,
          localeListResolutionCallback: localeListResolutionCallback,
          localeResolutionCallback: localeResolutionCallback,
          supportedLocales:
              supportedLocales ?? const <Locale>[Locale('en', 'US')],
          showPerformanceOverlay: showPerformanceOverlay ?? false,
          checkerboardRasterCacheImages: checkerboardRasterCacheImages ?? false,
          checkerboardOffscreenLayers: checkerboardOffscreenLayers ?? false,
          showSemanticsDebugger: showSemanticsDebugger ?? false,
          debugShowCheckedModeBanner: debugShowCheckedModeBanner ?? true,
          shortcuts:
              shortcuts ? Map<ShortcutActivator, Intent>.from(shortcuts) : null,
          actions: actions ? Map<Type, Action<Intent>>.from(actions) : null,
          restorationScopeId: restorationScopeId,
          scrollBehavior: scrollBehavior,
          useInheritedMediaQuery: useInheritedMediaQuery ?? false);
    },
    "CupertinoButton": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      final padding =
          getValue(maps["padding"], datas, "EdgeInsetsGeometry?", vars, props);
      final color = getValue(maps["color"], datas, "Color?", vars, props);
      final disabledColor =
          getValue(maps["disabledColor"], datas, "Color", vars, props);
      final minSize = getValue(maps["minSize"], datas, "double?", vars, props);
      final pressedOpacity =
          getValue(maps["pressedOpacity"], datas, "double?", vars, props);
      final borderRadius =
          getValue(maps["borderRadius"], datas, "BorderRadius?", vars, props);
      final alignment =
          getValue(maps["alignment"], datas, "AlignmentGeometry", vars, props);
      final onPressed =
          getValue(maps["onPressed"], datas, "VoidCallback?", vars, props);
      if (child == null || onPressed == null) {
        return null;
      }
      return CupertinoButton(
          key: key,
          child: child!,
          padding: padding,
          color: color,
          disabledColor: disabledColor ?? CupertinoColors.quaternarySystemFill,
          minSize: minSize ?? kMinInteractiveDimensionCupertino,
          pressedOpacity: pressedOpacity ?? 0.4,
          borderRadius:
              borderRadius ?? const BorderRadius.all(Radius.circular(8.0)),
          alignment: alignment ?? Alignment.center,
          onPressed: onPressed!);
    },
    "CupertinoButton.filled": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      final padding =
          getValue(maps["padding"], datas, "EdgeInsetsGeometry?", vars, props);
      final disabledColor =
          getValue(maps["disabledColor"], datas, "Color", vars, props);
      final minSize = getValue(maps["minSize"], datas, "double?", vars, props);
      final pressedOpacity =
          getValue(maps["pressedOpacity"], datas, "double?", vars, props);
      final borderRadius =
          getValue(maps["borderRadius"], datas, "BorderRadius?", vars, props);
      final alignment =
          getValue(maps["alignment"], datas, "AlignmentGeometry", vars, props);
      final onPressed =
          getValue(maps["onPressed"], datas, "VoidCallback?", vars, props);
      if (child == null || onPressed == null) {
        return null;
      }
      return CupertinoButton.filled(
          key: key,
          child: child!,
          padding: padding,
          disabledColor: disabledColor ?? CupertinoColors.quaternarySystemFill,
          minSize: minSize ?? kMinInteractiveDimensionCupertino,
          pressedOpacity: pressedOpacity ?? 0.4,
          borderRadius:
              borderRadius ?? const BorderRadius.all(Radius.circular(8.0)),
          alignment: alignment ?? Alignment.center,
          onPressed: onPressed!);
    },
    "CupertinoCheckbox": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final value = getValue(maps["value"], datas, "bool?", vars, props);
      final tristate = getValue(maps["tristate"], datas, "bool", vars, props);
      final onChanged = getValue(
          maps["onChanged"], datas, "ValueChanged<bool?>?", vars, props);
      final activeColor =
          getValue(maps["activeColor"], datas, "Color?", vars, props);
      final inactiveColor =
          getValue(maps["inactiveColor"], datas, "Color?", vars, props);
      final checkColor =
          getValue(maps["checkColor"], datas, "Color?", vars, props);
      final focusColor =
          getValue(maps["focusColor"], datas, "Color?", vars, props);
      final focusNode =
          getValue(maps["focusNode"], datas, "FocusNode?", vars, props);
      final autofocus = getValue(maps["autofocus"], datas, "bool", vars, props);
      final side = getValue(maps["side"], datas, "BorderSide?", vars, props);
      final shape =
          getValue(maps["shape"], datas, "OutlinedBorder?", vars, props);
      if (value == null || onChanged == null) {
        return null;
      }
      return CupertinoCheckbox(
          key: key,
          value: value!,
          tristate: tristate ?? false,
          onChanged: onChanged!,
          activeColor: activeColor,
          inactiveColor: inactiveColor,
          checkColor: checkColor,
          focusColor: focusColor,
          focusNode: focusNode,
          autofocus: autofocus ?? false,
          side: side,
          shape: shape);
    },
    "CupertinoContextMenu": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final actions =
          getValue(maps["actions"], datas, "List<Widget>", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      final enableHapticFeedback =
          getValue(maps["enableHapticFeedback"], datas, "bool", vars, props);
      final previewBuilder = getValue(maps["previewBuilder"], datas,
          "ContextMenuPreviewBuilder?", vars, props);
      if (actions == null || child == null) {
        return null;
      }
      if (previewBuilder != null) {
        return CupertinoContextMenu(
          key: key,
          actions: List<Widget>.from(actions!),
          child: child!,
          enableHapticFeedback: enableHapticFeedback ?? false,
          //previewBuilder: previewBuilder,
        );
      }
      return CupertinoContextMenu(
          key: key,
          actions: List<Widget>.from(actions!),
          child: child!,
          enableHapticFeedback: enableHapticFeedback ?? false);
    },
    "CupertinoContextMenu.builder": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final actions =
          getValue(maps["actions"], datas, "List<Widget>", vars, props);
      final builder = getValue(
          maps["builder"], datas, "CupertinoContextMenuBuilder", vars, props);
      final enableHapticFeedback =
          getValue(maps["enableHapticFeedback"], datas, "bool", vars, props);
      if (actions == null || builder == null) {
        return null;
      }
      return CupertinoContextMenu.builder(
          key: key,
          actions: List<Widget>.from(actions!),
          builder: builder!,
          enableHapticFeedback: enableHapticFeedback ?? false);
    },
    "CupertinoContextMenuAction": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      final isDefaultAction =
          getValue(maps["isDefaultAction"], datas, "bool", vars, props);
      final isDestructiveAction =
          getValue(maps["isDestructiveAction"], datas, "bool", vars, props);
      final onPressed =
          getValue(maps["onPressed"], datas, "VoidCallback?", vars, props);
      final trailingIcon =
          getValue(maps["trailingIcon"], datas, "IconData?", vars, props);
      if (child == null) {
        return null;
      }
      return CupertinoContextMenuAction(
          key: key,
          child: child!,
          isDefaultAction: isDefaultAction ?? false,
          isDestructiveAction: isDestructiveAction ?? false,
          onPressed: onPressed,
          trailingIcon: trailingIcon);
    },
    "CupertinoDatePicker": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final mode =
          getValue(maps["mode"], datas, "CupertinoDatePickerMode", vars, props);
      final onDateTimeChanged = getValue(maps["onDateTimeChanged"], datas,
          "ValueChanged<DateTime>", vars, props);
      final initialDateTime =
          getValue(maps["initialDateTime"], datas, "DateTime?", vars, props);
      final minimumDate =
          getValue(maps["minimumDate"], datas, "DateTime?", vars, props);
      final maximumDate =
          getValue(maps["maximumDate"], datas, "DateTime?", vars, props);
      final minimumYear =
          getValue(maps["minimumYear"], datas, "int", vars, props);
      final maximumYear =
          getValue(maps["maximumYear"], datas, "int?", vars, props);
      final minuteInterval =
          getValue(maps["minuteInterval"], datas, "int", vars, props);
      final use24hFormat =
          getValue(maps["use24hFormat"], datas, "bool", vars, props);
      final dateOrder = getValue(
          maps["dateOrder"], datas, "DatePickerDateOrder?", vars, props);
      final backgroundColor =
          getValue(maps["backgroundColor"], datas, "Color?", vars, props);
      final showDayOfWeek =
          getValue(maps["showDayOfWeek"], datas, "bool", vars, props);
      if (onDateTimeChanged == null) {
        return null;
      }
      return CupertinoDatePicker(
          key: key,
          mode: mode ?? CupertinoDatePickerMode.dateAndTime,
          onDateTimeChanged: onDateTimeChanged!,
          initialDateTime: initialDateTime,
          minimumDate: minimumDate,
          maximumDate: maximumDate,
          minimumYear: minimumYear ?? 1,
          maximumYear: maximumYear,
          minuteInterval: minuteInterval ?? 1,
          use24hFormat: use24hFormat ?? false,
          dateOrder: dateOrder,
          backgroundColor: backgroundColor,
          showDayOfWeek: showDayOfWeek ?? false);
    },
    "CupertinoDesktopTextSelectionToolbar": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final anchor = getValue(maps["anchor"], datas, "Offset", vars, props);
      final children =
          getValue(maps["children"], datas, "List<Widget>", vars, props);
      if (anchor == null || children == null) {
        return null;
      }
      return CupertinoDesktopTextSelectionToolbar(
          key: key, anchor: anchor!, children: List<Widget>.from(children!));
    },
    "CupertinoDesktopTextSelectionToolbarButton": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final onPressed =
          getValue(maps["onPressed"], datas, "VoidCallback", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (onPressed == null || child == null) {
        return null;
      }
      return CupertinoDesktopTextSelectionToolbarButton(
          key: key, onPressed: onPressed!, child: child!);
    },
    "CupertinoDesktopTextSelectionToolbarButton.text": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final context =
          getValue(maps["context"], datas, "BuildContext", vars, props);
      final onPressed =
          getValue(maps["onPressed"], datas, "VoidCallback", vars, props);
      final text = getValue(maps["text"], datas, "String", vars, props);
      if (context == null || onPressed == null || text == null) {
        return null;
      }
      return CupertinoDesktopTextSelectionToolbarButton.text(
          key: key, onPressed: onPressed!, text: text!);
    },
    "CupertinoDesktopTextSelectionToolbarButton.buttonItem": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final buttonItem = getValue(
          maps["buttonItem"], datas, "ContextMenuButtonItem", vars, props);
      if (buttonItem == null) {
        return null;
      }
      return CupertinoDesktopTextSelectionToolbarButton.buttonItem(
          key: key, buttonItem: buttonItem!);
    },
    "CupertinoDialogAction": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final onPressed =
          getValue(maps["onPressed"], datas, "VoidCallback?", vars, props);
      final isDefaultAction =
          getValue(maps["isDefaultAction"], datas, "bool", vars, props);
      final isDestructiveAction =
          getValue(maps["isDestructiveAction"], datas, "bool", vars, props);
      final textStyle =
          getValue(maps["textStyle"], datas, "TextStyle?", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (child == null) {
        return null;
      }
      return CupertinoDialogAction(
          key: key,
          onPressed: onPressed,
          isDefaultAction: isDefaultAction ?? false,
          isDestructiveAction: isDestructiveAction ?? false,
          textStyle: textStyle,
          child: child!);
    },
    "CupertinoDialogRoute": () {
      final builder =
          getValue(maps["builder"], datas, "WidgetBuilder", vars, props);
      final context =
          getValue(maps["context"], datas, "BuildContext", vars, props);
      final barrierDismissible =
          getValue(maps["barrierDismissible"], datas, "bool", vars, props);
      final barrierColor =
          getValue(maps["barrierColor"], datas, "Color?", vars, props);
      final barrierLabel =
          getValue(maps["barrierLabel"], datas, "String?", vars, props);
      final transitionDuration =
          getValue(maps["transitionDuration"], datas, "Duration", vars, props);
      final transitionBuilder = getValue(maps["transitionBuilder"], datas,
          "RouteTransitionsBuilder?", vars, props);
      final settings = getValue(maps["settings"], datas, "", vars, props);
      final anchorPoint =
          getValue(maps["anchorPoint"], datas, "Offset?", vars, props);
      if (builder == null || context == null) {
        return null;
      }
      if (transitionBuilder != null) {
        return CupertinoDialogRoute(
            builder: builder!,
            context: context!,
            barrierDismissible: barrierDismissible ?? true,
            barrierColor: barrierColor,
            barrierLabel: barrierLabel,
            transitionDuration:
                transitionDuration ?? const Duration(milliseconds: 250),
            settings: settings,
            anchorPoint: anchorPoint,
            transitionBuilder: transitionBuilder);
      }
      return CupertinoDialogRoute(
          builder: builder!,
          context: context!,
          barrierDismissible: barrierDismissible ?? true,
          barrierColor: barrierColor,
          barrierLabel: barrierLabel,
          transitionDuration:
              transitionDuration ?? const Duration(milliseconds: 250),
          settings: settings,
          anchorPoint: anchorPoint);
    },
    "CupertinoDynamicColor": () {
      final debugLabel =
          getValue(maps["debugLabel"], datas, "String?", vars, props);
      final color = getValue(maps["color"], datas, "Color", vars, props);
      final darkColor =
          getValue(maps["darkColor"], datas, "Color", vars, props);
      final highContrastColor =
          getValue(maps["highContrastColor"], datas, "Color", vars, props);
      final darkHighContrastColor =
          getValue(maps["darkHighContrastColor"], datas, "Color", vars, props);
      final elevatedColor =
          getValue(maps["elevatedColor"], datas, "Color", vars, props);
      final darkElevatedColor =
          getValue(maps["darkElevatedColor"], datas, "Color", vars, props);
      final highContrastElevatedColor = getValue(
          maps["highContrastElevatedColor"], datas, "Color", vars, props);
      final darkHighContrastElevatedColor = getValue(
          maps["darkHighContrastElevatedColor"], datas, "Color", vars, props);
      if (color == null ||
          darkColor == null ||
          highContrastColor == null ||
          darkHighContrastColor == null ||
          elevatedColor == null ||
          darkElevatedColor == null ||
          highContrastElevatedColor == null ||
          darkHighContrastElevatedColor == null) {
        return null;
      }
      return CupertinoDynamicColor(
          debugLabel: debugLabel,
          color: color!,
          darkColor: darkColor!,
          highContrastColor: highContrastColor!,
          darkHighContrastColor: darkHighContrastColor!,
          elevatedColor: elevatedColor!,
          darkElevatedColor: darkElevatedColor!,
          highContrastElevatedColor: highContrastElevatedColor!,
          darkHighContrastElevatedColor: darkHighContrastElevatedColor!);
    },
    "CupertinoDynamicColor.withBrightnessAndContrast": () {
      final debugLabel =
          getValue(maps["debugLabel"], datas, "String?", vars, props);
      final color = getValue(maps["color"], datas, "Color", vars, props);
      final darkColor =
          getValue(maps["darkColor"], datas, "Color", vars, props);
      final highContrastColor =
          getValue(maps["highContrastColor"], datas, "Color", vars, props);
      final darkHighContrastColor =
          getValue(maps["darkHighContrastColor"], datas, "Color", vars, props);
      if (color == null ||
          darkColor == null ||
          highContrastColor == null ||
          darkHighContrastColor == null) {
        return null;
      }
      return CupertinoDynamicColor.withBrightnessAndContrast(
          debugLabel: debugLabel,
          color: color!,
          darkColor: darkColor!,
          highContrastColor: highContrastColor!,
          darkHighContrastColor: darkHighContrastColor!);
    },
    "CupertinoDynamicColor.withBrightness": () {
      final debugLabel =
          getValue(maps["debugLabel"], datas, "String?", vars, props);
      final color = getValue(maps["color"], datas, "Color", vars, props);
      final darkColor =
          getValue(maps["darkColor"], datas, "Color", vars, props);
      if (color == null || darkColor == null) {
        return null;
      }
      return CupertinoDynamicColor.withBrightness(
          debugLabel: debugLabel, color: color!, darkColor: darkColor!);
    },
    "CupertinoFormRow": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      final prefix = getValue(maps["prefix"], datas, "Widget?", vars, props);
      final padding =
          getValue(maps["padding"], datas, "EdgeInsetsGeometry?", vars, props);
      final helper = getValue(maps["helper"], datas, "Widget?", vars, props);
      final error = getValue(maps["error"], datas, "Widget?", vars, props);
      if (child == null) {
        return null;
      }
      return CupertinoFormRow(
          key: key,
          child: child!,
          prefix: prefix,
          padding: padding,
          helper: helper,
          error: error);
    },
    "CupertinoFormSection": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final children =
          getValue(maps["children"], datas, "List<Widget>", vars, props);
      final header = getValue(maps["header"], datas, "Widget?", vars, props);
      final footer = getValue(maps["footer"], datas, "Widget?", vars, props);
      final margin =
          getValue(maps["margin"], datas, "EdgeInsetsGeometry", vars, props);
      final backgroundColor =
          getValue(maps["backgroundColor"], datas, "Color", vars, props);
      final decoration =
          getValue(maps["decoration"], datas, "BoxDecoration?", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      if (children == null) {
        return null;
      }
      return CupertinoFormSection(
          key: key,
          header: header,
          footer: footer,
          margin: margin ?? EdgeInsets.zero,
          backgroundColor:
              backgroundColor ?? CupertinoColors.systemGroupedBackground,
          decoration: decoration,
          clipBehavior: clipBehavior ?? Clip.none,
          children: List<Widget>.from(children!));
    },
    "CupertinoFormSection.insetGrouped": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final children =
          getValue(maps["children"], datas, "List<Widget>", vars, props);
      final header = getValue(maps["header"], datas, "Widget?", vars, props);
      final footer = getValue(maps["footer"], datas, "Widget?", vars, props);
      final margin =
          getValue(maps["margin"], datas, "EdgeInsetsGeometry", vars, props);
      final backgroundColor =
          getValue(maps["backgroundColor"], datas, "Color", vars, props);
      final decoration =
          getValue(maps["decoration"], datas, "BoxDecoration?", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      if (children == null) {
        return null;
      }
      if (margin != null) {
        return CupertinoFormSection.insetGrouped(
            key: key,
            header: header,
            footer: footer,
            backgroundColor:
                backgroundColor ?? CupertinoColors.systemGroupedBackground,
            decoration: decoration,
            clipBehavior: clipBehavior ?? Clip.none,
            margin: margin,
            children: List<Widget>.from(children!));
      }
      return CupertinoFormSection.insetGrouped(
          key: key,
          header: header,
          footer: footer,
          backgroundColor:
              backgroundColor ?? CupertinoColors.systemGroupedBackground,
          decoration: decoration,
          clipBehavior: clipBehavior ?? Clip.none,
          children: List<Widget>.from(children!));
    },
    "CupertinoFullscreenDialogTransition": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final primaryRouteAnimation = getValue(maps["primaryRouteAnimation"],
          datas, "Animation<double>", vars, props);
      final secondaryRouteAnimation = getValue(maps["secondaryRouteAnimation"],
          datas, "Animation<double>", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      final linearTransition =
          getValue(maps["linearTransition"], datas, "bool", vars, props);
      if (primaryRouteAnimation == null ||
          secondaryRouteAnimation == null ||
          child == null ||
          linearTransition == null) {
        return null;
      }
      return CupertinoFullscreenDialogTransition(
          key: key,
          primaryRouteAnimation: primaryRouteAnimation!,
          secondaryRouteAnimation: secondaryRouteAnimation!,
          child: child!,
          linearTransition: linearTransition!);
    },
    "CupertinoIconThemeData": () {
      final size = getValue(maps["size"], datas, "double?", vars, props);
      final fill = getValue(maps["fill"], datas, "double?", vars, props);
      final weight = getValue(maps["weight"], datas, "double?", vars, props);
      final grade = getValue(maps["grade"], datas, "double?", vars, props);
      final opticalSize =
          getValue(maps["opticalSize"], datas, "double?", vars, props);
      final color = getValue(maps["color"], datas, "Color?", vars, props);
      final opacity = getValue(maps["opacity"], datas, "double?", vars, props);
      final shadows =
          getValue(maps["shadows"], datas, "List<Shadow>?", vars, props);
      return CupertinoIconThemeData(
          size: size,
          fill: fill,
          weight: weight,
          grade: grade,
          opticalSize: opticalSize,
          color: color,
          opacity: opacity,
          shadows: shadows != null ? List<Shadow>.from(shadows) : null);
    },
    "CupertinoListSection": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final children =
          getValue(maps["children"], datas, "List<Widget>?", vars, props);
      final header = getValue(maps["header"], datas, "Widget?", vars, props);
      final footer = getValue(maps["footer"], datas, "Widget?", vars, props);
      final margin =
          getValue(maps["margin"], datas, "EdgeInsetsGeometry", vars, props);
      final backgroundColor =
          getValue(maps["backgroundColor"], datas, "Color", vars, props);
      final decoration =
          getValue(maps["decoration"], datas, "BoxDecoration?", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      final dividerMargin =
          getValue(maps["dividerMargin"], datas, "double", vars, props);
      final additionalDividerMargin = getValue(
          maps["additionalDividerMargin"], datas, "double?", vars, props);
      final topMargin =
          getValue(maps["topMargin"], datas, "double?", vars, props);
      final hasLeading =
          getValue(maps["hasLeading"], datas, "bool", vars, props);
      if (margin != null && dividerMargin != null && topMargin != null) {
        return CupertinoListSection(
            key: key,
            header: header,
            footer: footer,
            backgroundColor:
                backgroundColor ?? CupertinoColors.systemGroupedBackground,
            decoration: decoration,
            clipBehavior: clipBehavior ?? Clip.none,
            additionalDividerMargin: additionalDividerMargin,
            hasLeading: hasLeading ?? true,
            margin: margin,
            dividerMargin: dividerMargin,
            topMargin: topMargin,
            children: children != null ? List<Widget>.from(children) : null);
      }
      if (margin != null && dividerMargin != null) {
        return CupertinoListSection(
            key: key,
            header: header,
            footer: footer,
            backgroundColor:
                backgroundColor ?? CupertinoColors.systemGroupedBackground,
            decoration: decoration,
            clipBehavior: clipBehavior ?? Clip.none,
            additionalDividerMargin: additionalDividerMargin,
            hasLeading: hasLeading ?? true,
            margin: margin,
            dividerMargin: dividerMargin,
            children: children != null ? List<Widget>.from(children) : null);
      }
      if (margin != null && topMargin != null) {
        return CupertinoListSection(
            key: key,
            header: header,
            footer: footer,
            backgroundColor:
                backgroundColor ?? CupertinoColors.systemGroupedBackground,
            decoration: decoration,
            clipBehavior: clipBehavior ?? Clip.none,
            additionalDividerMargin: additionalDividerMargin,
            hasLeading: hasLeading ?? true,
            margin: margin,
            topMargin: topMargin,
            children: children != null ? List<Widget>.from(children) : null);
      }
      if (dividerMargin != null && topMargin != null) {
        return CupertinoListSection(
            key: key,
            header: header,
            footer: footer,
            backgroundColor:
                backgroundColor ?? CupertinoColors.systemGroupedBackground,
            decoration: decoration,
            clipBehavior: clipBehavior ?? Clip.none,
            additionalDividerMargin: additionalDividerMargin,
            hasLeading: hasLeading ?? true,
            dividerMargin: dividerMargin,
            topMargin: topMargin,
            children: children != null ? List<Widget>.from(children) : null);
      }
      if (margin != null) {
        return CupertinoListSection(
            key: key,
            header: header,
            footer: footer,
            backgroundColor:
                backgroundColor ?? CupertinoColors.systemGroupedBackground,
            decoration: decoration,
            clipBehavior: clipBehavior ?? Clip.none,
            additionalDividerMargin: additionalDividerMargin,
            hasLeading: hasLeading ?? true,
            margin: margin,
            children: children != null ? List<Widget>.from(children) : null);
      }
      if (dividerMargin != null) {
        return CupertinoListSection(
            key: key,
            header: header,
            footer: footer,
            backgroundColor:
                backgroundColor ?? CupertinoColors.systemGroupedBackground,
            decoration: decoration,
            clipBehavior: clipBehavior ?? Clip.none,
            additionalDividerMargin: additionalDividerMargin,
            hasLeading: hasLeading ?? true,
            dividerMargin: dividerMargin,
            children: children != null ? List<Widget>.from(children) : null);
      }
      if (topMargin != null) {
        return CupertinoListSection(
            key: key,
            header: header,
            footer: footer,
            backgroundColor:
                backgroundColor ?? CupertinoColors.systemGroupedBackground,
            decoration: decoration,
            clipBehavior: clipBehavior ?? Clip.none,
            additionalDividerMargin: additionalDividerMargin,
            hasLeading: hasLeading ?? true,
            topMargin: topMargin,
            children: children != null ? List<Widget>.from(children) : null);
      }
      return CupertinoListSection(
          key: key,
          header: header,
          footer: footer,
          backgroundColor:
              backgroundColor ?? CupertinoColors.systemGroupedBackground,
          decoration: decoration,
          clipBehavior: clipBehavior ?? Clip.none,
          additionalDividerMargin: additionalDividerMargin,
          hasLeading: hasLeading ?? true,
          children: children != null ? List<Widget>.from(children) : null);
    },
    "CupertinoListSection.insetGrouped": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final children =
          getValue(maps["children"], datas, "List<Widget>?", vars, props);
      final header = getValue(maps["header"], datas, "Widget?", vars, props);
      final footer = getValue(maps["footer"], datas, "Widget?", vars, props);
      final margin =
          getValue(maps["margin"], datas, "EdgeInsetsGeometry?", vars, props);
      final backgroundColor =
          getValue(maps["backgroundColor"], datas, "Color", vars, props);
      final decoration =
          getValue(maps["decoration"], datas, "BoxDecoration?", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      final dividerMargin =
          getValue(maps["dividerMargin"], datas, "double", vars, props);
      final additionalDividerMargin = getValue(
          maps["additionalDividerMargin"], datas, "double?", vars, props);
      final topMargin =
          getValue(maps["topMargin"], datas, "double?", vars, props);
      final hasLeading =
          getValue(maps["hasLeading"], datas, "bool", vars, props);
      if (dividerMargin != null) {
        return CupertinoListSection.insetGrouped(
            key: key,
            header: header,
            footer: footer,
            margin: margin,
            backgroundColor:
                backgroundColor ?? CupertinoColors.systemGroupedBackground,
            decoration: decoration,
            clipBehavior: clipBehavior ?? Clip.hardEdge,
            additionalDividerMargin: additionalDividerMargin,
            topMargin: topMargin,
            hasLeading: hasLeading ?? true,
            dividerMargin: dividerMargin,
            children: children != null ? List<Widget>.from(children) : null);
      }
      return CupertinoListSection.insetGrouped(
          key: key,
          header: header,
          footer: footer,
          margin: margin,
          backgroundColor:
              backgroundColor ?? CupertinoColors.systemGroupedBackground,
          decoration: decoration,
          clipBehavior: clipBehavior ?? Clip.hardEdge,
          additionalDividerMargin: additionalDividerMargin,
          topMargin: topMargin,
          hasLeading: hasLeading ?? true,
          children: children != null ? List<Widget>.from(children) : null);
    },
    "CupertinoListTile": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final title = getValue(maps["title"], datas, "Widget", vars, props);
      final subtitle =
          getValue(maps["subtitle"], datas, "Widget?", vars, props);
      final additionalInfo =
          getValue(maps["additionalInfo"], datas, "Widget?", vars, props);
      final leading = getValue(maps["leading"], datas, "Widget?", vars, props);
      final trailing =
          getValue(maps["trailing"], datas, "Widget?", vars, props);
      final onTap = getValue(maps["onTap"], datas, "", vars, props);
      final backgroundColor =
          getValue(maps["backgroundColor"], datas, "Color?", vars, props);
      final backgroundColorActivated = getValue(
          maps["backgroundColorActivated"], datas, "Color?", vars, props);
      final padding =
          getValue(maps["padding"], datas, "EdgeInsetsGeometry?", vars, props);
      final leadingSize =
          getValue(maps["leadingSize"], datas, "double", vars, props);
      final leadingToTitle =
          getValue(maps["leadingToTitle"], datas, "double", vars, props);
      if (title == null) {
        return null;
      }
      if (leadingSize != null && leadingToTitle != null) {
        return CupertinoListTile(
            key: key,
            title: title!,
            subtitle: subtitle,
            additionalInfo: additionalInfo,
            leading: leading,
            trailing: trailing,
            onTap: onTap,
            backgroundColor: backgroundColor,
            backgroundColorActivated: backgroundColorActivated,
            padding: padding,
            leadingSize: leadingSize,
            leadingToTitle: leadingToTitle);
      }
      if (leadingSize != null) {
        return CupertinoListTile(
            key: key,
            title: title!,
            subtitle: subtitle,
            additionalInfo: additionalInfo,
            leading: leading,
            trailing: trailing,
            onTap: onTap,
            backgroundColor: backgroundColor,
            backgroundColorActivated: backgroundColorActivated,
            padding: padding,
            leadingSize: leadingSize);
      }
      if (leadingToTitle != null) {
        return CupertinoListTile(
            key: key,
            title: title!,
            subtitle: subtitle,
            additionalInfo: additionalInfo,
            leading: leading,
            trailing: trailing,
            onTap: onTap,
            backgroundColor: backgroundColor,
            backgroundColorActivated: backgroundColorActivated,
            padding: padding,
            leadingToTitle: leadingToTitle);
      }
      return CupertinoListTile(
          key: key,
          title: title!,
          subtitle: subtitle,
          additionalInfo: additionalInfo,
          leading: leading,
          trailing: trailing,
          onTap: onTap,
          backgroundColor: backgroundColor,
          backgroundColorActivated: backgroundColorActivated,
          padding: padding);
    },
    "CupertinoListTile.notched": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final title = getValue(maps["title"], datas, "Widget", vars, props);
      final subtitle =
          getValue(maps["subtitle"], datas, "Widget?", vars, props);
      final additionalInfo =
          getValue(maps["additionalInfo"], datas, "Widget?", vars, props);
      final leading = getValue(maps["leading"], datas, "Widget?", vars, props);
      final trailing =
          getValue(maps["trailing"], datas, "Widget?", vars, props);
      final onTap = getValue(maps["onTap"], datas, "", vars, props);
      final backgroundColor =
          getValue(maps["backgroundColor"], datas, "Color?", vars, props);
      final backgroundColorActivated = getValue(
          maps["backgroundColorActivated"], datas, "Color?", vars, props);
      final padding =
          getValue(maps["padding"], datas, "EdgeInsetsGeometry?", vars, props);
      final leadingSize =
          getValue(maps["leadingSize"], datas, "double", vars, props);
      final leadingToTitle =
          getValue(maps["leadingToTitle"], datas, "double", vars, props);
      if (title == null) {
        return null;
      }
      if (leadingSize != null && leadingToTitle != null) {
        return CupertinoListTile.notched(
            key: key,
            title: title!,
            subtitle: subtitle,
            additionalInfo: additionalInfo,
            leading: leading,
            trailing: trailing,
            onTap: onTap,
            backgroundColor: backgroundColor,
            backgroundColorActivated: backgroundColorActivated,
            padding: padding,
            leadingSize: leadingSize,
            leadingToTitle: leadingToTitle);
      }
      if (leadingSize != null) {
        return CupertinoListTile.notched(
            key: key,
            title: title!,
            subtitle: subtitle,
            additionalInfo: additionalInfo,
            leading: leading,
            trailing: trailing,
            onTap: onTap,
            backgroundColor: backgroundColor,
            backgroundColorActivated: backgroundColorActivated,
            padding: padding,
            leadingSize: leadingSize);
      }
      if (leadingToTitle != null) {
        return CupertinoListTile.notched(
            key: key,
            title: title!,
            subtitle: subtitle,
            additionalInfo: additionalInfo,
            leading: leading,
            trailing: trailing,
            onTap: onTap,
            backgroundColor: backgroundColor,
            backgroundColorActivated: backgroundColorActivated,
            padding: padding,
            leadingToTitle: leadingToTitle);
      }
      return CupertinoListTile.notched(
          key: key,
          title: title!,
          subtitle: subtitle,
          additionalInfo: additionalInfo,
          leading: leading,
          trailing: trailing,
          onTap: onTap,
          backgroundColor: backgroundColor,
          backgroundColorActivated: backgroundColorActivated,
          padding: padding);
    },
    "CupertinoListTileChevron": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      return CupertinoListTileChevron(key: key);
    },
    "CupertinoMagnifier": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final size = getValue(maps["size"], datas, "Size", vars, props);
      final borderRadius =
          getValue(maps["borderRadius"], datas, "BorderRadius", vars, props);
      final additionalFocalPointOffset = getValue(
          maps["additionalFocalPointOffset"], datas, "Offset", vars, props);
      final shadows =
          getValue(maps["shadows"], datas, "List<BoxShadow>", vars, props);
      final borderSide =
          getValue(maps["borderSide"], datas, "BorderSide", vars, props);
      final inOutAnimation = getValue(
          maps["inOutAnimation"], datas, "Animation<double>?", vars, props);
      if (size != null) {
        return CupertinoMagnifier(
            key: key,
            borderRadius: borderRadius ??
                const BorderRadius.all(Radius.elliptical(60, 50)),
            additionalFocalPointOffset:
                additionalFocalPointOffset ?? Offset.zero,
            shadows: List<BoxShadow>.from(shadows ??
                const <BoxShadow>[
                  BoxShadow(
                    color: Color.fromARGB(25, 0, 0, 0),
                    blurRadius: 11,
                    spreadRadius: 0.2,
                  ),
                ]),
            borderSide: borderSide ??
                const BorderSide(color: Color.fromARGB(255, 232, 232, 232)),
            inOutAnimation: inOutAnimation,
            size: size);
      }
      return CupertinoMagnifier(
          key: key,
          borderRadius:
              borderRadius ?? const BorderRadius.all(Radius.elliptical(60, 50)),
          additionalFocalPointOffset: additionalFocalPointOffset ?? Offset.zero,
          shadows: List<BoxShadow>.from(shadows ??
              const <BoxShadow>[
                BoxShadow(
                  color: Color.fromARGB(25, 0, 0, 0),
                  blurRadius: 11,
                  spreadRadius: 0.2,
                ),
              ]),
          borderSide: borderSide ??
              const BorderSide(color: Color.fromARGB(255, 232, 232, 232)),
          inOutAnimation: inOutAnimation);
    },
    "CupertinoModalPopupRoute": () {
      final builder =
          getValue(maps["builder"], datas, "WidgetBuilder", vars, props);
      final barrierLabel =
          getValue(maps["barrierLabel"], datas, "String", vars, props);
      final barrierColor =
          getValue(maps["barrierColor"], datas, "Color?", vars, props);
      final barrierDismissible =
          getValue(maps["barrierDismissible"], datas, "bool", vars, props);
      final semanticsDismissible =
          getValue(maps["semanticsDismissible"], datas, "bool", vars, props);
      final filter = getValue(maps["filter"], datas, "", vars, props);
      final settings = getValue(maps["settings"], datas, "", vars, props);
      final anchorPoint =
          getValue(maps["anchorPoint"], datas, "Offset?", vars, props);
      if (builder == null) {
        return null;
      }
      if (barrierColor != null) {
        return CupertinoModalPopupRoute(
            builder: builder!,
            barrierLabel: barrierLabel ?? 'Dismiss',
            barrierDismissible: barrierDismissible ?? true,
            semanticsDismissible: semanticsDismissible ?? false,
            filter: filter,
            settings: settings,
            anchorPoint: anchorPoint,
            barrierColor: barrierColor);
      }
      return CupertinoModalPopupRoute(
          builder: builder!,
          barrierLabel: barrierLabel ?? 'Dismiss',
          barrierDismissible: barrierDismissible ?? true,
          semanticsDismissible: semanticsDismissible ?? false,
          filter: filter,
          settings: settings,
          anchorPoint: anchorPoint);
    },
    "CupertinoNavigationBar": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final leading = getValue(maps["leading"], datas, "Widget?", vars, props);
      final automaticallyImplyLeading = getValue(
          maps["automaticallyImplyLeading"], datas, "bool", vars, props);
      final automaticallyImplyMiddle = getValue(
          maps["automaticallyImplyMiddle"], datas, "bool", vars, props);
      final previousPageTitle =
          getValue(maps["previousPageTitle"], datas, "String?", vars, props);
      final middle = getValue(maps["middle"], datas, "Widget?", vars, props);
      final trailing =
          getValue(maps["trailing"], datas, "Widget?", vars, props);
      final border = getValue(maps["border"], datas, "Border?", vars, props);
      final backgroundColor =
          getValue(maps["backgroundColor"], datas, "Color?", vars, props);
      final brightness =
          getValue(maps["brightness"], datas, "Brightness?", vars, props);
      final padding = getValue(
          maps["padding"], datas, "EdgeInsetsDirectional?", vars, props);
      final transitionBetweenRoutes =
          getValue(maps["transitionBetweenRoutes"], datas, "bool", vars, props);
      final heroTag = getValue(maps["heroTag"], datas, "Object", vars, props);
      if (border != null && heroTag != null) {
        return CupertinoNavigationBar(
            key: key,
            leading: leading,
            automaticallyImplyLeading: automaticallyImplyLeading ?? true,
            automaticallyImplyMiddle: automaticallyImplyMiddle ?? true,
            previousPageTitle: previousPageTitle,
            middle: middle,
            trailing: trailing,
            backgroundColor: backgroundColor,
            brightness: brightness,
            padding: padding,
            transitionBetweenRoutes: transitionBetweenRoutes ?? true,
            border: border,
            heroTag: heroTag);
      }
      if (border != null) {
        return CupertinoNavigationBar(
            key: key,
            leading: leading,
            automaticallyImplyLeading: automaticallyImplyLeading ?? true,
            automaticallyImplyMiddle: automaticallyImplyMiddle ?? true,
            previousPageTitle: previousPageTitle,
            middle: middle,
            trailing: trailing,
            backgroundColor: backgroundColor,
            brightness: brightness,
            padding: padding,
            transitionBetweenRoutes: transitionBetweenRoutes ?? true,
            border: border);
      }
      if (heroTag != null) {
        return CupertinoNavigationBar(
            key: key,
            leading: leading,
            automaticallyImplyLeading: automaticallyImplyLeading ?? true,
            automaticallyImplyMiddle: automaticallyImplyMiddle ?? true,
            previousPageTitle: previousPageTitle,
            middle: middle,
            trailing: trailing,
            backgroundColor: backgroundColor,
            brightness: brightness,
            padding: padding,
            transitionBetweenRoutes: transitionBetweenRoutes ?? true,
            heroTag: heroTag);
      }
      return CupertinoNavigationBar(
          key: key,
          leading: leading,
          automaticallyImplyLeading: automaticallyImplyLeading ?? true,
          automaticallyImplyMiddle: automaticallyImplyMiddle ?? true,
          previousPageTitle: previousPageTitle,
          middle: middle,
          trailing: trailing,
          backgroundColor: backgroundColor,
          brightness: brightness,
          padding: padding,
          transitionBetweenRoutes: transitionBetweenRoutes ?? true);
    },
    "CupertinoNavigationBarBackButton": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final color = getValue(maps["color"], datas, "Color?", vars, props);
      final previousPageTitle =
          getValue(maps["previousPageTitle"], datas, "String?", vars, props);
      final onPressed =
          getValue(maps["onPressed"], datas, "VoidCallback?", vars, props);
      return CupertinoNavigationBarBackButton(
          key: key,
          color: color,
          previousPageTitle: previousPageTitle,
          onPressed: onPressed);
    },
    "CupertinoPage": () {
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      final maintainState =
          getValue(maps["maintainState"], datas, "bool", vars, props);
      final title = getValue(maps["title"], datas, "String?", vars, props);
      final fullscreenDialog =
          getValue(maps["fullscreenDialog"], datas, "bool", vars, props);
      final allowSnapshotting =
          getValue(maps["allowSnapshotting"], datas, "bool", vars, props);
      final key = getValue(maps["key"], datas, "", vars, props);
      final name = getValue(maps["name"], datas, "", vars, props);
      final arguments = getValue(maps["arguments"], datas, "", vars, props);
      final restorationId =
          getValue(maps["restorationId"], datas, "", vars, props);
      if (child == null) {
        return null;
      }
      return CupertinoPage(
          child: child!,
          maintainState: maintainState ?? true,
          title: title,
          fullscreenDialog: fullscreenDialog ?? false,
          allowSnapshotting: allowSnapshotting ?? true,
          key: key,
          name: name,
          arguments: arguments,
          restorationId: restorationId);
    },
    "CupertinoPageRoute": () {
      final builder =
          getValue(maps["builder"], datas, "WidgetBuilder", vars, props);
      final title = getValue(maps["title"], datas, "String?", vars, props);
      final settings =
          getValue(maps["settings"], datas, "RouteSettings?", vars, props);
      final maintainState =
          getValue(maps["maintainState"], datas, "bool", vars, props);
      final fullscreenDialog =
          getValue(maps["fullscreenDialog"], datas, "bool", vars, props);
      final allowSnapshotting =
          getValue(maps["allowSnapshotting"], datas, "bool", vars, props);
      if (builder == null) {
        return null;
      }
      return CupertinoPageRoute(
          builder: builder!,
          title: title,
          settings: settings,
          maintainState: maintainState ?? true,
          fullscreenDialog: fullscreenDialog ?? false,
          allowSnapshotting: allowSnapshotting ?? true);
    },
    "CupertinoPageScaffold": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final navigationBar = getValue(maps["navigationBar"], datas,
          "ObstructingPreferredSizeWidget?", vars, props);
      final backgroundColor =
          getValue(maps["backgroundColor"], datas, "Color?", vars, props);
      final resizeToAvoidBottomInset = getValue(
          maps["resizeToAvoidBottomInset"], datas, "bool", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (child == null) {
        return null;
      }
      return CupertinoPageScaffold(
          key: key,
          navigationBar: navigationBar,
          backgroundColor: backgroundColor,
          resizeToAvoidBottomInset: resizeToAvoidBottomInset ?? true,
          child: child!);
    },
    "CupertinoPageTransition": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final primaryRouteAnimation = getValue(maps["primaryRouteAnimation"],
          datas, "Animation<double>", vars, props);
      final secondaryRouteAnimation = getValue(maps["secondaryRouteAnimation"],
          datas, "Animation<double>", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      final linearTransition =
          getValue(maps["linearTransition"], datas, "bool", vars, props);
      if (primaryRouteAnimation == null ||
          secondaryRouteAnimation == null ||
          child == null ||
          linearTransition == null) {
        return null;
      }
      return CupertinoPageTransition(
          key: key,
          primaryRouteAnimation: primaryRouteAnimation!,
          secondaryRouteAnimation: secondaryRouteAnimation!,
          child: child!,
          linearTransition: linearTransition!);
    },
    "CupertinoPageTransitionsBuilder": () {
      return const CupertinoPageTransitionsBuilder();
    },
    "CupertinoPicker": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final diameterRatio =
          getValue(maps["diameterRatio"], datas, "double", vars, props);
      final backgroundColor =
          getValue(maps["backgroundColor"], datas, "Color?", vars, props);
      final offAxisFraction =
          getValue(maps["offAxisFraction"], datas, "double", vars, props);
      final useMagnifier =
          getValue(maps["useMagnifier"], datas, "bool", vars, props);
      final magnification =
          getValue(maps["magnification"], datas, "double", vars, props);
      final scrollController = getValue(maps["scrollController"], datas,
          "FixedExtentScrollController?", vars, props);
      final squeeze = getValue(maps["squeeze"], datas, "double", vars, props);
      final itemExtent =
          getValue(maps["itemExtent"], datas, "double", vars, props);
      final onSelectedItemChanged = getValue(maps["onSelectedItemChanged"],
          datas, "ValueChanged<int>?", vars, props);
      final children =
          getValue(maps["children"], datas, "List<Widget>", vars, props);
      final selectionOverlay =
          getValue(maps["selectionOverlay"], datas, "Widget?", vars, props);
      final looping = getValue(maps["looping"], datas, "bool", vars, props);
      if (itemExtent == null ||
          onSelectedItemChanged == null ||
          children == null) {
        return null;
      }
      if (diameterRatio != null && squeeze != null) {
        return CupertinoPicker(
            key: key,
            backgroundColor: backgroundColor,
            offAxisFraction: offAxisFraction ?? 0.0,
            useMagnifier: useMagnifier ?? false,
            magnification: magnification ?? 1.0,
            scrollController: scrollController,
            itemExtent: itemExtent!,
            onSelectedItemChanged: onSelectedItemChanged!,
            selectionOverlay: selectionOverlay ??
                const CupertinoPickerDefaultSelectionOverlay(),
            looping: looping ?? false,
            diameterRatio: diameterRatio,
            squeeze: squeeze,
            children: List<Widget>.from(children!));
      }
      if (diameterRatio != null) {
        return CupertinoPicker(
            key: key,
            backgroundColor: backgroundColor,
            offAxisFraction: offAxisFraction ?? 0.0,
            useMagnifier: useMagnifier ?? false,
            magnification: magnification ?? 1.0,
            scrollController: scrollController,
            itemExtent: itemExtent!,
            onSelectedItemChanged: onSelectedItemChanged!,
            selectionOverlay: selectionOverlay ??
                const CupertinoPickerDefaultSelectionOverlay(),
            looping: looping ?? false,
            diameterRatio: diameterRatio,
            children: List<Widget>.from(children!));
      }
      if (squeeze != null) {
        return CupertinoPicker(
            key: key,
            backgroundColor: backgroundColor,
            offAxisFraction: offAxisFraction ?? 0.0,
            useMagnifier: useMagnifier ?? false,
            magnification: magnification ?? 1.0,
            scrollController: scrollController,
            itemExtent: itemExtent!,
            onSelectedItemChanged: onSelectedItemChanged!,
            selectionOverlay: selectionOverlay ??
                const CupertinoPickerDefaultSelectionOverlay(),
            looping: looping ?? false,
            squeeze: squeeze,
            children: List<Widget>.from(children!));
      }
      return CupertinoPicker(
          key: key,
          backgroundColor: backgroundColor,
          offAxisFraction: offAxisFraction ?? 0.0,
          useMagnifier: useMagnifier ?? false,
          magnification: magnification ?? 1.0,
          scrollController: scrollController,
          itemExtent: itemExtent!,
          onSelectedItemChanged: onSelectedItemChanged!,
          selectionOverlay: selectionOverlay ??
              const CupertinoPickerDefaultSelectionOverlay(),
          looping: looping ?? false,
          children: List<Widget>.from(children!));
    },
    "CupertinoPicker.builder": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final diameterRatio =
          getValue(maps["diameterRatio"], datas, "double", vars, props);
      final backgroundColor =
          getValue(maps["backgroundColor"], datas, "Color?", vars, props);
      final offAxisFraction =
          getValue(maps["offAxisFraction"], datas, "double", vars, props);
      final useMagnifier =
          getValue(maps["useMagnifier"], datas, "bool", vars, props);
      final magnification =
          getValue(maps["magnification"], datas, "double", vars, props);
      final scrollController = getValue(maps["scrollController"], datas,
          "FixedExtentScrollController?", vars, props);
      final squeeze = getValue(maps["squeeze"], datas, "double", vars, props);
      final itemExtent =
          getValue(maps["itemExtent"], datas, "double", vars, props);
      final onSelectedItemChanged = getValue(maps["onSelectedItemChanged"],
          datas, "ValueChanged<int>?", vars, props);
      final itemBuilder = getValue(maps["itemBuilder"], datas,
          "NullableIndexedWidgetBuilder", vars, props);
      final childCount =
          getValue(maps["childCount"], datas, "int?", vars, props);
      final selectionOverlay =
          getValue(maps["selectionOverlay"], datas, "Widget?", vars, props);
      if (itemExtent == null ||
          onSelectedItemChanged == null ||
          itemBuilder == null) {
        return null;
      }
      if (diameterRatio != null && squeeze != null) {
        return CupertinoPicker.builder(
            key: key,
            backgroundColor: backgroundColor,
            offAxisFraction: offAxisFraction ?? 0.0,
            useMagnifier: useMagnifier ?? false,
            magnification: magnification ?? 1.0,
            scrollController: scrollController,
            itemExtent: itemExtent!,
            onSelectedItemChanged: onSelectedItemChanged!,
            itemBuilder: itemBuilder!,
            childCount: childCount,
            selectionOverlay: selectionOverlay ??
                const CupertinoPickerDefaultSelectionOverlay(),
            diameterRatio: diameterRatio,
            squeeze: squeeze);
      }
      if (diameterRatio != null) {
        return CupertinoPicker.builder(
            key: key,
            backgroundColor: backgroundColor,
            offAxisFraction: offAxisFraction ?? 0.0,
            useMagnifier: useMagnifier ?? false,
            magnification: magnification ?? 1.0,
            scrollController: scrollController,
            itemExtent: itemExtent!,
            onSelectedItemChanged: onSelectedItemChanged!,
            itemBuilder: itemBuilder!,
            childCount: childCount,
            selectionOverlay: selectionOverlay ??
                const CupertinoPickerDefaultSelectionOverlay(),
            diameterRatio: diameterRatio);
      }
      if (squeeze != null) {
        return CupertinoPicker.builder(
            key: key,
            backgroundColor: backgroundColor,
            offAxisFraction: offAxisFraction ?? 0.0,
            useMagnifier: useMagnifier ?? false,
            magnification: magnification ?? 1.0,
            scrollController: scrollController,
            itemExtent: itemExtent!,
            onSelectedItemChanged: onSelectedItemChanged!,
            itemBuilder: itemBuilder!,
            childCount: childCount,
            selectionOverlay: selectionOverlay ??
                const CupertinoPickerDefaultSelectionOverlay(),
            squeeze: squeeze);
      }
      return CupertinoPicker.builder(
          key: key,
          backgroundColor: backgroundColor,
          offAxisFraction: offAxisFraction ?? 0.0,
          useMagnifier: useMagnifier ?? false,
          magnification: magnification ?? 1.0,
          scrollController: scrollController,
          itemExtent: itemExtent!,
          onSelectedItemChanged: onSelectedItemChanged!,
          itemBuilder: itemBuilder!,
          childCount: childCount,
          selectionOverlay: selectionOverlay ??
              const CupertinoPickerDefaultSelectionOverlay());
    },
    "CupertinoPickerDefaultSelectionOverlay": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final background =
          getValue(maps["background"], datas, "Color", vars, props);
      final capStartEdge =
          getValue(maps["capStartEdge"], datas, "bool", vars, props);
      final capEndEdge =
          getValue(maps["capEndEdge"], datas, "bool", vars, props);
      return CupertinoPickerDefaultSelectionOverlay(
          key: key,
          background: background ?? CupertinoColors.tertiarySystemFill,
          capStartEdge: capStartEdge ?? true,
          capEndEdge: capEndEdge ?? true);
    },
    "CupertinoPopupSurface": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final isSurfacePainted =
          getValue(maps["isSurfacePainted"], datas, "bool", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      return CupertinoPopupSurface(
          key: key, isSurfacePainted: isSurfacePainted ?? true, child: child);
    },
    "CupertinoRadio": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final value = getValue(maps["value"], datas, "T", vars, props);
      final groupValue = getValue(maps["groupValue"], datas, "T?", vars, props);
      final onChanged =
          getValue(maps["onChanged"], datas, "ValueChanged<T?>?", vars, props);
      final toggleable =
          getValue(maps["toggleable"], datas, "bool", vars, props);
      final activeColor =
          getValue(maps["activeColor"], datas, "Color?", vars, props);
      final inactiveColor =
          getValue(maps["inactiveColor"], datas, "Color?", vars, props);
      final fillColor =
          getValue(maps["fillColor"], datas, "Color?", vars, props);
      final focusColor =
          getValue(maps["focusColor"], datas, "Color?", vars, props);
      final focusNode =
          getValue(maps["focusNode"], datas, "FocusNode?", vars, props);
      final autofocus = getValue(maps["autofocus"], datas, "bool", vars, props);
      if (value == null || groupValue == null || onChanged == null) {
        return null;
      }
      return CupertinoRadio(
          key: key,
          value: value!,
          groupValue: groupValue!,
          onChanged: onChanged!,
          toggleable: toggleable ?? false,
          activeColor: activeColor,
          inactiveColor: inactiveColor,
          fillColor: fillColor,
          focusColor: focusColor,
          focusNode: focusNode,
          autofocus: autofocus ?? false);
    },
    "CupertinoScrollBehavior": () {
      return const CupertinoScrollBehavior();
    },
    "CupertinoScrollbar": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      final controller =
          getValue(maps["controller"], datas, "ScrollController?", vars, props);
      final thumbVisibility =
          getValue(maps["thumbVisibility"], datas, "bool?", vars, props);
      final thickness =
          getValue(maps["thickness"], datas, "double", vars, props);
      final thicknessWhileDragging = getValue(
          maps["thicknessWhileDragging"], datas, "double", vars, props);
      final radius = getValue(maps["radius"], datas, "Radius", vars, props);
      final radiusWhileDragging =
          getValue(maps["radiusWhileDragging"], datas, "Radius", vars, props);
      final notificationPredicate = getValue(maps["notificationPredicate"],
          datas, "ScrollNotificationPredicate?", vars, props);
      final scrollbarOrientation = getValue(maps["scrollbarOrientation"], datas,
          "ScrollbarOrientation?", vars, props);
      final isAlwaysShown =
          getValue(maps["isAlwaysShown"], datas, "bool?", vars, props);
      if (child == null) {
        return null;
      }
      if (thickness != null &&
          thicknessWhileDragging != null &&
          radius != null &&
          radiusWhileDragging != null) {
        return CupertinoScrollbar(
            key: key,
            child: child!,
            controller: controller,
            thumbVisibility: thumbVisibility,
            notificationPredicate: notificationPredicate,
            scrollbarOrientation: scrollbarOrientation,
            //  isAlwaysShown: isAlwaysShown,
            thickness: thickness,
            thicknessWhileDragging: thicknessWhileDragging,
            radius: radius,
            radiusWhileDragging: radiusWhileDragging);
      }
      if (thickness != null &&
          thicknessWhileDragging != null &&
          radius != null) {
        return CupertinoScrollbar(
            key: key,
            child: child!,
            controller: controller,
            thumbVisibility: thumbVisibility,
            notificationPredicate: notificationPredicate,
            scrollbarOrientation: scrollbarOrientation,
            //  isAlwaysShown: isAlwaysShown,
            thickness: thickness,
            thicknessWhileDragging: thicknessWhileDragging,
            radius: radius);
      }
      if (thickness != null &&
          thicknessWhileDragging != null &&
          radiusWhileDragging != null) {
        return CupertinoScrollbar(
            key: key,
            child: child!,
            controller: controller,
            thumbVisibility: thumbVisibility,
            notificationPredicate: notificationPredicate,
            scrollbarOrientation: scrollbarOrientation,
            //  isAlwaysShown: isAlwaysShown,
            thickness: thickness,
            thicknessWhileDragging: thicknessWhileDragging,
            radiusWhileDragging: radiusWhileDragging);
      }
      if (thickness != null && radius != null && radiusWhileDragging != null) {
        return CupertinoScrollbar(
            key: key,
            child: child!,
            controller: controller,
            thumbVisibility: thumbVisibility,
            notificationPredicate: notificationPredicate,
            scrollbarOrientation: scrollbarOrientation,
            // isAlwaysShown: isAlwaysShown,
            thickness: thickness,
            radius: radius,
            radiusWhileDragging: radiusWhileDragging);
      }
      if (thicknessWhileDragging != null &&
          radius != null &&
          radiusWhileDragging != null) {
        return CupertinoScrollbar(
            key: key,
            child: child!,
            controller: controller,
            thumbVisibility: thumbVisibility,
            notificationPredicate: notificationPredicate,
            scrollbarOrientation: scrollbarOrientation,
            //    isAlwaysShown: isAlwaysShown,
            thicknessWhileDragging: thicknessWhileDragging,
            radius: radius,
            radiusWhileDragging: radiusWhileDragging);
      }
      if (thickness != null && thicknessWhileDragging != null) {
        return CupertinoScrollbar(
            key: key,
            child: child!,
            controller: controller,
            thumbVisibility: thumbVisibility,
            notificationPredicate: notificationPredicate,
            scrollbarOrientation: scrollbarOrientation,
            //  isAlwaysShown: isAlwaysShown,
            thickness: thickness,
            thicknessWhileDragging: thicknessWhileDragging);
      }
      if (thickness != null && radius != null) {
        return CupertinoScrollbar(
            key: key,
            child: child!,
            controller: controller,
            thumbVisibility: thumbVisibility,
            notificationPredicate: notificationPredicate,
            scrollbarOrientation: scrollbarOrientation,
            //  isAlwaysShown: isAlwaysShown,
            thickness: thickness,
            radius: radius);
      }
      if (thickness != null && radiusWhileDragging != null) {
        return CupertinoScrollbar(
            key: key,
            child: child!,
            controller: controller,
            thumbVisibility: thumbVisibility,
            notificationPredicate: notificationPredicate,
            scrollbarOrientation: scrollbarOrientation,
            // isAlwaysShown: isAlwaysShown,
            thickness: thickness,
            radiusWhileDragging: radiusWhileDragging);
      }
      if (thicknessWhileDragging != null && radius != null) {
        return CupertinoScrollbar(
            key: key,
            child: child!,
            controller: controller,
            thumbVisibility: thumbVisibility,
            notificationPredicate: notificationPredicate,
            scrollbarOrientation: scrollbarOrientation,
            // isAlwaysShown: isAlwaysShown,
            thicknessWhileDragging: thicknessWhileDragging,
            radius: radius);
      }
      if (thicknessWhileDragging != null && radiusWhileDragging != null) {
        return CupertinoScrollbar(
            key: key,
            child: child!,
            controller: controller,
            thumbVisibility: thumbVisibility,
            notificationPredicate: notificationPredicate,
            scrollbarOrientation: scrollbarOrientation,
            //  isAlwaysShown: isAlwaysShown,
            thicknessWhileDragging: thicknessWhileDragging,
            radiusWhileDragging: radiusWhileDragging);
      }
      if (radius != null && radiusWhileDragging != null) {
        return CupertinoScrollbar(
            key: key,
            child: child!,
            controller: controller,
            thumbVisibility: thumbVisibility,
            notificationPredicate: notificationPredicate,
            scrollbarOrientation: scrollbarOrientation,
            // isAlwaysShown: isAlwaysShown,
            radius: radius,
            radiusWhileDragging: radiusWhileDragging);
      }
      if (thickness != null) {
        return CupertinoScrollbar(
            key: key,
            child: child!,
            controller: controller,
            thumbVisibility: thumbVisibility,
            notificationPredicate: notificationPredicate,
            scrollbarOrientation: scrollbarOrientation,
            //  isAlwaysShown: isAlwaysShown,
            thickness: thickness);
      }
      if (thicknessWhileDragging != null) {
        return CupertinoScrollbar(
            key: key,
            child: child!,
            controller: controller,
            thumbVisibility: thumbVisibility,
            notificationPredicate: notificationPredicate,
            scrollbarOrientation: scrollbarOrientation,
            // isAlwaysShown: isAlwaysShown,
            thicknessWhileDragging: thicknessWhileDragging);
      }
      if (radius != null) {
        return CupertinoScrollbar(
            key: key,
            child: child!,
            controller: controller,
            thumbVisibility: thumbVisibility,
            notificationPredicate: notificationPredicate,
            scrollbarOrientation: scrollbarOrientation,
            //   isAlwaysShown: isAlwaysShown,
            radius: radius);
      }
      if (radiusWhileDragging != null) {
        return CupertinoScrollbar(
            key: key,
            child: child!,
            controller: controller,
            thumbVisibility: thumbVisibility,
            notificationPredicate: notificationPredicate,
            scrollbarOrientation: scrollbarOrientation,
            //  isAlwaysShown: isAlwaysShown,
            radiusWhileDragging: radiusWhileDragging);
      }
      return CupertinoScrollbar(
        key: key,
        child: child!,
        controller: controller,
        thumbVisibility: thumbVisibility,
        notificationPredicate: notificationPredicate,
        scrollbarOrientation: scrollbarOrientation,
        //   isAlwaysShown: isAlwaysShown,
      );
    },
    "CupertinoSearchTextField": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final controller = getValue(maps["controller"], datas, "", vars, props);
      final onChanged = getValue(maps["onChanged"], datas, "", vars, props);
      final onSubmitted = getValue(maps["onSubmitted"], datas, "", vars, props);
      final style = getValue(maps["style"], datas, "", vars, props);
      final placeholder = getValue(maps["placeholder"], datas, "", vars, props);
      final placeholderStyle =
          getValue(maps["placeholderStyle"], datas, "", vars, props);
      final decoration = getValue(maps["decoration"], datas, "", vars, props);
      final backgroundColor =
          getValue(maps["backgroundColor"], datas, "", vars, props);
      final borderRadius =
          getValue(maps["borderRadius"], datas, "", vars, props);
      final keyboardType =
          getValue(maps["keyboardType"], datas, "", vars, props);
      final padding = getValue(maps["padding"], datas, "", vars, props);
      final itemColor = getValue(maps["itemColor"], datas, "", vars, props);
      final itemSize = getValue(maps["itemSize"], datas, "", vars, props);
      final prefixInsets =
          getValue(maps["prefixInsets"], datas, "", vars, props);
      final prefixIcon = getValue(maps["prefixIcon"], datas, "", vars, props);
      final suffixInsets =
          getValue(maps["suffixInsets"], datas, "", vars, props);
      final suffixIcon = getValue(maps["suffixIcon"], datas, "", vars, props);
      final suffixMode = getValue(maps["suffixMode"], datas, "", vars, props);
      final onSuffixTap = getValue(maps["onSuffixTap"], datas, "", vars, props);
      final restorationId =
          getValue(maps["restorationId"], datas, "", vars, props);
      final focusNode = getValue(maps["focusNode"], datas, "", vars, props);
      final smartQuotesType =
          getValue(maps["smartQuotesType"], datas, "", vars, props);
      final smartDashesType =
          getValue(maps["smartDashesType"], datas, "", vars, props);
      final enableIMEPersonalizedLearning = getValue(
          maps["enableIMEPersonalizedLearning"], datas, "", vars, props);
      final autofocus = getValue(maps["autofocus"], datas, "", vars, props);
      final onTap = getValue(maps["onTap"], datas, "", vars, props);
      final autocorrect = getValue(maps["autocorrect"], datas, "", vars, props);
      final enabled = getValue(maps["enabled"], datas, "", vars, props);
      return CupertinoSearchTextField(
          key: key,
          controller: controller,
          onChanged: onChanged,
          onSubmitted: onSubmitted,
          style: style,
          placeholder: placeholder,
          placeholderStyle: placeholderStyle,
          decoration: decoration,
          backgroundColor: backgroundColor,
          borderRadius: borderRadius,
          keyboardType: keyboardType ?? TextInputType.text,
          padding:
              padding ?? const EdgeInsetsDirectional.fromSTEB(5.5, 8, 5.5, 8),
          itemColor: itemColor ?? CupertinoColors.secondaryLabel,
          itemSize: itemSize ?? 20.0,
          prefixInsets:
              prefixInsets ?? const EdgeInsetsDirectional.fromSTEB(6, 0, 0, 3),
          prefixIcon: prefixIcon ?? const Icon(CupertinoIcons.search),
          suffixInsets:
              suffixInsets ?? const EdgeInsetsDirectional.fromSTEB(0, 0, 5, 2),
          suffixIcon:
              suffixIcon ?? const Icon(CupertinoIcons.xmark_circle_fill),
          suffixMode: suffixMode ?? OverlayVisibilityMode.editing,
          onSuffixTap: onSuffixTap,
          restorationId: restorationId,
          focusNode: focusNode,
          smartQuotesType: smartQuotesType,
          smartDashesType: smartDashesType,
          enableIMEPersonalizedLearning: enableIMEPersonalizedLearning ?? true,
          autofocus: autofocus ?? false,
          onTap: onTap,
          autocorrect: autocorrect ?? true,
          enabled: enabled);
    },
    "CupertinoSegmentedControl": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final children =
          getValue(maps["children"], datas, "Map<T, Widget>", vars, props);
      final onValueChanged = getValue(
          maps["onValueChanged"], datas, "ValueChanged<T>", vars, props);
      final groupValue = getValue(maps["groupValue"], datas, "T?", vars, props);
      final unselectedColor =
          getValue(maps["unselectedColor"], datas, "Color?", vars, props);
      final selectedColor =
          getValue(maps["selectedColor"], datas, "Color?", vars, props);
      final borderColor =
          getValue(maps["borderColor"], datas, "Color?", vars, props);
      final pressedColor =
          getValue(maps["pressedColor"], datas, "Color?", vars, props);
      final padding =
          getValue(maps["padding"], datas, "EdgeInsetsGeometry?", vars, props);
      if (children == null || onValueChanged == null) {
        return null;
      }
      return CupertinoSegmentedControl(
          key: key,
          children: Map<T, Widget>.from(children!),
          onValueChanged: onValueChanged!,
          groupValue: groupValue,
          unselectedColor: unselectedColor,
          selectedColor: selectedColor,
          borderColor: borderColor,
          pressedColor: pressedColor,
          padding: padding);
    },
    "CupertinoSlider": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final value = getValue(maps["value"], datas, "double", vars, props);
      final onChanged = getValue(
          maps["onChanged"], datas, "ValueChanged<double>?", vars, props);
      final onChangeStart = getValue(
          maps["onChangeStart"], datas, "ValueChanged<double>?", vars, props);
      final onChangeEnd = getValue(
          maps["onChangeEnd"], datas, "ValueChanged<double>?", vars, props);
      final min = getValue(maps["min"], datas, "double", vars, props);
      final max = getValue(maps["max"], datas, "double", vars, props);
      final divisions = getValue(maps["divisions"], datas, "int?", vars, props);
      final activeColor =
          getValue(maps["activeColor"], datas, "Color?", vars, props);
      final thumbColor =
          getValue(maps["thumbColor"], datas, "Color", vars, props);
      if (value == null || onChanged == null) {
        return null;
      }
      return CupertinoSlider(
          key: key,
          value: value!,
          onChanged: onChanged!,
          onChangeStart: onChangeStart,
          onChangeEnd: onChangeEnd,
          min: min ?? 0.0,
          max: max ?? 1.0,
          divisions: divisions,
          activeColor: activeColor,
          thumbColor: thumbColor ?? CupertinoColors.white);
    },
    "CupertinoSlidingSegmentedControl": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final children =
          getValue(maps["children"], datas, "Map<T, Widget>", vars, props);
      final onValueChanged = getValue(
          maps["onValueChanged"], datas, "ValueChanged<T?>", vars, props);
      final groupValue = getValue(maps["groupValue"], datas, "T?", vars, props);
      final thumbColor =
          getValue(maps["thumbColor"], datas, "Color", vars, props);
      final padding =
          getValue(maps["padding"], datas, "EdgeInsetsGeometry", vars, props);
      final backgroundColor =
          getValue(maps["backgroundColor"], datas, "Color", vars, props);
      if (children == null || onValueChanged == null) {
        return null;
      }
      if (thumbColor != null && padding != null) {
        return CupertinoSlidingSegmentedControl(
            key: key,
            children: Map<T, Widget>.from(children!),
            onValueChanged: onValueChanged!,
            groupValue: groupValue,
            backgroundColor:
                backgroundColor ?? CupertinoColors.tertiarySystemFill,
            thumbColor: thumbColor,
            padding: padding);
      }
      if (thumbColor != null) {
        return CupertinoSlidingSegmentedControl(
            key: key,
            children: Map<T, Widget>.from(children!),
            onValueChanged: onValueChanged!,
            groupValue: groupValue,
            backgroundColor:
                backgroundColor ?? CupertinoColors.tertiarySystemFill,
            thumbColor: thumbColor);
      }
      if (padding != null) {
        return CupertinoSlidingSegmentedControl(
            key: key,
            children: Map<T, Widget>.from(children!),
            onValueChanged: onValueChanged!,
            groupValue: groupValue,
            backgroundColor:
                backgroundColor ?? CupertinoColors.tertiarySystemFill,
            padding: padding);
      }
      return CupertinoSlidingSegmentedControl(
          key: key,
          children: Map<T, Widget>.from(children!),
          onValueChanged: onValueChanged!,
          groupValue: groupValue,
          backgroundColor:
              backgroundColor ?? CupertinoColors.tertiarySystemFill);
    },
    "CupertinoSliverNavigationBar": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final largeTitle =
          getValue(maps["largeTitle"], datas, "Widget?", vars, props);
      final leading = getValue(maps["leading"], datas, "Widget?", vars, props);
      final automaticallyImplyLeading = getValue(
          maps["automaticallyImplyLeading"], datas, "bool", vars, props);
      final automaticallyImplyTitle =
          getValue(maps["automaticallyImplyTitle"], datas, "bool", vars, props);
      final alwaysShowMiddle =
          getValue(maps["alwaysShowMiddle"], datas, "bool", vars, props);
      final previousPageTitle =
          getValue(maps["previousPageTitle"], datas, "String?", vars, props);
      final middle = getValue(maps["middle"], datas, "Widget?", vars, props);
      final trailing =
          getValue(maps["trailing"], datas, "Widget?", vars, props);
      final border = getValue(maps["border"], datas, "Border?", vars, props);
      final backgroundColor =
          getValue(maps["backgroundColor"], datas, "Color?", vars, props);
      final brightness =
          getValue(maps["brightness"], datas, "Brightness?", vars, props);
      final padding = getValue(
          maps["padding"], datas, "EdgeInsetsDirectional?", vars, props);
      final transitionBetweenRoutes =
          getValue(maps["transitionBetweenRoutes"], datas, "bool", vars, props);
      final heroTag = getValue(maps["heroTag"], datas, "Object", vars, props);
      final stretch = getValue(maps["stretch"], datas, "bool", vars, props);
      if (border != null && heroTag != null) {
        return CupertinoSliverNavigationBar(
            key: key,
            largeTitle: largeTitle,
            leading: leading,
            automaticallyImplyLeading: automaticallyImplyLeading ?? true,
            automaticallyImplyTitle: automaticallyImplyTitle ?? true,
            alwaysShowMiddle: alwaysShowMiddle ?? true,
            previousPageTitle: previousPageTitle,
            middle: middle,
            trailing: trailing,
            backgroundColor: backgroundColor,
            brightness: brightness,
            padding: padding,
            transitionBetweenRoutes: transitionBetweenRoutes ?? true,
            stretch: stretch ?? false,
            border: border,
            heroTag: heroTag);
      }
      if (border != null) {
        return CupertinoSliverNavigationBar(
            key: key,
            largeTitle: largeTitle,
            leading: leading,
            automaticallyImplyLeading: automaticallyImplyLeading ?? true,
            automaticallyImplyTitle: automaticallyImplyTitle ?? true,
            alwaysShowMiddle: alwaysShowMiddle ?? true,
            previousPageTitle: previousPageTitle,
            middle: middle,
            trailing: trailing,
            backgroundColor: backgroundColor,
            brightness: brightness,
            padding: padding,
            transitionBetweenRoutes: transitionBetweenRoutes ?? true,
            stretch: stretch ?? false,
            border: border);
      }
      if (heroTag != null) {
        return CupertinoSliverNavigationBar(
            key: key,
            largeTitle: largeTitle,
            leading: leading,
            automaticallyImplyLeading: automaticallyImplyLeading ?? true,
            automaticallyImplyTitle: automaticallyImplyTitle ?? true,
            alwaysShowMiddle: alwaysShowMiddle ?? true,
            previousPageTitle: previousPageTitle,
            middle: middle,
            trailing: trailing,
            backgroundColor: backgroundColor,
            brightness: brightness,
            padding: padding,
            transitionBetweenRoutes: transitionBetweenRoutes ?? true,
            stretch: stretch ?? false,
            heroTag: heroTag);
      }
      return CupertinoSliverNavigationBar(
          key: key,
          largeTitle: largeTitle,
          leading: leading,
          automaticallyImplyLeading: automaticallyImplyLeading ?? true,
          automaticallyImplyTitle: automaticallyImplyTitle ?? true,
          alwaysShowMiddle: alwaysShowMiddle ?? true,
          previousPageTitle: previousPageTitle,
          middle: middle,
          trailing: trailing,
          backgroundColor: backgroundColor,
          brightness: brightness,
          padding: padding,
          transitionBetweenRoutes: transitionBetweenRoutes ?? true,
          stretch: stretch ?? false);
    },
    "CupertinoSliverRefreshControl": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final refreshTriggerPullDistance = getValue(
          maps["refreshTriggerPullDistance"], datas, "double", vars, props);
      final refreshIndicatorExtent = getValue(
          maps["refreshIndicatorExtent"], datas, "double", vars, props);
      final builder = getValue(maps["builder"], datas,
          "RefreshControlIndicatorBuilder?", vars, props);
      final onRefresh =
          getValue(maps["onRefresh"], datas, "RefreshCallback?", vars, props);
      if (refreshTriggerPullDistance != null &&
          refreshIndicatorExtent != null &&
          builder != null) {
        return CupertinoSliverRefreshControl(
            key: key,
            onRefresh: onRefresh,
            refreshTriggerPullDistance: refreshTriggerPullDistance,
            refreshIndicatorExtent: refreshIndicatorExtent,
            builder: builder);
      }
      if (refreshTriggerPullDistance != null &&
          refreshIndicatorExtent != null) {
        return CupertinoSliverRefreshControl(
            key: key,
            onRefresh: onRefresh,
            refreshTriggerPullDistance: refreshTriggerPullDistance,
            refreshIndicatorExtent: refreshIndicatorExtent);
      }
      if (refreshTriggerPullDistance != null && builder != null) {
        return CupertinoSliverRefreshControl(
            key: key,
            onRefresh: onRefresh,
            refreshTriggerPullDistance: refreshTriggerPullDistance,
            builder: builder);
      }
      if (refreshIndicatorExtent != null && builder != null) {
        return CupertinoSliverRefreshControl(
            key: key,
            onRefresh: onRefresh,
            refreshIndicatorExtent: refreshIndicatorExtent,
            builder: builder);
      }
      if (refreshTriggerPullDistance != null) {
        return CupertinoSliverRefreshControl(
            key: key,
            onRefresh: onRefresh,
            refreshTriggerPullDistance: refreshTriggerPullDistance);
      }
      if (refreshIndicatorExtent != null) {
        return CupertinoSliverRefreshControl(
            key: key,
            onRefresh: onRefresh,
            refreshIndicatorExtent: refreshIndicatorExtent);
      }
      if (builder != null) {
        return CupertinoSliverRefreshControl(
            key: key, onRefresh: onRefresh, builder: builder);
      }
      return CupertinoSliverRefreshControl(key: key, onRefresh: onRefresh);
    },
    "CupertinoSpellCheckSuggestionsToolbar": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final anchors = getValue(
          maps["anchors"], datas, "TextSelectionToolbarAnchors", vars, props);
      final buttonItems = getValue(maps["buttonItems"], datas,
          "List<ContextMenuButtonItem>", vars, props);
      if (anchors == null || buttonItems == null) {
        return null;
      }
      return CupertinoSpellCheckSuggestionsToolbar(
          key: key,
          anchors: anchors!,
          buttonItems: List<ContextMenuButtonItem>.from(buttonItems!));
    },
    "CupertinoSpellCheckSuggestionsToolbar.editableText": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final editableTextState = getValue(
          maps["editableTextState"], datas, "EditableTextState", vars, props);
      if (editableTextState == null) {
        return null;
      }
      return CupertinoSpellCheckSuggestionsToolbar.editableText(
          key: key, editableTextState: editableTextState!);
    },
    "CupertinoSwitch": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final value = getValue(maps["value"], datas, "bool", vars, props);
      final onChanged = getValue(
          maps["onChanged"], datas, "ValueChanged<bool>?", vars, props);
      final activeColor =
          getValue(maps["activeColor"], datas, "Color?", vars, props);
      final trackColor =
          getValue(maps["trackColor"], datas, "Color?", vars, props);
      final thumbColor =
          getValue(maps["thumbColor"], datas, "Color?", vars, props);
      final applyTheme =
          getValue(maps["applyTheme"], datas, "bool?", vars, props);
      final focusColor =
          getValue(maps["focusColor"], datas, "Color?", vars, props);
      final dragStartBehavior = getValue(
          maps["dragStartBehavior"], datas, "DragStartBehavior", vars, props);
      if (value == null || onChanged == null) {
        return null;
      }
      return CupertinoSwitch(
          key: key,
          value: value!,
          onChanged: onChanged!,
          activeColor: activeColor,
          trackColor: trackColor,
          thumbColor: thumbColor,
          applyTheme: applyTheme,
          focusColor: focusColor,
          dragStartBehavior: dragStartBehavior ?? DragStartBehavior.start);
    },
    "CupertinoTabBar": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final items = getValue(
          maps["items"], datas, "List<BottomNavigationBarItem>", vars, props);
      final onTap =
          getValue(maps["onTap"], datas, "ValueChanged<int>?", vars, props);
      final currentIndex =
          getValue(maps["currentIndex"], datas, "int", vars, props);
      final backgroundColor =
          getValue(maps["backgroundColor"], datas, "Color?", vars, props);
      final activeColor =
          getValue(maps["activeColor"], datas, "Color?", vars, props);
      final inactiveColor =
          getValue(maps["inactiveColor"], datas, "Color", vars, props);
      final iconSize = getValue(maps["iconSize"], datas, "double", vars, props);
      final height = getValue(maps["height"], datas, "double", vars, props);
      final border = getValue(maps["border"], datas, "Border?", vars, props);
      if (items == null) {
        return null;
      }
      if (inactiveColor != null && height != null) {
        return CupertinoTabBar(
            key: key,
            items: List<BottomNavigationBarItem>.from(items!),
            onTap: onTap,
            currentIndex: currentIndex ?? 0,
            backgroundColor: backgroundColor,
            activeColor: activeColor,
            iconSize: iconSize ?? 30.0,
            border: border ??
                const Border(
                  top: BorderSide(
                    color: _kDefaultTabBarBorderColor,
                    width: 0.0,
                  ),
                ),
            inactiveColor: inactiveColor,
            height: height);
      }
      if (inactiveColor != null) {
        return CupertinoTabBar(
            key: key,
            items: List<BottomNavigationBarItem>.from(items!),
            onTap: onTap,
            currentIndex: currentIndex ?? 0,
            backgroundColor: backgroundColor,
            activeColor: activeColor,
            iconSize: iconSize ?? 30.0,
            border: border ??
                const Border(
                  top: BorderSide(
                    color: _kDefaultTabBarBorderColor,
                    width: 0.0,
                  ),
                ),
            inactiveColor: inactiveColor);
      }
      if (height != null) {
        return CupertinoTabBar(
            key: key,
            items: List<BottomNavigationBarItem>.from(items!),
            onTap: onTap,
            currentIndex: currentIndex ?? 0,
            backgroundColor: backgroundColor,
            activeColor: activeColor,
            iconSize: iconSize ?? 30.0,
            border: border ??
                const Border(
                  top: BorderSide(
                    color: _kDefaultTabBarBorderColor,
                    width: 0.0,
                  ),
                ),
            height: height);
      }
      return CupertinoTabBar(
          key: key,
          items: List<BottomNavigationBarItem>.from(items!),
          onTap: onTap,
          currentIndex: currentIndex ?? 0,
          backgroundColor: backgroundColor,
          activeColor: activeColor,
          iconSize: iconSize ?? 30.0,
          border: border ??
              const Border(
                top: BorderSide(
                  color: _kDefaultTabBarBorderColor,
                  width: 0.0,
                ),
              ));
    },
    "CupertinoTabController": () {
      final initialIndex =
          getValue(maps["initialIndex"], datas, "int", vars, props);
      return CupertinoTabController(initialIndex: initialIndex ?? 0);
    },
    "CupertinoTabScaffold": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final tabBar =
          getValue(maps["tabBar"], datas, "CupertinoTabBar", vars, props);
      final tabBuilder = getValue(
          maps["tabBuilder"], datas, "IndexedWidgetBuilder", vars, props);
      final controller = getValue(
          maps["controller"], datas, "CupertinoTabController?", vars, props);
      final backgroundColor =
          getValue(maps["backgroundColor"], datas, "Color?", vars, props);
      final resizeToAvoidBottomInset = getValue(
          maps["resizeToAvoidBottomInset"], datas, "bool", vars, props);
      final restorationId =
          getValue(maps["restorationId"], datas, "String?", vars, props);
      if (tabBar == null || tabBuilder == null) {
        return null;
      }
      return CupertinoTabScaffold(
          key: key,
          tabBar: tabBar!,
          tabBuilder: tabBuilder!,
          controller: controller,
          backgroundColor: backgroundColor,
          resizeToAvoidBottomInset: resizeToAvoidBottomInset ?? true,
          restorationId: restorationId);
    },
    "CupertinoTabView": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final builder =
          getValue(maps["builder"], datas, "WidgetBuilder?", vars, props);
      final navigatorKey = getValue(maps["navigatorKey"], datas,
          "GlobalKey<NavigatorState>?", vars, props);
      final defaultTitle =
          getValue(maps["defaultTitle"], datas, "String?", vars, props);
      final routes = getValue(
          maps["routes"], datas, "Map<String, WidgetBuilder>?", vars, props);
      final onGenerateRoute = getValue(
          maps["onGenerateRoute"], datas, "RouteFactory?", vars, props);
      final onUnknownRoute =
          getValue(maps["onUnknownRoute"], datas, "RouteFactory?", vars, props);
      final navigatorObservers = getValue(maps["navigatorObservers"], datas,
          "List<NavigatorObserver>", vars, props);
      final restorationScopeId =
          getValue(maps["restorationScopeId"], datas, "String?", vars, props);
      return CupertinoTabView(
          key: key,
          builder: builder,
          navigatorKey: navigatorKey,
          defaultTitle: defaultTitle,
          routes: routes ? Map<String, WidgetBuilder>.from(routes) : null,
          onGenerateRoute: onGenerateRoute,
          onUnknownRoute: onUnknownRoute,
          navigatorObservers: List<NavigatorObserver>.from(
              navigatorObservers ?? const <NavigatorObserver>[]),
          restorationScopeId: restorationScopeId);
    },
    "CupertinoTextField": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final controller = getValue(maps["controller"], datas, "", vars, props);
      final focusNode = getValue(maps["focusNode"], datas, "", vars, props);
      final undoController =
          getValue(maps["undoController"], datas, "", vars, props);
      final decoration = getValue(maps["decoration"], datas, "", vars, props);
      final padding = getValue(maps["padding"], datas, "", vars, props);
      final placeholder = getValue(maps["placeholder"], datas, "", vars, props);
      final placeholderStyle =
          getValue(maps["placeholderStyle"], datas, "", vars, props);
      final prefix = getValue(maps["prefix"], datas, "", vars, props);
      final prefixMode = getValue(maps["prefixMode"], datas, "", vars, props);
      final suffix = getValue(maps["suffix"], datas, "", vars, props);
      final suffixMode = getValue(maps["suffixMode"], datas, "", vars, props);
      final clearButtonMode =
          getValue(maps["clearButtonMode"], datas, "", vars, props);
      final keyboardType =
          getValue(maps["keyboardType"], datas, "TextInputType?", vars, props);
      final textInputAction =
          getValue(maps["textInputAction"], datas, "", vars, props);
      final textCapitalization =
          getValue(maps["textCapitalization"], datas, "", vars, props);
      final style = getValue(maps["style"], datas, "", vars, props);
      final strutStyle = getValue(maps["strutStyle"], datas, "", vars, props);
      final textAlign = getValue(maps["textAlign"], datas, "", vars, props);
      final textAlignVertical =
          getValue(maps["textAlignVertical"], datas, "", vars, props);
      final textDirection =
          getValue(maps["textDirection"], datas, "", vars, props);
      final readOnly = getValue(maps["readOnly"], datas, "", vars, props);
      final toolbarOptions =
          getValue(maps["toolbarOptions"], datas, "", vars, props);
      final showCursor = getValue(maps["showCursor"], datas, "", vars, props);
      final autofocus = getValue(maps["autofocus"], datas, "", vars, props);
      final obscuringCharacter =
          getValue(maps["obscuringCharacter"], datas, "", vars, props);
      final obscureText = getValue(maps["obscureText"], datas, "", vars, props);
      final autocorrect = getValue(maps["autocorrect"], datas, "", vars, props);
      final smartDashesType = getValue(
          maps["smartDashesType"], datas, "SmartDashesType?", vars, props);
      final smartQuotesType = getValue(
          maps["smartQuotesType"], datas, "SmartQuotesType?", vars, props);
      final enableSuggestions =
          getValue(maps["enableSuggestions"], datas, "", vars, props);
      final maxLines = getValue(maps["maxLines"], datas, "", vars, props);
      final minLines = getValue(maps["minLines"], datas, "", vars, props);
      final expands = getValue(maps["expands"], datas, "", vars, props);
      final maxLength = getValue(maps["maxLength"], datas, "", vars, props);
      final maxLengthEnforcement =
          getValue(maps["maxLengthEnforcement"], datas, "", vars, props);
      final onChanged = getValue(maps["onChanged"], datas, "", vars, props);
      final onEditingComplete =
          getValue(maps["onEditingComplete"], datas, "", vars, props);
      final onSubmitted = getValue(maps["onSubmitted"], datas, "", vars, props);
      final onTapOutside =
          getValue(maps["onTapOutside"], datas, "", vars, props);
      final inputFormatters =
          getValue(maps["inputFormatters"], datas, "", vars, props);
      final enabled = getValue(maps["enabled"], datas, "", vars, props);
      final cursorWidth = getValue(maps["cursorWidth"], datas, "", vars, props);
      final cursorHeight =
          getValue(maps["cursorHeight"], datas, "", vars, props);
      final cursorRadius =
          getValue(maps["cursorRadius"], datas, "", vars, props);
      final cursorOpacityAnimates =
          getValue(maps["cursorOpacityAnimates"], datas, "", vars, props);
      final cursorColor = getValue(maps["cursorColor"], datas, "", vars, props);
      final selectionHeightStyle =
          getValue(maps["selectionHeightStyle"], datas, "", vars, props);
      final selectionWidthStyle =
          getValue(maps["selectionWidthStyle"], datas, "", vars, props);
      final keyboardAppearance =
          getValue(maps["keyboardAppearance"], datas, "", vars, props);
      final scrollPadding =
          getValue(maps["scrollPadding"], datas, "", vars, props);
      final dragStartBehavior =
          getValue(maps["dragStartBehavior"], datas, "", vars, props);
      final enableInteractiveSelection = getValue(
          maps["enableInteractiveSelection"], datas, "bool?", vars, props);
      final selectionControls =
          getValue(maps["selectionControls"], datas, "", vars, props);
      final onTap = getValue(maps["onTap"], datas, "", vars, props);
      final scrollController =
          getValue(maps["scrollController"], datas, "", vars, props);
      final scrollPhysics =
          getValue(maps["scrollPhysics"], datas, "", vars, props);
      final autofillHints =
          getValue(maps["autofillHints"], datas, "", vars, props);
      final contentInsertionConfiguration = getValue(
          maps["contentInsertionConfiguration"], datas, "", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "", vars, props);
      final restorationId =
          getValue(maps["restorationId"], datas, "", vars, props);
      final scribbleEnabled =
          getValue(maps["scribbleEnabled"], datas, "", vars, props);
      final enableIMEPersonalizedLearning = getValue(
          maps["enableIMEPersonalizedLearning"], datas, "", vars, props);
      final contextMenuBuilder =
          getValue(maps["contextMenuBuilder"], datas, "", vars, props);
      final spellCheckConfiguration =
          getValue(maps["spellCheckConfiguration"], datas, "", vars, props);
      final magnifierConfiguration =
          getValue(maps["magnifierConfiguration"], datas, "", vars, props);
      if (decoration != null) {
        return CupertinoTextField(
            key: key,
            controller: controller,
            focusNode: focusNode,
            undoController: undoController,
            padding: padding ?? const EdgeInsets.all(7.0),
            placeholder: placeholder,
            placeholderStyle: placeholderStyle ??
                const TextStyle(
                  fontWeight: FontWeight.w400,
                  color: CupertinoColors.placeholderText,
                ),
            prefix: prefix,
            prefixMode: prefixMode ?? OverlayVisibilityMode.always,
            suffix: suffix,
            suffixMode: suffixMode ?? OverlayVisibilityMode.always,
            clearButtonMode: clearButtonMode ?? OverlayVisibilityMode.never,
            keyboardType: keyboardType,
            textInputAction: textInputAction,
            textCapitalization: textCapitalization ?? TextCapitalization.none,
            style: style,
            strutStyle: strutStyle,
            textAlign: textAlign ?? TextAlign.start,
            textAlignVertical: textAlignVertical,
            textDirection: textDirection,
            readOnly: readOnly ?? false,
            toolbarOptions: toolbarOptions,
            showCursor: showCursor,
            autofocus: autofocus ?? false,
            obscuringCharacter: obscuringCharacter ?? '•',
            obscureText: obscureText ?? false,
            autocorrect: autocorrect ?? true,
            smartDashesType: smartDashesType,
            smartQuotesType: smartQuotesType,
            enableSuggestions: enableSuggestions ?? true,
            maxLines: maxLines ?? 1,
            minLines: minLines,
            expands: expands ?? false,
            maxLength: maxLength,
            maxLengthEnforcement: maxLengthEnforcement,
            onChanged: onChanged,
            onEditingComplete: onEditingComplete,
            onSubmitted: onSubmitted,
            onTapOutside: onTapOutside,
            inputFormatters: inputFormatters,
            enabled: enabled,
            cursorWidth: cursorWidth ?? 2.0,
            cursorHeight: cursorHeight,
            cursorRadius: cursorRadius ?? const Radius.circular(2.0),
            cursorOpacityAnimates: cursorOpacityAnimates ?? true,
            cursorColor: cursorColor,
            selectionHeightStyle:
                selectionHeightStyle ?? ui.BoxHeightStyle.tight,
            selectionWidthStyle: selectionWidthStyle ?? ui.BoxWidthStyle.tight,
            keyboardAppearance: keyboardAppearance,
            scrollPadding: scrollPadding ?? const EdgeInsets.all(20.0),
            dragStartBehavior: dragStartBehavior ?? DragStartBehavior.start,
            enableInteractiveSelection: enableInteractiveSelection,
            selectionControls: selectionControls,
            onTap: onTap,
            scrollController: scrollController,
            scrollPhysics: scrollPhysics,
            autofillHints: autofillHints ?? const <String>[],
            contentInsertionConfiguration: contentInsertionConfiguration,
            clipBehavior: clipBehavior ?? Clip.hardEdge,
            restorationId: restorationId,
            scribbleEnabled: scribbleEnabled ?? true,
            enableIMEPersonalizedLearning:
                enableIMEPersonalizedLearning ?? true,
            contextMenuBuilder:
                contextMenuBuilder ?? _defaultContextMenuBuilder,
            spellCheckConfiguration: spellCheckConfiguration,
            magnifierConfiguration: magnifierConfiguration,
            decoration: decoration);
      }
      return CupertinoTextField(
          key: key,
          controller: controller,
          focusNode: focusNode,
          undoController: undoController,
          padding: padding ?? const EdgeInsets.all(7.0),
          placeholder: placeholder,
          placeholderStyle: placeholderStyle ??
              const TextStyle(
                fontWeight: FontWeight.w400,
                color: CupertinoColors.placeholderText,
              ),
          prefix: prefix,
          prefixMode: prefixMode ?? OverlayVisibilityMode.always,
          suffix: suffix,
          suffixMode: suffixMode ?? OverlayVisibilityMode.always,
          clearButtonMode: clearButtonMode ?? OverlayVisibilityMode.never,
          keyboardType: keyboardType,
          textInputAction: textInputAction,
          textCapitalization: textCapitalization ?? TextCapitalization.none,
          style: style,
          strutStyle: strutStyle,
          textAlign: textAlign ?? TextAlign.start,
          textAlignVertical: textAlignVertical,
          textDirection: textDirection,
          readOnly: readOnly ?? false,
          toolbarOptions: toolbarOptions,
          showCursor: showCursor,
          autofocus: autofocus ?? false,
          obscuringCharacter: obscuringCharacter ?? '•',
          obscureText: obscureText ?? false,
          autocorrect: autocorrect ?? true,
          smartDashesType: smartDashesType,
          smartQuotesType: smartQuotesType,
          enableSuggestions: enableSuggestions ?? true,
          maxLines: maxLines ?? 1,
          minLines: minLines,
          expands: expands ?? false,
          maxLength: maxLength,
          maxLengthEnforcement: maxLengthEnforcement,
          onChanged: onChanged,
          onEditingComplete: onEditingComplete,
          onSubmitted: onSubmitted,
          onTapOutside: onTapOutside,
          inputFormatters: inputFormatters,
          enabled: enabled,
          cursorWidth: cursorWidth ?? 2.0,
          cursorHeight: cursorHeight,
          cursorRadius: cursorRadius ?? const Radius.circular(2.0),
          cursorOpacityAnimates: cursorOpacityAnimates ?? true,
          cursorColor: cursorColor,
          selectionHeightStyle: selectionHeightStyle ?? ui.BoxHeightStyle.tight,
          selectionWidthStyle: selectionWidthStyle ?? ui.BoxWidthStyle.tight,
          keyboardAppearance: keyboardAppearance,
          scrollPadding: scrollPadding ?? const EdgeInsets.all(20.0),
          dragStartBehavior: dragStartBehavior ?? DragStartBehavior.start,
          enableInteractiveSelection: enableInteractiveSelection,
          selectionControls: selectionControls,
          onTap: onTap,
          scrollController: scrollController,
          scrollPhysics: scrollPhysics,
          autofillHints: autofillHints ?? const <String>[],
          contentInsertionConfiguration: contentInsertionConfiguration,
          clipBehavior: clipBehavior ?? Clip.hardEdge,
          restorationId: restorationId,
          scribbleEnabled: scribbleEnabled ?? true,
          enableIMEPersonalizedLearning: enableIMEPersonalizedLearning ?? true,
          contextMenuBuilder: contextMenuBuilder ?? _defaultContextMenuBuilder,
          spellCheckConfiguration: spellCheckConfiguration,
          magnifierConfiguration: magnifierConfiguration);
    },
    "CupertinoTextFormFieldRow": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final prefix = getValue(maps["prefix"], datas, "", vars, props);
      final padding = getValue(maps["padding"], datas, "", vars, props);
      final controller = getValue(maps["controller"], datas, "", vars, props);
      final initialValue =
          getValue(maps["initialValue"], datas, "String?", vars, props);
      final focusNode =
          getValue(maps["focusNode"], datas, "FocusNode?", vars, props);
      final decoration =
          getValue(maps["decoration"], datas, "BoxDecoration?", vars, props);
      final keyboardType =
          getValue(maps["keyboardType"], datas, "TextInputType?", vars, props);
      final textCapitalization = getValue(
          maps["textCapitalization"], datas, "TextCapitalization", vars, props);
      final textInputAction = getValue(
          maps["textInputAction"], datas, "TextInputAction?", vars, props);
      final style = getValue(maps["style"], datas, "TextStyle?", vars, props);
      final strutStyle =
          getValue(maps["strutStyle"], datas, "StrutStyle?", vars, props);
      final textDirection =
          getValue(maps["textDirection"], datas, "TextDirection?", vars, props);
      final textAlign =
          getValue(maps["textAlign"], datas, "TextAlign", vars, props);
      final textAlignVertical = getValue(
          maps["textAlignVertical"], datas, "TextAlignVertical?", vars, props);
      final autofocus = getValue(maps["autofocus"], datas, "bool", vars, props);
      final readOnly = getValue(maps["readOnly"], datas, "bool", vars, props);
      final toolbarOptions = getValue(
          maps["toolbarOptions"], datas, "ToolbarOptions?", vars, props);
      final showCursor =
          getValue(maps["showCursor"], datas, "bool?", vars, props);
      final obscuringCharacter =
          getValue(maps["obscuringCharacter"], datas, "String", vars, props);
      final obscureText =
          getValue(maps["obscureText"], datas, "bool", vars, props);
      final autocorrect =
          getValue(maps["autocorrect"], datas, "bool", vars, props);
      final smartDashesType = getValue(
          maps["smartDashesType"], datas, "SmartDashesType?", vars, props);
      final smartQuotesType = getValue(
          maps["smartQuotesType"], datas, "SmartQuotesType?", vars, props);
      final enableSuggestions =
          getValue(maps["enableSuggestions"], datas, "bool", vars, props);
      final maxLines = getValue(maps["maxLines"], datas, "int?", vars, props);
      final minLines = getValue(maps["minLines"], datas, "int?", vars, props);
      final expands = getValue(maps["expands"], datas, "bool", vars, props);
      final maxLength = getValue(maps["maxLength"], datas, "int?", vars, props);
      final onChanged = getValue(
          maps["onChanged"], datas, "ValueChanged<String>?", vars, props);
      final onTap =
          getValue(maps["onTap"], datas, "GestureTapCallback?", vars, props);
      final onEditingComplete = getValue(
          maps["onEditingComplete"], datas, "VoidCallback?", vars, props);
      final onFieldSubmitted = getValue(maps["onFieldSubmitted"], datas,
          "ValueChanged<String>?", vars, props);
      final onSaved =
          getValue(maps["onSaved"], datas, "FormFieldSetter<T>?", vars, props);
      final validator = getValue(
          maps["validator"], datas, "FormFieldValidator<T>?", vars, props);
      final inputFormatters = getValue(maps["inputFormatters"], datas,
          "List<TextInputFormatter>?", vars, props);
      final enabled = getValue(maps["enabled"], datas, "bool?", vars, props);
      final cursorWidth =
          getValue(maps["cursorWidth"], datas, "double", vars, props);
      final cursorHeight =
          getValue(maps["cursorHeight"], datas, "double?", vars, props);
      final cursorColor =
          getValue(maps["cursorColor"], datas, "Color?", vars, props);
      final keyboardAppearance = getValue(
          maps["keyboardAppearance"], datas, "Brightness?", vars, props);
      final scrollPadding =
          getValue(maps["scrollPadding"], datas, "EdgeInsets", vars, props);
      final enableInteractiveSelection = getValue(
          maps["enableInteractiveSelection"], datas, "bool", vars, props);
      final selectionControls = getValue(maps["selectionControls"], datas,
          "TextSelectionControls?", vars, props);
      final scrollPhysics =
          getValue(maps["scrollPhysics"], datas, "ScrollPhysics?", vars, props);
      final autofillHints = getValue(
          maps["autofillHints"], datas, "Iterable<String>?", vars, props);
      final autovalidateMode = getValue(
          maps["autovalidateMode"], datas, "AutovalidateMode", vars, props);
      final placeholder =
          getValue(maps["placeholder"], datas, "String?", vars, props);
      final placeholderStyle =
          getValue(maps["placeholderStyle"], datas, "TextStyle?", vars, props);
      final contextMenuBuilder = getValue(maps["contextMenuBuilder"], datas,
          "EditableTextContextMenuBuilder?", vars, props);
      return CupertinoTextFormFieldRow(
          key: key,
          prefix: prefix,
          padding: padding,
          controller: controller,
          initialValue: initialValue,
          focusNode: focusNode,
          decoration: decoration,
          keyboardType: keyboardType,
          textCapitalization: textCapitalization ?? TextCapitalization.none,
          textInputAction: textInputAction,
          style: style,
          strutStyle: strutStyle,
          textDirection: textDirection,
          textAlign: textAlign ?? TextAlign.start,
          textAlignVertical: textAlignVertical,
          autofocus: autofocus ?? false,
          readOnly: readOnly ?? false,
          toolbarOptions: toolbarOptions,
          showCursor: showCursor,
          obscuringCharacter: obscuringCharacter ?? '•',
          obscureText: obscureText ?? false,
          autocorrect: autocorrect ?? true,
          smartDashesType: smartDashesType,
          smartQuotesType: smartQuotesType,
          enableSuggestions: enableSuggestions ?? true,
          maxLines: maxLines ?? 1,
          minLines: minLines,
          expands: expands ?? false,
          maxLength: maxLength,
          onChanged: onChanged,
          onTap: onTap,
          onEditingComplete: onEditingComplete,
          onFieldSubmitted: onFieldSubmitted,
          onSaved: onSaved,
          validator: validator,
          inputFormatters: inputFormatters != null
              ? List<TextInputFormatter>.from(inputFormatters)
              : null,
          enabled: enabled,
          cursorWidth: cursorWidth ?? 2.0,
          cursorHeight: cursorHeight,
          cursorColor: cursorColor,
          keyboardAppearance: keyboardAppearance,
          scrollPadding: scrollPadding ?? const EdgeInsets.all(20.0),
          enableInteractiveSelection: enableInteractiveSelection ?? true,
          selectionControls: selectionControls,
          scrollPhysics: scrollPhysics,
          autofillHints: autofillHints,
          autovalidateMode: autovalidateMode ?? AutovalidateMode.disabled,
          placeholder: placeholder,
          placeholderStyle: placeholderStyle ??
              const TextStyle(
                fontWeight: FontWeight.w400,
                color: CupertinoColors.placeholderText,
              ),
          contextMenuBuilder: contextMenuBuilder ?? _defaultContextMenuBuilder);
    },
    "CupertinoTextMagnifier": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final animationCurve =
          getValue(maps["animationCurve"], datas, "Curve", vars, props);
      final controller = getValue(
          maps["controller"], datas, "MagnifierController", vars, props);
      final dragResistance =
          getValue(maps["dragResistance"], datas, "double", vars, props);
      final hideBelowThreshold =
          getValue(maps["hideBelowThreshold"], datas, "double", vars, props);
      final horizontalScreenEdgePadding = getValue(
          maps["horizontalScreenEdgePadding"], datas, "double", vars, props);
      final magnifierInfo = getValue(maps["magnifierInfo"], datas,
          "ValueNotifier<MagnifierInfo>", vars, props);
      if (controller == null || magnifierInfo == null) {
        return null;
      }
      return CupertinoTextMagnifier(
          key: key,
          animationCurve: animationCurve ?? Curves.easeOut,
          controller: controller!,
          dragResistance: dragResistance ?? 10.0,
          hideBelowThreshold: hideBelowThreshold ?? 48.0,
          horizontalScreenEdgePadding: horizontalScreenEdgePadding ?? 10.0,
          magnifierInfo: magnifierInfo!);
    },
    "CupertinoTextSelectionToolbar": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final anchorAbove =
          getValue(maps["anchorAbove"], datas, "Offset", vars, props);
      final anchorBelow =
          getValue(maps["anchorBelow"], datas, "Offset", vars, props);
      final children =
          getValue(maps["children"], datas, "List<Widget>", vars, props);
      final toolbarBuilder = getValue(maps["toolbarBuilder"], datas,
          "CupertinoToolbarBuilder", vars, props);
      if (anchorAbove == null || anchorBelow == null || children == null) {
        return null;
      }
      if (toolbarBuilder != null) {
        return CupertinoTextSelectionToolbar(
            key: key,
            anchorAbove: anchorAbove!,
            anchorBelow: anchorBelow!,
            toolbarBuilder: toolbarBuilder,
            children: List<Widget>.from(children!));
      }
      return CupertinoTextSelectionToolbar(
          key: key,
          anchorAbove: anchorAbove!,
          anchorBelow: anchorBelow!,
          children: List<Widget>.from(children!));
    },
    "CupertinoTextSelectionToolbarButton": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final onPressed =
          getValue(maps["onPressed"], datas, "VoidCallback?", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (child == null) {
        return null;
      }
      return CupertinoTextSelectionToolbarButton(
          key: key, onPressed: onPressed, child: child!);
    },
    "CupertinoTextSelectionToolbarButton.text": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final onPressed =
          getValue(maps["onPressed"], datas, "VoidCallback?", vars, props);
      final text = getValue(maps["text"], datas, "String?", vars, props);
      if (text == null) {
        return null;
      }
      return CupertinoTextSelectionToolbarButton.text(
          key: key, onPressed: onPressed, text: text!);
    },
    "CupertinoTextSelectionToolbarButton.buttonItem": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final buttonItem = getValue(
          maps["buttonItem"], datas, "ContextMenuButtonItem", vars, props);
      if (buttonItem == null) {
        return null;
      }
      return CupertinoTextSelectionToolbarButton.buttonItem(
          key: key, buttonItem: buttonItem!);
    },
    "CupertinoTextThemeData": () {
      final primaryColor =
          getValue(maps["primaryColor"], datas, "Color", vars, props);
      final textStyle =
          getValue(maps["textStyle"], datas, "TextStyle?", vars, props);
      final actionTextStyle =
          getValue(maps["actionTextStyle"], datas, "TextStyle?", vars, props);
      final tabLabelTextStyle =
          getValue(maps["tabLabelTextStyle"], datas, "TextStyle?", vars, props);
      final navTitleTextStyle =
          getValue(maps["navTitleTextStyle"], datas, "TextStyle?", vars, props);
      final navLargeTitleTextStyle = getValue(
          maps["navLargeTitleTextStyle"], datas, "TextStyle?", vars, props);
      final navActionTextStyle = getValue(
          maps["navActionTextStyle"], datas, "TextStyle?", vars, props);
      final pickerTextStyle =
          getValue(maps["pickerTextStyle"], datas, "TextStyle?", vars, props);
      final dateTimePickerTextStyle = getValue(
          maps["dateTimePickerTextStyle"], datas, "TextStyle?", vars, props);
      return CupertinoTextThemeData(
          primaryColor: primaryColor ?? CupertinoColors.systemBlue,
          textStyle: textStyle,
          actionTextStyle: actionTextStyle,
          tabLabelTextStyle: tabLabelTextStyle,
          navTitleTextStyle: navTitleTextStyle,
          navLargeTitleTextStyle: navLargeTitleTextStyle,
          navActionTextStyle: navActionTextStyle,
          pickerTextStyle: pickerTextStyle,
          dateTimePickerTextStyle: dateTimePickerTextStyle);
    },
    "CupertinoTheme": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final data =
          getValue(maps["data"], datas, "CupertinoThemeData", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (data == null || child == null) {
        return null;
      }
      return CupertinoTheme(key: key, data: data!, child: child!);
    },
    "CupertinoThemeData": () {
      final brightness =
          getValue(maps["brightness"], datas, "Brightness?", vars, props);
      final primaryColor =
          getValue(maps["primaryColor"], datas, "Color?", vars, props);
      final primaryContrastingColor = getValue(
          maps["primaryContrastingColor"], datas, "Color?", vars, props);
      final textTheme = getValue(
          maps["textTheme"], datas, "CupertinoTextThemeData?", vars, props);
      final barBackgroundColor =
          getValue(maps["barBackgroundColor"], datas, "Color?", vars, props);
      final scaffoldBackgroundColor = getValue(
          maps["scaffoldBackgroundColor"], datas, "Color?", vars, props);
      final applyThemeToAll =
          getValue(maps["applyThemeToAll"], datas, "bool?", vars, props);
      return CupertinoThemeData(
          brightness: brightness,
          primaryColor: primaryColor,
          primaryContrastingColor: primaryContrastingColor,
          textTheme: textTheme,
          barBackgroundColor: barBackgroundColor,
          scaffoldBackgroundColor: scaffoldBackgroundColor,
          applyThemeToAll: applyThemeToAll);
    },
    "CupertinoThemeData.raw": () {
      final brightness = getValue(maps["0"], datas, "Brightness?", vars, props);
      final primaryColor = getValue(maps["1"], datas, "Color?", vars, props);
      final primaryContrastingColor =
          getValue(maps["2"], datas, "Color?", vars, props);
      final textTheme =
          getValue(maps["3"], datas, "CupertinoTextThemeData?", vars, props);
      final barBackgroundColor =
          getValue(maps["4"], datas, "Color?", vars, props);
      final scaffoldBackgroundColor =
          getValue(maps["5"], datas, "Color?", vars, props);
      final applyThemeToAll = getValue(maps["6"], datas, "bool?", vars, props);
      if (brightness == null ||
          primaryColor == null ||
          primaryContrastingColor == null ||
          textTheme == null ||
          barBackgroundColor == null ||
          scaffoldBackgroundColor == null ||
          applyThemeToAll == null) {
        return null;
      }
      return CupertinoThemeData.raw(
          brightness!,
          primaryColor!,
          primaryContrastingColor!,
          textTheme!,
          barBackgroundColor!,
          scaffoldBackgroundColor!,
          applyThemeToAll!);
    },
    "CupertinoThumbPainter": () {
      final color = getValue(maps["color"], datas, "Color", vars, props);
      final shadows =
          getValue(maps["shadows"], datas, "List<BoxShadow>", vars, props);
      if (shadows != null) {
        return CupertinoThumbPainter(
            color: color ?? CupertinoColors.white,
            shadows: List<BoxShadow>.from(shadows));
      }
      return CupertinoThumbPainter(color: color ?? CupertinoColors.white);
    },
    "CupertinoThumbPainter.switchThumb": () {
      final color = getValue(maps["color"], datas, "Color", vars, props);
      final shadows =
          getValue(maps["shadows"], datas, "List<BoxShadow>", vars, props);
      if (shadows != null) {
        return CupertinoThumbPainter.switchThumb(
            color: color ?? CupertinoColors.white,
            shadows: List<BoxShadow>.from(shadows));
      }
      return CupertinoThumbPainter.switchThumb(
          color: color ?? CupertinoColors.white);
    },
    "CupertinoTimerPicker": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final mode = getValue(
          maps["mode"], datas, "CupertinoTimerPickerMode", vars, props);
      final initialTimerDuration = getValue(
          maps["initialTimerDuration"], datas, "Duration", vars, props);
      final minuteInterval =
          getValue(maps["minuteInterval"], datas, "int", vars, props);
      final secondInterval =
          getValue(maps["secondInterval"], datas, "int", vars, props);
      final alignment =
          getValue(maps["alignment"], datas, "AlignmentGeometry", vars, props);
      final backgroundColor =
          getValue(maps["backgroundColor"], datas, "Color?", vars, props);
      final onTimerDurationChanged = getValue(maps["onTimerDurationChanged"],
          datas, "ValueChanged<Duration>", vars, props);
      if (onTimerDurationChanged == null) {
        return null;
      }
      return CupertinoTimerPicker(
          key: key,
          mode: mode ?? CupertinoTimerPickerMode.hms,
          initialTimerDuration: initialTimerDuration ?? Duration.zero,
          minuteInterval: minuteInterval ?? 1,
          secondInterval: secondInterval ?? 1,
          alignment: alignment ?? Alignment.center,
          backgroundColor: backgroundColor,
          onTimerDurationChanged: onTimerDurationChanged!);
    },
    "CupertinoUserInterfaceLevel": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final data = getValue(
          maps["data"], datas, "CupertinoUserInterfaceLevelData", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (data == null || child == null) {
        return null;
      }
      return CupertinoUserInterfaceLevel(key: key, data: data!, child: child!);
    },
    "Curve2DSample": () {
      final t = getValue(maps["0"], datas, "double", vars, props);
      final value = getValue(maps["1"], datas, "Offset", vars, props);
      if (t == null || value == null) {
        return null;
      }
      return Curve2DSample(t!, value!);
    },
    "CustomMultiChildLayout": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final delegate = getValue(
          maps["delegate"], datas, "MultiChildLayoutDelegate", vars, props);
      final children =
          getValue(maps["children"], datas, "List<Widget>", vars, props);
      if (delegate == null) {
        return null;
      }
      return CustomMultiChildLayout(
          key: key,
          delegate: delegate!,
          children: List<Widget>.from(children ?? const <Widget>[]));
    },
    "CustomPaint": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final painter =
          getValue(maps["painter"], datas, "CustomPainter?", vars, props);
      final foregroundPainter = getValue(
          maps["foregroundPainter"], datas, "CustomPainter?", vars, props);
      final size = getValue(maps["size"], datas, "Size", vars, props);
      final isComplex = getValue(maps["isComplex"], datas, "bool", vars, props);
      final willChange =
          getValue(maps["willChange"], datas, "bool", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      return CustomPaint(
          key: key,
          painter: painter,
          foregroundPainter: foregroundPainter,
          size: size ?? Size.zero,
          isComplex: isComplex ?? false,
          willChange: willChange ?? false,
          child: child);
    },
    "CustomScrollView": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final scrollDirection =
          getValue(maps["scrollDirection"], datas, "Axis", vars, props);
      final reverse = getValue(maps["reverse"], datas, "bool", vars, props);
      final controller =
          getValue(maps["controller"], datas, "ScrollController?", vars, props);
      final primary = getValue(maps["primary"], datas, "bool?", vars, props);
      final physics =
          getValue(maps["physics"], datas, "ScrollPhysics?", vars, props);
      final scrollBehavior = getValue(
          maps["scrollBehavior"], datas, "ScrollBehavior?", vars, props);
      final shrinkWrap =
          getValue(maps["shrinkWrap"], datas, "bool", vars, props);
      final center = getValue(maps["center"], datas, "Key?", vars, props);
      final anchor = getValue(maps["anchor"], datas, "double", vars, props);
      final cacheExtent =
          getValue(maps["cacheExtent"], datas, "double?", vars, props);
      final slivers =
          getValue(maps["slivers"], datas, "List<Widget>", vars, props);
      final semanticChildCount =
          getValue(maps["semanticChildCount"], datas, "int?", vars, props);
      final dragStartBehavior = getValue(
          maps["dragStartBehavior"], datas, "DragStartBehavior", vars, props);
      final keyboardDismissBehavior = getValue(maps["keyboardDismissBehavior"],
          datas, "ScrollViewKeyboardDismissBehavior", vars, props);
      final restorationId =
          getValue(maps["restorationId"], datas, "String?", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      return CustomScrollView(
          key: key,
          scrollDirection: scrollDirection ?? Axis.vertical,
          reverse: reverse ?? false,
          controller: controller,
          primary: primary,
          physics: physics,
          scrollBehavior: scrollBehavior,
          shrinkWrap: shrinkWrap ?? false,
          center: center,
          anchor: anchor ?? 0.0,
          cacheExtent: cacheExtent,
          slivers: List<Widget>.from(slivers ?? const <Widget>[]),
          semanticChildCount: semanticChildCount,
          dragStartBehavior: dragStartBehavior ?? DragStartBehavior.start,
          keyboardDismissBehavior: keyboardDismissBehavior ??
              ScrollViewKeyboardDismissBehavior.manual,
          restorationId: restorationId,
          clipBehavior: clipBehavior ?? Clip.hardEdge);
    },
    "CustomSemanticsAction": () {
      final label = getValue(maps["label"], datas, "String", vars, props);
      if (label == null) {
        return null;
      }
      return CustomSemanticsAction(label: label!);
    },
    "CustomSemanticsAction.overridingAction": () {
      final hint = getValue(maps["hint"], datas, "String", vars, props);
      final action =
          getValue(maps["action"], datas, "SemanticsAction", vars, props);
      if (hint == null || action == null) {
        return null;
      }
      return CustomSemanticsAction.overridingAction(
          hint: hint!, action: action!);
    },
    "CustomSingleChildLayout": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final delegate = getValue(
          maps["delegate"], datas, "SingleChildLayoutDelegate", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      if (delegate == null) {
        return null;
      }
      return CustomSingleChildLayout(
          key: key, delegate: delegate!, child: child);
    },
    "DataCell": () {
      final child = getValue(maps["0"], datas, "Widget", vars, props);
      final placeholder =
          getValue(maps["placeholder"], datas, "bool", vars, props);
      final showEditIcon =
          getValue(maps["showEditIcon"], datas, "bool", vars, props);
      final onTap =
          getValue(maps["onTap"], datas, "GestureTapCallback?", vars, props);
      final onLongPress = getValue(
          maps["onLongPress"], datas, "GestureLongPressCallback?", vars, props);
      final onTapDown = getValue(
          maps["onTapDown"], datas, "GestureTapDownCallback?", vars, props);
      final onDoubleTap = getValue(
          maps["onDoubleTap"], datas, "GestureTapCallback?", vars, props);
      final onTapCancel = getValue(
          maps["onTapCancel"], datas, "GestureTapCancelCallback?", vars, props);
      if (child == null) {
        return null;
      }
      return DataCell(child!,
          placeholder: placeholder ?? false,
          showEditIcon: showEditIcon ?? false,
          onTap: onTap,
          onLongPress: onLongPress,
          onTapDown: onTapDown,
          onDoubleTap: onDoubleTap,
          onTapCancel: onTapCancel);
    },
    "DataColumn": () {
      final label = getValue(maps["label"], datas, "Widget", vars, props);
      final tooltip = getValue(maps["tooltip"], datas, "String?", vars, props);
      final numeric = getValue(maps["numeric"], datas, "bool", vars, props);
      final onSort = getValue(
          maps["onSort"], datas, "DataColumnSortCallback?", vars, props);
      final mouseCursor = getValue(maps["mouseCursor"], datas,
          "MaterialStateProperty<MouseCursor?>?", vars, props);
      if (label == null) {
        return null;
      }
      return DataColumn(
          label: label!,
          tooltip: tooltip,
          numeric: numeric ?? false,
          onSort: onSort,
          mouseCursor: mouseCursor);
    },
    "DataRow": () {
      final key = getValue(maps["key"], datas, "LocalKey?", vars, props);
      final selected = getValue(maps["selected"], datas, "bool", vars, props);
      final onSelectChanged = getValue(
          maps["onSelectChanged"], datas, "ValueChanged<bool?>?", vars, props);
      final onLongPress = getValue(
          maps["onLongPress"], datas, "GestureLongPressCallback?", vars, props);
      final color = getValue(
          maps["color"], datas, "MaterialStateProperty<Color?>?", vars, props);
      final mouseCursor = getValue(maps["mouseCursor"], datas,
          "MaterialStateProperty<MouseCursor?>?", vars, props);
      final cells =
          getValue(maps["cells"], datas, "List<DataCell>", vars, props);
      if (cells == null) {
        return null;
      }
      return DataRow(
          key: key,
          selected: selected ?? false,
          onSelectChanged: onSelectChanged,
          onLongPress: onLongPress,
          color: color,
          mouseCursor: mouseCursor,
          cells: List<DataCell>.from(cells!));
    },
    "DataRow.byIndex": () {
      final index = getValue(maps["index"], datas, "int?", vars, props);
      final selected = getValue(maps["selected"], datas, "bool", vars, props);
      final onSelectChanged = getValue(
          maps["onSelectChanged"], datas, "ValueChanged<bool?>?", vars, props);
      final onLongPress = getValue(
          maps["onLongPress"], datas, "GestureLongPressCallback?", vars, props);
      final color = getValue(
          maps["color"], datas, "MaterialStateProperty<Color?>?", vars, props);
      final mouseCursor = getValue(maps["mouseCursor"], datas,
          "MaterialStateProperty<MouseCursor?>?", vars, props);
      final cells =
          getValue(maps["cells"], datas, "List<DataCell>", vars, props);
      if (cells == null) {
        return null;
      }
      return DataRow.byIndex(
          index: index,
          selected: selected ?? false,
          onSelectChanged: onSelectChanged,
          onLongPress: onLongPress,
          color: color,
          mouseCursor: mouseCursor,
          cells: List<DataCell>.from(cells!));
    },
    "DataTable": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final columns = getValue(maps["columns"], datas, "", vars, props);
      final sortColumnIndex =
          getValue(maps["sortColumnIndex"], datas, "", vars, props);
      final sortAscending =
          getValue(maps["sortAscending"], datas, "", vars, props);
      final onSelectAll = getValue(maps["onSelectAll"], datas, "", vars, props);
      final decoration = getValue(maps["decoration"], datas, "", vars, props);
      final dataRowColor =
          getValue(maps["dataRowColor"], datas, "", vars, props);
      final dataRowHeight =
          getValue(maps["dataRowHeight"], datas, "double?", vars, props);
      final dataRowMinHeight =
          getValue(maps["dataRowMinHeight"], datas, "double?", vars, props);
      final dataRowMaxHeight =
          getValue(maps["dataRowMaxHeight"], datas, "double?", vars, props);
      final dataTextStyle =
          getValue(maps["dataTextStyle"], datas, "", vars, props);
      final headingRowColor =
          getValue(maps["headingRowColor"], datas, "", vars, props);
      final headingRowHeight =
          getValue(maps["headingRowHeight"], datas, "", vars, props);
      final headingTextStyle =
          getValue(maps["headingTextStyle"], datas, "", vars, props);
      final horizontalMargin =
          getValue(maps["horizontalMargin"], datas, "", vars, props);
      final columnSpacing =
          getValue(maps["columnSpacing"], datas, "", vars, props);
      final showCheckboxColumn =
          getValue(maps["showCheckboxColumn"], datas, "", vars, props);
      final showBottomBorder =
          getValue(maps["showBottomBorder"], datas, "", vars, props);
      final dividerThickness =
          getValue(maps["dividerThickness"], datas, "", vars, props);
      final rows = getValue(maps["rows"], datas, "", vars, props);
      final checkboxHorizontalMargin =
          getValue(maps["checkboxHorizontalMargin"], datas, "", vars, props);
      final border = getValue(maps["border"], datas, "", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "", vars, props);
      if (columns == null || rows == null) {
        return null;
      }
      return DataTable(
          key: key,
          columns: columns!,
          sortColumnIndex: sortColumnIndex,
          sortAscending: sortAscending ?? true,
          onSelectAll: onSelectAll,
          decoration: decoration,
          dataRowColor: dataRowColor,
          dataRowHeight: dataRowHeight,
          dataRowMinHeight: dataRowMinHeight,
          dataRowMaxHeight: dataRowMaxHeight,
          dataTextStyle: dataTextStyle,
          headingRowColor: headingRowColor,
          headingRowHeight: headingRowHeight,
          headingTextStyle: headingTextStyle,
          horizontalMargin: horizontalMargin,
          columnSpacing: columnSpacing,
          showCheckboxColumn: showCheckboxColumn ?? true,
          showBottomBorder: showBottomBorder ?? false,
          dividerThickness: dividerThickness,
          rows: rows!,
          checkboxHorizontalMargin: checkboxHorizontalMargin,
          border: border,
          clipBehavior: clipBehavior ?? Clip.none);
    },
    "DataTableTheme": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final data =
          getValue(maps["data"], datas, "DataTableThemeData", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (data == null || child == null) {
        return null;
      }
      return DataTableTheme(key: key, data: data!, child: child!);
    },
    "DataTableThemeData": () {
      final decoration = getValue(maps["decoration"], datas, "", vars, props);
      final dataRowColor =
          getValue(maps["dataRowColor"], datas, "", vars, props);
      final dataRowHeight =
          getValue(maps["dataRowHeight"], datas, "double?", vars, props);
      final dataRowMinHeight =
          getValue(maps["dataRowMinHeight"], datas, "double?", vars, props);
      final dataRowMaxHeight =
          getValue(maps["dataRowMaxHeight"], datas, "double?", vars, props);
      final dataTextStyle =
          getValue(maps["dataTextStyle"], datas, "", vars, props);
      final headingRowColor =
          getValue(maps["headingRowColor"], datas, "", vars, props);
      final headingRowHeight =
          getValue(maps["headingRowHeight"], datas, "", vars, props);
      final headingTextStyle =
          getValue(maps["headingTextStyle"], datas, "", vars, props);
      final horizontalMargin =
          getValue(maps["horizontalMargin"], datas, "", vars, props);
      final columnSpacing =
          getValue(maps["columnSpacing"], datas, "", vars, props);
      final dividerThickness =
          getValue(maps["dividerThickness"], datas, "", vars, props);
      final checkboxHorizontalMargin =
          getValue(maps["checkboxHorizontalMargin"], datas, "", vars, props);
      final headingCellCursor =
          getValue(maps["headingCellCursor"], datas, "", vars, props);
      final dataRowCursor =
          getValue(maps["dataRowCursor"], datas, "", vars, props);
      return DataTableThemeData(
          decoration: decoration,
          dataRowColor: dataRowColor,
          dataRowHeight: dataRowHeight,
          dataRowMinHeight: dataRowMinHeight,
          dataRowMaxHeight: dataRowMaxHeight,
          dataTextStyle: dataTextStyle,
          headingRowColor: headingRowColor,
          headingRowHeight: headingRowHeight,
          headingTextStyle: headingTextStyle,
          horizontalMargin: horizontalMargin,
          columnSpacing: columnSpacing,
          dividerThickness: dividerThickness,
          checkboxHorizontalMargin: checkboxHorizontalMargin,
          headingCellCursor: headingCellCursor,
          dataRowCursor: dataRowCursor);
    },
    "DatePickerDialog": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final initialDate =
          getValue(maps["initialDate"], datas, "DateTime", vars, props);
      final firstDate =
          getValue(maps["firstDate"], datas, "DateTime", vars, props);
      final lastDate =
          getValue(maps["lastDate"], datas, "DateTime", vars, props);
      final currentDate =
          getValue(maps["currentDate"], datas, "DateTime?", vars, props);
      final initialEntryMode = getValue(
          maps["initialEntryMode"], datas, "DatePickerEntryMode", vars, props);
      final selectableDayPredicate = getValue(maps["selectableDayPredicate"],
          datas, "SelectableDayPredicate?", vars, props);
      final cancelText =
          getValue(maps["cancelText"], datas, "String?", vars, props);
      final confirmText =
          getValue(maps["confirmText"], datas, "String?", vars, props);
      final helpText =
          getValue(maps["helpText"], datas, "String?", vars, props);
      final initialCalendarMode = getValue(
          maps["initialCalendarMode"], datas, "DatePickerMode", vars, props);
      final errorFormatText =
          getValue(maps["errorFormatText"], datas, "String?", vars, props);
      final errorInvalidText =
          getValue(maps["errorInvalidText"], datas, "String?", vars, props);
      final fieldHintText =
          getValue(maps["fieldHintText"], datas, "String?", vars, props);
      final fieldLabelText =
          getValue(maps["fieldLabelText"], datas, "String?", vars, props);
      final keyboardType =
          getValue(maps["keyboardType"], datas, "TextInputType?", vars, props);
      final restorationId =
          getValue(maps["restorationId"], datas, "String?", vars, props);
      final onDatePickerModeChange = getValue(maps["onDatePickerModeChange"],
          datas, "ValueChanged<DatePickerEntryMode>?", vars, props);
      if (initialDate == null || firstDate == null || lastDate == null) {
        return null;
      }
      return DatePickerDialog(
          key: key,
          initialDate: initialDate!,
          firstDate: firstDate!,
          lastDate: lastDate!,
          currentDate: currentDate,
          initialEntryMode: initialEntryMode ?? DatePickerEntryMode.calendar,
          selectableDayPredicate: selectableDayPredicate,
          cancelText: cancelText,
          confirmText: confirmText,
          helpText: helpText,
          initialCalendarMode: initialCalendarMode ?? DatePickerMode.day,
          errorFormatText: errorFormatText,
          errorInvalidText: errorInvalidText,
          fieldHintText: fieldHintText,
          fieldLabelText: fieldLabelText,
          keyboardType: keyboardType,
          restorationId: restorationId,
          onDatePickerModeChange: onDatePickerModeChange);
    },
    "DatePickerTheme": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final data =
          getValue(maps["data"], datas, "DatePickerThemeData", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (data == null || child == null) {
        return null;
      }
      return DatePickerTheme(key: key, data: data!, child: child!);
    },
    "DatePickerThemeData": () {
      final backgroundColor =
          getValue(maps["backgroundColor"], datas, "Color?", vars, props);
      final elevation =
          getValue(maps["elevation"], datas, "double?", vars, props);
      final shadowColor =
          getValue(maps["shadowColor"], datas, "Color?", vars, props);
      final surfaceTintColor =
          getValue(maps["surfaceTintColor"], datas, "Color?", vars, props);
      final shape = getValue(maps["shape"], datas, "ShapeBorder?", vars, props);
      final headerBackgroundColor =
          getValue(maps["headerBackgroundColor"], datas, "Color?", vars, props);
      final headerForegroundColor =
          getValue(maps["headerForegroundColor"], datas, "Color?", vars, props);
      final headerHeadlineStyle = getValue(
          maps["headerHeadlineStyle"], datas, "TextStyle?", vars, props);
      final headerHelpStyle =
          getValue(maps["headerHelpStyle"], datas, "TextStyle?", vars, props);
      final weekdayStyle =
          getValue(maps["weekdayStyle"], datas, "TextStyle?", vars, props);
      final dayStyle =
          getValue(maps["dayStyle"], datas, "TextStyle?", vars, props);
      final dayForegroundColor = getValue(maps["dayForegroundColor"], datas,
          "MaterialStateProperty<Color?>?", vars, props);
      final dayBackgroundColor = getValue(maps["dayBackgroundColor"], datas,
          "MaterialStateProperty<Color?>?", vars, props);
      final dayOverlayColor = getValue(maps["dayOverlayColor"], datas,
          "MaterialStateProperty<Color?>?", vars, props);
      final todayForegroundColor = getValue(maps["todayForegroundColor"], datas,
          "MaterialStateProperty<Color?>?", vars, props);
      final todayBackgroundColor = getValue(maps["todayBackgroundColor"], datas,
          "MaterialStateProperty<Color?>?", vars, props);
      final todayBorder =
          getValue(maps["todayBorder"], datas, "BorderSide?", vars, props);
      final yearStyle =
          getValue(maps["yearStyle"], datas, "TextStyle?", vars, props);
      final yearForegroundColor = getValue(maps["yearForegroundColor"], datas,
          "MaterialStateProperty<Color?>?", vars, props);
      final yearBackgroundColor = getValue(maps["yearBackgroundColor"], datas,
          "MaterialStateProperty<Color?>?", vars, props);
      final yearOverlayColor = getValue(maps["yearOverlayColor"], datas,
          "MaterialStateProperty<Color?>?", vars, props);
      final rangePickerBackgroundColor = getValue(
          maps["rangePickerBackgroundColor"], datas, "Color?", vars, props);
      final rangePickerElevation =
          getValue(maps["rangePickerElevation"], datas, "double?", vars, props);
      final rangePickerShadowColor = getValue(
          maps["rangePickerShadowColor"], datas, "Color?", vars, props);
      final rangePickerSurfaceTintColor = getValue(
          maps["rangePickerSurfaceTintColor"], datas, "Color?", vars, props);
      final rangePickerShape = getValue(
          maps["rangePickerShape"], datas, "ShapeBorder?", vars, props);
      final rangePickerHeaderBackgroundColor = getValue(
          maps["rangePickerHeaderBackgroundColor"],
          datas,
          "Color?",
          vars,
          props);
      final rangePickerHeaderForegroundColor = getValue(
          maps["rangePickerHeaderForegroundColor"],
          datas,
          "Color?",
          vars,
          props);
      final rangePickerHeaderHeadlineStyle = getValue(
          maps["rangePickerHeaderHeadlineStyle"],
          datas,
          "TextStyle?",
          vars,
          props);
      final rangePickerHeaderHelpStyle = getValue(
          maps["rangePickerHeaderHelpStyle"], datas, "TextStyle?", vars, props);
      final rangeSelectionBackgroundColor = getValue(
          maps["rangeSelectionBackgroundColor"], datas, "Color?", vars, props);
      final rangeSelectionOverlayColor = getValue(
          maps["rangeSelectionOverlayColor"],
          datas,
          "MaterialStateProperty<Color?>?",
          vars,
          props);
      return DatePickerThemeData(
          backgroundColor: backgroundColor,
          elevation: elevation,
          shadowColor: shadowColor,
          surfaceTintColor: surfaceTintColor,
          shape: shape,
          headerBackgroundColor: headerBackgroundColor,
          headerForegroundColor: headerForegroundColor,
          headerHeadlineStyle: headerHeadlineStyle,
          headerHelpStyle: headerHelpStyle,
          weekdayStyle: weekdayStyle,
          dayStyle: dayStyle,
          dayForegroundColor: dayForegroundColor,
          dayBackgroundColor: dayBackgroundColor,
          dayOverlayColor: dayOverlayColor,
          todayForegroundColor: todayForegroundColor,
          todayBackgroundColor: todayBackgroundColor,
          todayBorder: todayBorder,
          yearStyle: yearStyle,
          yearForegroundColor: yearForegroundColor,
          yearBackgroundColor: yearBackgroundColor,
          yearOverlayColor: yearOverlayColor,
          rangePickerBackgroundColor: rangePickerBackgroundColor,
          rangePickerElevation: rangePickerElevation,
          rangePickerShadowColor: rangePickerShadowColor,
          rangePickerSurfaceTintColor: rangePickerSurfaceTintColor,
          rangePickerShape: rangePickerShape,
          rangePickerHeaderBackgroundColor: rangePickerHeaderBackgroundColor,
          rangePickerHeaderForegroundColor: rangePickerHeaderForegroundColor,
          rangePickerHeaderHeadlineStyle: rangePickerHeaderHeadlineStyle,
          rangePickerHeaderHelpStyle: rangePickerHeaderHelpStyle,
          rangeSelectionBackgroundColor: rangeSelectionBackgroundColor,
          rangeSelectionOverlayColor: rangeSelectionOverlayColor);
    },
    "DateRangePickerDialog": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final initialDateRange = getValue(
          maps["initialDateRange"], datas, "DateTimeRange?", vars, props);
      final firstDate =
          getValue(maps["firstDate"], datas, "DateTime", vars, props);
      final lastDate =
          getValue(maps["lastDate"], datas, "DateTime", vars, props);
      final currentDate =
          getValue(maps["currentDate"], datas, "DateTime?", vars, props);
      final initialEntryMode = getValue(
          maps["initialEntryMode"], datas, "DatePickerEntryMode", vars, props);
      final helpText =
          getValue(maps["helpText"], datas, "String?", vars, props);
      final cancelText =
          getValue(maps["cancelText"], datas, "String?", vars, props);
      final confirmText =
          getValue(maps["confirmText"], datas, "String?", vars, props);
      final saveText =
          getValue(maps["saveText"], datas, "String?", vars, props);
      final errorInvalidRangeText = getValue(
          maps["errorInvalidRangeText"], datas, "String?", vars, props);
      final errorFormatText =
          getValue(maps["errorFormatText"], datas, "String?", vars, props);
      final errorInvalidText =
          getValue(maps["errorInvalidText"], datas, "String?", vars, props);
      final fieldStartHintText =
          getValue(maps["fieldStartHintText"], datas, "String?", vars, props);
      final fieldEndHintText =
          getValue(maps["fieldEndHintText"], datas, "String?", vars, props);
      final fieldStartLabelText =
          getValue(maps["fieldStartLabelText"], datas, "String?", vars, props);
      final fieldEndLabelText =
          getValue(maps["fieldEndLabelText"], datas, "String?", vars, props);
      final keyboardType =
          getValue(maps["keyboardType"], datas, "TextInputType", vars, props);
      final restorationId =
          getValue(maps["restorationId"], datas, "String?", vars, props);
      if (firstDate == null || lastDate == null) {
        return null;
      }
      return DateRangePickerDialog(
          key: key,
          initialDateRange: initialDateRange,
          firstDate: firstDate!,
          lastDate: lastDate!,
          currentDate: currentDate,
          initialEntryMode: initialEntryMode ?? DatePickerEntryMode.calendar,
          helpText: helpText,
          cancelText: cancelText,
          confirmText: confirmText,
          saveText: saveText,
          errorInvalidRangeText: errorInvalidRangeText,
          errorFormatText: errorFormatText,
          errorInvalidText: errorInvalidText,
          fieldStartHintText: fieldStartHintText,
          fieldEndHintText: fieldEndHintText,
          fieldStartLabelText: fieldStartLabelText,
          fieldEndLabelText: fieldEndLabelText,
          keyboardType: keyboardType ?? TextInputType.datetime,
          restorationId: restorationId);
    },
    "DateTimeRange": () {
      final start = getValue(maps["start"], datas, "DateTime", vars, props);
      final end = getValue(maps["end"], datas, "DateTime", vars, props);
      if (start == null || end == null) {
        return null;
      }
      return DateTimeRange(start: start!, end: end!);
      // "DebugReassembleConfig": () {
      //   final widgetName =
      //       getValue(maps["widgetName"], datas, "String?", vars, props);
      //   return DebugReassembleConfig(widgetName: widgetName);
    },
    "DecoratedBox": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final decoration =
          getValue(maps["decoration"], datas, "Decoration", vars, props);
      final position =
          getValue(maps["position"], datas, "DecorationPosition", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      if (decoration == null) {
        return null;
      }
      return DecoratedBox(
          key: key,
          decoration: decoration!,
          position: position ?? DecorationPosition.background,
          child: child);
    },
    "DecoratedBoxTransition": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final decoration = getValue(
          maps["decoration"], datas, "Animation<Decoration>", vars, props);
      final position =
          getValue(maps["position"], datas, "DecorationPosition", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (decoration == null || child == null) {
        return null;
      }
      return DecoratedBoxTransition(
          key: key,
          decoration: decoration!,
          position: position ?? DecorationPosition.background,
          child: child!);
    },
    "DecorationImage": () {
      final image =
          getValue(maps["image"], datas, "ImageProvider", vars, props);
      final onError =
          getValue(maps["onError"], datas, "ImageErrorListener?", vars, props);
      final colorFilter =
          getValue(maps["colorFilter"], datas, "ColorFilter?", vars, props);
      final fit = getValue(maps["fit"], datas, "BoxFit?", vars, props);
      final alignment =
          getValue(maps["alignment"], datas, "AlignmentGeometry", vars, props);
      final centerSlice =
          getValue(maps["centerSlice"], datas, "Rect?", vars, props);
      final repeat =
          getValue(maps["repeat"], datas, "ImageRepeat", vars, props);
      final matchTextDirection =
          getValue(maps["matchTextDirection"], datas, "bool", vars, props);
      final scale = getValue(maps["scale"], datas, "double", vars, props);
      final opacity = getValue(maps["opacity"], datas, "double", vars, props);
      final filterQuality =
          getValue(maps["filterQuality"], datas, "FilterQuality", vars, props);
      final invertColors =
          getValue(maps["invertColors"], datas, "bool", vars, props);
      final isAntiAlias =
          getValue(maps["isAntiAlias"], datas, "bool", vars, props);
      if (image == null) {
        return null;
      }
      return DecorationImage(
          image: image!,
          onError: onError,
          colorFilter: colorFilter,
          fit: fit,
          alignment: alignment ?? Alignment.center,
          centerSlice: centerSlice,
          repeat: repeat ?? ImageRepeat.noRepeat,
          matchTextDirection: matchTextDirection ?? false,
          scale: scale ?? 1.0,
          opacity: opacity ?? 1.0,
          filterQuality: filterQuality ?? FilterQuality.low,
          invertColors: invertColors ?? false,
          isAntiAlias: isAntiAlias ?? false);
    },
    "DecorationTween": () {
      final begin = getValue(maps["begin"], datas, "T?", vars, props);
      final end = getValue(maps["end"], datas, "T?", vars, props);
      return DecorationTween(begin: begin, end: end);
    },
    "DefaultAssetBundle": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final bundle =
          getValue(maps["bundle"], datas, "AssetBundle", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (bundle == null || child == null) {
        return null;
      }
      return DefaultAssetBundle(key: key, bundle: bundle!, child: child!);
    },
    "DefaultCupertinoLocalizations": () {
      return const DefaultCupertinoLocalizations();
    },
    "DefaultMaterialLocalizations": () {
      return const DefaultMaterialLocalizations();
    },
    "DefaultPlatformMenuDelegate": () {
      final channel =
          getValue(maps["channel"], datas, "MethodChannel?", vars, props);
      return DefaultPlatformMenuDelegate(channel: channel);
    },
    "DefaultSelectionStyle": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final cursorColor =
          getValue(maps["cursorColor"], datas, "Color?", vars, props);
      final selectionColor =
          getValue(maps["selectionColor"], datas, "Color?", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (child == null) {
        return null;
      }
      return DefaultSelectionStyle(
          key: key,
          cursorColor: cursorColor,
          selectionColor: selectionColor,
          child: child!);
    },
    "DefaultSelectionStyle.fallback": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      return DefaultSelectionStyle.fallback(key: key);
    },
    "DefaultSpellCheckService": () {
      return DefaultSpellCheckService();
    },
    "DefaultTabController": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final length = getValue(maps["length"], datas, "int", vars, props);
      final initialIndex =
          getValue(maps["initialIndex"], datas, "int", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      final animationDuration =
          getValue(maps["animationDuration"], datas, "Duration?", vars, props);
      if (length == null || child == null) {
        return null;
      }
      return DefaultTabController(
          key: key,
          length: length!,
          initialIndex: initialIndex ?? 0,
          child: child!,
          animationDuration: animationDuration);
    },
    "DefaultTextEditingShortcuts": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (child == null) {
        return null;
      }
      return DefaultTextEditingShortcuts(key: key, child: child!);
    },
    "DefaultTextHeightBehavior": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final textHeightBehavior = getValue(
          maps["textHeightBehavior"], datas, "TextHeightBehavior", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (textHeightBehavior == null || child == null) {
        return null;
      }
      return DefaultTextHeightBehavior(
          key: key, textHeightBehavior: textHeightBehavior!, child: child!);
    },
    "DefaultTextStyle": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final style = getValue(maps["style"], datas, "TextStyle", vars, props);
      final textAlign =
          getValue(maps["textAlign"], datas, "TextAlign?", vars, props);
      final softWrap = getValue(maps["softWrap"], datas, "bool", vars, props);
      final overflow =
          getValue(maps["overflow"], datas, "TextOverflow", vars, props);
      final maxLines = getValue(maps["maxLines"], datas, "int?", vars, props);
      final textWidthBasis = getValue(
          maps["textWidthBasis"], datas, "TextWidthBasis", vars, props);
      final textHeightBehavior = getValue(maps["textHeightBehavior"], datas,
          "TextHeightBehavior?", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (style == null || child == null) {
        return null;
      }
      return DefaultTextStyle(
          key: key,
          style: style!,
          textAlign: textAlign,
          softWrap: softWrap ?? true,
          overflow: overflow ?? TextOverflow.clip,
          maxLines: maxLines,
          textWidthBasis: textWidthBasis ?? TextWidthBasis.parent,
          textHeightBehavior: textHeightBehavior,
          child: child!);
    },
    "DefaultTextStyle.fallback": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      return DefaultTextStyle.fallback(key: key);
    },
    "DefaultTextStyleTransition": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final style =
          getValue(maps["style"], datas, "Animation<TextStyle>", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      final textAlign =
          getValue(maps["textAlign"], datas, "TextAlign?", vars, props);
      final softWrap = getValue(maps["softWrap"], datas, "bool", vars, props);
      final overflow =
          getValue(maps["overflow"], datas, "TextOverflow", vars, props);
      final maxLines = getValue(maps["maxLines"], datas, "int?", vars, props);
      if (style == null || child == null) {
        return null;
      }
      return DefaultTextStyleTransition(
          key: key,
          style: style!,
          child: child!,
          textAlign: textAlign,
          softWrap: softWrap ?? true,
          overflow: overflow ?? TextOverflow.clip,
          maxLines: maxLines);
    },
    "DefaultTransitionDelegate": () {
      return const DefaultTransitionDelegate();
    },
    "DefaultWidgetsLocalizations": () {
      return const DefaultWidgetsLocalizations();
    },
    "DelayedMultiDragGestureRecognizer": () {
      final delay = getValue(maps["delay"], datas, "Duration", vars, props);
      final debugOwner =
          getValue(maps["debugOwner"], datas, "Object?", vars, props);
      final supportedDevices = getValue(maps["supportedDevices"], datas,
          "Set<PointerDeviceKind>?", vars, props);
      final allowedButtonsFilter = getValue(maps["allowedButtonsFilter"], datas,
          "AllowedButtonsFilter?", vars, props);
      return DelayedMultiDragGestureRecognizer(
          delay: delay ?? kLongPressTimeout,
          debugOwner: debugOwner,
          supportedDevices: supportedDevices
              ? Set<PointerDeviceKind>.from(supportedDevices)
              : null,
          allowedButtonsFilter: allowedButtonsFilter);
    },
    "DeleteCharacterIntent": () {
      final forward = getValue(maps["forward"], datas, "bool", vars, props);
      if (forward == null) {
        return null;
      }
      return DeleteCharacterIntent(forward: forward!);
    },
    "DeleteToLineBreakIntent": () {
      final forward = getValue(maps["forward"], datas, "bool", vars, props);
      if (forward == null) {
        return null;
      }
      return DeleteToLineBreakIntent(forward: forward!);
    },
    "DeleteToNextWordBoundaryIntent": () {
      final forward = getValue(maps["forward"], datas, "bool", vars, props);
      if (forward == null) {
        return null;
      }
      return DeleteToNextWordBoundaryIntent(forward: forward!);
    },
    "Deprecated": () {
      final message = getValue(maps["0"], datas, "", vars, props);
      if (message == null) {
        return null;
      }
      return Deprecated(message!);
    },
    "DesktopTextSelectionToolbar": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final anchor = getValue(maps["anchor"], datas, "Offset", vars, props);
      final children =
          getValue(maps["children"], datas, "List<Widget>", vars, props);
      if (anchor == null || children == null) {
        return null;
      }
      return DesktopTextSelectionToolbar(
          key: key, anchor: anchor!, children: List<Widget>.from(children!));
    },
    "DesktopTextSelectionToolbarButton": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final onPressed =
          getValue(maps["onPressed"], datas, "VoidCallback", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (onPressed == null || child == null) {
        return null;
      }
      return DesktopTextSelectionToolbarButton(
          key: key, onPressed: onPressed!, child: child!);
    },
    "DesktopTextSelectionToolbarButton.text": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final context =
          getValue(maps["context"], datas, "BuildContext", vars, props);
      final onPressed =
          getValue(maps["onPressed"], datas, "VoidCallback", vars, props);
      final text = getValue(maps["text"], datas, "String", vars, props);
      if (context == null || onPressed == null || text == null) {
        return null;
      }
      return DesktopTextSelectionToolbarButton.text(
          key: key, context: context!, onPressed: onPressed!, text: text!);
    },
    "DesktopTextSelectionToolbarLayoutDelegate": () {
      final anchor = getValue(maps["anchor"], datas, "Offset", vars, props);
      if (anchor == null) {
        return null;
      }
      return DesktopTextSelectionToolbarLayoutDelegate(anchor: anchor!);
    },
    "DevToolsDeepLinkProperty": () {
      final description = getValue(maps["0"], datas, "String", vars, props);
      final url = getValue(maps["1"], datas, "String", vars, props);
      if (description == null || url == null) {
        return null;
      }
      return DevToolsDeepLinkProperty(description!, url!);
    },
    "DeviceGestureSettings": () {
      final touchSlop =
          getValue(maps["touchSlop"], datas, "double?", vars, props);
      return DeviceGestureSettings(touchSlop: touchSlop);
    },
    "DeviceGestureSettings.fromView": () {
      final view = getValue(maps["0"], datas, "FlutterView", vars, props);
      if (view == null) {
        return null;
      }
      return DeviceGestureSettings.fromView(view!);
    },
    "DiagnosticPropertiesBuilder": () {
      return DiagnosticPropertiesBuilder();
    },
    "DiagnosticPropertiesBuilder.fromProperties": () {
      final properties =
          getValue(maps["0"], datas, "List<DiagnosticsNode>", vars, props);
      if (properties == null) {
        return null;
      }
      return DiagnosticPropertiesBuilder.fromProperties(
          List<DiagnosticsNode>.from(properties!));
    },
    "DiagnosticableNode": () {
      final name = getValue(maps["name"], datas, "", vars, props);
      final value = getValue(maps["value"], datas, "T", vars, props);
      final style = getValue(maps["style"], datas, "", vars, props);
      if (value == null || style == null) {
        return null;
      }
      return DiagnosticableNode<D>(name: name, value: value!, style: style!);
    },
    "DiagnosticableTreeNode": () {
      final name = getValue(maps["name"], datas, "", vars, props);
      final value = getValue(maps["value"], datas, "T", vars, props);
      final style = getValue(maps["style"], datas, "", vars, props);
      if (value == null || style == null) {
        return null;
      }
      return DiagnosticableTreeNode(name: name, value: value!, style: style!);
    },
    "DiagnosticsBlock": () {
      final name = getValue(maps["name"], datas, "", vars, props);
      final style =
          getValue(maps["style"], datas, "DiagnosticsTreeStyle", vars, props);
      final showName = getValue(maps["showName"], datas, "bool", vars, props);
      final showSeparator =
          getValue(maps["showSeparator"], datas, "", vars, props);
      final linePrefix = getValue(maps["linePrefix"], datas, "", vars, props);
      final value = getValue(maps["value"], datas, "Object?", vars, props);
      final description =
          getValue(maps["description"], datas, "String?", vars, props);
      final level =
          getValue(maps["level"], datas, "DiagnosticLevel", vars, props);
      final allowTruncate =
          getValue(maps["allowTruncate"], datas, "bool", vars, props);
      final children = getValue(
          maps["children"], datas, "List<DiagnosticsNode>", vars, props);
      final properties = getValue(
          maps["properties"], datas, "List<DiagnosticsNode>", vars, props);
      return DiagnosticsBlock(
          name: name,
          style: style ?? DiagnosticsTreeStyle.whitespace,
          showName: showName ?? true,
          showSeparator: showSeparator,
          linePrefix: linePrefix,
          value: value,
          description: description,
          level: level ?? DiagnosticLevel.info,
          allowTruncate: allowTruncate ?? false,
          children:
              List<DiagnosticsNode>.from(children ?? const <DiagnosticsNode>[]),
          properties: List<DiagnosticsNode>.from(
              properties ?? const <DiagnosticsNode>[]));
    },
    "DiagnosticsDebugCreator": () {
      final value = getValue(maps["0"], datas, "Object", vars, props);
      if (value == null) {
        return null;
      }
      return DiagnosticsDebugCreator(value!);
    },
    "DiagnosticsProperty": () {
      final name = getValue(maps["0"], datas, "String?", vars, props);
      final value = getValue(maps["1"], datas, "T?", vars, props);
      final description =
          getValue(maps["description"], datas, "String?", vars, props);
      final ifNull = getValue(maps["ifNull"], datas, "String?", vars, props);
      final ifEmpty = getValue(maps["ifEmpty"], datas, "String?", vars, props);
      final showName = getValue(maps["showName"], datas, "", vars, props);
      final showSeparator =
          getValue(maps["showSeparator"], datas, "", vars, props);
      final defaultValue =
          getValue(maps["defaultValue"], datas, "Object?", vars, props);
      final tooltip = getValue(maps["tooltip"], datas, "String?", vars, props);
      final missingIfNull =
          getValue(maps["missingIfNull"], datas, "bool", vars, props);
      final linePrefix = getValue(maps["linePrefix"], datas, "", vars, props);
      final expandableValue =
          getValue(maps["expandableValue"], datas, "bool", vars, props);
      final allowWrap = getValue(maps["allowWrap"], datas, "bool", vars, props);
      final allowNameWrap =
          getValue(maps["allowNameWrap"], datas, "bool", vars, props);
      final style =
          getValue(maps["style"], datas, "DiagnosticsTreeStyle", vars, props);
      final level =
          getValue(maps["level"], datas, "DiagnosticLevel", vars, props);
      if (name == null || value == null) {
        return null;
      }
      if (defaultValue != null) {
        return DiagnosticsProperty(name!, value!,
            description: description,
            ifNull: ifNull,
            ifEmpty: ifEmpty,
            showName: showName,
            showSeparator: showSeparator,
            tooltip: tooltip,
            missingIfNull: missingIfNull ?? false,
            linePrefix: linePrefix,
            expandableValue: expandableValue ?? false,
            allowWrap: allowWrap ?? true,
            allowNameWrap: allowNameWrap ?? true,
            style: style ?? DiagnosticsTreeStyle.singleLine,
            level: level ?? DiagnosticLevel.info,
            defaultValue: defaultValue);
      }
      return DiagnosticsProperty(name!, value!,
          description: description,
          ifNull: ifNull,
          ifEmpty: ifEmpty,
          showName: showName,
          showSeparator: showSeparator,
          tooltip: tooltip,
          missingIfNull: missingIfNull ?? false,
          linePrefix: linePrefix,
          expandableValue: expandableValue ?? false,
          allowWrap: allowWrap ?? true,
          allowNameWrap: allowNameWrap ?? true,
          style: style ?? DiagnosticsTreeStyle.singleLine,
          level: level ?? DiagnosticLevel.info);
    },
    "DiagnosticsProperty.lazy": () {
      final name = getValue(maps["0"], datas, "String?", vars, props);
      final computeValue = getValue(
          maps["1"], datas, "ComputePropertyValueCallback<T>", vars, props);
      final description =
          getValue(maps["description"], datas, "String?", vars, props);
      final ifNull = getValue(maps["ifNull"], datas, "String?", vars, props);
      final ifEmpty = getValue(maps["ifEmpty"], datas, "String?", vars, props);
      final showName = getValue(maps["showName"], datas, "", vars, props);
      final showSeparator =
          getValue(maps["showSeparator"], datas, "", vars, props);
      final defaultValue =
          getValue(maps["defaultValue"], datas, "Object?", vars, props);
      final tooltip = getValue(maps["tooltip"], datas, "String?", vars, props);
      final missingIfNull =
          getValue(maps["missingIfNull"], datas, "bool", vars, props);
      final expandableValue =
          getValue(maps["expandableValue"], datas, "bool", vars, props);
      final allowWrap = getValue(maps["allowWrap"], datas, "bool", vars, props);
      final allowNameWrap =
          getValue(maps["allowNameWrap"], datas, "bool", vars, props);
      final style =
          getValue(maps["style"], datas, "DiagnosticsTreeStyle", vars, props);
      final level =
          getValue(maps["level"], datas, "DiagnosticLevel", vars, props);
      if (name == null || computeValue == null) {
        return null;
      }
      if (defaultValue != null) {
        return DiagnosticsProperty.lazy(name!, computeValue!,
            description: description,
            ifNull: ifNull,
            ifEmpty: ifEmpty,
            showName: showName,
            showSeparator: showSeparator,
            tooltip: tooltip,
            missingIfNull: missingIfNull ?? false,
            expandableValue: expandableValue ?? false,
            allowWrap: allowWrap ?? true,
            allowNameWrap: allowNameWrap ?? true,
            style: style ?? DiagnosticsTreeStyle.singleLine,
            level: level ?? DiagnosticLevel.info,
            defaultValue: defaultValue);
      }
      return DiagnosticsProperty.lazy(name!, computeValue!,
          description: description,
          ifNull: ifNull,
          ifEmpty: ifEmpty,
          showName: showName,
          showSeparator: showSeparator,
          tooltip: tooltip,
          missingIfNull: missingIfNull ?? false,
          expandableValue: expandableValue ?? false,
          allowWrap: allowWrap ?? true,
          allowNameWrap: allowNameWrap ?? true,
          style: style ?? DiagnosticsTreeStyle.singleLine,
          level: level ?? DiagnosticLevel.info);
    },
    "Dialog": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final backgroundColor =
          getValue(maps["backgroundColor"], datas, "Color?", vars, props);
      final elevation =
          getValue(maps["elevation"], datas, "double?", vars, props);
      final shadowColor =
          getValue(maps["shadowColor"], datas, "Color?", vars, props);
      final surfaceTintColor =
          getValue(maps["surfaceTintColor"], datas, "Color?", vars, props);
      final insetAnimationDuration = getValue(
          maps["insetAnimationDuration"], datas, "Duration", vars, props);
      final insetAnimationCurve =
          getValue(maps["insetAnimationCurve"], datas, "Curve", vars, props);
      final insetPadding =
          getValue(maps["insetPadding"], datas, "EdgeInsets?", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      final shape = getValue(maps["shape"], datas, "ShapeBorder?", vars, props);
      final alignment =
          getValue(maps["alignment"], datas, "AlignmentGeometry?", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      if (insetPadding != null) {
        return Dialog(
            key: key,
            backgroundColor: backgroundColor,
            elevation: elevation,
            shadowColor: shadowColor,
            surfaceTintColor: surfaceTintColor,
            insetAnimationDuration:
                insetAnimationDuration ?? const Duration(milliseconds: 100),
            insetAnimationCurve: insetAnimationCurve ?? Curves.decelerate,
            clipBehavior: clipBehavior ?? Clip.none,
            shape: shape,
            alignment: alignment,
            child: child,
            insetPadding: insetPadding);
      }
      return Dialog(
          key: key,
          backgroundColor: backgroundColor,
          elevation: elevation,
          shadowColor: shadowColor,
          surfaceTintColor: surfaceTintColor,
          insetAnimationDuration:
              insetAnimationDuration ?? const Duration(milliseconds: 100),
          insetAnimationCurve: insetAnimationCurve ?? Curves.decelerate,
          clipBehavior: clipBehavior ?? Clip.none,
          shape: shape,
          alignment: alignment,
          child: child);
    },
    "Dialog.fullscreen": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final backgroundColor =
          getValue(maps["backgroundColor"], datas, "Color?", vars, props);
      final insetAnimationDuration = getValue(
          maps["insetAnimationDuration"], datas, "Duration", vars, props);
      final insetAnimationCurve =
          getValue(maps["insetAnimationCurve"], datas, "Curve", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      return Dialog.fullscreen(
          key: key,
          backgroundColor: backgroundColor,
          insetAnimationDuration: insetAnimationDuration ?? Duration.zero,
          insetAnimationCurve: insetAnimationCurve ?? Curves.decelerate,
          child: child);
    },
    "DialogRoute": () {
      final context =
          getValue(maps["context"], datas, "BuildContext", vars, props);
      final builder =
          getValue(maps["builder"], datas, "WidgetBuilder", vars, props);
      final themes =
          getValue(maps["themes"], datas, "CapturedThemes?", vars, props);
      final barrierColor =
          getValue(maps["barrierColor"], datas, "Color?", vars, props);
      final barrierDismissible =
          getValue(maps["barrierDismissible"], datas, "bool", vars, props);
      final barrierLabel =
          getValue(maps["barrierLabel"], datas, "String?", vars, props);
      final useSafeArea =
          getValue(maps["useSafeArea"], datas, "bool", vars, props);
      final settings = getValue(maps["settings"], datas, "", vars, props);
      final anchorPoint =
          getValue(maps["anchorPoint"], datas, "Offset?", vars, props);
      final traversalEdgeBehavior =
          getValue(maps["traversalEdgeBehavior"], datas, "", vars, props);
      if (context == null || builder == null) {
        return null;
      }
      return DialogRoute(
          context: context!,
          builder: builder!,
          themes: themes,
          barrierColor: barrierColor ?? Colors.black54,
          barrierDismissible: barrierDismissible ?? true,
          barrierLabel: barrierLabel,
          useSafeArea: useSafeArea ?? true,
          settings: settings,
          anchorPoint: anchorPoint,
          traversalEdgeBehavior: traversalEdgeBehavior);
    },
    "DialogTheme": () {
      final backgroundColor =
          getValue(maps["backgroundColor"], datas, "Color?", vars, props);
      final elevation =
          getValue(maps["elevation"], datas, "double?", vars, props);
      final shadowColor =
          getValue(maps["shadowColor"], datas, "Color?", vars, props);
      final surfaceTintColor =
          getValue(maps["surfaceTintColor"], datas, "Color?", vars, props);
      final shape = getValue(maps["shape"], datas, "ShapeBorder?", vars, props);
      final alignment =
          getValue(maps["alignment"], datas, "AlignmentGeometry?", vars, props);
      final iconColor =
          getValue(maps["iconColor"], datas, "Color?", vars, props);
      final titleTextStyle =
          getValue(maps["titleTextStyle"], datas, "TextStyle?", vars, props);
      final contentTextStyle =
          getValue(maps["contentTextStyle"], datas, "TextStyle?", vars, props);
      final actionsPadding = getValue(
          maps["actionsPadding"], datas, "EdgeInsetsGeometry?", vars, props);
      return DialogTheme(
          backgroundColor: backgroundColor,
          elevation: elevation,
          shadowColor: shadowColor,
          surfaceTintColor: surfaceTintColor,
          shape: shape,
          alignment: alignment,
          iconColor: iconColor,
          titleTextStyle: titleTextStyle,
          contentTextStyle: contentTextStyle,
          actionsPadding: actionsPadding);
    },
    "DirectionalFocusAction": () {
      return DirectionalFocusAction();
    },
    "DirectionalFocusAction.forTextField": () {
      return DirectionalFocusAction.forTextField();
    },
    "DirectionalFocusIntent": () {
      final direction =
          getValue(maps["0"], datas, "TraversalDirection", vars, props);
      final ignoreTextFields =
          getValue(maps["ignoreTextFields"], datas, "bool", vars, props);
      if (direction == null) {
        return null;
      }
      return DirectionalFocusIntent(direction!,
          ignoreTextFields: ignoreTextFields ?? true);
    },
    "Directionality": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final textDirection =
          getValue(maps["textDirection"], datas, "TextDirection", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (textDirection == null || child == null) {
        return null;
      }
      return Directionality(
          key: key, textDirection: textDirection!, child: child!);
    },
    "DirectionallyExtendSelectionEvent": () {
      final dx = getValue(maps["dx"], datas, "double", vars, props);
      final isEnd = getValue(maps["isEnd"], datas, "bool", vars, props);
      final direction = getValue(
          maps["direction"], datas, "SelectionExtendDirection", vars, props);
      if (dx == null || isEnd == null || direction == null) {
        return null;
      }
      return DirectionallyExtendSelectionEvent(
          dx: dx!, isEnd: isEnd!, direction: direction!);
    },
    "DismissIntent": () {
      return const DismissIntent();
    },
    "DismissMenuAction": () {
      final controller =
          getValue(maps["controller"], datas, "MenuController", vars, props);
      if (controller == null) {
        return null;
      }
      return DismissMenuAction(controller: controller!);
    },
    "DismissUpdateDetails": () {
      final direction =
          getValue(maps["direction"], datas, "DismissDirection", vars, props);
      final reached = getValue(maps["reached"], datas, "bool", vars, props);
      final previousReached =
          getValue(maps["previousReached"], datas, "bool", vars, props);
      final progress = getValue(maps["progress"], datas, "double", vars, props);
      return DismissUpdateDetails(
          direction: direction ?? DismissDirection.horizontal,
          reached: reached ?? false,
          previousReached: previousReached ?? false,
          progress: progress ?? 0.0);
    },
    "Dismissible": () {
      final key = getValue(maps["key"], datas, "Key", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      final background =
          getValue(maps["background"], datas, "Widget?", vars, props);
      final secondaryBackground =
          getValue(maps["secondaryBackground"], datas, "Widget?", vars, props);
      final confirmDismiss = getValue(maps["confirmDismiss"], datas,
          "ConfirmDismissCallback?", vars, props);
      final onResize =
          getValue(maps["onResize"], datas, "VoidCallback?", vars, props);
      final onUpdate = getValue(
          maps["onUpdate"], datas, "DismissUpdateCallback?", vars, props);
      final onDismissed = getValue(
          maps["onDismissed"], datas, "DismissDirectionCallback?", vars, props);
      final direction =
          getValue(maps["direction"], datas, "DismissDirection", vars, props);
      final resizeDuration =
          getValue(maps["resizeDuration"], datas, "Duration?", vars, props);
      final dismissThresholds = getValue(maps["dismissThresholds"], datas,
          "Map<DismissDirection, double>", vars, props);
      final movementDuration =
          getValue(maps["movementDuration"], datas, "Duration", vars, props);
      final crossAxisEndOffset =
          getValue(maps["crossAxisEndOffset"], datas, "double", vars, props);
      final dragStartBehavior = getValue(
          maps["dragStartBehavior"], datas, "DragStartBehavior", vars, props);
      final behavior =
          getValue(maps["behavior"], datas, "HitTestBehavior", vars, props);
      if (key == null || child == null) {
        return null;
      }
      return Dismissible(
          key: key!,
          child: child!,
          background: background,
          secondaryBackground: secondaryBackground,
          confirmDismiss: confirmDismiss,
          onResize: onResize,
          onUpdate: onUpdate,
          onDismissed: onDismissed,
          direction: direction ?? DismissDirection.horizontal,
          resizeDuration: resizeDuration ?? const Duration(milliseconds: 300),
          dismissThresholds: Map<DismissDirection, double>.from(
              dismissThresholds ?? const <DismissDirection, double>{}),
          movementDuration:
              movementDuration ?? const Duration(milliseconds: 200),
          crossAxisEndOffset: crossAxisEndOffset ?? 0.0,
          dragStartBehavior: dragStartBehavior ?? DragStartBehavior.start,
          behavior: behavior ?? HitTestBehavior.opaque);
    },
    "DisplayFeatureSubScreen": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final anchorPoint =
          getValue(maps["anchorPoint"], datas, "Offset?", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (child == null) {
        return null;
      }
      return DisplayFeatureSubScreen(
          key: key, anchorPoint: anchorPoint, child: child!);
    },
    "DisposableBuildContext": () {
      final _state = getValue(maps["0"], datas, "T", vars, props);
      if (_state == null) {
        return null;
      }
      return DisposableBuildContext<S>(_state!);
    },
    "Divider": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final height = getValue(maps["height"], datas, "double?", vars, props);
      final thickness =
          getValue(maps["thickness"], datas, "double?", vars, props);
      final indent = getValue(maps["indent"], datas, "double?", vars, props);
      final endIndent =
          getValue(maps["endIndent"], datas, "double?", vars, props);
      final color = getValue(maps["color"], datas, "Color?", vars, props);
      return Divider(
          key: key,
          height: height,
          thickness: thickness,
          indent: indent,
          endIndent: endIndent,
          color: color);
    },
    "DividerTheme": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final data =
          getValue(maps["data"], datas, "DividerThemeData", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (data == null || child == null) {
        return null;
      }
      return DividerTheme(key: key, data: data!, child: child!);
    },
    "DividerThemeData": () {
      final color = getValue(maps["color"], datas, "Color?", vars, props);
      final space = getValue(maps["space"], datas, "double?", vars, props);
      final thickness =
          getValue(maps["thickness"], datas, "double?", vars, props);
      final indent = getValue(maps["indent"], datas, "double?", vars, props);
      final endIndent =
          getValue(maps["endIndent"], datas, "double?", vars, props);
      return DividerThemeData(
          color: color,
          space: space,
          thickness: thickness,
          indent: indent,
          endIndent: endIndent);
    },
    "DoNothingAction": () {
      final consumesKey =
          getValue(maps["consumesKey"], datas, "bool", vars, props);
      return DoNothingAction(consumesKey: consumesKey ?? true);
    },
    "DoNothingAndStopPropagationIntent": () {
      return const DoNothingAndStopPropagationIntent();
    },
    "DoNothingAndStopPropagationTextIntent": () {
      return const DoNothingAndStopPropagationTextIntent();
    },
    "DoNothingIntent": () {
      return const DoNothingIntent();
    },
    "DocumentBoundary": () {
      final _text = getValue(maps["0"], datas, "String", vars, props);
      if (_text == null) {
        return null;
      }
      return DocumentBoundary(_text!);
    },
    "DocumentationIcon": () {
      final url = getValue(maps["0"], datas, "String", vars, props);
      if (url == null) {
        return null;
      }
      return DocumentationIcon(url!);
    },
    "DoubleProperty": () {
      final name = getValue(maps["0"], datas, "String", vars, props);
      final value = getValue(maps["1"], datas, "T?", vars, props);
      final ifNull = getValue(maps["ifNull"], datas, "String?", vars, props);
      final unit = getValue(maps["unit"], datas, "String?", vars, props);
      final tooltip = getValue(maps["tooltip"], datas, "String?", vars, props);
      final defaultValue =
          getValue(maps["defaultValue"], datas, "Object?", vars, props);
      final showName = getValue(maps["showName"], datas, "", vars, props);
      final style =
          getValue(maps["style"], datas, "DiagnosticsTreeStyle", vars, props);
      final level =
          getValue(maps["level"], datas, "DiagnosticLevel", vars, props);
      if (name == null || value == null) {
        return null;
      }
      if (defaultValue != null) {
        return DoubleProperty(name!, value!,
            ifNull: ifNull,
            unit: unit,
            tooltip: tooltip,
            showName: showName,
            style: style ?? DiagnosticsTreeStyle.singleLine,
            level: level ?? DiagnosticLevel.info,
            defaultValue: defaultValue);
      }
      return DoubleProperty(name!, value!,
          ifNull: ifNull,
          unit: unit,
          tooltip: tooltip,
          showName: showName,
          style: style ?? DiagnosticsTreeStyle.singleLine,
          level: level ?? DiagnosticLevel.info);
    },
    "DoubleProperty.lazy": () {
      final name = getValue(maps["0"], datas, "String", vars, props);
      final computeValue = getValue(maps["1"], datas, "", vars, props);
      final ifNull = getValue(maps["ifNull"], datas, "String?", vars, props);
      final showName = getValue(maps["showName"], datas, "", vars, props);
      final unit = getValue(maps["unit"], datas, "String?", vars, props);
      final tooltip = getValue(maps["tooltip"], datas, "String?", vars, props);
      final defaultValue =
          getValue(maps["defaultValue"], datas, "Object?", vars, props);
      final level =
          getValue(maps["level"], datas, "DiagnosticLevel", vars, props);
      if (name == null || computeValue == null) {
        return null;
      }
      if (defaultValue != null) {
        return DoubleProperty.lazy(name!, computeValue!,
            ifNull: ifNull,
            showName: showName,
            unit: unit,
            tooltip: tooltip,
            level: level ?? DiagnosticLevel.info,
            defaultValue: defaultValue);
      }
      return DoubleProperty.lazy(name!, computeValue!,
          ifNull: ifNull,
          showName: showName,
          unit: unit,
          tooltip: tooltip,
          level: level ?? DiagnosticLevel.info);
    },
    "DoubleTapGestureRecognizer": () {
      final debugOwner =
          getValue(maps["debugOwner"], datas, "Object?", vars, props);
      final supportedDevices = getValue(maps["supportedDevices"], datas,
          "Set<PointerDeviceKind>?", vars, props);
      final allowedButtonsFilter = getValue(maps["allowedButtonsFilter"], datas,
          "AllowedButtonsFilter?", vars, props);
      return DoubleTapGestureRecognizer(
          debugOwner: debugOwner,
          supportedDevices: supportedDevices
              ? Set<PointerDeviceKind>.from(supportedDevices)
              : null,
          allowedButtonsFilter: allowedButtonsFilter);
    },
    "DragDownDetails": () {
      final globalPosition =
          getValue(maps["globalPosition"], datas, "Offset", vars, props);
      final localPosition =
          getValue(maps["localPosition"], datas, "Offset?", vars, props);
      return DragDownDetails(
          globalPosition: globalPosition ?? Offset.zero,
          localPosition: localPosition);
    },
    "DragEndDetails": () {
      final velocity =
          getValue(maps["velocity"], datas, "Velocity", vars, props);
      final primaryVelocity =
          getValue(maps["primaryVelocity"], datas, "double?", vars, props);
      return DragEndDetails(
          velocity: velocity ?? Velocity.zero,
          primaryVelocity: primaryVelocity);
    },
    "DragScrollActivity": () {
      final delegate =
          getValue(maps["0"], datas, "ScrollActivityDelegate", vars, props);
      final controller =
          getValue(maps["1"], datas, "ScrollDragController", vars, props);
      if (delegate == null || controller == null) {
        return null;
      }
      return DragScrollActivity(delegate!, controller!);
    },
    "DragStartDetails": () {
      final sourceTimeStamp =
          getValue(maps["sourceTimeStamp"], datas, "Duration?", vars, props);
      final globalPosition =
          getValue(maps["globalPosition"], datas, "Offset", vars, props);
      final localPosition =
          getValue(maps["localPosition"], datas, "Offset?", vars, props);
      final kind =
          getValue(maps["kind"], datas, "PointerDeviceKind?", vars, props);
      return DragStartDetails(
          sourceTimeStamp: sourceTimeStamp,
          globalPosition: globalPosition ?? Offset.zero,
          localPosition: localPosition,
          kind: kind);
    },
    "DragTarget": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final builder =
          getValue(maps["builder"], datas, "DragTargetBuilder<T>", vars, props);
      final onWillAccept = getValue(
          maps["onWillAccept"], datas, "DragTargetWillAccept<T>?", vars, props);
      final onAccept = getValue(
          maps["onAccept"], datas, "DragTargetAccept<T>?", vars, props);
      final onAcceptWithDetails = getValue(maps["onAcceptWithDetails"], datas,
          "DragTargetAcceptWithDetails<T>?", vars, props);
      final onLeave =
          getValue(maps["onLeave"], datas, "DragTargetLeave<T>?", vars, props);
      final onMove =
          getValue(maps["onMove"], datas, "DragTargetMove<T>?", vars, props);
      final hitTestBehavior = getValue(
          maps["hitTestBehavior"], datas, "HitTestBehavior", vars, props);
      if (builder == null) {
        return null;
      }
      return DragTarget(
          key: key,
          builder: builder!,
          onWillAccept: onWillAccept,
          onAccept: onAccept,
          onAcceptWithDetails: onAcceptWithDetails,
          onLeave: onLeave,
          onMove: onMove,
          hitTestBehavior: hitTestBehavior ?? HitTestBehavior.translucent);
    },
    "DragTargetDetails": () {
      final data = getValue(maps["data"], datas, "T", vars, props);
      final offset = getValue(maps["offset"], datas, "Offset", vars, props);
      if (data == null || offset == null) {
        return null;
      }
      return DragTargetDetails(data: data!, offset: offset!);
    },
    "DragUpdateDetails": () {
      final sourceTimeStamp =
          getValue(maps["sourceTimeStamp"], datas, "Duration?", vars, props);
      final delta = getValue(maps["delta"], datas, "Offset", vars, props);
      final primaryDelta =
          getValue(maps["primaryDelta"], datas, "double?", vars, props);
      final globalPosition =
          getValue(maps["globalPosition"], datas, "Offset", vars, props);
      final localPosition =
          getValue(maps["localPosition"], datas, "Offset?", vars, props);
      if (globalPosition == null) {
        return null;
      }
      return DragUpdateDetails(
          sourceTimeStamp: sourceTimeStamp,
          delta: delta ?? Offset.zero,
          primaryDelta: primaryDelta,
          globalPosition: globalPosition!,
          localPosition: localPosition);
    },
    "Draggable": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      final feedback = getValue(maps["feedback"], datas, "Widget", vars, props);
      final data = getValue(maps["data"], datas, "T?", vars, props);
      final axis = getValue(maps["axis"], datas, "Axis?", vars, props);
      final childWhenDragging =
          getValue(maps["childWhenDragging"], datas, "Widget?", vars, props);
      final feedbackOffset =
          getValue(maps["feedbackOffset"], datas, "Offset", vars, props);
      final dragAnchorStrategy = getValue(
          maps["dragAnchorStrategy"], datas, "DragAnchorStrategy", vars, props);
      final affinity = getValue(maps["affinity"], datas, "Axis?", vars, props);
      final maxSimultaneousDrags =
          getValue(maps["maxSimultaneousDrags"], datas, "int?", vars, props);
      final onDragStarted =
          getValue(maps["onDragStarted"], datas, "VoidCallback?", vars, props);
      final onDragUpdate = getValue(
          maps["onDragUpdate"], datas, "DragUpdateCallback?", vars, props);
      final onDraggableCanceled = getValue(maps["onDraggableCanceled"], datas,
          "DraggableCanceledCallback?", vars, props);
      final onDragEnd =
          getValue(maps["onDragEnd"], datas, "DragEndCallback?", vars, props);
      final onDragCompleted = getValue(
          maps["onDragCompleted"], datas, "VoidCallback?", vars, props);
      final ignoringFeedbackSemantics = getValue(
          maps["ignoringFeedbackSemantics"], datas, "bool", vars, props);
      final ignoringFeedbackPointer =
          getValue(maps["ignoringFeedbackPointer"], datas, "bool", vars, props);
      final rootOverlay =
          getValue(maps["rootOverlay"], datas, "bool", vars, props);
      final hitTestBehavior = getValue(
          maps["hitTestBehavior"], datas, "HitTestBehavior", vars, props);
      final allowedButtonsFilter = getValue(maps["allowedButtonsFilter"], datas,
          "AllowedButtonsFilter?", vars, props);
      if (child == null || feedback == null) {
        return null;
      }
      if (dragAnchorStrategy != null) {
        return Draggable(
            key: key,
            child: child!,
            feedback: feedback!,
            data: data,
            axis: axis,
            childWhenDragging: childWhenDragging,
            feedbackOffset: feedbackOffset ?? Offset.zero,
            affinity: affinity,
            maxSimultaneousDrags: maxSimultaneousDrags,
            onDragStarted: onDragStarted,
            onDragUpdate: onDragUpdate,
            onDraggableCanceled: onDraggableCanceled,
            onDragEnd: onDragEnd,
            onDragCompleted: onDragCompleted,
            ignoringFeedbackSemantics: ignoringFeedbackSemantics ?? true,
            ignoringFeedbackPointer: ignoringFeedbackPointer ?? true,
            rootOverlay: rootOverlay ?? false,
            hitTestBehavior: hitTestBehavior ?? HitTestBehavior.deferToChild,
            allowedButtonsFilter: allowedButtonsFilter,
            dragAnchorStrategy: dragAnchorStrategy);
      }
      return Draggable(
          key: key,
          child: child!,
          feedback: feedback!,
          data: data,
          axis: axis,
          childWhenDragging: childWhenDragging,
          feedbackOffset: feedbackOffset ?? Offset.zero,
          affinity: affinity,
          maxSimultaneousDrags: maxSimultaneousDrags,
          onDragStarted: onDragStarted,
          onDragUpdate: onDragUpdate,
          onDraggableCanceled: onDraggableCanceled,
          onDragEnd: onDragEnd,
          onDragCompleted: onDragCompleted,
          ignoringFeedbackSemantics: ignoringFeedbackSemantics ?? true,
          ignoringFeedbackPointer: ignoringFeedbackPointer ?? true,
          rootOverlay: rootOverlay ?? false,
          hitTestBehavior: hitTestBehavior ?? HitTestBehavior.deferToChild,
          allowedButtonsFilter: allowedButtonsFilter);
    },
    "DraggableDetails": () {
      final wasAccepted =
          getValue(maps["wasAccepted"], datas, "bool", vars, props);
      final velocity =
          getValue(maps["velocity"], datas, "Velocity", vars, props);
      final offset = getValue(maps["offset"], datas, "Offset", vars, props);
      if (velocity == null || offset == null) {
        return null;
      }
      return DraggableDetails(
          wasAccepted: wasAccepted ?? false,
          velocity: velocity!,
          offset: offset!);
    },
    "DraggableScrollableActuator": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (child == null) {
        return null;
      }
      return DraggableScrollableActuator(key: key, child: child!);
    },
    "DraggableScrollableNotification": () {
      final extent = getValue(maps["extent"], datas, "double", vars, props);
      final minExtent =
          getValue(maps["minExtent"], datas, "double", vars, props);
      final maxExtent =
          getValue(maps["maxExtent"], datas, "double", vars, props);
      final initialExtent =
          getValue(maps["initialExtent"], datas, "double", vars, props);
      final context =
          getValue(maps["context"], datas, "BuildContext", vars, props);
      if (extent == null ||
          minExtent == null ||
          maxExtent == null ||
          initialExtent == null ||
          context == null) {
        return null;
      }
      return DraggableScrollableNotification(
          extent: extent!,
          minExtent: minExtent!,
          maxExtent: maxExtent!,
          initialExtent: initialExtent!,
          context: context!);
    },
    "DraggableScrollableSheet": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final initialChildSize =
          getValue(maps["initialChildSize"], datas, "double", vars, props);
      final minChildSize =
          getValue(maps["minChildSize"], datas, "double", vars, props);
      final maxChildSize =
          getValue(maps["maxChildSize"], datas, "double", vars, props);
      final expand = getValue(maps["expand"], datas, "bool", vars, props);
      final snap = getValue(maps["snap"], datas, "bool", vars, props);
      final snapSizes =
          getValue(maps["snapSizes"], datas, "List<double>?", vars, props);
      final snapAnimationDuration = getValue(
          maps["snapAnimationDuration"], datas, "Duration?", vars, props);
      final controller = getValue(maps["controller"], datas,
          "DraggableScrollableController?", vars, props);
      final builder = getValue(
          maps["builder"], datas, "ScrollableWidgetBuilder", vars, props);
      if (builder == null) {
        return null;
      }
      return DraggableScrollableSheet(
          key: key,
          initialChildSize: initialChildSize ?? 0.5,
          minChildSize: minChildSize ?? 0.25,
          maxChildSize: maxChildSize ?? 1.0,
          expand: expand ?? true,
          snap: snap ?? false,
          snapSizes: snapSizes != null ? List<double>.from(snapSizes) : null,
          snapAnimationDuration: snapAnimationDuration,
          controller: controller,
          builder: builder!);
    },
    "Drawer": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final backgroundColor =
          getValue(maps["backgroundColor"], datas, "Color?", vars, props);
      final elevation =
          getValue(maps["elevation"], datas, "double?", vars, props);
      final shadowColor =
          getValue(maps["shadowColor"], datas, "Color?", vars, props);
      final surfaceTintColor =
          getValue(maps["surfaceTintColor"], datas, "Color?", vars, props);
      final shape = getValue(maps["shape"], datas, "ShapeBorder?", vars, props);
      final width = getValue(maps["width"], datas, "double?", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      final semanticLabel =
          getValue(maps["semanticLabel"], datas, "String?", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip?", vars, props);
      return Drawer(
          key: key,
          backgroundColor: backgroundColor,
          elevation: elevation,
          shadowColor: shadowColor,
          surfaceTintColor: surfaceTintColor,
          shape: shape,
          width: width,
          child: child,
          semanticLabel: semanticLabel,
          clipBehavior: clipBehavior);
    },
    "DrawerButton": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final style = getValue(maps["style"], datas, "ButtonStyle?", vars, props);
      final onPressed =
          getValue(maps["onPressed"], datas, "VoidCallback?", vars, props);
      return DrawerButton(key: key, style: style, onPressed: onPressed);
    },
    "DrawerButtonIcon": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      return DrawerButtonIcon(key: key);
    },
    "DrawerController": () {
      final key = getValue(maps["key"], datas, "GlobalKey?", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      final alignment =
          getValue(maps["alignment"], datas, "DrawerAlignment", vars, props);
      final isDrawerOpen =
          getValue(maps["isDrawerOpen"], datas, "bool", vars, props);
      final drawerCallback = getValue(
          maps["drawerCallback"], datas, "DrawerCallback?", vars, props);
      final dragStartBehavior = getValue(
          maps["dragStartBehavior"], datas, "DragStartBehavior", vars, props);
      final scrimColor =
          getValue(maps["scrimColor"], datas, "Color?", vars, props);
      final edgeDragWidth =
          getValue(maps["edgeDragWidth"], datas, "double?", vars, props);
      final enableOpenDragGesture =
          getValue(maps["enableOpenDragGesture"], datas, "bool", vars, props);
      if (child == null || alignment == null) {
        return null;
      }
      return DrawerController(
          key: key,
          child: child!,
          alignment: alignment!,
          isDrawerOpen: isDrawerOpen ?? false,
          drawerCallback: drawerCallback,
          dragStartBehavior: dragStartBehavior ?? DragStartBehavior.start,
          scrimColor: scrimColor,
          edgeDragWidth: edgeDragWidth,
          enableOpenDragGesture: enableOpenDragGesture ?? true);
    },
    "DrawerHeader": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final decoration =
          getValue(maps["decoration"], datas, "Decoration?", vars, props);
      final margin =
          getValue(maps["margin"], datas, "EdgeInsetsGeometry?", vars, props);
      final padding =
          getValue(maps["padding"], datas, "EdgeInsetsGeometry", vars, props);
      final duration =
          getValue(maps["duration"], datas, "Duration", vars, props);
      final curve = getValue(maps["curve"], datas, "Curve", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      if (child == null) {
        return null;
      }
      return DrawerHeader(
          key: key,
          decoration: decoration,
          margin: margin ?? const EdgeInsets.only(bottom: 8.0),
          padding: padding ?? const EdgeInsets.fromLTRB(16.0, 16.0, 16.0, 8.0),
          duration: duration ?? const Duration(milliseconds: 250),
          curve: curve ?? Curves.fastOutSlowIn,
          child: child!);
    },
    "DrawerTheme": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final data =
          getValue(maps["data"], datas, "DrawerThemeData", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (data == null || child == null) {
        return null;
      }
      return DrawerTheme(key: key, data: data!, child: child!);
    },
    "DrawerThemeData": () {
      final backgroundColor =
          getValue(maps["backgroundColor"], datas, "Color?", vars, props);
      final scrimColor =
          getValue(maps["scrimColor"], datas, "Color?", vars, props);
      final elevation =
          getValue(maps["elevation"], datas, "double?", vars, props);
      final shadowColor =
          getValue(maps["shadowColor"], datas, "Color?", vars, props);
      final surfaceTintColor =
          getValue(maps["surfaceTintColor"], datas, "Color?", vars, props);
      final shape = getValue(maps["shape"], datas, "ShapeBorder?", vars, props);
      final endShape =
          getValue(maps["endShape"], datas, "ShapeBorder?", vars, props);
      final width = getValue(maps["width"], datas, "double?", vars, props);
      return DrawerThemeData(
          backgroundColor: backgroundColor,
          scrimColor: scrimColor,
          elevation: elevation,
          shadowColor: shadowColor,
          surfaceTintColor: surfaceTintColor,
          shape: shape,
          endShape: endShape,
          width: width);
    },
    "DrivenScrollActivity": () {
      final delegate =
          getValue(maps["0"], datas, "ScrollActivityDelegate", vars, props);
      final from = getValue(maps["from"], datas, "double", vars, props);
      final to = getValue(maps["to"], datas, "double", vars, props);
      final duration =
          getValue(maps["duration"], datas, "Duration", vars, props);
      final curve = getValue(maps["curve"], datas, "Curve", vars, props);
      final vsync =
          getValue(maps["vsync"], datas, "TickerProvider", vars, props);
      if (delegate == null ||
          from == null ||
          to == null ||
          duration == null ||
          curve == null ||
          vsync == null) {
        return null;
      }
      return DrivenScrollActivity(delegate!,
          from: from!,
          to: to!,
          duration: duration!,
          curve: curve!,
          vsync: vsync!);
    },
    "DropSliderValueIndicatorShape": () {
      return const DropSliderValueIndicatorShape();
    },
    "DropdownButton": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final items = getValue(
          maps["items"], datas, "List<DropdownMenuItem<T>>?", vars, props);
      final selectedItemBuilder = getValue(maps["selectedItemBuilder"], datas,
          "DropdownButtonBuilder?", vars, props);
      final value = getValue(maps["value"], datas, "T?", vars, props);
      final hint = getValue(maps["hint"], datas, "Widget?", vars, props);
      final disabledHint =
          getValue(maps["disabledHint"], datas, "Widget?", vars, props);
      final onChanged =
          getValue(maps["onChanged"], datas, "ValueChanged<T?>?", vars, props);
      final onTap =
          getValue(maps["onTap"], datas, "VoidCallback?", vars, props);
      final elevation = getValue(maps["elevation"], datas, "int", vars, props);
      final style = getValue(maps["style"], datas, "TextStyle?", vars, props);
      final underline =
          getValue(maps["underline"], datas, "Widget?", vars, props);
      final icon = getValue(maps["icon"], datas, "Widget?", vars, props);
      final iconDisabledColor =
          getValue(maps["iconDisabledColor"], datas, "Color?", vars, props);
      final iconEnabledColor =
          getValue(maps["iconEnabledColor"], datas, "Color?", vars, props);
      final iconSize = getValue(maps["iconSize"], datas, "double", vars, props);
      final isDense = getValue(maps["isDense"], datas, "bool", vars, props);
      final isExpanded =
          getValue(maps["isExpanded"], datas, "bool", vars, props);
      final itemHeight =
          getValue(maps["itemHeight"], datas, "double?", vars, props);
      final focusColor =
          getValue(maps["focusColor"], datas, "Color?", vars, props);
      final focusNode =
          getValue(maps["focusNode"], datas, "FocusNode?", vars, props);
      final autofocus = getValue(maps["autofocus"], datas, "bool", vars, props);
      final dropdownColor =
          getValue(maps["dropdownColor"], datas, "Color?", vars, props);
      final menuMaxHeight =
          getValue(maps["menuMaxHeight"], datas, "double?", vars, props);
      final enableFeedback =
          getValue(maps["enableFeedback"], datas, "bool?", vars, props);
      final alignment =
          getValue(maps["alignment"], datas, "AlignmentGeometry", vars, props);
      final borderRadius =
          getValue(maps["borderRadius"], datas, "BorderRadius?", vars, props);
      final padding =
          getValue(maps["padding"], datas, "EdgeInsetsGeometry?", vars, props);
      if (items == null || onChanged == null) {
        return null;
      }
      return DropdownButton(
          key: key,
          items: List<DropdownMenuItem<T>>.from(items!),
          selectedItemBuilder: selectedItemBuilder,
          value: value,
          hint: hint,
          disabledHint: disabledHint,
          onChanged: onChanged!,
          onTap: onTap,
          elevation: elevation ?? 8,
          style: style,
          underline: underline,
          icon: icon,
          iconDisabledColor: iconDisabledColor,
          iconEnabledColor: iconEnabledColor,
          iconSize: iconSize ?? 24.0,
          isDense: isDense ?? false,
          isExpanded: isExpanded ?? false,
          itemHeight: itemHeight ?? kMinInteractiveDimension,
          focusColor: focusColor,
          focusNode: focusNode,
          autofocus: autofocus ?? false,
          dropdownColor: dropdownColor,
          menuMaxHeight: menuMaxHeight,
          enableFeedback: enableFeedback,
          alignment: alignment ?? AlignmentDirectional.centerStart,
          borderRadius: borderRadius,
          padding: padding);
    },
    "DropdownButtonFormField": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final items = getValue(
          maps["items"], datas, "List<DropdownMenuItem<T>>?", vars, props);
      final selectedItemBuilder = getValue(maps["selectedItemBuilder"], datas,
          "DropdownButtonBuilder?", vars, props);
      final value = getValue(maps["value"], datas, "T?", vars, props);
      final hint = getValue(maps["hint"], datas, "Widget?", vars, props);
      final disabledHint =
          getValue(maps["disabledHint"], datas, "Widget?", vars, props);
      final onChanged =
          getValue(maps["onChanged"], datas, "ValueChanged<T?>?", vars, props);
      final onTap =
          getValue(maps["onTap"], datas, "VoidCallback?", vars, props);
      final elevation = getValue(maps["elevation"], datas, "int", vars, props);
      final style = getValue(maps["style"], datas, "TextStyle?", vars, props);
      final icon = getValue(maps["icon"], datas, "Widget?", vars, props);
      final iconDisabledColor =
          getValue(maps["iconDisabledColor"], datas, "Color?", vars, props);
      final iconEnabledColor =
          getValue(maps["iconEnabledColor"], datas, "Color?", vars, props);
      final iconSize = getValue(maps["iconSize"], datas, "double", vars, props);
      final isDense = getValue(maps["isDense"], datas, "bool", vars, props);
      final isExpanded =
          getValue(maps["isExpanded"], datas, "bool", vars, props);
      final itemHeight =
          getValue(maps["itemHeight"], datas, "double?", vars, props);
      final focusColor =
          getValue(maps["focusColor"], datas, "Color?", vars, props);
      final focusNode =
          getValue(maps["focusNode"], datas, "FocusNode?", vars, props);
      final autofocus = getValue(maps["autofocus"], datas, "bool", vars, props);
      final dropdownColor =
          getValue(maps["dropdownColor"], datas, "Color?", vars, props);
      final decoration =
          getValue(maps["decoration"], datas, "InputDecoration?", vars, props);
      final onSaved =
          getValue(maps["onSaved"], datas, "FormFieldSetter<T>?", vars, props);
      final validator = getValue(
          maps["validator"], datas, "FormFieldValidator<T>?", vars, props);
      final autovalidateMode = getValue(
          maps["autovalidateMode"], datas, "AutovalidateMode?", vars, props);
      final menuMaxHeight =
          getValue(maps["menuMaxHeight"], datas, "double?", vars, props);
      final enableFeedback =
          getValue(maps["enableFeedback"], datas, "bool?", vars, props);
      final alignment =
          getValue(maps["alignment"], datas, "AlignmentGeometry", vars, props);
      final borderRadius =
          getValue(maps["borderRadius"], datas, "BorderRadius?", vars, props);
      final padding =
          getValue(maps["padding"], datas, "EdgeInsetsGeometry?", vars, props);
      if (items == null || onChanged == null) {
        return null;
      }
      return DropdownButtonFormField(
          key: key,
          items: List<DropdownMenuItem<T>>.from(items!),
          selectedItemBuilder: selectedItemBuilder,
          value: value,
          hint: hint,
          disabledHint: disabledHint,
          onChanged: onChanged!,
          onTap: onTap,
          elevation: elevation ?? 8,
          style: style,
          icon: icon,
          iconDisabledColor: iconDisabledColor,
          iconEnabledColor: iconEnabledColor,
          iconSize: iconSize ?? 24.0,
          isDense: isDense ?? true,
          isExpanded: isExpanded ?? false,
          itemHeight: itemHeight,
          focusColor: focusColor,
          focusNode: focusNode,
          autofocus: autofocus ?? false,
          dropdownColor: dropdownColor,
          decoration: decoration,
          onSaved: onSaved,
          validator: validator,
          autovalidateMode: autovalidateMode,
          menuMaxHeight: menuMaxHeight,
          enableFeedback: enableFeedback,
          alignment: alignment ?? AlignmentDirectional.centerStart,
          borderRadius: borderRadius,
          padding: padding);
    },
    "DropdownButtonHideUnderline": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (child == null) {
        return null;
      }
      return DropdownButtonHideUnderline(key: key, child: child!);
    },
    "DropdownMenu": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final enabled = getValue(maps["enabled"], datas, "bool", vars, props);
      final width = getValue(maps["width"], datas, "double?", vars, props);
      final menuHeight =
          getValue(maps["menuHeight"], datas, "double?", vars, props);
      final leadingIcon =
          getValue(maps["leadingIcon"], datas, "Widget?", vars, props);
      final trailingIcon =
          getValue(maps["trailingIcon"], datas, "Widget?", vars, props);
      final label = getValue(maps["label"], datas, "Widget?", vars, props);
      final hintText =
          getValue(maps["hintText"], datas, "String?", vars, props);
      final helperText =
          getValue(maps["helperText"], datas, "String?", vars, props);
      final errorText =
          getValue(maps["errorText"], datas, "String?", vars, props);
      final selectedTrailingIcon =
          getValue(maps["selectedTrailingIcon"], datas, "Widget?", vars, props);
      final enableFilter =
          getValue(maps["enableFilter"], datas, "bool", vars, props);
      final enableSearch =
          getValue(maps["enableSearch"], datas, "bool", vars, props);
      final textStyle =
          getValue(maps["textStyle"], datas, "TextStyle?", vars, props);
      final inputDecorationTheme = getValue(maps["inputDecorationTheme"], datas,
          "InputDecorationTheme?", vars, props);
      final menuStyle =
          getValue(maps["menuStyle"], datas, "MenuStyle?", vars, props);
      final controller = getValue(
          maps["controller"], datas, "TextEditingController?", vars, props);
      final initialSelection =
          getValue(maps["initialSelection"], datas, "T?", vars, props);
      final onSelected =
          getValue(maps["onSelected"], datas, "ValueChanged<T?>?", vars, props);
      final requestFocusOnTap =
          getValue(maps["requestFocusOnTap"], datas, "bool?", vars, props);
      final dropdownMenuEntries = getValue(maps["dropdownMenuEntries"], datas,
          "List<DropdownMenuEntry<T>>", vars, props);
      if (dropdownMenuEntries == null) {
        return null;
      }
      return DropdownMenu(
          key: key,
          enabled: enabled ?? true,
          width: width,
          menuHeight: menuHeight,
          leadingIcon: leadingIcon,
          trailingIcon: trailingIcon,
          label: label,
          hintText: hintText,
          helperText: helperText,
          errorText: errorText,
          selectedTrailingIcon: selectedTrailingIcon,
          enableFilter: enableFilter ?? false,
          enableSearch: enableSearch ?? true,
          textStyle: textStyle,
          inputDecorationTheme: inputDecorationTheme,
          menuStyle: menuStyle,
          controller: controller,
          initialSelection: initialSelection,
          onSelected: onSelected,
          requestFocusOnTap: requestFocusOnTap,
          dropdownMenuEntries:
              List<DropdownMenuEntry<T>>.from(dropdownMenuEntries!));
    },
    "DropdownMenuEntry": () {
      final value = getValue(maps["value"], datas, "T", vars, props);
      final label = getValue(maps["label"], datas, "String", vars, props);
      final leadingIcon =
          getValue(maps["leadingIcon"], datas, "Widget?", vars, props);
      final trailingIcon =
          getValue(maps["trailingIcon"], datas, "Widget?", vars, props);
      final enabled = getValue(maps["enabled"], datas, "bool", vars, props);
      final style = getValue(maps["style"], datas, "ButtonStyle?", vars, props);
      if (value == null || label == null) {
        return null;
      }
      return DropdownMenuEntry(
          value: value!,
          label: label!,
          leadingIcon: leadingIcon,
          trailingIcon: trailingIcon,
          enabled: enabled ?? true,
          style: style);
    },
    "DropdownMenuItem": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final onTap =
          getValue(maps["onTap"], datas, "VoidCallback?", vars, props);
      final value = getValue(maps["value"], datas, "T?", vars, props);
      final enabled = getValue(maps["enabled"], datas, "bool", vars, props);
      final alignment =
          getValue(maps["alignment"], datas, "AlignmentGeometry", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (child == null) {
        return null;
      }
      return DropdownMenuItem(
          key: key,
          onTap: onTap,
          value: value,
          enabled: enabled ?? true,
          alignment: alignment ?? AlignmentDirectional.centerStart,
          child: child!);
    },
    "DropdownMenuTheme": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final data =
          getValue(maps["data"], datas, "DropdownMenuThemeData", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (data == null || child == null) {
        return null;
      }
      return DropdownMenuTheme(key: key, data: data!, child: child!);
    },
    "DropdownMenuThemeData": () {
      final textStyle =
          getValue(maps["textStyle"], datas, "TextStyle?", vars, props);
      final inputDecorationTheme = getValue(maps["inputDecorationTheme"], datas,
          "InputDecorationTheme?", vars, props);
      final menuStyle =
          getValue(maps["menuStyle"], datas, "MenuStyle?", vars, props);
      return DropdownMenuThemeData(
          textStyle: textStyle,
          inputDecorationTheme: inputDecorationTheme,
          menuStyle: menuStyle);
    },
    "DualTransitionBuilder": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final animation =
          getValue(maps["animation"], datas, "Animation<double>", vars, props);
      final forwardBuilder = getValue(maps["forwardBuilder"], datas,
          "AnimatedTransitionBuilder", vars, props);
      final reverseBuilder = getValue(maps["reverseBuilder"], datas,
          "AnimatedTransitionBuilder", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      if (animation == null ||
          forwardBuilder == null ||
          reverseBuilder == null) {
        return null;
      }
      return DualTransitionBuilder(
          key: key,
          animation: animation!,
          forwardBuilder: forwardBuilder!,
          reverseBuilder: reverseBuilder!,
          child: child);
    },
    "Duration": () {
      final days = getValue(maps["days"], datas, "int", vars, props);
      final hours = getValue(maps["hours"], datas, "int", vars, props);
      final minutes = getValue(maps["minutes"], datas, "int", vars, props);
      final seconds = getValue(maps["seconds"], datas, "int", vars, props);
      final milliseconds =
          getValue(maps["milliseconds"], datas, "int", vars, props);
      final microseconds =
          getValue(maps["microseconds"], datas, "int", vars, props);
      return Duration(
          days: days ?? 0,
          hours: hours ?? 0,
          minutes: minutes ?? 0,
          seconds: seconds ?? 0,
          milliseconds: milliseconds ?? 0,
          microseconds: microseconds ?? 0);
    },
    "EagerGestureRecognizer": () {
      final supportedDevices =
          getValue(maps["supportedDevices"], datas, "", vars, props);
      final allowedButtonsFilter =
          getValue(maps["allowedButtonsFilter"], datas, "", vars, props);
      return EagerGestureRecognizer(
          supportedDevices: supportedDevices,
          allowedButtonsFilter: allowedButtonsFilter);
    },
    "EdgeDraggingAutoScroller": () {
      final scrollable =
          getValue(maps["0"], datas, "ScrollableState", vars, props);
      final onScrollViewScrolled = getValue(
          maps["onScrollViewScrolled"], datas, "VoidCallback?", vars, props);
      final velocityScalar =
          getValue(maps["velocityScalar"], datas, "double", vars, props);
      if (scrollable == null || velocityScalar == null) {
        return null;
      }
      return EdgeDraggingAutoScroller(scrollable!,
          onScrollViewScrolled: onScrollViewScrolled,
          velocityScalar: velocityScalar);
    },
    "EdgeInsets.fromLTRB": () {
      final left = getValue(maps["0"], datas, "double", vars, props);
      final top = getValue(maps["1"], datas, "double", vars, props);
      final right = getValue(maps["2"], datas, "double", vars, props);
      final bottom = getValue(maps["3"], datas, "double", vars, props);
      if (left == null || top == null || right == null || bottom == null) {
        return null;
      }
      return EdgeInsets.fromLTRB(left!, top!, right!, bottom!);
    },
    "EdgeInsets.all": () {
      final value = getValue(maps["0"], datas, "double", vars, props);
      if (value == null) {
        return null;
      }
      return EdgeInsets.all(value!);
    },
    "EdgeInsets.only": () {
      final left = getValue(maps["left"], datas, "double", vars, props);
      final top = getValue(maps["top"], datas, "double", vars, props);
      final right = getValue(maps["right"], datas, "double", vars, props);
      final bottom = getValue(maps["bottom"], datas, "double", vars, props);
      return EdgeInsets.only(
          left: left ?? 0.0,
          top: top ?? 0.0,
          right: right ?? 0.0,
          bottom: bottom ?? 0.0);
    },
    "EdgeInsets.symmetric": () {
      final vertical = getValue(maps["vertical"], datas, "double", vars, props);
      final horizontal =
          getValue(maps["horizontal"], datas, "double", vars, props);
      return EdgeInsets.symmetric(
          vertical: vertical ?? 0.0, horizontal: horizontal ?? 0.0);
    },
    "EdgeInsets.fromViewPadding": () {
      final padding = getValue(maps["0"], datas, "ViewPadding", vars, props);
      final devicePixelRatio =
          getValue(maps["1"], datas, "double", vars, props);
      if (padding == null || devicePixelRatio == null) {
        return null;
      }
      return EdgeInsets.fromViewPadding(padding!, devicePixelRatio!);
    },
    "EdgeInsets.fromWindowPadding": () {
      final padding = getValue(maps["0"], datas, "ViewPadding", vars, props);
      final devicePixelRatio =
          getValue(maps["1"], datas, "double", vars, props);
      if (padding == null || devicePixelRatio == null) {
        return null;
      }
      return EdgeInsets.fromWindowPadding(padding!, devicePixelRatio!);
    },
    "EdgeInsetsDirectional.fromSTEB": () {
      final start = getValue(maps["0"], datas, "double", vars, props);
      final top = getValue(maps["1"], datas, "double", vars, props);
      final end = getValue(maps["2"], datas, "double", vars, props);
      final bottom = getValue(maps["3"], datas, "double", vars, props);
      if (start == null || top == null || end == null || bottom == null) {
        return null;
      }
      return EdgeInsetsDirectional.fromSTEB(start!, top!, end!, bottom!);
    },
    "EdgeInsetsDirectional.only": () {
      final start = getValue(maps["start"], datas, "double", vars, props);
      final top = getValue(maps["top"], datas, "double", vars, props);
      final end = getValue(maps["end"], datas, "double", vars, props);
      final bottom = getValue(maps["bottom"], datas, "double", vars, props);
      return EdgeInsetsDirectional.only(
          start: start ?? 0.0,
          top: top ?? 0.0,
          end: end ?? 0.0,
          bottom: bottom ?? 0.0);
    },
    "EdgeInsetsDirectional.symmetric": () {
      final horizontal =
          getValue(maps["horizontal"], datas, "double", vars, props);
      final vertical = getValue(maps["vertical"], datas, "double", vars, props);
      return EdgeInsetsDirectional.symmetric(
          horizontal: horizontal ?? 0.0, vertical: vertical ?? 0.0);
    },
    "EdgeInsetsDirectional.all": () {
      final value = getValue(maps["0"], datas, "double", vars, props);
      if (value == null) {
        return null;
      }
      return EdgeInsetsDirectional.all(value!);
    },
    "EdgeInsetsGeometryTween": () {
      final begin = getValue(maps["begin"], datas, "T?", vars, props);
      final end = getValue(maps["end"], datas, "T?", vars, props);
      return EdgeInsetsGeometryTween(begin: begin, end: end);
    },
    "EdgeInsetsTween": () {
      final begin = getValue(maps["begin"], datas, "T?", vars, props);
      final end = getValue(maps["end"], datas, "T?", vars, props);
      return EdgeInsetsTween(begin: begin, end: end);
    },
    "EditableText": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final controller = getValue(maps["controller"], datas, "", vars, props);
      final focusNode = getValue(maps["focusNode"], datas, "", vars, props);
      final readOnly = getValue(maps["readOnly"], datas, "", vars, props);
      final obscuringCharacter =
          getValue(maps["obscuringCharacter"], datas, "", vars, props);
      final obscureText = getValue(maps["obscureText"], datas, "", vars, props);
      final autocorrect = getValue(maps["autocorrect"], datas, "", vars, props);
      final smartDashesType = getValue(
          maps["smartDashesType"], datas, "SmartDashesType?", vars, props);
      final smartQuotesType = getValue(
          maps["smartQuotesType"], datas, "SmartQuotesType?", vars, props);
      final enableSuggestions =
          getValue(maps["enableSuggestions"], datas, "", vars, props);
      final style = getValue(maps["style"], datas, "", vars, props);
      final strutStyle =
          getValue(maps["strutStyle"], datas, "StrutStyle?", vars, props);
      final cursorColor = getValue(maps["cursorColor"], datas, "", vars, props);
      final backgroundCursorColor =
          getValue(maps["backgroundCursorColor"], datas, "", vars, props);
      final textAlign = getValue(maps["textAlign"], datas, "", vars, props);
      final textDirection =
          getValue(maps["textDirection"], datas, "", vars, props);
      final locale = getValue(maps["locale"], datas, "", vars, props);
      final textScaleFactor =
          getValue(maps["textScaleFactor"], datas, "", vars, props);
      final maxLines = getValue(maps["maxLines"], datas, "", vars, props);
      final minLines = getValue(maps["minLines"], datas, "", vars, props);
      final expands = getValue(maps["expands"], datas, "", vars, props);
      final forceLine = getValue(maps["forceLine"], datas, "", vars, props);
      final textHeightBehavior =
          getValue(maps["textHeightBehavior"], datas, "", vars, props);
      final textWidthBasis =
          getValue(maps["textWidthBasis"], datas, "", vars, props);
      final autofocus = getValue(maps["autofocus"], datas, "", vars, props);
      final showCursor =
          getValue(maps["showCursor"], datas, "bool?", vars, props);
      final showSelectionHandles =
          getValue(maps["showSelectionHandles"], datas, "", vars, props);
      final selectionColor =
          getValue(maps["selectionColor"], datas, "", vars, props);
      final selectionControls =
          getValue(maps["selectionControls"], datas, "", vars, props);
      final keyboardType =
          getValue(maps["keyboardType"], datas, "TextInputType?", vars, props);
      final textInputAction =
          getValue(maps["textInputAction"], datas, "", vars, props);
      final textCapitalization =
          getValue(maps["textCapitalization"], datas, "", vars, props);
      final onChanged = getValue(maps["onChanged"], datas, "", vars, props);
      final onEditingComplete =
          getValue(maps["onEditingComplete"], datas, "", vars, props);
      final onSubmitted = getValue(maps["onSubmitted"], datas, "", vars, props);
      final onAppPrivateCommand =
          getValue(maps["onAppPrivateCommand"], datas, "", vars, props);
      final onSelectionChanged =
          getValue(maps["onSelectionChanged"], datas, "", vars, props);
      final onSelectionHandleTapped =
          getValue(maps["onSelectionHandleTapped"], datas, "", vars, props);
      final onTapOutside =
          getValue(maps["onTapOutside"], datas, "", vars, props);
      final inputFormatters = getValue(maps["inputFormatters"], datas,
          "List<TextInputFormatter>?", vars, props);
      final mouseCursor = getValue(maps["mouseCursor"], datas, "", vars, props);
      final rendererIgnoresPointer =
          getValue(maps["rendererIgnoresPointer"], datas, "", vars, props);
      final cursorWidth = getValue(maps["cursorWidth"], datas, "", vars, props);
      final cursorHeight =
          getValue(maps["cursorHeight"], datas, "", vars, props);
      final cursorRadius =
          getValue(maps["cursorRadius"], datas, "", vars, props);
      final cursorOpacityAnimates =
          getValue(maps["cursorOpacityAnimates"], datas, "", vars, props);
      final cursorOffset =
          getValue(maps["cursorOffset"], datas, "", vars, props);
      final paintCursorAboveText =
          getValue(maps["paintCursorAboveText"], datas, "", vars, props);
      final selectionHeightStyle =
          getValue(maps["selectionHeightStyle"], datas, "", vars, props);
      final selectionWidthStyle =
          getValue(maps["selectionWidthStyle"], datas, "", vars, props);
      final scrollPadding =
          getValue(maps["scrollPadding"], datas, "", vars, props);
      final keyboardAppearance =
          getValue(maps["keyboardAppearance"], datas, "", vars, props);
      final dragStartBehavior =
          getValue(maps["dragStartBehavior"], datas, "", vars, props);
      final enableInteractiveSelection = getValue(
          maps["enableInteractiveSelection"], datas, "bool?", vars, props);
      final scrollController =
          getValue(maps["scrollController"], datas, "", vars, props);
      final scrollPhysics =
          getValue(maps["scrollPhysics"], datas, "", vars, props);
      final autocorrectionTextRectColor =
          getValue(maps["autocorrectionTextRectColor"], datas, "", vars, props);
      final toolbarOptions = getValue(
          maps["toolbarOptions"], datas, "ToolbarOptions?", vars, props);
      final autofillHints =
          getValue(maps["autofillHints"], datas, "", vars, props);
      final autofillClient =
          getValue(maps["autofillClient"], datas, "", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "", vars, props);
      final restorationId =
          getValue(maps["restorationId"], datas, "", vars, props);
      final scrollBehavior =
          getValue(maps["scrollBehavior"], datas, "", vars, props);
      final scribbleEnabled =
          getValue(maps["scribbleEnabled"], datas, "", vars, props);
      final enableIMEPersonalizedLearning = getValue(
          maps["enableIMEPersonalizedLearning"], datas, "", vars, props);
      final contentInsertionConfiguration = getValue(
          maps["contentInsertionConfiguration"], datas, "", vars, props);
      final contextMenuBuilder =
          getValue(maps["contextMenuBuilder"], datas, "", vars, props);
      final spellCheckConfiguration =
          getValue(maps["spellCheckConfiguration"], datas, "", vars, props);
      final magnifierConfiguration =
          getValue(maps["magnifierConfiguration"], datas, "", vars, props);
      final undoController =
          getValue(maps["undoController"], datas, "", vars, props);
      if (controller == null ||
          focusNode == null ||
          style == null ||
          cursorColor == null ||
          backgroundCursorColor == null) {
        return null;
      }
      return EditableText(
          key: key,
          controller: controller!,
          focusNode: focusNode!,
          readOnly: readOnly ?? false,
          obscuringCharacter: obscuringCharacter ?? '•',
          obscureText: obscureText ?? false,
          autocorrect: autocorrect ?? true,
          smartDashesType: smartDashesType,
          smartQuotesType: smartQuotesType,
          enableSuggestions: enableSuggestions ?? true,
          style: style!,
          strutStyle: strutStyle,
          cursorColor: cursorColor!,
          backgroundCursorColor: backgroundCursorColor!,
          textAlign: textAlign ?? TextAlign.start,
          textDirection: textDirection,
          locale: locale,
          textScaleFactor: textScaleFactor,
          maxLines: maxLines ?? 1,
          minLines: minLines,
          expands: expands ?? false,
          forceLine: forceLine ?? true,
          textHeightBehavior: textHeightBehavior,
          textWidthBasis: textWidthBasis ?? TextWidthBasis.parent,
          autofocus: autofocus ?? false,
          showCursor: showCursor,
          showSelectionHandles: showSelectionHandles ?? false,
          selectionColor: selectionColor,
          selectionControls: selectionControls,
          keyboardType: keyboardType,
          textInputAction: textInputAction,
          textCapitalization: textCapitalization ?? TextCapitalization.none,
          onChanged: onChanged,
          onEditingComplete: onEditingComplete,
          onSubmitted: onSubmitted,
          onAppPrivateCommand: onAppPrivateCommand,
          onSelectionChanged: onSelectionChanged,
          onSelectionHandleTapped: onSelectionHandleTapped,
          onTapOutside: onTapOutside,
          inputFormatters: inputFormatters != null
              ? List<TextInputFormatter>.from(inputFormatters)
              : null,
          mouseCursor: mouseCursor,
          rendererIgnoresPointer: rendererIgnoresPointer ?? false,
          cursorWidth: cursorWidth ?? 2.0,
          cursorHeight: cursorHeight,
          cursorRadius: cursorRadius,
          cursorOpacityAnimates: cursorOpacityAnimates ?? false,
          cursorOffset: cursorOffset,
          paintCursorAboveText: paintCursorAboveText ?? false,
          selectionHeightStyle: selectionHeightStyle ?? ui.BoxHeightStyle.tight,
          selectionWidthStyle: selectionWidthStyle ?? ui.BoxWidthStyle.tight,
          scrollPadding: scrollPadding ?? const EdgeInsets.all(20.0),
          keyboardAppearance: keyboardAppearance ?? Brightness.light,
          dragStartBehavior: dragStartBehavior ?? DragStartBehavior.start,
          enableInteractiveSelection: enableInteractiveSelection,
          scrollController: scrollController,
          scrollPhysics: scrollPhysics,
          autocorrectionTextRectColor: autocorrectionTextRectColor,
          toolbarOptions: toolbarOptions,
          autofillHints: autofillHints ?? const <String>[],
          autofillClient: autofillClient,
          clipBehavior: clipBehavior ?? Clip.hardEdge,
          restorationId: restorationId,
          scrollBehavior: scrollBehavior,
          scribbleEnabled: scribbleEnabled ?? true,
          enableIMEPersonalizedLearning: enableIMEPersonalizedLearning ?? true,
          contentInsertionConfiguration: contentInsertionConfiguration,
          contextMenuBuilder: contextMenuBuilder,
          spellCheckConfiguration: spellCheckConfiguration,
          magnifierConfiguration:
              magnifierConfiguration ?? TextMagnifierConfiguration.disabled,
          undoController: undoController);
    },
    "ElasticOutCurve": () {
      final period = getValue(maps["0"], datas, "double", vars, props);
      return ElasticOutCurve(period ?? 0.4);
    },
    "ElevatedButton": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final onPressed =
          getValue(maps["onPressed"], datas, "VoidCallback?", vars, props);
      final onLongPress =
          getValue(maps["onLongPress"], datas, "VoidCallback?", vars, props);
      final onHover =
          getValue(maps["onHover"], datas, "ValueChanged<bool>?", vars, props);
      final onFocusChange = getValue(
          maps["onFocusChange"], datas, "ValueChanged<bool>?", vars, props);
      final style = getValue(maps["style"], datas, "ButtonStyle?", vars, props);
      final focusNode =
          getValue(maps["focusNode"], datas, "FocusNode?", vars, props);
      final autofocus = getValue(maps["autofocus"], datas, "bool", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      final statesController = getValue(maps["statesController"], datas,
          "MaterialStatesController?", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      if (onPressed == null || child == null) {
        return null;
      }
      return ElevatedButton(
          key: key,
          onPressed: onPressed!,
          onLongPress: onLongPress,
          onHover: onHover,
          onFocusChange: onFocusChange,
          style: style,
          focusNode: focusNode,
          autofocus: autofocus ?? false,
          clipBehavior: clipBehavior ?? Clip.none,
          statesController: statesController,
          child: child!);
    },
    "ElevatedButton.icon": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final onPressed =
          getValue(maps["onPressed"], datas, "VoidCallback?", vars, props);
      final onLongPress =
          getValue(maps["onLongPress"], datas, "VoidCallback?", vars, props);
      final onHover =
          getValue(maps["onHover"], datas, "ValueChanged<bool>?", vars, props);
      final onFocusChange = getValue(
          maps["onFocusChange"], datas, "ValueChanged<bool>?", vars, props);
      final style = getValue(maps["style"], datas, "ButtonStyle?", vars, props);
      final focusNode =
          getValue(maps["focusNode"], datas, "FocusNode?", vars, props);
      final autofocus =
          getValue(maps["autofocus"], datas, "bool?", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip?", vars, props);
      final statesController = getValue(maps["statesController"], datas,
          "MaterialStatesController?", vars, props);
      final icon = getValue(maps["icon"], datas, "Widget", vars, props);
      final label = getValue(maps["label"], datas, "Widget", vars, props);
      if (onPressed == null || icon == null || label == null) {
        return null;
      }
      return ElevatedButton.icon(
          key: key,
          onPressed: onPressed!,
          onLongPress: onLongPress,
          onHover: onHover,
          onFocusChange: onFocusChange,
          style: style,
          focusNode: focusNode,
          autofocus: autofocus,
          clipBehavior: clipBehavior,
          statesController: statesController,
          icon: icon!,
          label: label!);
    },
    "ElevatedButtonTheme": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final data =
          getValue(maps["data"], datas, "ElevatedButtonThemeData", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (data == null || child == null) {
        return null;
      }
      return ElevatedButtonTheme(key: key, data: data!, child: child!);
    },
    "ElevatedButtonThemeData": () {
      final style = getValue(maps["style"], datas, "ButtonStyle?", vars, props);
      return ElevatedButtonThemeData(style: style);
    },
    "EndDrawerButton": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final style = getValue(maps["style"], datas, "ButtonStyle?", vars, props);
      final onPressed =
          getValue(maps["onPressed"], datas, "VoidCallback?", vars, props);
      return EndDrawerButton(key: key, style: style, onPressed: onPressed);
    },
    "EndDrawerButtonIcon": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      return EndDrawerButtonIcon(key: key);
    },
    "EnumProperty": () {
      final name = getValue(maps["0"], datas, "String", vars, props);
      final value = getValue(maps["1"], datas, "T?", vars, props);
      final defaultValue =
          getValue(maps["defaultValue"], datas, "Object?", vars, props);
      final level =
          getValue(maps["level"], datas, "DiagnosticLevel", vars, props);
      if (name == null || value == null) {
        return null;
      }
      if (defaultValue != null) {
        return EnumProperty<E>(name!, value!,
            level: level ?? DiagnosticLevel.info, defaultValue: defaultValue);
      }
      return EnumProperty<E>(name!, value!,
          level: level ?? DiagnosticLevel.info);
    },
    "Error": () {
      return Error();
    },
    "ErrorDescription": () {
      final message = getValue(maps["0"], datas, "String", vars, props);
      if (message == null) {
        return null;
      }
      return ErrorDescription(message!);
    },
    "ErrorHint": () {
      final message = getValue(maps["0"], datas, "String", vars, props);
      if (message == null) {
        return null;
      }
      return ErrorHint(message!);
    },
    "ErrorSpacer": () {
      return ErrorSpacer();
    },
    "ErrorSummary": () {
      final message = getValue(maps["0"], datas, "String", vars, props);
      if (message == null) {
        return null;
      }
      return ErrorSummary(message!);
    },
    "EventChannel": () {
      final name = getValue(maps["0"], datas, "String", vars, props);
      final codec = getValue(maps["1"], datas, "MethodCodec", vars, props);
      final binaryMessenger =
          getValue(maps["2"], datas, "BinaryMessenger?", vars, props);
      if (name == null) {
        return null;
      }
      return EventChannel(
          name!, codec ?? const StandardMethodCodec(), binaryMessenger);
    },
    "ExcludeFocus": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final excluding = getValue(maps["excluding"], datas, "bool", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (child == null) {
        return null;
      }
      return ExcludeFocus(
          key: key, excluding: excluding ?? true, child: child!);
    },
    "ExcludeFocusTraversal": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final excluding = getValue(maps["excluding"], datas, "bool", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (child == null) {
        return null;
      }
      return ExcludeFocusTraversal(
          key: key, excluding: excluding ?? true, child: child!);
    },
    "ExcludeSemantics": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final excluding = getValue(maps["excluding"], datas, "bool", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      return ExcludeSemantics(
          key: key, excluding: excluding ?? true, child: child);
    },
    "ExpandIcon": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final isExpanded =
          getValue(maps["isExpanded"], datas, "bool", vars, props);
      final size = getValue(maps["size"], datas, "double", vars, props);
      final onPressed = getValue(
          maps["onPressed"], datas, "ValueChanged<bool>?", vars, props);
      final padding =
          getValue(maps["padding"], datas, "EdgeInsetsGeometry", vars, props);
      final color = getValue(maps["color"], datas, "Color?", vars, props);
      final disabledColor =
          getValue(maps["disabledColor"], datas, "Color?", vars, props);
      final expandedColor =
          getValue(maps["expandedColor"], datas, "Color?", vars, props);
      if (onPressed == null) {
        return null;
      }
      return ExpandIcon(
          key: key,
          isExpanded: isExpanded ?? false,
          size: size ?? 24.0,
          onPressed: onPressed!,
          padding: padding ?? const EdgeInsets.all(8.0),
          color: color,
          disabledColor: disabledColor,
          expandedColor: expandedColor);
    },
    "ExpandSelectionToDocumentBoundaryIntent": () {
      final forward = getValue(maps["forward"], datas, "bool", vars, props);
      if (forward == null) {
        return null;
      }
      return ExpandSelectionToDocumentBoundaryIntent(forward: forward!);
    },
    "ExpandSelectionToLineBreakIntent": () {
      final forward = getValue(maps["forward"], datas, "bool", vars, props);
      if (forward == null) {
        return null;
      }
      return ExpandSelectionToLineBreakIntent(forward: forward!);
    },
    "Expanded": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final flex = getValue(maps["flex"], datas, "int", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (child == null) {
        return null;
      }
      return Expanded(key: key, flex: flex ?? 1, child: child!);
    },
    "Expando": () {
      final name = getValue(maps["0"], datas, "String?", vars, props);
      return Expando(name);
    },
    "ExpansionPanel": () {
      final headerBuilder = getValue(maps["headerBuilder"], datas,
          "ExpansionPanelHeaderBuilder", vars, props);
      final body = getValue(maps["body"], datas, "Widget", vars, props);
      final isExpanded =
          getValue(maps["isExpanded"], datas, "bool", vars, props);
      final canTapOnHeader =
          getValue(maps["canTapOnHeader"], datas, "bool", vars, props);
      final backgroundColor =
          getValue(maps["backgroundColor"], datas, "Color?", vars, props);
      if (headerBuilder == null || body == null) {
        return null;
      }
      return ExpansionPanel(
          headerBuilder: headerBuilder!,
          body: body!,
          isExpanded: isExpanded ?? false,
          canTapOnHeader: canTapOnHeader ?? false,
          backgroundColor: backgroundColor);
    },
    "ExpansionPanelList": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final children = getValue(
          maps["children"], datas, "List<ExpansionPanel>", vars, props);
      final expansionCallback = getValue(maps["expansionCallback"], datas,
          "ExpansionPanelCallback?", vars, props);
      final animationDuration =
          getValue(maps["animationDuration"], datas, "Duration", vars, props);
      final expandedHeaderPadding = getValue(
          maps["expandedHeaderPadding"], datas, "EdgeInsets", vars, props);
      final dividerColor =
          getValue(maps["dividerColor"], datas, "Color?", vars, props);
      final elevation =
          getValue(maps["elevation"], datas, "double", vars, props);
      final expandIconColor =
          getValue(maps["expandIconColor"], datas, "Color?", vars, props);
      if (expandedHeaderPadding != null) {
        return ExpansionPanelList(
            key: key,
            children:
                List<ExpansionPanel>.from(children ?? const <ExpansionPanel>[]),
            expansionCallback: expansionCallback,
            animationDuration: animationDuration ?? kThemeAnimationDuration,
            dividerColor: dividerColor,
            elevation: elevation ?? 2,
            expandIconColor: expandIconColor,
            expandedHeaderPadding: expandedHeaderPadding);
      }
      return ExpansionPanelList(
          key: key,
          children:
              List<ExpansionPanel>.from(children ?? const <ExpansionPanel>[]),
          expansionCallback: expansionCallback,
          animationDuration: animationDuration ?? kThemeAnimationDuration,
          dividerColor: dividerColor,
          elevation: elevation ?? 2,
          expandIconColor: expandIconColor);
    },
    "ExpansionPanelList.radio": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final children = getValue(
          maps["children"], datas, "List<ExpansionPanel>", vars, props);
      final expansionCallback = getValue(maps["expansionCallback"], datas,
          "ExpansionPanelCallback?", vars, props);
      final animationDuration =
          getValue(maps["animationDuration"], datas, "Duration", vars, props);
      final initialOpenPanelValue = getValue(
          maps["initialOpenPanelValue"], datas, "Object?", vars, props);
      final expandedHeaderPadding = getValue(
          maps["expandedHeaderPadding"], datas, "EdgeInsets", vars, props);
      final dividerColor =
          getValue(maps["dividerColor"], datas, "Color?", vars, props);
      final elevation =
          getValue(maps["elevation"], datas, "double", vars, props);
      final expandIconColor =
          getValue(maps["expandIconColor"], datas, "Color?", vars, props);
      if (expandedHeaderPadding != null) {
        return ExpansionPanelList.radio(
            key: key,
            children: List<ExpansionPanel>.from(
                children ?? const <ExpansionPanelRadio>[]),
            expansionCallback: expansionCallback,
            animationDuration: animationDuration ?? kThemeAnimationDuration,
            initialOpenPanelValue: initialOpenPanelValue,
            dividerColor: dividerColor,
            elevation: elevation ?? 2,
            expandIconColor: expandIconColor,
            expandedHeaderPadding: expandedHeaderPadding);
      }
      return ExpansionPanelList.radio(
          key: key,
          children: List<ExpansionPanel>.from(
              children ?? const <ExpansionPanelRadio>[]),
          expansionCallback: expansionCallback,
          animationDuration: animationDuration ?? kThemeAnimationDuration,
          initialOpenPanelValue: initialOpenPanelValue,
          dividerColor: dividerColor,
          elevation: elevation ?? 2,
          expandIconColor: expandIconColor);
    },
    "ExpansionPanelRadio": () {
      final value = getValue(maps["value"], datas, "Object", vars, props);
      final headerBuilder = getValue(maps["headerBuilder"], datas,
          "ExpansionPanelHeaderBuilder", vars, props);
      final body = getValue(maps["body"], datas, "Widget", vars, props);
      final canTapOnHeader =
          getValue(maps["canTapOnHeader"], datas, "bool", vars, props);
      final backgroundColor =
          getValue(maps["backgroundColor"], datas, "Color?", vars, props);
      if (value == null || headerBuilder == null || body == null) {
        return null;
      }
      return ExpansionPanelRadio(
          value: value!,
          headerBuilder: headerBuilder!,
          body: body!,
          canTapOnHeader: canTapOnHeader ?? false,
          backgroundColor: backgroundColor);
    },
    "ExpansionTile": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final leading = getValue(maps["leading"], datas, "Widget?", vars, props);
      final title = getValue(maps["title"], datas, "Widget", vars, props);
      final subtitle =
          getValue(maps["subtitle"], datas, "Widget?", vars, props);
      final onExpansionChanged = getValue(maps["onExpansionChanged"], datas,
          "ValueChanged<bool>?", vars, props);
      final children =
          getValue(maps["children"], datas, "List<Widget>", vars, props);
      final trailing =
          getValue(maps["trailing"], datas, "Widget?", vars, props);
      final initiallyExpanded =
          getValue(maps["initiallyExpanded"], datas, "bool", vars, props);
      final maintainState =
          getValue(maps["maintainState"], datas, "bool", vars, props);
      final tilePadding = getValue(
          maps["tilePadding"], datas, "EdgeInsetsGeometry?", vars, props);
      final expandedCrossAxisAlignment = getValue(
          maps["expandedCrossAxisAlignment"],
          datas,
          "CrossAxisAlignment?",
          vars,
          props);
      final expandedAlignment =
          getValue(maps["expandedAlignment"], datas, "Alignment?", vars, props);
      final childrenPadding = getValue(
          maps["childrenPadding"], datas, "EdgeInsetsGeometry?", vars, props);
      final backgroundColor =
          getValue(maps["backgroundColor"], datas, "Color?", vars, props);
      final collapsedBackgroundColor = getValue(
          maps["collapsedBackgroundColor"], datas, "Color?", vars, props);
      final textColor =
          getValue(maps["textColor"], datas, "Color?", vars, props);
      final collapsedTextColor =
          getValue(maps["collapsedTextColor"], datas, "Color?", vars, props);
      final iconColor =
          getValue(maps["iconColor"], datas, "Color?", vars, props);
      final collapsedIconColor =
          getValue(maps["collapsedIconColor"], datas, "Color?", vars, props);
      final shape = getValue(maps["shape"], datas, "ShapeBorder?", vars, props);
      final collapsedShape =
          getValue(maps["collapsedShape"], datas, "ShapeBorder?", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip?", vars, props);
      final controlAffinity = getValue(maps["controlAffinity"], datas,
          "ListTileControlAffinity?", vars, props);
      final controller = getValue(
          maps["controller"], datas, "ExpansionTileController?", vars, props);
      if (title == null) {
        return null;
      }
      return ExpansionTile(
          key: key,
          leading: leading,
          title: title!,
          subtitle: subtitle,
          onExpansionChanged: onExpansionChanged,
          trailing: trailing,
          initiallyExpanded: initiallyExpanded ?? false,
          maintainState: maintainState ?? false,
          tilePadding: tilePadding,
          expandedCrossAxisAlignment: expandedCrossAxisAlignment,
          expandedAlignment: expandedAlignment,
          childrenPadding: childrenPadding,
          backgroundColor: backgroundColor,
          collapsedBackgroundColor: collapsedBackgroundColor,
          textColor: textColor,
          collapsedTextColor: collapsedTextColor,
          iconColor: iconColor,
          collapsedIconColor: collapsedIconColor,
          shape: shape,
          collapsedShape: collapsedShape,
          clipBehavior: clipBehavior,
          controlAffinity: controlAffinity,
          controller: controller,
          children: List<Widget>.from(children ?? const <Widget>[]));
    },
    "ExpansionTileController": () {
      return ExpansionTileController();
    },
    "ExpansionTileTheme": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final data =
          getValue(maps["data"], datas, "ExpansionTileThemeData", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (data == null || child == null) {
        return null;
      }
      return ExpansionTileTheme(key: key, data: data!, child: child!);
    },
    "ExtendSelectionByCharacterIntent": () {
      final forward = getValue(maps["forward"], datas, "bool", vars, props);
      final collapseSelection =
          getValue(maps["collapseSelection"], datas, "bool", vars, props);
      if (forward == null || collapseSelection == null) {
        return null;
      }
      return ExtendSelectionByCharacterIntent(
          forward: forward!, collapseSelection: collapseSelection!);
    },
    "ExtendSelectionByPageIntent": () {
      final forward = getValue(maps["forward"], datas, "bool", vars, props);
      if (forward == null) {
        return null;
      }
      return ExtendSelectionByPageIntent(forward: forward!);
    },
    "ExtendSelectionToDocumentBoundaryIntent": () {
      final forward = getValue(maps["forward"], datas, "bool", vars, props);
      final collapseSelection =
          getValue(maps["collapseSelection"], datas, "bool", vars, props);
      if (forward == null || collapseSelection == null) {
        return null;
      }
      return ExtendSelectionToDocumentBoundaryIntent(
          forward: forward!, collapseSelection: collapseSelection!);
    },
    "ExtendSelectionToLineBreakIntent": () {
      final forward = getValue(maps["forward"], datas, "bool", vars, props);
      final collapseSelection =
          getValue(maps["collapseSelection"], datas, "bool", vars, props);
      final collapseAtReversal =
          getValue(maps["collapseAtReversal"], datas, "bool", vars, props);
      final continuesAtWrap =
          getValue(maps["continuesAtWrap"], datas, "bool", vars, props);
      if (forward == null || collapseSelection == null) {
        return null;
      }
      return ExtendSelectionToLineBreakIntent(
          forward: forward!,
          collapseSelection: collapseSelection!,
          collapseAtReversal: collapseAtReversal ?? false,
          continuesAtWrap: continuesAtWrap ?? false);
    },
    "ExtendSelectionToNextParagraphBoundaryIntent": () {
      final forward = getValue(maps["forward"], datas, "bool", vars, props);
      final collapseSelection =
          getValue(maps["collapseSelection"], datas, "bool", vars, props);
      if (forward == null || collapseSelection == null) {
        return null;
      }
      return ExtendSelectionToNextParagraphBoundaryIntent(
          forward: forward!, collapseSelection: collapseSelection!);
    },
    "ExtendSelectionToNextParagraphBoundaryOrCaretLocationIntent": () {
      final forward = getValue(maps["forward"], datas, "bool", vars, props);
      if (forward == null) {
        return null;
      }
      return ExtendSelectionToNextParagraphBoundaryOrCaretLocationIntent(
          forward: forward!);
    },
    "ExtendSelectionToNextWordBoundaryIntent": () {
      final forward = getValue(maps["forward"], datas, "bool", vars, props);
      final collapseSelection =
          getValue(maps["collapseSelection"], datas, "bool", vars, props);
      if (forward == null || collapseSelection == null) {
        return null;
      }
      return ExtendSelectionToNextWordBoundaryIntent(
          forward: forward!, collapseSelection: collapseSelection!);
    },
    "ExtendSelectionToNextWordBoundaryOrCaretLocationIntent": () {
      final forward = getValue(maps["forward"], datas, "bool", vars, props);
      if (forward == null) {
        return null;
      }
      return ExtendSelectionToNextWordBoundaryOrCaretLocationIntent(
          forward: forward!);
    },
    "ExtendSelectionVerticallyToAdjacentLineIntent": () {
      final forward = getValue(maps["forward"], datas, "bool", vars, props);
      final collapseSelection =
          getValue(maps["collapseSelection"], datas, "bool", vars, props);
      if (forward == null || collapseSelection == null) {
        return null;
      }
      return ExtendSelectionVerticallyToAdjacentLineIntent(
          forward: forward!, collapseSelection: collapseSelection!);
    },
    "ExtendSelectionVerticallyToAdjacentPageIntent": () {
      final forward = getValue(maps["forward"], datas, "bool", vars, props);
      final collapseSelection =
          getValue(maps["collapseSelection"], datas, "bool", vars, props);
      if (forward == null || collapseSelection == null) {
        return null;
      }
      return ExtendSelectionVerticallyToAdjacentPageIntent(
          forward: forward!, collapseSelection: collapseSelection!);
    },
    "Factory": () {
      final constructor =
          getValue(maps["0"], datas, "ValueGetter<T>", vars, props);
      if (constructor == null) {
        return null;
      }
      return Factory(constructor!);
    },
    "FadeInImage": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final placeholder =
          getValue(maps["placeholder"], datas, "ImageProvider", vars, props);
      final placeholderErrorBuilder = getValue(maps["placeholderErrorBuilder"],
          datas, "ImageErrorWidgetBuilder?", vars, props);
      final image =
          getValue(maps["image"], datas, "ImageProvider", vars, props);
      final imageErrorBuilder = getValue(maps["imageErrorBuilder"], datas,
          "ImageErrorWidgetBuilder?", vars, props);
      final excludeFromSemantics =
          getValue(maps["excludeFromSemantics"], datas, "bool", vars, props);
      final imageSemanticLabel =
          getValue(maps["imageSemanticLabel"], datas, "String?", vars, props);
      final fadeOutDuration =
          getValue(maps["fadeOutDuration"], datas, "Duration", vars, props);
      final fadeOutCurve =
          getValue(maps["fadeOutCurve"], datas, "Curve", vars, props);
      final fadeInDuration =
          getValue(maps["fadeInDuration"], datas, "Duration", vars, props);
      final fadeInCurve =
          getValue(maps["fadeInCurve"], datas, "Curve", vars, props);
      final width = getValue(maps["width"], datas, "double?", vars, props);
      final height = getValue(maps["height"], datas, "double?", vars, props);
      final fit = getValue(maps["fit"], datas, "BoxFit?", vars, props);
      final placeholderFit =
          getValue(maps["placeholderFit"], datas, "BoxFit?", vars, props);
      final filterQuality =
          getValue(maps["filterQuality"], datas, "FilterQuality", vars, props);
      final placeholderFilterQuality = getValue(
          maps["placeholderFilterQuality"],
          datas,
          "FilterQuality?",
          vars,
          props);
      final alignment =
          getValue(maps["alignment"], datas, "AlignmentGeometry", vars, props);
      final repeat =
          getValue(maps["repeat"], datas, "ImageRepeat", vars, props);
      final matchTextDirection =
          getValue(maps["matchTextDirection"], datas, "bool", vars, props);
      if (placeholder == null || image == null) {
        return null;
      }
      return FadeInImage(
          key: key,
          placeholder: placeholder!,
          placeholderErrorBuilder: placeholderErrorBuilder,
          image: image!,
          imageErrorBuilder: imageErrorBuilder,
          excludeFromSemantics: excludeFromSemantics ?? false,
          imageSemanticLabel: imageSemanticLabel,
          fadeOutDuration: fadeOutDuration ?? const Duration(milliseconds: 300),
          fadeOutCurve: fadeOutCurve ?? Curves.easeOut,
          fadeInDuration: fadeInDuration ?? const Duration(milliseconds: 700),
          fadeInCurve: fadeInCurve ?? Curves.easeIn,
          width: width,
          height: height,
          fit: fit,
          placeholderFit: placeholderFit,
          filterQuality: filterQuality ?? FilterQuality.low,
          placeholderFilterQuality: placeholderFilterQuality,
          alignment: alignment ?? Alignment.center,
          repeat: repeat ?? ImageRepeat.noRepeat,
          matchTextDirection: matchTextDirection ?? false);
    },
    "FadeInImage.memoryNetwork": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final placeholder =
          getValue(maps["placeholder"], datas, "Uint8List", vars, props);
      final placeholderErrorBuilder = getValue(maps["placeholderErrorBuilder"],
          datas, "ImageErrorWidgetBuilder?", vars, props);
      final image = getValue(maps["image"], datas, "String", vars, props);
      final imageErrorBuilder = getValue(maps["imageErrorBuilder"], datas,
          "ImageErrorWidgetBuilder?", vars, props);
      final placeholderScale =
          getValue(maps["placeholderScale"], datas, "double", vars, props);
      final imageScale =
          getValue(maps["imageScale"], datas, "double", vars, props);
      final excludeFromSemantics =
          getValue(maps["excludeFromSemantics"], datas, "bool", vars, props);
      final imageSemanticLabel =
          getValue(maps["imageSemanticLabel"], datas, "String?", vars, props);
      final fadeOutDuration =
          getValue(maps["fadeOutDuration"], datas, "Duration", vars, props);
      final fadeOutCurve =
          getValue(maps["fadeOutCurve"], datas, "Curve", vars, props);
      final fadeInDuration =
          getValue(maps["fadeInDuration"], datas, "Duration", vars, props);
      final fadeInCurve =
          getValue(maps["fadeInCurve"], datas, "Curve", vars, props);
      final width = getValue(maps["width"], datas, "double?", vars, props);
      final height = getValue(maps["height"], datas, "double?", vars, props);
      final fit = getValue(maps["fit"], datas, "BoxFit?", vars, props);
      final placeholderFit =
          getValue(maps["placeholderFit"], datas, "BoxFit?", vars, props);
      final filterQuality =
          getValue(maps["filterQuality"], datas, "FilterQuality", vars, props);
      final placeholderFilterQuality = getValue(
          maps["placeholderFilterQuality"],
          datas,
          "FilterQuality?",
          vars,
          props);
      final alignment =
          getValue(maps["alignment"], datas, "AlignmentGeometry", vars, props);
      final repeat =
          getValue(maps["repeat"], datas, "ImageRepeat", vars, props);
      final matchTextDirection =
          getValue(maps["matchTextDirection"], datas, "bool", vars, props);
      final placeholderCacheWidth =
          getValue(maps["placeholderCacheWidth"], datas, "int?", vars, props);
      final placeholderCacheHeight =
          getValue(maps["placeholderCacheHeight"], datas, "int?", vars, props);
      final imageCacheWidth =
          getValue(maps["imageCacheWidth"], datas, "int?", vars, props);
      final imageCacheHeight =
          getValue(maps["imageCacheHeight"], datas, "int?", vars, props);
      if (placeholder == null || image == null) {
        return null;
      }
      return FadeInImage.memoryNetwork(
          key: key,
          placeholder: placeholder!,
          placeholderErrorBuilder: placeholderErrorBuilder,
          image: image!,
          imageErrorBuilder: imageErrorBuilder,
          placeholderScale: placeholderScale ?? 1.0,
          imageScale: imageScale ?? 1.0,
          excludeFromSemantics: excludeFromSemantics ?? false,
          imageSemanticLabel: imageSemanticLabel,
          fadeOutDuration: fadeOutDuration ?? const Duration(milliseconds: 300),
          fadeOutCurve: fadeOutCurve ?? Curves.easeOut,
          fadeInDuration: fadeInDuration ?? const Duration(milliseconds: 700),
          fadeInCurve: fadeInCurve ?? Curves.easeIn,
          width: width,
          height: height,
          fit: fit,
          placeholderFit: placeholderFit,
          filterQuality: filterQuality ?? FilterQuality.low,
          placeholderFilterQuality: placeholderFilterQuality,
          alignment: alignment ?? Alignment.center,
          repeat: repeat ?? ImageRepeat.noRepeat,
          matchTextDirection: matchTextDirection ?? false,
          placeholderCacheWidth: placeholderCacheWidth,
          placeholderCacheHeight: placeholderCacheHeight,
          imageCacheWidth: imageCacheWidth,
          imageCacheHeight: imageCacheHeight);
    },
    "FadeInImage.assetNetwork": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final placeholder =
          getValue(maps["placeholder"], datas, "String", vars, props);
      final placeholderErrorBuilder = getValue(maps["placeholderErrorBuilder"],
          datas, "ImageErrorWidgetBuilder?", vars, props);
      final image = getValue(maps["image"], datas, "String", vars, props);
      final imageErrorBuilder = getValue(maps["imageErrorBuilder"], datas,
          "ImageErrorWidgetBuilder?", vars, props);
      final bundle =
          getValue(maps["bundle"], datas, "AssetBundle?", vars, props);
      final placeholderScale =
          getValue(maps["placeholderScale"], datas, "double?", vars, props);
      final imageScale =
          getValue(maps["imageScale"], datas, "double", vars, props);
      final excludeFromSemantics =
          getValue(maps["excludeFromSemantics"], datas, "bool", vars, props);
      final imageSemanticLabel =
          getValue(maps["imageSemanticLabel"], datas, "String?", vars, props);
      final fadeOutDuration =
          getValue(maps["fadeOutDuration"], datas, "Duration", vars, props);
      final fadeOutCurve =
          getValue(maps["fadeOutCurve"], datas, "Curve", vars, props);
      final fadeInDuration =
          getValue(maps["fadeInDuration"], datas, "Duration", vars, props);
      final fadeInCurve =
          getValue(maps["fadeInCurve"], datas, "Curve", vars, props);
      final width = getValue(maps["width"], datas, "double?", vars, props);
      final height = getValue(maps["height"], datas, "double?", vars, props);
      final fit = getValue(maps["fit"], datas, "BoxFit?", vars, props);
      final placeholderFit =
          getValue(maps["placeholderFit"], datas, "BoxFit?", vars, props);
      final filterQuality =
          getValue(maps["filterQuality"], datas, "FilterQuality", vars, props);
      final placeholderFilterQuality = getValue(
          maps["placeholderFilterQuality"],
          datas,
          "FilterQuality?",
          vars,
          props);
      final alignment =
          getValue(maps["alignment"], datas, "AlignmentGeometry", vars, props);
      final repeat =
          getValue(maps["repeat"], datas, "ImageRepeat", vars, props);
      final matchTextDirection =
          getValue(maps["matchTextDirection"], datas, "bool", vars, props);
      final placeholderCacheWidth =
          getValue(maps["placeholderCacheWidth"], datas, "int?", vars, props);
      final placeholderCacheHeight =
          getValue(maps["placeholderCacheHeight"], datas, "int?", vars, props);
      final imageCacheWidth =
          getValue(maps["imageCacheWidth"], datas, "int?", vars, props);
      final imageCacheHeight =
          getValue(maps["imageCacheHeight"], datas, "int?", vars, props);
      if (placeholder == null || image == null) {
        return null;
      }
      return FadeInImage.assetNetwork(
          key: key,
          placeholder: placeholder!,
          placeholderErrorBuilder: placeholderErrorBuilder,
          image: image!,
          imageErrorBuilder: imageErrorBuilder,
          bundle: bundle,
          placeholderScale: placeholderScale,
          imageScale: imageScale ?? 1.0,
          excludeFromSemantics: excludeFromSemantics ?? false,
          imageSemanticLabel: imageSemanticLabel,
          fadeOutDuration: fadeOutDuration ?? const Duration(milliseconds: 300),
          fadeOutCurve: fadeOutCurve ?? Curves.easeOut,
          fadeInDuration: fadeInDuration ?? const Duration(milliseconds: 700),
          fadeInCurve: fadeInCurve ?? Curves.easeIn,
          width: width,
          height: height,
          fit: fit,
          placeholderFit: placeholderFit,
          filterQuality: filterQuality ?? FilterQuality.low,
          placeholderFilterQuality: placeholderFilterQuality,
          alignment: alignment ?? Alignment.center,
          repeat: repeat ?? ImageRepeat.noRepeat,
          matchTextDirection: matchTextDirection ?? false,
          placeholderCacheWidth: placeholderCacheWidth,
          placeholderCacheHeight: placeholderCacheHeight,
          imageCacheWidth: imageCacheWidth,
          imageCacheHeight: imageCacheHeight);
    },
    "FadeTransition": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final opacity =
          getValue(maps["opacity"], datas, "Animation<double>", vars, props);
      final alwaysIncludeSemantics =
          getValue(maps["alwaysIncludeSemantics"], datas, "bool", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      if (opacity == null) {
        return null;
      }
      return FadeTransition(
          key: key,
          opacity: opacity!,
          alwaysIncludeSemantics: alwaysIncludeSemantics ?? false,
          child: child);
    },
    "FadeUpwardsPageTransitionsBuilder": () {
      return const FadeUpwardsPageTransitionsBuilder();
    },
    "FileImage": () {
      final file = getValue(maps["0"], datas, "File", vars, props);
      final scale = getValue(maps["scale"], datas, "double", vars, props);
      if (file == null) {
        return null;
      }
      return FileImage(file!, scale: scale ?? 1.0);
    },
    "FilledButton": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final onPressed =
          getValue(maps["onPressed"], datas, "VoidCallback?", vars, props);
      final onLongPress =
          getValue(maps["onLongPress"], datas, "VoidCallback?", vars, props);
      final onHover =
          getValue(maps["onHover"], datas, "ValueChanged<bool>?", vars, props);
      final onFocusChange = getValue(
          maps["onFocusChange"], datas, "ValueChanged<bool>?", vars, props);
      final style = getValue(maps["style"], datas, "ButtonStyle?", vars, props);
      final focusNode =
          getValue(maps["focusNode"], datas, "FocusNode?", vars, props);
      final autofocus = getValue(maps["autofocus"], datas, "bool", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      final statesController = getValue(maps["statesController"], datas,
          "MaterialStatesController?", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      if (onPressed == null || child == null) {
        return null;
      }
      return FilledButton(
          key: key,
          onPressed: onPressed!,
          onLongPress: onLongPress,
          onHover: onHover,
          onFocusChange: onFocusChange,
          style: style,
          focusNode: focusNode,
          autofocus: autofocus ?? false,
          clipBehavior: clipBehavior ?? Clip.none,
          statesController: statesController,
          child: child!);
    },
    "FilledButton.icon": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final onPressed =
          getValue(maps["onPressed"], datas, "VoidCallback?", vars, props);
      final onLongPress =
          getValue(maps["onLongPress"], datas, "VoidCallback?", vars, props);
      final onHover =
          getValue(maps["onHover"], datas, "ValueChanged<bool>?", vars, props);
      final onFocusChange = getValue(
          maps["onFocusChange"], datas, "ValueChanged<bool>?", vars, props);
      final style = getValue(maps["style"], datas, "ButtonStyle?", vars, props);
      final focusNode =
          getValue(maps["focusNode"], datas, "FocusNode?", vars, props);
      final autofocus =
          getValue(maps["autofocus"], datas, "bool?", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip?", vars, props);
      final statesController = getValue(maps["statesController"], datas,
          "MaterialStatesController?", vars, props);
      final icon = getValue(maps["icon"], datas, "Widget", vars, props);
      final label = getValue(maps["label"], datas, "Widget", vars, props);
      if (onPressed == null || icon == null || label == null) {
        return null;
      }
      return FilledButton.icon(
          key: key,
          onPressed: onPressed!,
          onLongPress: onLongPress,
          onHover: onHover,
          onFocusChange: onFocusChange,
          style: style,
          focusNode: focusNode,
          autofocus: autofocus,
          clipBehavior: clipBehavior,
          statesController: statesController,
          icon: icon!,
          label: label!);
    },
    "FilledButton.tonal": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final onPressed =
          getValue(maps["onPressed"], datas, "VoidCallback?", vars, props);
      final onLongPress =
          getValue(maps["onLongPress"], datas, "VoidCallback?", vars, props);
      final onHover =
          getValue(maps["onHover"], datas, "ValueChanged<bool>?", vars, props);
      final onFocusChange = getValue(
          maps["onFocusChange"], datas, "ValueChanged<bool>?", vars, props);
      final style = getValue(maps["style"], datas, "ButtonStyle?", vars, props);
      final focusNode =
          getValue(maps["focusNode"], datas, "FocusNode?", vars, props);
      final autofocus = getValue(maps["autofocus"], datas, "bool", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      final statesController = getValue(maps["statesController"], datas,
          "MaterialStatesController?", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      if (onPressed == null || child == null) {
        return null;
      }
      return FilledButton.tonal(
          key: key,
          onPressed: onPressed!,
          onLongPress: onLongPress,
          onHover: onHover,
          onFocusChange: onFocusChange,
          style: style,
          focusNode: focusNode,
          autofocus: autofocus ?? false,
          clipBehavior: clipBehavior ?? Clip.none,
          statesController: statesController,
          child: child!);
    },
    "FilledButton.tonalIcon": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final onPressed =
          getValue(maps["onPressed"], datas, "VoidCallback?", vars, props);
      final onLongPress =
          getValue(maps["onLongPress"], datas, "VoidCallback?", vars, props);
      final onHover =
          getValue(maps["onHover"], datas, "ValueChanged<bool>?", vars, props);
      final onFocusChange = getValue(
          maps["onFocusChange"], datas, "ValueChanged<bool>?", vars, props);
      final style = getValue(maps["style"], datas, "ButtonStyle?", vars, props);
      final focusNode =
          getValue(maps["focusNode"], datas, "FocusNode?", vars, props);
      final autofocus =
          getValue(maps["autofocus"], datas, "bool?", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip?", vars, props);
      final statesController = getValue(maps["statesController"], datas,
          "MaterialStatesController?", vars, props);
      final icon = getValue(maps["icon"], datas, "Widget", vars, props);
      final label = getValue(maps["label"], datas, "Widget", vars, props);
      if (onPressed == null || icon == null || label == null) {
        return null;
      }
      return FilledButton.tonalIcon(
          key: key,
          onPressed: onPressed!,
          onLongPress: onLongPress,
          onHover: onHover,
          onFocusChange: onFocusChange,
          style: style,
          focusNode: focusNode,
          autofocus: autofocus,
          clipBehavior: clipBehavior,
          statesController: statesController,
          icon: icon!,
          label: label!);
    },
    "FilledButtonTheme": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final data =
          getValue(maps["data"], datas, "FilledButtonThemeData", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (data == null || child == null) {
        return null;
      }
      return FilledButtonTheme(key: key, data: data!, child: child!);
    },
    "FilledButtonThemeData": () {
      final style = getValue(maps["style"], datas, "ButtonStyle?", vars, props);
      return FilledButtonThemeData(style: style);
    },
    "FilterChip": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final avatar = getValue(maps["avatar"], datas, "Widget?", vars, props);
      final label = getValue(maps["label"], datas, "Widget", vars, props);
      final labelStyle =
          getValue(maps["labelStyle"], datas, "TextStyle?", vars, props);
      final labelPadding = getValue(
          maps["labelPadding"], datas, "EdgeInsetsGeometry?", vars, props);
      final selected = getValue(maps["selected"], datas, "bool", vars, props);
      final onSelected = getValue(
          maps["onSelected"], datas, "ValueChanged<bool>?", vars, props);
      final pressElevation =
          getValue(maps["pressElevation"], datas, "double?", vars, props);
      final disabledColor =
          getValue(maps["disabledColor"], datas, "Color?", vars, props);
      final selectedColor =
          getValue(maps["selectedColor"], datas, "Color?", vars, props);
      final tooltip = getValue(maps["tooltip"], datas, "String?", vars, props);
      final side = getValue(maps["side"], datas, "BorderSide?", vars, props);
      final shape =
          getValue(maps["shape"], datas, "OutlinedBorder?", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      final focusNode =
          getValue(maps["focusNode"], datas, "FocusNode?", vars, props);
      final autofocus = getValue(maps["autofocus"], datas, "bool", vars, props);
      final backgroundColor =
          getValue(maps["backgroundColor"], datas, "Color?", vars, props);
      final padding =
          getValue(maps["padding"], datas, "EdgeInsetsGeometry?", vars, props);
      final visualDensity =
          getValue(maps["visualDensity"], datas, "VisualDensity?", vars, props);
      final materialTapTargetSize = getValue(maps["materialTapTargetSize"],
          datas, "MaterialTapTargetSize?", vars, props);
      final elevation =
          getValue(maps["elevation"], datas, "double?", vars, props);
      final shadowColor =
          getValue(maps["shadowColor"], datas, "Color?", vars, props);
      final surfaceTintColor =
          getValue(maps["surfaceTintColor"], datas, "Color?", vars, props);
      final iconTheme =
          getValue(maps["iconTheme"], datas, "IconThemeData?", vars, props);
      final selectedShadowColor =
          getValue(maps["selectedShadowColor"], datas, "Color?", vars, props);
      final showCheckmark =
          getValue(maps["showCheckmark"], datas, "bool?", vars, props);
      final checkmarkColor =
          getValue(maps["checkmarkColor"], datas, "Color?", vars, props);
      final avatarBorder =
          getValue(maps["avatarBorder"], datas, "ShapeBorder", vars, props);
      if (label == null || onSelected == null) {
        return null;
      }
      return FilterChip(
          key: key,
          avatar: avatar,
          label: label!,
          labelStyle: labelStyle,
          labelPadding: labelPadding,
          selected: selected ?? false,
          onSelected: onSelected!,
          pressElevation: pressElevation,
          disabledColor: disabledColor,
          selectedColor: selectedColor,
          tooltip: tooltip,
          side: side,
          shape: shape,
          clipBehavior: clipBehavior ?? Clip.none,
          focusNode: focusNode,
          autofocus: autofocus ?? false,
          backgroundColor: backgroundColor,
          padding: padding,
          visualDensity: visualDensity,
          materialTapTargetSize: materialTapTargetSize,
          elevation: elevation,
          shadowColor: shadowColor,
          surfaceTintColor: surfaceTintColor,
          iconTheme: iconTheme,
          selectedShadowColor: selectedShadowColor,
          showCheckmark: showCheckmark,
          checkmarkColor: checkmarkColor,
          avatarBorder: avatarBorder ?? const CircleBorder());
    },
    "FilteringTextInputFormatter": () {
      final filterPattern = getValue(maps["0"], datas, "Pattern", vars, props);
      final allow = getValue(maps["allow"], datas, "bool", vars, props);
      final replacementString =
          getValue(maps["replacementString"], datas, "String", vars, props);
      if (filterPattern == null || allow == null) {
        return null;
      }
      return FilteringTextInputFormatter(filterPattern!,
          allow: allow!, replacementString: replacementString ?? '');
    },
    "FilteringTextInputFormatter.allow": () {
      final filterPattern = getValue(maps["0"], datas, "Pattern", vars, props);
      final replacementString =
          getValue(maps["replacementString"], datas, "String", vars, props);
      if (filterPattern == null) {
        return null;
      }
      return FilteringTextInputFormatter.allow(filterPattern!,
          replacementString: replacementString ?? '');
    },
    "FilteringTextInputFormatter.deny": () {
      final filterPattern = getValue(maps["0"], datas, "Pattern", vars, props);
      final replacementString =
          getValue(maps["replacementString"], datas, "String", vars, props);
      if (filterPattern == null) {
        return null;
      }
      return FilteringTextInputFormatter.deny(filterPattern!,
          replacementString: replacementString ?? '');
    },
    "FittedBox": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final fit = getValue(maps["fit"], datas, "BoxFit", vars, props);
      final alignment =
          getValue(maps["alignment"], datas, "AlignmentGeometry", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      return FittedBox(
          key: key,
          fit: fit ?? BoxFit.contain,
          alignment: alignment ?? Alignment.center,
          clipBehavior: clipBehavior ?? Clip.none,
          child: child);
    },
    "FittedSizes": () {
      final source = getValue(maps["0"], datas, "Size", vars, props);
      final destination = getValue(maps["1"], datas, "Size", vars, props);
      if (source == null || destination == null) {
        return null;
      }
      return FittedSizes(source!, destination!);
    },
    "FixedExtentMetrics": () {
      final minScrollExtent =
          getValue(maps["minScrollExtent"], datas, "double?", vars, props);
      final maxScrollExtent =
          getValue(maps["maxScrollExtent"], datas, "double?", vars, props);
      final pixels = getValue(maps["pixels"], datas, "double?", vars, props);
      final viewportDimension =
          getValue(maps["viewportDimension"], datas, "double?", vars, props);
      final axisDirection =
          getValue(maps["axisDirection"], datas, "AxisDirection", vars, props);
      final itemIndex = getValue(maps["itemIndex"], datas, "int", vars, props);
      final devicePixelRatio =
          getValue(maps["devicePixelRatio"], datas, "double", vars, props);
      if (minScrollExtent == null ||
          maxScrollExtent == null ||
          pixels == null ||
          viewportDimension == null ||
          axisDirection == null ||
          itemIndex == null ||
          devicePixelRatio == null) {
        return null;
      }
      return FixedExtentMetrics(
          minScrollExtent: minScrollExtent!,
          maxScrollExtent: maxScrollExtent!,
          pixels: pixels!,
          viewportDimension: viewportDimension!,
          axisDirection: axisDirection!,
          itemIndex: itemIndex!,
          devicePixelRatio: devicePixelRatio!);
    },
    "FixedExtentScrollController": () {
      final initialItem =
          getValue(maps["initialItem"], datas, "int", vars, props);
      return FixedExtentScrollController(initialItem: initialItem ?? 0);
    },
    "FixedExtentScrollPhysics": () {
      final parent =
          getValue(maps["parent"], datas, "ScrollPhysics?", vars, props);
      return FixedExtentScrollPhysics(parent: parent);
    },
    "FixedScrollMetrics": () {
      final minScrollExtent =
          getValue(maps["minScrollExtent"], datas, "double?", vars, props);
      final maxScrollExtent =
          getValue(maps["maxScrollExtent"], datas, "double?", vars, props);
      final pixels = getValue(maps["pixels"], datas, "double?", vars, props);
      final viewportDimension =
          getValue(maps["viewportDimension"], datas, "double?", vars, props);
      final axisDirection =
          getValue(maps["axisDirection"], datas, "AxisDirection", vars, props);
      final devicePixelRatio =
          getValue(maps["devicePixelRatio"], datas, "double", vars, props);
      if (minScrollExtent == null ||
          maxScrollExtent == null ||
          pixels == null ||
          viewportDimension == null ||
          axisDirection == null ||
          devicePixelRatio == null) {
        return null;
      }
      return FixedScrollMetrics(
          minScrollExtent: minScrollExtent!,
          maxScrollExtent: maxScrollExtent!,
          pixels: pixels!,
          viewportDimension: viewportDimension!,
          axisDirection: axisDirection!,
          devicePixelRatio: devicePixelRatio!);
    },
    "FlagsSummary": () {
      final name = getValue(maps["0"], datas, "String", vars, props);
      final value =
          getValue(maps["1"], datas, "Map<String,   T?>", vars, props);
      final ifEmpty = getValue(maps["ifEmpty"], datas, "String?", vars, props);
      final showName = getValue(maps["showName"], datas, "", vars, props);
      final showSeparator =
          getValue(maps["showSeparator"], datas, "", vars, props);
      final level =
          getValue(maps["level"], datas, "DiagnosticLevel", vars, props);
      if (name == null || value == null) {
        return null;
      }
      return FlagsSummary(name!, Map<String, T?>.from(value!),
          ifEmpty: ifEmpty,
          showName: showName,
          showSeparator: showSeparator,
          level: level ?? DiagnosticLevel.info);
    },
    "Flex": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final direction = getValue(maps["direction"], datas, "", vars, props);
      final mainAxisAlignment =
          getValue(maps["mainAxisAlignment"], datas, "", vars, props);
      final mainAxisSize =
          getValue(maps["mainAxisSize"], datas, "", vars, props);
      final crossAxisAlignment =
          getValue(maps["crossAxisAlignment"], datas, "", vars, props);
      final textDirection =
          getValue(maps["textDirection"], datas, "", vars, props);
      final verticalDirection =
          getValue(maps["verticalDirection"], datas, "", vars, props);
      final textBaseline =
          getValue(maps["textBaseline"], datas, "", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "", vars, props);
      final children =
          getValue(maps["children"], datas, "List<Widget>", vars, props);
      if (direction == null) {
        return null;
      }
      return Flex(
          key: key,
          direction: direction!,
          mainAxisAlignment: mainAxisAlignment ?? MainAxisAlignment.start,
          mainAxisSize: mainAxisSize ?? MainAxisSize.max,
          crossAxisAlignment: crossAxisAlignment ?? CrossAxisAlignment.center,
          textDirection: textDirection,
          verticalDirection: verticalDirection ?? VerticalDirection.down,
          textBaseline: textBaseline,
          clipBehavior: clipBehavior ?? Clip.none,
          children: List<Widget>.from(children ?? const <Widget>[]));
    },
    "Flexible": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final flex = getValue(maps["flex"], datas, "int", vars, props);
      final fit = getValue(maps["fit"], datas, "FlexFit", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (child == null) {
        return null;
      }
      return Flexible(
          key: key, flex: flex ?? 1, fit: fit ?? FlexFit.loose, child: child!);
    },
    "FlexibleSpaceBar": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final title = getValue(maps["title"], datas, "Widget?", vars, props);
      final background =
          getValue(maps["background"], datas, "Widget?", vars, props);
      final centerTitle =
          getValue(maps["centerTitle"], datas, "bool?", vars, props);
      final titlePadding = getValue(
          maps["titlePadding"], datas, "EdgeInsetsGeometry?", vars, props);
      final collapseMode =
          getValue(maps["collapseMode"], datas, "CollapseMode", vars, props);
      final stretchModes = getValue(
          maps["stretchModes"], datas, "List<StretchMode>", vars, props);
      final expandedTitleScale =
          getValue(maps["expandedTitleScale"], datas, "double", vars, props);
      return FlexibleSpaceBar(
          key: key,
          title: title,
          background: background,
          centerTitle: centerTitle,
          titlePadding: titlePadding,
          collapseMode: collapseMode ?? CollapseMode.parallax,
          stretchModes: List<StretchMode>.from(
              stretchModes ?? const <StretchMode>[StretchMode.zoomBackground]),
          expandedTitleScale: expandedTitleScale ?? 1.5);
    },
    "FlexibleSpaceBarSettings": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final toolbarOpacity =
          getValue(maps["toolbarOpacity"], datas, "double", vars, props);
      final minExtent =
          getValue(maps["minExtent"], datas, "double", vars, props);
      final maxExtent =
          getValue(maps["maxExtent"], datas, "double", vars, props);
      final currentExtent =
          getValue(maps["currentExtent"], datas, "double", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      final isScrolledUnder =
          getValue(maps["isScrolledUnder"], datas, "bool?", vars, props);
      if (toolbarOpacity == null ||
          minExtent == null ||
          maxExtent == null ||
          currentExtent == null ||
          child == null) {
        return null;
      }
      return FlexibleSpaceBarSettings(
          key: key,
          toolbarOpacity: toolbarOpacity!,
          minExtent: minExtent!,
          maxExtent: maxExtent!,
          currentExtent: currentExtent!,
          child: child!,
          isScrolledUnder: isScrolledUnder);
    },
    "FlippedTweenSequence": () {
      final items =
          getValue(maps["0"], datas, "List<TweenSequenceItem<T>>", vars, props);
      if (items == null) {
        return null;
      }
      return FlippedTweenSequence(List<TweenSequenceItem<double>>.from(items!));
    },
    "FloatingActionButton": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      final tooltip = getValue(maps["tooltip"], datas, "String?", vars, props);
      final foregroundColor =
          getValue(maps["foregroundColor"], datas, "Color?", vars, props);
      final backgroundColor =
          getValue(maps["backgroundColor"], datas, "Color?", vars, props);
      final focusColor =
          getValue(maps["focusColor"], datas, "Color?", vars, props);
      final hoverColor =
          getValue(maps["hoverColor"], datas, "Color?", vars, props);
      final splashColor =
          getValue(maps["splashColor"], datas, "Color?", vars, props);
      final heroTag = getValue(maps["heroTag"], datas, "Object?", vars, props);
      final elevation =
          getValue(maps["elevation"], datas, "double?", vars, props);
      final focusElevation =
          getValue(maps["focusElevation"], datas, "double?", vars, props);
      final hoverElevation =
          getValue(maps["hoverElevation"], datas, "double?", vars, props);
      final highlightElevation =
          getValue(maps["highlightElevation"], datas, "double?", vars, props);
      final disabledElevation =
          getValue(maps["disabledElevation"], datas, "double?", vars, props);
      final onPressed =
          getValue(maps["onPressed"], datas, "VoidCallback?", vars, props);
      final mouseCursor =
          getValue(maps["mouseCursor"], datas, "MouseCursor?", vars, props);
      final mini = getValue(maps["mini"], datas, "bool", vars, props);
      final shape = getValue(maps["shape"], datas, "ShapeBorder?", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      final focusNode =
          getValue(maps["focusNode"], datas, "FocusNode?", vars, props);
      final autofocus = getValue(maps["autofocus"], datas, "bool", vars, props);
      final materialTapTargetSize = getValue(maps["materialTapTargetSize"],
          datas, "MaterialTapTargetSize?", vars, props);
      final isExtended =
          getValue(maps["isExtended"], datas, "bool", vars, props);
      final enableFeedback =
          getValue(maps["enableFeedback"], datas, "bool?", vars, props);
      if (onPressed == null) {
        return null;
      }
      return FloatingActionButton(
          key: key,
          child: child,
          tooltip: tooltip,
          foregroundColor: foregroundColor,
          backgroundColor: backgroundColor,
          focusColor: focusColor,
          hoverColor: hoverColor,
          splashColor: splashColor,
          heroTag: heroTag ?? const _DefaultHeroTag(),
          elevation: elevation,
          focusElevation: focusElevation,
          hoverElevation: hoverElevation,
          highlightElevation: highlightElevation,
          disabledElevation: disabledElevation,
          onPressed: onPressed!,
          mouseCursor: mouseCursor,
          mini: mini ?? false,
          shape: shape,
          clipBehavior: clipBehavior ?? Clip.none,
          focusNode: focusNode,
          autofocus: autofocus ?? false,
          materialTapTargetSize: materialTapTargetSize,
          isExtended: isExtended ?? false,
          enableFeedback: enableFeedback);
    },
    "FloatingActionButton.small": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      final tooltip = getValue(maps["tooltip"], datas, "String?", vars, props);
      final foregroundColor =
          getValue(maps["foregroundColor"], datas, "Color?", vars, props);
      final backgroundColor =
          getValue(maps["backgroundColor"], datas, "Color?", vars, props);
      final focusColor =
          getValue(maps["focusColor"], datas, "Color?", vars, props);
      final hoverColor =
          getValue(maps["hoverColor"], datas, "Color?", vars, props);
      final splashColor =
          getValue(maps["splashColor"], datas, "Color?", vars, props);
      final heroTag = getValue(maps["heroTag"], datas, "Object?", vars, props);
      final elevation =
          getValue(maps["elevation"], datas, "double?", vars, props);
      final focusElevation =
          getValue(maps["focusElevation"], datas, "double?", vars, props);
      final hoverElevation =
          getValue(maps["hoverElevation"], datas, "double?", vars, props);
      final highlightElevation =
          getValue(maps["highlightElevation"], datas, "double?", vars, props);
      final disabledElevation =
          getValue(maps["disabledElevation"], datas, "double?", vars, props);
      final onPressed =
          getValue(maps["onPressed"], datas, "VoidCallback?", vars, props);
      final mouseCursor =
          getValue(maps["mouseCursor"], datas, "MouseCursor?", vars, props);
      final shape = getValue(maps["shape"], datas, "ShapeBorder?", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      final focusNode =
          getValue(maps["focusNode"], datas, "FocusNode?", vars, props);
      final autofocus = getValue(maps["autofocus"], datas, "bool", vars, props);
      final materialTapTargetSize = getValue(maps["materialTapTargetSize"],
          datas, "MaterialTapTargetSize?", vars, props);
      final enableFeedback =
          getValue(maps["enableFeedback"], datas, "bool?", vars, props);
      if (onPressed == null) {
        return null;
      }
      return FloatingActionButton.small(
          key: key,
          child: child,
          tooltip: tooltip,
          foregroundColor: foregroundColor,
          backgroundColor: backgroundColor,
          focusColor: focusColor,
          hoverColor: hoverColor,
          splashColor: splashColor,
          heroTag: heroTag ?? const _DefaultHeroTag(),
          elevation: elevation,
          focusElevation: focusElevation,
          hoverElevation: hoverElevation,
          highlightElevation: highlightElevation,
          disabledElevation: disabledElevation,
          onPressed: onPressed!,
          mouseCursor: mouseCursor,
          shape: shape,
          clipBehavior: clipBehavior ?? Clip.none,
          focusNode: focusNode,
          autofocus: autofocus ?? false,
          materialTapTargetSize: materialTapTargetSize,
          enableFeedback: enableFeedback);
    },
    "FloatingActionButton.large": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      final tooltip = getValue(maps["tooltip"], datas, "String?", vars, props);
      final foregroundColor =
          getValue(maps["foregroundColor"], datas, "Color?", vars, props);
      final backgroundColor =
          getValue(maps["backgroundColor"], datas, "Color?", vars, props);
      final focusColor =
          getValue(maps["focusColor"], datas, "Color?", vars, props);
      final hoverColor =
          getValue(maps["hoverColor"], datas, "Color?", vars, props);
      final splashColor =
          getValue(maps["splashColor"], datas, "Color?", vars, props);
      final heroTag = getValue(maps["heroTag"], datas, "Object?", vars, props);
      final elevation =
          getValue(maps["elevation"], datas, "double?", vars, props);
      final focusElevation =
          getValue(maps["focusElevation"], datas, "double?", vars, props);
      final hoverElevation =
          getValue(maps["hoverElevation"], datas, "double?", vars, props);
      final highlightElevation =
          getValue(maps["highlightElevation"], datas, "double?", vars, props);
      final disabledElevation =
          getValue(maps["disabledElevation"], datas, "double?", vars, props);
      final onPressed =
          getValue(maps["onPressed"], datas, "VoidCallback?", vars, props);
      final mouseCursor =
          getValue(maps["mouseCursor"], datas, "MouseCursor?", vars, props);
      final shape = getValue(maps["shape"], datas, "ShapeBorder?", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      final focusNode =
          getValue(maps["focusNode"], datas, "FocusNode?", vars, props);
      final autofocus = getValue(maps["autofocus"], datas, "bool", vars, props);
      final materialTapTargetSize = getValue(maps["materialTapTargetSize"],
          datas, "MaterialTapTargetSize?", vars, props);
      final enableFeedback =
          getValue(maps["enableFeedback"], datas, "bool?", vars, props);
      if (onPressed == null) {
        return null;
      }
      return FloatingActionButton.large(
          key: key,
          child: child,
          tooltip: tooltip,
          foregroundColor: foregroundColor,
          backgroundColor: backgroundColor,
          focusColor: focusColor,
          hoverColor: hoverColor,
          splashColor: splashColor,
          heroTag: heroTag ?? const _DefaultHeroTag(),
          elevation: elevation,
          focusElevation: focusElevation,
          hoverElevation: hoverElevation,
          highlightElevation: highlightElevation,
          disabledElevation: disabledElevation,
          onPressed: onPressed!,
          mouseCursor: mouseCursor,
          shape: shape,
          clipBehavior: clipBehavior ?? Clip.none,
          focusNode: focusNode,
          autofocus: autofocus ?? false,
          materialTapTargetSize: materialTapTargetSize,
          enableFeedback: enableFeedback);
    },
    "FloatingActionButton.extended": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final tooltip = getValue(maps["tooltip"], datas, "String?", vars, props);
      final foregroundColor =
          getValue(maps["foregroundColor"], datas, "Color?", vars, props);
      final backgroundColor =
          getValue(maps["backgroundColor"], datas, "Color?", vars, props);
      final focusColor =
          getValue(maps["focusColor"], datas, "Color?", vars, props);
      final hoverColor =
          getValue(maps["hoverColor"], datas, "Color?", vars, props);
      final heroTag = getValue(maps["heroTag"], datas, "Object?", vars, props);
      final elevation =
          getValue(maps["elevation"], datas, "double?", vars, props);
      final focusElevation =
          getValue(maps["focusElevation"], datas, "double?", vars, props);
      final hoverElevation =
          getValue(maps["hoverElevation"], datas, "double?", vars, props);
      final splashColor =
          getValue(maps["splashColor"], datas, "Color?", vars, props);
      final highlightElevation =
          getValue(maps["highlightElevation"], datas, "double?", vars, props);
      final disabledElevation =
          getValue(maps["disabledElevation"], datas, "double?", vars, props);
      final onPressed =
          getValue(maps["onPressed"], datas, "VoidCallback?", vars, props);
      final mouseCursor =
          getValue(maps["mouseCursor"], datas, "MouseCursor?", vars, props);
      final shape = getValue(maps["shape"], datas, "ShapeBorder?", vars, props);
      final isExtended =
          getValue(maps["isExtended"], datas, "bool", vars, props);
      final materialTapTargetSize = getValue(maps["materialTapTargetSize"],
          datas, "MaterialTapTargetSize?", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      final focusNode =
          getValue(maps["focusNode"], datas, "FocusNode?", vars, props);
      final autofocus = getValue(maps["autofocus"], datas, "bool", vars, props);
      final extendedIconLabelSpacing = getValue(
          maps["extendedIconLabelSpacing"], datas, "double?", vars, props);
      final extendedPadding = getValue(
          maps["extendedPadding"], datas, "EdgeInsetsGeometry?", vars, props);
      final extendedTextStyle =
          getValue(maps["extendedTextStyle"], datas, "TextStyle?", vars, props);
      final icon = getValue(maps["icon"], datas, "Widget?", vars, props);
      final label = getValue(maps["label"], datas, "Widget", vars, props);
      final enableFeedback =
          getValue(maps["enableFeedback"], datas, "bool?", vars, props);
      if (onPressed == null || label == null) {
        return null;
      }
      return FloatingActionButton.extended(
          key: key,
          tooltip: tooltip,
          foregroundColor: foregroundColor,
          backgroundColor: backgroundColor,
          focusColor: focusColor,
          hoverColor: hoverColor,
          heroTag: heroTag ?? const _DefaultHeroTag(),
          elevation: elevation,
          focusElevation: focusElevation,
          hoverElevation: hoverElevation,
          splashColor: splashColor,
          highlightElevation: highlightElevation,
          disabledElevation: disabledElevation,
          onPressed: onPressed!,
          mouseCursor: mouseCursor ?? SystemMouseCursors.click,
          shape: shape,
          isExtended: isExtended ?? true,
          materialTapTargetSize: materialTapTargetSize,
          clipBehavior: clipBehavior ?? Clip.none,
          focusNode: focusNode,
          autofocus: autofocus ?? false,
          extendedIconLabelSpacing: extendedIconLabelSpacing,
          extendedPadding: extendedPadding,
          extendedTextStyle: extendedTextStyle,
          icon: icon,
          label: label!,
          enableFeedback: enableFeedback);
    },
    "FloatingActionButtonThemeData": () {
      final foregroundColor =
          getValue(maps["foregroundColor"], datas, "Color?", vars, props);
      final backgroundColor =
          getValue(maps["backgroundColor"], datas, "Color?", vars, props);
      final focusColor =
          getValue(maps["focusColor"], datas, "Color?", vars, props);
      final hoverColor =
          getValue(maps["hoverColor"], datas, "Color?", vars, props);
      final splashColor =
          getValue(maps["splashColor"], datas, "Color?", vars, props);
      final elevation =
          getValue(maps["elevation"], datas, "double?", vars, props);
      final focusElevation =
          getValue(maps["focusElevation"], datas, "double?", vars, props);
      final hoverElevation =
          getValue(maps["hoverElevation"], datas, "double?", vars, props);
      final disabledElevation =
          getValue(maps["disabledElevation"], datas, "double?", vars, props);
      final highlightElevation =
          getValue(maps["highlightElevation"], datas, "double?", vars, props);
      final shape = getValue(maps["shape"], datas, "ShapeBorder?", vars, props);
      final enableFeedback =
          getValue(maps["enableFeedback"], datas, "bool?", vars, props);
      final iconSize =
          getValue(maps["iconSize"], datas, "double?", vars, props);
      final sizeConstraints = getValue(
          maps["sizeConstraints"], datas, "BoxConstraints?", vars, props);
      final smallSizeConstraints = getValue(
          maps["smallSizeConstraints"], datas, "BoxConstraints?", vars, props);
      final largeSizeConstraints = getValue(
          maps["largeSizeConstraints"], datas, "BoxConstraints?", vars, props);
      final extendedSizeConstraints = getValue(maps["extendedSizeConstraints"],
          datas, "BoxConstraints?", vars, props);
      final extendedIconLabelSpacing = getValue(
          maps["extendedIconLabelSpacing"], datas, "double?", vars, props);
      final extendedPadding = getValue(
          maps["extendedPadding"], datas, "EdgeInsetsGeometry?", vars, props);
      final extendedTextStyle =
          getValue(maps["extendedTextStyle"], datas, "TextStyle?", vars, props);
      final mouseCursor = getValue(maps["mouseCursor"], datas,
          "MaterialStateProperty<MouseCursor?>?", vars, props);
      return FloatingActionButtonThemeData(
          foregroundColor: foregroundColor,
          backgroundColor: backgroundColor,
          focusColor: focusColor,
          hoverColor: hoverColor,
          splashColor: splashColor,
          elevation: elevation,
          focusElevation: focusElevation,
          hoverElevation: hoverElevation,
          disabledElevation: disabledElevation,
          highlightElevation: highlightElevation,
          shape: shape,
          enableFeedback: enableFeedback,
          iconSize: iconSize,
          sizeConstraints: sizeConstraints,
          smallSizeConstraints: smallSizeConstraints,
          largeSizeConstraints: largeSizeConstraints,
          extendedSizeConstraints: extendedSizeConstraints,
          extendedIconLabelSpacing: extendedIconLabelSpacing,
          extendedPadding: extendedPadding,
          extendedTextStyle: extendedTextStyle,
          mouseCursor: mouseCursor);
    },
    "FloatingHeaderSnapConfiguration": () {
      final curve = getValue(maps["curve"], datas, "Curve", vars, props);
      final duration =
          getValue(maps["duration"], datas, "Duration", vars, props);
      return FloatingHeaderSnapConfiguration(
          curve: curve ?? Curves.ease,
          duration: duration ?? const Duration(milliseconds: 300));
    },
    "Flow": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final delegate =
          getValue(maps["delegate"], datas, "FlowDelegate", vars, props);
      final children =
          getValue(maps["children"], datas, "List<Widget>", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      if (delegate == null) {
        return null;
      }
      return Flow(
          key: key,
          delegate: delegate!,
          clipBehavior: clipBehavior ?? Clip.hardEdge,
          children: List<Widget>.from(children ?? const <Widget>[]));
    },
    "Flow.unwrapped": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final delegate =
          getValue(maps["delegate"], datas, "FlowDelegate", vars, props);
      final children =
          getValue(maps["children"], datas, "List<Widget>", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      if (delegate == null) {
        return null;
      }
      return Flow.unwrapped(
          key: key,
          delegate: delegate!,
          clipBehavior: clipBehavior ?? Clip.hardEdge,
          children: List<Widget>.from(children ?? const <Widget>[]));
    },
    "FlutterErrorDetails": () {
      final exception =
          getValue(maps["exception"], datas, "Object", vars, props);
      final stack = getValue(maps["stack"], datas, "StackTrace?", vars, props);
      final library = getValue(maps["library"], datas, "String?", vars, props);
      final context =
          getValue(maps["context"], datas, "DiagnosticsNode?", vars, props);
      final stackFilter = getValue(
          maps["stackFilter"], datas, "IterableFilter<String>?", vars, props);
      final informationCollector = getValue(maps["informationCollector"], datas,
          "InformationCollector?", vars, props);
      final silent = getValue(maps["silent"], datas, "bool", vars, props);
      if (exception == null) {
        return null;
      }
      return FlutterErrorDetails(
          exception: exception!,
          stack: stack,
          library: library ?? 'Flutter framework',
          context: context,
          stackFilter: stackFilter,
          informationCollector: informationCollector,
          silent: silent ?? false);
    },
    "FlutterLogo": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final size = getValue(maps["size"], datas, "double?", vars, props);
      final textColor =
          getValue(maps["textColor"], datas, "Color", vars, props);
      final style =
          getValue(maps["style"], datas, "FlutterLogoStyle", vars, props);
      final duration =
          getValue(maps["duration"], datas, "Duration", vars, props);
      final curve = getValue(maps["curve"], datas, "Curve", vars, props);
      return FlutterLogo(
          key: key,
          size: size,
          textColor: textColor ?? const Color(0xFF757575),
          style: style ?? FlutterLogoStyle.markOnly,
          duration: duration ?? const Duration(milliseconds: 750),
          curve: curve ?? Curves.fastOutSlowIn);
    },
    "FlutterLogoDecoration": () {
      final textColor =
          getValue(maps["textColor"], datas, "Color", vars, props);
      final style =
          getValue(maps["style"], datas, "FlutterLogoStyle", vars, props);
      final margin = getValue(maps["margin"], datas, "EdgeInsets", vars, props);
      return FlutterLogoDecoration(
          textColor: textColor ?? const Color(0xFF757575),
          style: style ?? FlutterLogoStyle.markOnly,
          margin: margin ?? EdgeInsets.zero);
    },
    "Focus": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      final focusNode =
          getValue(maps["focusNode"], datas, "FocusNode?", vars, props);
      final parentNode =
          getValue(maps["parentNode"], datas, "FocusNode?", vars, props);
      final autofocus = getValue(maps["autofocus"], datas, "bool", vars, props);
      final onFocusChange = getValue(
          maps["onFocusChange"], datas, "ValueChanged<bool>?", vars, props);
      final onKeyEvent = getValue(
          maps["onKeyEvent"], datas, "FocusOnKeyEventCallback?", vars, props);
      final onKey =
          getValue(maps["onKey"], datas, "FocusOnKeyCallback?", vars, props);
      final canRequestFocus =
          getValue(maps["canRequestFocus"], datas, "bool?", vars, props);
      final skipTraversal =
          getValue(maps["skipTraversal"], datas, "bool?", vars, props);
      final descendantsAreFocusable = getValue(
          maps["descendantsAreFocusable"], datas, "bool?", vars, props);
      final descendantsAreTraversable = getValue(
          maps["descendantsAreTraversable"], datas, "bool?", vars, props);
      final includeSemantics =
          getValue(maps["includeSemantics"], datas, "bool", vars, props);
      final debugLabel =
          getValue(maps["debugLabel"], datas, "String?", vars, props);
      if (child == null) {
        return null;
      }
      return Focus(
          key: key,
          child: child!,
          focusNode: focusNode,
          parentNode: parentNode,
          autofocus: autofocus ?? false,
          onFocusChange: onFocusChange,
          onKeyEvent: onKeyEvent,
          onKey: onKey,
          canRequestFocus: canRequestFocus,
          skipTraversal: skipTraversal,
          descendantsAreFocusable: descendantsAreFocusable,
          descendantsAreTraversable: descendantsAreTraversable,
          includeSemantics: includeSemantics ?? true,
          debugLabel: debugLabel);
    },
    "Focus.withExternalFocusNode": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      final focusNode =
          getValue(maps["focusNode"], datas, "FocusNode", vars, props);
      final parentNode =
          getValue(maps["parentNode"], datas, "FocusNode?", vars, props);
      final autofocus = getValue(maps["autofocus"], datas, "bool", vars, props);
      final onFocusChange = getValue(
          maps["onFocusChange"], datas, "ValueChanged<bool>?", vars, props);
      final includeSemantics =
          getValue(maps["includeSemantics"], datas, "bool", vars, props);
      if (child == null || focusNode == null) {
        return null;
      }
      return Focus.withExternalFocusNode(
          key: key,
          child: child!,
          focusNode: focusNode!,
          parentNode: parentNode,
          autofocus: autofocus,
          onFocusChange: onFocusChange,
          includeSemantics: includeSemantics);
    },
    "FocusManager": () {
      return FocusManager();
    },
    "FocusNode": () {
      final debugLabel =
          getValue(maps["debugLabel"], datas, "String?", vars, props);
      final onKey =
          getValue(maps["onKey"], datas, "FocusOnKeyCallback?", vars, props);
      final onKeyEvent = getValue(
          maps["onKeyEvent"], datas, "FocusOnKeyEventCallback?", vars, props);
      final skipTraversal =
          getValue(maps["skipTraversal"], datas, "bool", vars, props);
      final canRequestFocus =
          getValue(maps["canRequestFocus"], datas, "bool", vars, props);
      final descendantsAreFocusable =
          getValue(maps["descendantsAreFocusable"], datas, "bool", vars, props);
      final descendantsAreTraversable = getValue(
          maps["descendantsAreTraversable"], datas, "bool", vars, props);
      return FocusNode(
          debugLabel: debugLabel,
          onKey: onKey,
          onKeyEvent: onKeyEvent,
          skipTraversal: skipTraversal ?? false,
          canRequestFocus: canRequestFocus ?? true,
          descendantsAreFocusable: descendantsAreFocusable ?? true,
          descendantsAreTraversable: descendantsAreTraversable ?? true);
    },
    "FocusScope": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final node =
          getValue(maps["node"], datas, "FocusScopeNode?", vars, props);
      final parentNode =
          getValue(maps["parentNode"], datas, "FocusNode?", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      final autofocus = getValue(maps["autofocus"], datas, "bool", vars, props);
      final onFocusChange = getValue(
          maps["onFocusChange"], datas, "ValueChanged<bool>?", vars, props);
      final canRequestFocus =
          getValue(maps["canRequestFocus"], datas, "bool?", vars, props);
      final skipTraversal =
          getValue(maps["skipTraversal"], datas, "bool?", vars, props);
      final onKeyEvent = getValue(
          maps["onKeyEvent"], datas, "FocusOnKeyEventCallback?", vars, props);
      final onKey = getValue(
          maps["onKey"], datas, "FocusOnKeyEventCallback?", vars, props);
      final debugLabel =
          getValue(maps["debugLabel"], datas, "String?", vars, props);
      if (child == null) {
        return null;
      }
      return FocusScope(
          key: key,
          node: node,
          parentNode: parentNode,
          child: child!,
          autofocus: autofocus ?? false,
          onFocusChange: onFocusChange,
          canRequestFocus: canRequestFocus,
          skipTraversal: skipTraversal,
          onKeyEvent: onKeyEvent,
          onKey: onKey,
          debugLabel: debugLabel);
    },
    "FocusScope.withExternalFocusNode": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      final focusScopeNode = getValue(
          maps["focusScopeNode"], datas, "FocusScopeNode", vars, props);
      final parentNode =
          getValue(maps["parentNode"], datas, "FocusNode?", vars, props);
      final autofocus = getValue(maps["autofocus"], datas, "bool", vars, props);
      final onFocusChange = getValue(
          maps["onFocusChange"], datas, "ValueChanged<bool>?", vars, props);
      if (child == null || focusScopeNode == null) {
        return null;
      }
      return FocusScope.withExternalFocusNode(
          key: key,
          child: child!,
          focusScopeNode: focusScopeNode!,
          parentNode: parentNode,
          autofocus: autofocus,
          onFocusChange: onFocusChange);
    },
    "FocusTraversalGroup": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final policy =
          getValue(maps["policy"], datas, "FocusTraversalPolicy?", vars, props);
      final descendantsAreFocusable =
          getValue(maps["descendantsAreFocusable"], datas, "bool", vars, props);
      final descendantsAreTraversable = getValue(
          maps["descendantsAreTraversable"], datas, "bool", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (child == null) {
        return null;
      }
      return FocusTraversalGroup(
          key: key,
          policy: policy,
          descendantsAreFocusable: descendantsAreFocusable ?? true,
          descendantsAreTraversable: descendantsAreTraversable ?? true,
          child: child!);
    },
    "FocusTraversalOrder": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final order = getValue(maps["order"], datas, "FocusOrder", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (order == null || child == null) {
        return null;
      }
      return FocusTraversalOrder(key: key, order: order!, child: child!);
    },
    "FocusableActionDetector": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final enabled = getValue(maps["enabled"], datas, "bool", vars, props);
      final focusNode =
          getValue(maps["focusNode"], datas, "FocusNode?", vars, props);
      final autofocus = getValue(maps["autofocus"], datas, "bool", vars, props);
      final descendantsAreFocusable =
          getValue(maps["descendantsAreFocusable"], datas, "bool", vars, props);
      final descendantsAreTraversable = getValue(
          maps["descendantsAreTraversable"], datas, "bool", vars, props);
      final shortcuts = getValue(maps["shortcuts"], datas,
          "Map<ShortcutActivator, Intent>?", vars, props);
      final actions = getValue(
          maps["actions"], datas, "Map<Type, Action<Intent>>?", vars, props);
      final onShowFocusHighlight = getValue(maps["onShowFocusHighlight"], datas,
          "ValueChanged<bool>?", vars, props);
      final onShowHoverHighlight = getValue(maps["onShowHoverHighlight"], datas,
          "ValueChanged<bool>?", vars, props);
      final onFocusChange = getValue(
          maps["onFocusChange"], datas, "ValueChanged<bool>?", vars, props);
      final mouseCursor =
          getValue(maps["mouseCursor"], datas, "MouseCursor", vars, props);
      final includeFocusSemantics =
          getValue(maps["includeFocusSemantics"], datas, "bool", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (child == null) {
        return null;
      }
      return FocusableActionDetector(
          key: key,
          enabled: enabled ?? true,
          focusNode: focusNode,
          autofocus: autofocus ?? false,
          descendantsAreFocusable: descendantsAreFocusable ?? true,
          descendantsAreTraversable: descendantsAreTraversable ?? true,
          shortcuts:
              shortcuts ? Map<ShortcutActivator, Intent>.from(shortcuts) : null,
          actions: actions ? Map<Type, Action<Intent>>.from(actions) : null,
          onShowFocusHighlight: onShowFocusHighlight,
          onShowHoverHighlight: onShowHoverHighlight,
          onFocusChange: onFocusChange,
          mouseCursor: mouseCursor ?? MouseCursor.defer,
          includeFocusSemantics: includeFocusSemantics ?? true,
          child: child!);
    },
    "FollowerLayer": () {
      final link = getValue(maps["link"], datas, "LayerLink", vars, props);
      final showWhenUnlinked =
          getValue(maps["showWhenUnlinked"], datas, "bool?", vars, props);
      final unlinkedOffset =
          getValue(maps["unlinkedOffset"], datas, "Offset?", vars, props);
      final linkedOffset =
          getValue(maps["linkedOffset"], datas, "Offset?", vars, props);
      if (link == null) {
        return null;
      }
      return FollowerLayer(
          link: link!,
          showWhenUnlinked: showWhenUnlinked ?? true,
          unlinkedOffset: unlinkedOffset ?? Offset.zero,
          linkedOffset: linkedOffset ?? Offset.zero);
    },
    "FontFeature": () {
      final feature = getValue(maps["0"], datas, "String", vars, props);
      final value = getValue(maps["1"], datas, "int", vars, props);
      if (feature == null) {
        return null;
      }
      return ui.FontFeature(feature!, value ?? 1);
    },
    "FontLoader": () {
      final family = getValue(maps["0"], datas, "String", vars, props);
      if (family == null) {
        return null;
      }
      return FontLoader(family!);
    },
    "ForcePressDetails": () {
      final globalPosition =
          getValue(maps["globalPosition"], datas, "Offset", vars, props);
      final localPosition =
          getValue(maps["localPosition"], datas, "Offset?", vars, props);
      final pressure = getValue(maps["pressure"], datas, "double", vars, props);
      if (globalPosition == null || pressure == null) {
        return null;
      }
      return ForcePressDetails(
          globalPosition: globalPosition!,
          localPosition: localPosition,
          pressure: pressure!);
    },
    "ForcePressGestureRecognizer": () {
      final startPressure =
          getValue(maps["startPressure"], datas, "double", vars, props);
      final peakPressure =
          getValue(maps["peakPressure"], datas, "double", vars, props);
      final interpolation = getValue(maps["interpolation"], datas,
          "GestureForceInterpolation", vars, props);
      final debugOwner = getValue(maps["debugOwner"], datas, "", vars, props);
      final supportedDevices =
          getValue(maps["supportedDevices"], datas, "", vars, props);
      final allowedButtonsFilter =
          getValue(maps["allowedButtonsFilter"], datas, "", vars, props);
      if (interpolation != null) {
        return ForcePressGestureRecognizer(
            startPressure: startPressure ?? 0.4,
            peakPressure: peakPressure ?? 0.85,
            debugOwner: debugOwner,
            supportedDevices: supportedDevices,
            allowedButtonsFilter: allowedButtonsFilter,
            interpolation: interpolation);
      }
      return ForcePressGestureRecognizer(
          startPressure: startPressure ?? 0.4,
          peakPressure: peakPressure ?? 0.85,
          debugOwner: debugOwner,
          supportedDevices: supportedDevices,
          allowedButtonsFilter: allowedButtonsFilter);
    },
    "Form": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      final onWillPop =
          getValue(maps["onWillPop"], datas, "WillPopCallback?", vars, props);
      final onChanged =
          getValue(maps["onChanged"], datas, "VoidCallback?", vars, props);
      final autovalidateMode = getValue(
          maps["autovalidateMode"], datas, "AutovalidateMode?", vars, props);
      if (child == null) {
        return null;
      }
      return Form(
          key: key,
          child: child!,
          onWillPop: onWillPop,
          onChanged: onChanged,
          autovalidateMode: autovalidateMode);
    },
    "FormField": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final builder =
          getValue(maps["builder"], datas, "FormFieldBuilder<T>", vars, props);
      final onSaved =
          getValue(maps["onSaved"], datas, "FormFieldSetter<T>?", vars, props);
      final validator = getValue(
          maps["validator"], datas, "FormFieldValidator<T>?", vars, props);
      final initialValue =
          getValue(maps["initialValue"], datas, "T?", vars, props);
      final enabled = getValue(maps["enabled"], datas, "bool", vars, props);
      final autovalidateMode = getValue(
          maps["autovalidateMode"], datas, "AutovalidateMode?", vars, props);
      final restorationId =
          getValue(maps["restorationId"], datas, "String?", vars, props);
      if (builder == null) {
        return null;
      }
      return FormField(
          key: key,
          builder: builder!,
          onSaved: onSaved,
          validator: validator,
          initialValue: initialValue,
          enabled: enabled ?? true,
          autovalidateMode: autovalidateMode,
          restorationId: restorationId);
    },
    "FormatException": () {
      final message = getValue(maps["0"], datas, "String", vars, props);
      final source = getValue(maps["1"], datas, "dynamic", vars, props);
      final offset = getValue(maps["2"], datas, "int?", vars, props);
      return FormatException(message ?? "", source, offset);
    },
    "FractionalOffset": () {
      final dx = getValue(maps["0"], datas, "double", vars, props);
      final dy = getValue(maps["1"], datas, "double", vars, props);
      if (dx == null || dy == null) {
        return null;
      }
      return FractionalOffset(dx!, dy!);
    },
    "FractionalOffset.fromOffsetAndSize": () {
      final offset = getValue(maps["0"], datas, "Offset", vars, props);
      final size = getValue(maps["1"], datas, "Size", vars, props);
      if (offset == null || size == null) {
        return null;
      }
      return FractionalOffset.fromOffsetAndSize(offset!, size!);
    },
    "FractionalOffset.fromOffsetAndRect": () {
      final offset = getValue(maps["0"], datas, "Offset", vars, props);
      final rect = getValue(maps["1"], datas, "Rect", vars, props);
      if (offset == null || rect == null) {
        return null;
      }
      return FractionalOffset.fromOffsetAndRect(offset!, rect!);
    },
    "FractionalOffsetTween": () {
      final begin = getValue(maps["begin"], datas, "T?", vars, props);
      final end = getValue(maps["end"], datas, "T?", vars, props);
      return FractionalOffsetTween(begin: begin, end: end);
    },
    "FractionalTranslation": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final translation =
          getValue(maps["translation"], datas, "Offset", vars, props);
      final transformHitTests =
          getValue(maps["transformHitTests"], datas, "bool", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      if (translation == null) {
        return null;
      }
      return FractionalTranslation(
          key: key,
          translation: translation!,
          transformHitTests: transformHitTests ?? true,
          child: child);
    },
    "FractionallySizedBox": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final alignment =
          getValue(maps["alignment"], datas, "AlignmentGeometry", vars, props);
      final widthFactor =
          getValue(maps["widthFactor"], datas, "double?", vars, props);
      final heightFactor =
          getValue(maps["heightFactor"], datas, "double?", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      return FractionallySizedBox(
          key: key,
          alignment: alignment ?? Alignment.center,
          widthFactor: widthFactor,
          heightFactor: heightFactor,
          child: child);
    },
    "FrictionSimulation": () {
      final drag = getValue(maps["0"], datas, "double", vars, props);
      final position = getValue(maps["1"], datas, "double", vars, props);
      final velocity = getValue(maps["2"], datas, "double", vars, props);
      final tolerance =
          getValue(maps["tolerance"], datas, "Tolerance", vars, props);
      final constantDeceleration =
          getValue(maps["constantDeceleration"], datas, "double", vars, props);
      if (drag == null || position == null || velocity == null) {
        return null;
      }
      return FrictionSimulation(drag!, position!, velocity!,
          tolerance: tolerance ?? Tolerance.defaultTolerance,
          constantDeceleration: constantDeceleration ?? 0);
    },
    "FrictionSimulation.through": () {
      final startPosition = getValue(maps["0"], datas, "double", vars, props);
      final endPosition = getValue(maps["1"], datas, "double", vars, props);
      final startVelocity = getValue(maps["2"], datas, "double", vars, props);
      final endVelocity = getValue(maps["3"], datas, "double", vars, props);
      if (startPosition == null ||
          endPosition == null ||
          startVelocity == null ||
          endVelocity == null) {
        return null;
      }
      return FrictionSimulation.through(
          startPosition!, endPosition!, startVelocity!, endVelocity!);
    },
    "FutureBuilder": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final future = getValue(maps["future"], datas, "Future<T>?", vars, props);
      final initialData =
          getValue(maps["initialData"], datas, "T?", vars, props);
      final builder = getValue(
          maps["builder"], datas, "AsyncWidgetBuilder<T>", vars, props);
      if (builder == null) {
        return null;
      }
      return FutureBuilder(
          key: key,
          future: future,
          initialData: initialData,
          builder: builder!);
    },
    "GestureDetector": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final child = getValue(maps["child"], datas, "", vars, props);
      final onTapDown = getValue(maps["onTapDown"], datas, "", vars, props);
      final onTapUp = getValue(maps["onTapUp"], datas, "", vars, props);
      final onTap = getValue(maps["onTap"], datas, "", vars, props);
      final onTapCancel = getValue(maps["onTapCancel"], datas, "", vars, props);
      final onSecondaryTap =
          getValue(maps["onSecondaryTap"], datas, "", vars, props);
      final onSecondaryTapDown =
          getValue(maps["onSecondaryTapDown"], datas, "", vars, props);
      final onSecondaryTapUp =
          getValue(maps["onSecondaryTapUp"], datas, "", vars, props);
      final onSecondaryTapCancel =
          getValue(maps["onSecondaryTapCancel"], datas, "", vars, props);
      final onTertiaryTapDown =
          getValue(maps["onTertiaryTapDown"], datas, "", vars, props);
      final onTertiaryTapUp =
          getValue(maps["onTertiaryTapUp"], datas, "", vars, props);
      final onTertiaryTapCancel =
          getValue(maps["onTertiaryTapCancel"], datas, "", vars, props);
      final onDoubleTapDown =
          getValue(maps["onDoubleTapDown"], datas, "", vars, props);
      final onDoubleTap = getValue(maps["onDoubleTap"], datas, "", vars, props);
      final onDoubleTapCancel =
          getValue(maps["onDoubleTapCancel"], datas, "", vars, props);
      final onLongPressDown =
          getValue(maps["onLongPressDown"], datas, "", vars, props);
      final onLongPressCancel =
          getValue(maps["onLongPressCancel"], datas, "", vars, props);
      final onLongPress = getValue(maps["onLongPress"], datas, "", vars, props);
      final onLongPressStart =
          getValue(maps["onLongPressStart"], datas, "", vars, props);
      final onLongPressMoveUpdate =
          getValue(maps["onLongPressMoveUpdate"], datas, "", vars, props);
      final onLongPressUp =
          getValue(maps["onLongPressUp"], datas, "", vars, props);
      final onLongPressEnd =
          getValue(maps["onLongPressEnd"], datas, "", vars, props);
      final onSecondaryLongPressDown =
          getValue(maps["onSecondaryLongPressDown"], datas, "", vars, props);
      final onSecondaryLongPressCancel =
          getValue(maps["onSecondaryLongPressCancel"], datas, "", vars, props);
      final onSecondaryLongPress =
          getValue(maps["onSecondaryLongPress"], datas, "", vars, props);
      final onSecondaryLongPressStart =
          getValue(maps["onSecondaryLongPressStart"], datas, "", vars, props);
      final onSecondaryLongPressMoveUpdate = getValue(
          maps["onSecondaryLongPressMoveUpdate"], datas, "", vars, props);
      final onSecondaryLongPressUp =
          getValue(maps["onSecondaryLongPressUp"], datas, "", vars, props);
      final onSecondaryLongPressEnd =
          getValue(maps["onSecondaryLongPressEnd"], datas, "", vars, props);
      final onTertiaryLongPressDown =
          getValue(maps["onTertiaryLongPressDown"], datas, "", vars, props);
      final onTertiaryLongPressCancel =
          getValue(maps["onTertiaryLongPressCancel"], datas, "", vars, props);
      final onTertiaryLongPress =
          getValue(maps["onTertiaryLongPress"], datas, "", vars, props);
      final onTertiaryLongPressStart =
          getValue(maps["onTertiaryLongPressStart"], datas, "", vars, props);
      final onTertiaryLongPressMoveUpdate = getValue(
          maps["onTertiaryLongPressMoveUpdate"], datas, "", vars, props);
      final onTertiaryLongPressUp =
          getValue(maps["onTertiaryLongPressUp"], datas, "", vars, props);
      final onTertiaryLongPressEnd =
          getValue(maps["onTertiaryLongPressEnd"], datas, "", vars, props);
      final onVerticalDragDown =
          getValue(maps["onVerticalDragDown"], datas, "", vars, props);
      final onVerticalDragStart =
          getValue(maps["onVerticalDragStart"], datas, "", vars, props);
      final onVerticalDragUpdate =
          getValue(maps["onVerticalDragUpdate"], datas, "", vars, props);
      final onVerticalDragEnd =
          getValue(maps["onVerticalDragEnd"], datas, "", vars, props);
      final onVerticalDragCancel =
          getValue(maps["onVerticalDragCancel"], datas, "", vars, props);
      final onHorizontalDragDown =
          getValue(maps["onHorizontalDragDown"], datas, "", vars, props);
      final onHorizontalDragStart =
          getValue(maps["onHorizontalDragStart"], datas, "", vars, props);
      final onHorizontalDragUpdate =
          getValue(maps["onHorizontalDragUpdate"], datas, "", vars, props);
      final onHorizontalDragEnd =
          getValue(maps["onHorizontalDragEnd"], datas, "", vars, props);
      final onHorizontalDragCancel =
          getValue(maps["onHorizontalDragCancel"], datas, "", vars, props);
      final onForcePressStart =
          getValue(maps["onForcePressStart"], datas, "", vars, props);
      final onForcePressPeak =
          getValue(maps["onForcePressPeak"], datas, "", vars, props);
      final onForcePressUpdate =
          getValue(maps["onForcePressUpdate"], datas, "", vars, props);
      final onForcePressEnd =
          getValue(maps["onForcePressEnd"], datas, "", vars, props);
      final onPanDown = getValue(maps["onPanDown"], datas, "", vars, props);
      final onPanStart = getValue(maps["onPanStart"], datas, "", vars, props);
      final onPanUpdate = getValue(maps["onPanUpdate"], datas, "", vars, props);
      final onPanEnd = getValue(maps["onPanEnd"], datas, "", vars, props);
      final onPanCancel = getValue(maps["onPanCancel"], datas, "", vars, props);
      final onScaleStart =
          getValue(maps["onScaleStart"], datas, "", vars, props);
      final onScaleUpdate =
          getValue(maps["onScaleUpdate"], datas, "", vars, props);
      final onScaleEnd = getValue(maps["onScaleEnd"], datas, "", vars, props);
      final behavior = getValue(maps["behavior"], datas, "", vars, props);
      final excludeFromSemantics =
          getValue(maps["excludeFromSemantics"], datas, "", vars, props);
      final dragStartBehavior =
          getValue(maps["dragStartBehavior"], datas, "", vars, props);
      final trackpadScrollCausesScale =
          getValue(maps["trackpadScrollCausesScale"], datas, "", vars, props);
      final trackpadScrollToScaleFactor =
          getValue(maps["trackpadScrollToScaleFactor"], datas, "", vars, props);
      final supportedDevices =
          getValue(maps["supportedDevices"], datas, "", vars, props);
      return GestureDetector(
          key: key,
          child: child,
          onTapDown: onTapDown,
          onTapUp: onTapUp,
          onTap: onTap,
          onTapCancel: onTapCancel,
          onSecondaryTap: onSecondaryTap,
          onSecondaryTapDown: onSecondaryTapDown,
          onSecondaryTapUp: onSecondaryTapUp,
          onSecondaryTapCancel: onSecondaryTapCancel,
          onTertiaryTapDown: onTertiaryTapDown,
          onTertiaryTapUp: onTertiaryTapUp,
          onTertiaryTapCancel: onTertiaryTapCancel,
          onDoubleTapDown: onDoubleTapDown,
          onDoubleTap: onDoubleTap,
          onDoubleTapCancel: onDoubleTapCancel,
          onLongPressDown: onLongPressDown,
          onLongPressCancel: onLongPressCancel,
          onLongPress: onLongPress,
          onLongPressStart: onLongPressStart,
          onLongPressMoveUpdate: onLongPressMoveUpdate,
          onLongPressUp: onLongPressUp,
          onLongPressEnd: onLongPressEnd,
          onSecondaryLongPressDown: onSecondaryLongPressDown,
          onSecondaryLongPressCancel: onSecondaryLongPressCancel,
          onSecondaryLongPress: onSecondaryLongPress,
          onSecondaryLongPressStart: onSecondaryLongPressStart,
          onSecondaryLongPressMoveUpdate: onSecondaryLongPressMoveUpdate,
          onSecondaryLongPressUp: onSecondaryLongPressUp,
          onSecondaryLongPressEnd: onSecondaryLongPressEnd,
          onTertiaryLongPressDown: onTertiaryLongPressDown,
          onTertiaryLongPressCancel: onTertiaryLongPressCancel,
          onTertiaryLongPress: onTertiaryLongPress,
          onTertiaryLongPressStart: onTertiaryLongPressStart,
          onTertiaryLongPressMoveUpdate: onTertiaryLongPressMoveUpdate,
          onTertiaryLongPressUp: onTertiaryLongPressUp,
          onTertiaryLongPressEnd: onTertiaryLongPressEnd,
          onVerticalDragDown: onVerticalDragDown,
          onVerticalDragStart: onVerticalDragStart,
          onVerticalDragUpdate: onVerticalDragUpdate,
          onVerticalDragEnd: onVerticalDragEnd,
          onVerticalDragCancel: onVerticalDragCancel,
          onHorizontalDragDown: onHorizontalDragDown,
          onHorizontalDragStart: onHorizontalDragStart,
          onHorizontalDragUpdate: onHorizontalDragUpdate,
          onHorizontalDragEnd: onHorizontalDragEnd,
          onHorizontalDragCancel: onHorizontalDragCancel,
          onForcePressStart: onForcePressStart,
          onForcePressPeak: onForcePressPeak,
          onForcePressUpdate: onForcePressUpdate,
          onForcePressEnd: onForcePressEnd,
          onPanDown: onPanDown,
          onPanStart: onPanStart,
          onPanUpdate: onPanUpdate,
          onPanEnd: onPanEnd,
          onPanCancel: onPanCancel,
          onScaleStart: onScaleStart,
          onScaleUpdate: onScaleUpdate,
          onScaleEnd: onScaleEnd,
          behavior: behavior,
          excludeFromSemantics: excludeFromSemantics ?? false,
          dragStartBehavior: dragStartBehavior ?? DragStartBehavior.start,
          trackpadScrollCausesScale: trackpadScrollCausesScale ?? false,
          trackpadScrollToScaleFactor: trackpadScrollToScaleFactor ??
              kDefaultTrackpadScrollToScaleFactor,
          supportedDevices: supportedDevices);
    },
    "GestureRecognizerFactoryWithHandlers": () {
      final _constructor = getValue(maps["0"], datas,
          "GestureRecognizerFactoryConstructor<T>", vars, props);
      final _initializer = getValue(maps["1"], datas,
          "GestureRecognizerFactoryInitializer<T>", vars, props);
      if (_constructor == null || _initializer == null) {
        return null;
      }
      return GestureRecognizerFactoryWithHandlers(_constructor!, _initializer!);
    },
    "GestureSettings": () {
      final physicalTouchSlop =
          getValue(maps["physicalTouchSlop"], datas, "double?", vars, props);
      final physicalDoubleTapSlop = getValue(
          maps["physicalDoubleTapSlop"], datas, "double?", vars, props);
      return ui.GestureSettings(
          physicalTouchSlop: physicalTouchSlop,
          physicalDoubleTapSlop: physicalDoubleTapSlop);
    },
    "GlobalObjectKey": () {
      final value = getValue(maps["0"], datas, "Object", vars, props);
      if (value == null) {
        return null;
      }
      return GlobalObjectKey(value!);
    },
    "GlowingOverscrollIndicator": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final showLeading =
          getValue(maps["showLeading"], datas, "bool", vars, props);
      final showTrailing =
          getValue(maps["showTrailing"], datas, "bool", vars, props);
      final axisDirection =
          getValue(maps["axisDirection"], datas, "AxisDirection", vars, props);
      final color = getValue(maps["color"], datas, "Color", vars, props);
      final notificationPredicate = getValue(maps["notificationPredicate"],
          datas, "ScrollNotificationPredicate", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      if (axisDirection == null || color == null) {
        return null;
      }
      return GlowingOverscrollIndicator(
          key: key,
          showLeading: showLeading ?? true,
          showTrailing: showTrailing ?? true,
          axisDirection: axisDirection!,
          color: color!,
          notificationPredicate:
              notificationPredicate ?? defaultScrollNotificationPredicate,
          child: child);
//  },"Gradient.linear": () {
// final from = getValue(maps["0"], datas, "Offset", vars, props);final to = getValue(maps["1"], datas, "Offset", vars, props);final colors = getValue(maps["2"], datas, "List<Color>", vars, props);final colorStops = getValue(maps["3"], datas, "List<double>?", vars, props);final tileMode = getValue(maps["4"], datas, "TileMode", vars, props);final matrix4 = getValue(maps["5"], datas, "Float64List?", vars, props);if (from == null || to == null || colors == null){ return null; }return Gradient.linear(from!, to!, List<Color>.from(colors!), colorStops  != null ? List<double>.from(colorStops) : null, tileMode ?? TileMode.clamp, matrix4);
//  },"Gradient.radial": () {
// final center = getValue(maps["0"], datas, "Offset", vars, props);final radius = getValue(maps["1"], datas, "double", vars, props);final colors
// = getValue(maps["2"], datas, "List<Color>", vars, props);final colorStops = getValue(maps["3"], datas, "List<double>?", vars, props);final tileMode = getValue(maps["4"], datas, "TileMode", vars, props);final matrix4 = getValue(maps["5"], datas, "Float64List?", vars, props);final focal
// = getValue(maps["6"], datas, "Offset?", vars, props);final focalRadius = getValue(maps["7"], datas, "double", vars, props);if (center == null || radius == null || colors == null){ return null; }return Gradient.radial(center!, radius!, List<Color>.from(colors!), colorStops  != null ? List<double>.from(colorStops) : null, tileMode ?? TileMode.clamp, matrix4, focal, focalRadius ?? 0.0);
//  },"Gradient.sweep": () {
// final center = getValue(maps["0"], datas, "Offset", vars, props);final colors = getValue(maps["1"], datas, "List<Color>", vars, props);final colorStops = getValue(maps["2"], datas, "List<double>?", vars, props);final tileMode = getValue(maps["3"], datas, "TileMode", vars, props);final
// startAngle = getValue(maps["4"], datas, "double", vars, props);final endAngle = getValue(maps["5"], datas, "double", vars, props);final matrix4 = getValue(maps["6"], datas, "Float64List?", vars, props);if (center == null || colors == null){ return null; }return Gradient.sweep(center!, List<Color>.from(colors!), colorStops  != null ? List<double>.from(colorStops) : null, tileMode ?? TileMode.clamp, startAngle ?? 0.0, endAngle ?? math.pi * 2, matrix4);
    },
    "GradientRotation": () {
      final radians = getValue(maps["0"], datas, "double", vars, props);
      if (radians == null) {
        return null;
      }
      return GradientRotation(radians!);
    },
    "GranularlyExtendSelectionEvent": () {
      final forward = getValue(maps["forward"], datas, "bool", vars, props);
      final isEnd = getValue(maps["isEnd"], datas, "bool", vars, props);
      final granularity =
          getValue(maps["granularity"], datas, "TextGranularity", vars, props);
      if (forward == null || isEnd == null || granularity == null) {
        return null;
      }
      return GranularlyExtendSelectionEvent(
          forward: forward!, isEnd: isEnd!, granularity: granularity!);
    },
    "GravitySimulation": () {
      final acceleration = getValue(maps["0"], datas, "double", vars, props);
      final distance = getValue(maps["1"], datas, "double", vars, props);
      final endDistance = getValue(maps["2"], datas, "double", vars, props);
      final velocity = getValue(maps["3"], datas, "double", vars, props);
      if (acceleration == null ||
          distance == null ||
          endDistance == null ||
          velocity == null) {
        return null;
      }
      return GravitySimulation(
          acceleration!, distance!, endDistance!, velocity!);
    },
    "GridPaper": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final color = getValue(maps["color"], datas, "", vars, props);
      final interval = getValue(maps["interval"], datas, "", vars, props);
      final divisions = getValue(maps["divisions"], datas, "", vars, props);
      final subdivisions =
          getValue(maps["subdivisions"], datas, "", vars, props);
      final child = getValue(maps["child"], datas, "", vars, props);
      return GridPaper(
          key: key,
          color: color ?? const Color(0x7FC3E8F3),
          interval: interval ?? 100.0,
          divisions: divisions ?? 2,
          subdivisions: subdivisions ?? 5,
          child: child);
    },
    "GridTile": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final header = getValue(maps["header"], datas, "Widget?", vars, props);
      final footer = getValue(maps["footer"], datas, "Widget?", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (child == null) {
        return null;
      }
      return GridTile(key: key, header: header, footer: footer, child: child!);
    },
    "GridTileBar": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final backgroundColor =
          getValue(maps["backgroundColor"], datas, "Color?", vars, props);
      final leading = getValue(maps["leading"], datas, "Widget?", vars, props);
      final title = getValue(maps["title"], datas, "Widget?", vars, props);
      final subtitle =
          getValue(maps["subtitle"], datas, "Widget?", vars, props);
      final trailing =
          getValue(maps["trailing"], datas, "Widget?", vars, props);
      return GridTileBar(
          key: key,
          backgroundColor: backgroundColor,
          leading: leading,
          title: title,
          subtitle: subtitle,
          trailing: trailing);
    },
    "GridView": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final scrollDirection =
          getValue(maps["scrollDirection"], datas, "Axis", vars, props);
      final reverse = getValue(maps["reverse"], datas, "bool", vars, props);
      final controller =
          getValue(maps["controller"], datas, "ScrollController?", vars, props);
      final primary = getValue(maps["primary"], datas, "bool?", vars, props);
      final physics =
          getValue(maps["physics"], datas, "ScrollPhysics?", vars, props);
      final shrinkWrap =
          getValue(maps["shrinkWrap"], datas, "bool", vars, props);
      final padding =
          getValue(maps["padding"], datas, "EdgeInsetsGeometry?", vars, props);
      final gridDelegate = getValue(
          maps["gridDelegate"], datas, "SliverGridDelegate", vars, props);
      final addAutomaticKeepAlives =
          getValue(maps["addAutomaticKeepAlives"], datas, "bool", vars, props);
      final addRepaintBoundaries =
          getValue(maps["addRepaintBoundaries"], datas, "bool", vars, props);
      final addSemanticIndexes =
          getValue(maps["addSemanticIndexes"], datas, "bool", vars, props);
      final cacheExtent =
          getValue(maps["cacheExtent"], datas, "double?", vars, props);
      final children =
          getValue(maps["children"], datas, "List<Widget>", vars, props);
      final semanticChildCount =
          getValue(maps["semanticChildCount"], datas, "int?", vars, props);
      final dragStartBehavior = getValue(
          maps["dragStartBehavior"], datas, "DragStartBehavior", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      final keyboardDismissBehavior = getValue(maps["keyboardDismissBehavior"],
          datas, "ScrollViewKeyboardDismissBehavior", vars, props);
      final restorationId =
          getValue(maps["restorationId"], datas, "String?", vars, props);
      if (gridDelegate == null) {
        return null;
      }
      return GridView(
          key: key,
          scrollDirection: scrollDirection ?? Axis.vertical,
          reverse: reverse ?? false,
          controller: controller,
          primary: primary,
          physics: physics,
          shrinkWrap: shrinkWrap ?? false,
          padding: padding,
          gridDelegate: gridDelegate!,
          addAutomaticKeepAlives: addAutomaticKeepAlives ?? true,
          addRepaintBoundaries: addRepaintBoundaries ?? true,
          addSemanticIndexes: addSemanticIndexes ?? true,
          cacheExtent: cacheExtent,
          semanticChildCount: semanticChildCount,
          dragStartBehavior: dragStartBehavior ?? DragStartBehavior.start,
          clipBehavior: clipBehavior ?? Clip.hardEdge,
          keyboardDismissBehavior: keyboardDismissBehavior ??
              ScrollViewKeyboardDismissBehavior.manual,
          restorationId: restorationId,
          children: List<Widget>.from(children ?? const <Widget>[]));
    },
    "GridView.builder": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final scrollDirection =
          getValue(maps["scrollDirection"], datas, "Axis", vars, props);
      final reverse = getValue(maps["reverse"], datas, "bool", vars, props);
      final controller =
          getValue(maps["controller"], datas, "ScrollController?", vars, props);
      final primary = getValue(maps["primary"], datas, "bool?", vars, props);
      final physics =
          getValue(maps["physics"], datas, "ScrollPhysics?", vars, props);
      final shrinkWrap =
          getValue(maps["shrinkWrap"], datas, "bool", vars, props);
      final padding =
          getValue(maps["padding"], datas, "EdgeInsetsGeometry?", vars, props);
      final gridDelegate = getValue(
          maps["gridDelegate"], datas, "SliverGridDelegate", vars, props);
      final itemBuilder = getValue(maps["itemBuilder"], datas,
          "NullableIndexedWidgetBuilder", vars, props);
      final findChildIndexCallback = getValue(maps["findChildIndexCallback"],
          datas, "ChildIndexGetter?", vars, props);
      final itemCount = getValue(maps["itemCount"], datas, "int?", vars, props);
      final addAutomaticKeepAlives =
          getValue(maps["addAutomaticKeepAlives"], datas, "bool", vars, props);
      final addRepaintBoundaries =
          getValue(maps["addRepaintBoundaries"], datas, "bool", vars, props);
      final addSemanticIndexes =
          getValue(maps["addSemanticIndexes"], datas, "bool", vars, props);
      final cacheExtent =
          getValue(maps["cacheExtent"], datas, "double?", vars, props);
      final semanticChildCount =
          getValue(maps["semanticChildCount"], datas, "int?", vars, props);
      final dragStartBehavior = getValue(
          maps["dragStartBehavior"], datas, "DragStartBehavior", vars, props);
      final keyboardDismissBehavior = getValue(maps["keyboardDismissBehavior"],
          datas, "ScrollViewKeyboardDismissBehavior", vars, props);
      final restorationId =
          getValue(maps["restorationId"], datas, "String?", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      if (gridDelegate == null || itemBuilder == null) {
        return null;
      }
      return GridView.builder(
          key: key,
          scrollDirection: scrollDirection ?? Axis.vertical,
          reverse: reverse ?? false,
          controller: controller,
          primary: primary,
          physics: physics,
          shrinkWrap: shrinkWrap ?? false,
          padding: padding,
          gridDelegate: gridDelegate!,
          itemBuilder: itemBuilder!,
          findChildIndexCallback: findChildIndexCallback,
          itemCount: itemCount,
          addAutomaticKeepAlives: addAutomaticKeepAlives ?? true,
          addRepaintBoundaries: addRepaintBoundaries ?? true,
          addSemanticIndexes: addSemanticIndexes ?? true,
          cacheExtent: cacheExtent,
          semanticChildCount: semanticChildCount,
          dragStartBehavior: dragStartBehavior ?? DragStartBehavior.start,
          keyboardDismissBehavior: keyboardDismissBehavior ??
              ScrollViewKeyboardDismissBehavior.manual,
          restorationId: restorationId,
          clipBehavior: clipBehavior ?? Clip.hardEdge);
    },
    "GridView.custom": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final scrollDirection =
          getValue(maps["scrollDirection"], datas, "Axis", vars, props);
      final reverse = getValue(maps["reverse"], datas, "bool", vars, props);
      final controller =
          getValue(maps["controller"], datas, "ScrollController?", vars, props);
      final primary = getValue(maps["primary"], datas, "bool?", vars, props);
      final physics =
          getValue(maps["physics"], datas, "ScrollPhysics?", vars, props);
      final shrinkWrap =
          getValue(maps["shrinkWrap"], datas, "bool", vars, props);
      final padding =
          getValue(maps["padding"], datas, "EdgeInsetsGeometry?", vars, props);
      final gridDelegate = getValue(
          maps["gridDelegate"], datas, "SliverGridDelegate", vars, props);
      final childrenDelegate = getValue(
          maps["childrenDelegate"], datas, "SliverChildDelegate", vars, props);
      final cacheExtent =
          getValue(maps["cacheExtent"], datas, "double?", vars, props);
      final semanticChildCount =
          getValue(maps["semanticChildCount"], datas, "int?", vars, props);
      final dragStartBehavior = getValue(
          maps["dragStartBehavior"], datas, "DragStartBehavior", vars, props);
      final keyboardDismissBehavior = getValue(maps["keyboardDismissBehavior"],
          datas, "ScrollViewKeyboardDismissBehavior", vars, props);
      final restorationId =
          getValue(maps["restorationId"], datas, "String?", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      if (gridDelegate == null || childrenDelegate == null) {
        return null;
      }
      return GridView.custom(
          key: key,
          scrollDirection: scrollDirection ?? Axis.vertical,
          reverse: reverse ?? false,
          controller: controller,
          primary: primary,
          physics: physics,
          shrinkWrap: shrinkWrap ?? false,
          padding: padding,
          gridDelegate: gridDelegate!,
          childrenDelegate: childrenDelegate!,
          cacheExtent: cacheExtent,
          semanticChildCount: semanticChildCount,
          dragStartBehavior: dragStartBehavior ?? DragStartBehavior.start,
          keyboardDismissBehavior: keyboardDismissBehavior ??
              ScrollViewKeyboardDismissBehavior.manual,
          restorationId: restorationId,
          clipBehavior: clipBehavior ?? Clip.hardEdge);
    },
    "GridView.count": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final scrollDirection =
          getValue(maps["scrollDirection"], datas, "Axis", vars, props);
      final reverse = getValue(maps["reverse"], datas, "bool", vars, props);
      final controller =
          getValue(maps["controller"], datas, "ScrollController?", vars, props);
      final primary = getValue(maps["primary"], datas, "bool?", vars, props);
      final physics =
          getValue(maps["physics"], datas, "ScrollPhysics?", vars, props);
      final shrinkWrap =
          getValue(maps["shrinkWrap"], datas, "bool", vars, props);
      final padding =
          getValue(maps["padding"], datas, "EdgeInsetsGeometry?", vars, props);
      final crossAxisCount =
          getValue(maps["crossAxisCount"], datas, "int", vars, props);
      final mainAxisSpacing =
          getValue(maps["mainAxisSpacing"], datas, "double", vars, props);
      final crossAxisSpacing =
          getValue(maps["crossAxisSpacing"], datas, "double", vars, props);
      final childAspectRatio =
          getValue(maps["childAspectRatio"], datas, "double", vars, props);
      final addAutomaticKeepAlives =
          getValue(maps["addAutomaticKeepAlives"], datas, "bool", vars, props);
      final addRepaintBoundaries =
          getValue(maps["addRepaintBoundaries"], datas, "bool", vars, props);
      final addSemanticIndexes =
          getValue(maps["addSemanticIndexes"], datas, "bool", vars, props);
      final cacheExtent =
          getValue(maps["cacheExtent"], datas, "double?", vars, props);
      final children =
          getValue(maps["children"], datas, "List<Widget>", vars, props);
      final semanticChildCount =
          getValue(maps["semanticChildCount"], datas, "int?", vars, props);
      final dragStartBehavior = getValue(
          maps["dragStartBehavior"], datas, "DragStartBehavior", vars, props);
      final keyboardDismissBehavior = getValue(maps["keyboardDismissBehavior"],
          datas, "ScrollViewKeyboardDismissBehavior", vars, props);
      final restorationId =
          getValue(maps["restorationId"], datas, "String?", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      if (crossAxisCount == null) {
        return null;
      }
      return GridView.count(
          key: key,
          scrollDirection: scrollDirection ?? Axis.vertical,
          reverse: reverse ?? false,
          controller: controller,
          primary: primary,
          physics: physics,
          shrinkWrap: shrinkWrap ?? false,
          padding: padding,
          crossAxisCount: crossAxisCount!,
          mainAxisSpacing: mainAxisSpacing ?? 0.0,
          crossAxisSpacing: crossAxisSpacing ?? 0.0,
          childAspectRatio: childAspectRatio ?? 1.0,
          addAutomaticKeepAlives: addAutomaticKeepAlives ?? true,
          addRepaintBoundaries: addRepaintBoundaries ?? true,
          addSemanticIndexes: addSemanticIndexes ?? true,
          cacheExtent: cacheExtent,
          semanticChildCount: semanticChildCount,
          dragStartBehavior: dragStartBehavior ?? DragStartBehavior.start,
          keyboardDismissBehavior: keyboardDismissBehavior ??
              ScrollViewKeyboardDismissBehavior.manual,
          restorationId: restorationId,
          clipBehavior: clipBehavior ?? Clip.hardEdge,
          children: List<Widget>.from(children ?? const <Widget>[]));
    },
    "GridView.extent": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final scrollDirection =
          getValue(maps["scrollDirection"], datas, "Axis", vars, props);
      final reverse = getValue(maps["reverse"], datas, "bool", vars, props);
      final controller =
          getValue(maps["controller"], datas, "ScrollController?", vars, props);
      final primary = getValue(maps["primary"], datas, "bool?", vars, props);
      final physics =
          getValue(maps["physics"], datas, "ScrollPhysics?", vars, props);
      final shrinkWrap =
          getValue(maps["shrinkWrap"], datas, "bool", vars, props);
      final padding =
          getValue(maps["padding"], datas, "EdgeInsetsGeometry?", vars, props);
      final maxCrossAxisExtent =
          getValue(maps["maxCrossAxisExtent"], datas, "double", vars, props);
      final mainAxisSpacing =
          getValue(maps["mainAxisSpacing"], datas, "double", vars, props);
      final crossAxisSpacing =
          getValue(maps["crossAxisSpacing"], datas, "double", vars, props);
      final childAspectRatio =
          getValue(maps["childAspectRatio"], datas, "double", vars, props);
      final addAutomaticKeepAlives =
          getValue(maps["addAutomaticKeepAlives"], datas, "bool", vars, props);
      final addRepaintBoundaries =
          getValue(maps["addRepaintBoundaries"], datas, "bool", vars, props);
      final addSemanticIndexes =
          getValue(maps["addSemanticIndexes"], datas, "bool", vars, props);
      final cacheExtent =
          getValue(maps["cacheExtent"], datas, "double?", vars, props);
      final children =
          getValue(maps["children"], datas, "List<Widget>", vars, props);
      final semanticChildCount =
          getValue(maps["semanticChildCount"], datas, "int?", vars, props);
      final dragStartBehavior = getValue(
          maps["dragStartBehavior"], datas, "DragStartBehavior", vars, props);
      final keyboardDismissBehavior = getValue(maps["keyboardDismissBehavior"],
          datas, "ScrollViewKeyboardDismissBehavior", vars, props);
      final restorationId =
          getValue(maps["restorationId"], datas, "String?", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      if (maxCrossAxisExtent == null) {
        return null;
      }
      return GridView.extent(
          key: key,
          scrollDirection: scrollDirection ?? Axis.vertical,
          reverse: reverse ?? false,
          controller: controller,
          primary: primary,
          physics: physics,
          shrinkWrap: shrinkWrap ?? false,
          padding: padding,
          maxCrossAxisExtent: maxCrossAxisExtent!,
          mainAxisSpacing: mainAxisSpacing ?? 0.0,
          crossAxisSpacing: crossAxisSpacing ?? 0.0,
          childAspectRatio: childAspectRatio ?? 1.0,
          addAutomaticKeepAlives: addAutomaticKeepAlives ?? true,
          addRepaintBoundaries: addRepaintBoundaries ?? true,
          addSemanticIndexes: addSemanticIndexes ?? true,
          cacheExtent: cacheExtent,
          semanticChildCount: semanticChildCount,
          dragStartBehavior: dragStartBehavior ?? DragStartBehavior.start,
          keyboardDismissBehavior: keyboardDismissBehavior ??
              ScrollViewKeyboardDismissBehavior.manual,
          restorationId: restorationId,
          clipBehavior: clipBehavior ?? Clip.hardEdge,
          children: List<Widget>.from(children ?? const <Widget>[]));
    },
    "HSVColor.fromAHSV": () {
      final alpha = getValue(maps["0"], datas, "double", vars, props);
      final hue = getValue(maps["1"], datas, "double", vars, props);
      final saturation = getValue(maps["2"], datas, "double", vars, props);
      final value = getValue(maps["3"], datas, "double", vars, props);
      if (alpha == null || hue == null || saturation == null || value == null) {
        return null;
      }
      return HSVColor.fromAHSV(alpha!, hue!, saturation!, value!);
    },
    "HSVColor.fromColor": () {
      final color = getValue(maps["0"], datas, "Color", vars, props);
      if (color == null) {
        return null;
      }
      return HSVColor.fromColor(color!);
    },
    "Hero": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final tag = getValue(maps["tag"], datas, "Object", vars, props);
      final createRectTween = getValue(
          maps["createRectTween"], datas, "CreateRectTween?", vars, props);
      final flightShuttleBuilder = getValue(maps["flightShuttleBuilder"], datas,
          "HeroFlightShuttleBuilder?", vars, props);
      final placeholderBuilder = getValue(maps["placeholderBuilder"], datas,
          "HeroPlaceholderBuilder?", vars, props);
      final transitionOnUserGestures = getValue(
          maps["transitionOnUserGestures"], datas, "bool", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (tag == null || child == null) {
        return null;
      }
      return Hero(
          key: key,
          tag: tag!,
          createRectTween: createRectTween,
          flightShuttleBuilder: flightShuttleBuilder,
          placeholderBuilder: placeholderBuilder,
          transitionOnUserGestures: transitionOnUserGestures ?? false,
          child: child!);
    },
    "HeroControllerScope": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final controller =
          getValue(maps["controller"], datas, "HeroController", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (controller == null || child == null) {
        return null;
      }
      return HeroControllerScope(
          key: key, controller: controller!, child: child!);
    },
    "HeroControllerScope.none": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (child == null) {
        return null;
      }
      return HeroControllerScope.none(key: key, child: child!);
    },
    "HitTestEntry": () {
      final target = getValue(maps["0"], datas, "T", vars, props);
      if (target == null) {
        return null;
      }
      return HitTestEntry<H>(target!);
    },
    "HitTestResult": () {
      return HitTestResult();
    },
    "HitTestResult.wrap": () {
      final result = getValue(maps["0"], datas, "HitTestResult", vars, props);
      if (result == null) {
        return null;
      }
      return HitTestResult.wrap(result!);
    },
    "HoldScrollActivity": () {
      final delegate = getValue(
          maps["delegate"], datas, "ScrollActivityDelegate", vars, props);
      final onHoldCanceled =
          getValue(maps["onHoldCanceled"], datas, "VoidCallback?", vars, props);
      if (delegate == null) {
        return null;
      }
      return HoldScrollActivity(
          delegate: delegate!, onHoldCanceled: onHoldCanceled);
    },
    "HorizontalDragGestureRecognizer": () {
      final debugOwner = getValue(maps["debugOwner"], datas, "", vars, props);
      final supportedDevices =
          getValue(maps["supportedDevices"], datas, "", vars, props);
      final allowedButtonsFilter = getValue(maps["allowedButtonsFilter"], datas,
          "AllowedButtonsFilter?", vars, props);
      return HorizontalDragGestureRecognizer(
          debugOwner: debugOwner,
          supportedDevices: supportedDevices,
          allowedButtonsFilter: allowedButtonsFilter);
    },
    "HorizontalMultiDragGestureRecognizer": () {
      final debugOwner =
          getValue(maps["debugOwner"], datas, "Object?", vars, props);
      final supportedDevices = getValue(maps["supportedDevices"], datas,
          "Set<PointerDeviceKind>?", vars, props);
      final allowedButtonsFilter = getValue(maps["allowedButtonsFilter"], datas,
          "AllowedButtonsFilter?", vars, props);
      return HorizontalMultiDragGestureRecognizer(
          debugOwner: debugOwner,
          supportedDevices: supportedDevices
              ? Set<PointerDeviceKind>.from(supportedDevices)
              : null,
          allowedButtonsFilter: allowedButtonsFilter);
    },
    "HtmlElementView": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final viewType = getValue(maps["viewType"], datas, "", vars, props);
      final onPlatformViewCreated =
          getValue(maps["onPlatformViewCreated"], datas, "", vars, props);
      if (viewType == null) {
        return null;
      }
      return HtmlElementView(
          key: key,
          viewType: viewType!,
          onPlatformViewCreated: onPlatformViewCreated);
    },
    "IOSScrollViewFlingVelocityTracker": () {
      final kind = getValue(maps["0"], datas, "", vars, props);
      if (kind == null) {
        return null;
      }
      return IOSScrollViewFlingVelocityTracker(kind!);
    },
    "Icon": () {
      final icon = getValue(maps["0"], datas, "IconData?", vars, props);
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final size = getValue(maps["size"], datas, "double?", vars, props);
      final fill = getValue(maps["fill"], datas, "double?", vars, props);
      final weight = getValue(maps["weight"], datas, "double?", vars, props);
      final grade = getValue(maps["grade"], datas, "double?", vars, props);
      final opticalSize =
          getValue(maps["opticalSize"], datas, "double?", vars, props);
      final color = getValue(maps["color"], datas, "Color?", vars, props);
      final shadows =
          getValue(maps["shadows"], datas, "List<Shadow>?", vars, props);
      final semanticLabel =
          getValue(maps["semanticLabel"], datas, "String?", vars, props);
      final textDirection =
          getValue(maps["textDirection"], datas, "TextDirection?", vars, props);
      if (icon == null) {
        return null;
      }
      return Icon(icon!,
          key: key,
          size: size,
          fill: fill,
          weight: weight,
          grade: grade,
          opticalSize: opticalSize,
          color: color,
          shadows: shadows != null ? List<Shadow>.from(shadows) : null,
          semanticLabel: semanticLabel,
          textDirection: textDirection);
    },
    "IconButton": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final iconSize =
          getValue(maps["iconSize"], datas, "double?", vars, props);
      final visualDensity =
          getValue(maps["visualDensity"], datas, "VisualDensity?", vars, props);
      final padding =
          getValue(maps["padding"], datas, "EdgeInsetsGeometry?", vars, props);
      final alignment =
          getValue(maps["alignment"], datas, "AlignmentGeometry?", vars, props);
      final splashRadius =
          getValue(maps["splashRadius"], datas, "double?", vars, props);
      final color = getValue(maps["color"], datas, "Color?", vars, props);
      final focusColor =
          getValue(maps["focusColor"], datas, "Color?", vars, props);
      final hoverColor =
          getValue(maps["hoverColor"], datas, "Color?", vars, props);
      final highlightColor =
          getValue(maps["highlightColor"], datas, "Color?", vars, props);
      final splashColor =
          getValue(maps["splashColor"], datas, "Color?", vars, props);
      final disabledColor =
          getValue(maps["disabledColor"], datas, "Color?", vars, props);
      final onPressed =
          getValue(maps["onPressed"], datas, "VoidCallback?", vars, props);
      final mouseCursor =
          getValue(maps["mouseCursor"], datas, "MouseCursor?", vars, props);
      final focusNode =
          getValue(maps["focusNode"], datas, "FocusNode?", vars, props);
      final autofocus = getValue(maps["autofocus"], datas, "bool", vars, props);
      final tooltip = getValue(maps["tooltip"], datas, "String?", vars, props);
      final enableFeedback =
          getValue(maps["enableFeedback"], datas, "bool?", vars, props);
      final constraints =
          getValue(maps["constraints"], datas, "BoxConstraints?", vars, props);
      final style = getValue(maps["style"], datas, "ButtonStyle?", vars, props);
      final isSelected =
          getValue(maps["isSelected"], datas, "bool?", vars, props);
      final selectedIcon =
          getValue(maps["selectedIcon"], datas, "Widget?", vars, props);
      final icon = getValue(maps["icon"], datas, "double?", vars, props);
      if (onPressed == null || icon == null) {
        return null;
      }
      return IconButton(
          key: key,
          iconSize: iconSize,
          visualDensity: visualDensity,
          padding: padding,
          alignment: alignment,
          splashRadius: splashRadius,
          color: color,
          focusColor: focusColor,
          hoverColor: hoverColor,
          highlightColor: highlightColor,
          splashColor: splashColor,
          disabledColor: disabledColor,
          onPressed: onPressed!,
          mouseCursor: mouseCursor,
          focusNode: focusNode,
          autofocus: autofocus ?? false,
          tooltip: tooltip,
          enableFeedback: enableFeedback,
          constraints: constraints,
          style: style,
          isSelected: isSelected,
          selectedIcon: selectedIcon,
          icon: icon!);
    },
    "IconButton.filled": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final iconSize =
          getValue(maps["iconSize"], datas, "double?", vars, props);
      final visualDensity =
          getValue(maps["visualDensity"], datas, "VisualDensity?", vars, props);
      final padding =
          getValue(maps["padding"], datas, "EdgeInsetsGeometry?", vars, props);
      final alignment =
          getValue(maps["alignment"], datas, "AlignmentGeometry?", vars, props);
      final splashRadius =
          getValue(maps["splashRadius"], datas, "double?", vars, props);
      final color = getValue(maps["color"], datas, "Color?", vars, props);
      final focusColor =
          getValue(maps["focusColor"], datas, "Color?", vars, props);
      final hoverColor =
          getValue(maps["hoverColor"], datas, "Color?", vars, props);
      final highlightColor =
          getValue(maps["highlightColor"], datas, "Color?", vars, props);
      final splashColor =
          getValue(maps["splashColor"], datas, "Color?", vars, props);
      final disabledColor =
          getValue(maps["disabledColor"], datas, "Color?", vars, props);
      final onPressed =
          getValue(maps["onPressed"], datas, "VoidCallback?", vars, props);
      final mouseCursor =
          getValue(maps["mouseCursor"], datas, "MouseCursor?", vars, props);
      final focusNode =
          getValue(maps["focusNode"], datas, "FocusNode?", vars, props);
      final autofocus = getValue(maps["autofocus"], datas, "bool", vars, props);
      final tooltip = getValue(maps["tooltip"], datas, "String?", vars, props);
      final enableFeedback =
          getValue(maps["enableFeedback"], datas, "bool?", vars, props);
      final constraints =
          getValue(maps["constraints"], datas, "BoxConstraints?", vars, props);
      final style = getValue(maps["style"], datas, "ButtonStyle?", vars, props);
      final isSelected =
          getValue(maps["isSelected"], datas, "bool?", vars, props);
      final selectedIcon =
          getValue(maps["selectedIcon"], datas, "Widget?", vars, props);
      final icon = getValue(maps["icon"], datas, "double?", vars, props);
      if (onPressed == null || icon == null) {
        return null;
      }
      return IconButton.filled(
          key: key,
          iconSize: iconSize,
          visualDensity: visualDensity,
          padding: padding,
          alignment: alignment,
          splashRadius: splashRadius,
          color: color,
          focusColor: focusColor,
          hoverColor: hoverColor,
          highlightColor: highlightColor,
          splashColor: splashColor,
          disabledColor: disabledColor,
          onPressed: onPressed!,
          mouseCursor: mouseCursor,
          focusNode: focusNode,
          autofocus: autofocus ?? false,
          tooltip: tooltip,
          enableFeedback: enableFeedback,
          constraints: constraints,
          style: style,
          isSelected: isSelected,
          selectedIcon: selectedIcon,
          icon: icon!);
    },
    "IconButton.filledTonal": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final iconSize =
          getValue(maps["iconSize"], datas, "double?", vars, props);
      final visualDensity =
          getValue(maps["visualDensity"], datas, "VisualDensity?", vars, props);
      final padding =
          getValue(maps["padding"], datas, "EdgeInsetsGeometry?", vars, props);
      final alignment =
          getValue(maps["alignment"], datas, "AlignmentGeometry?", vars, props);
      final splashRadius =
          getValue(maps["splashRadius"], datas, "double?", vars, props);
      final color = getValue(maps["color"], datas, "Color?", vars, props);
      final focusColor =
          getValue(maps["focusColor"], datas, "Color?", vars, props);
      final hoverColor =
          getValue(maps["hoverColor"], datas, "Color?", vars, props);
      final highlightColor =
          getValue(maps["highlightColor"], datas, "Color?", vars, props);
      final splashColor =
          getValue(maps["splashColor"], datas, "Color?", vars, props);
      final disabledColor =
          getValue(maps["disabledColor"], datas, "Color?", vars, props);
      final onPressed =
          getValue(maps["onPressed"], datas, "VoidCallback?", vars, props);
      final mouseCursor =
          getValue(maps["mouseCursor"], datas, "MouseCursor?", vars, props);
      final focusNode =
          getValue(maps["focusNode"], datas, "FocusNode?", vars, props);
      final autofocus = getValue(maps["autofocus"], datas, "bool", vars, props);
      final tooltip = getValue(maps["tooltip"], datas, "String?", vars, props);
      final enableFeedback =
          getValue(maps["enableFeedback"], datas, "bool?", vars, props);
      final constraints =
          getValue(maps["constraints"], datas, "BoxConstraints?", vars, props);
      final style = getValue(maps["style"], datas, "ButtonStyle?", vars, props);
      final isSelected =
          getValue(maps["isSelected"], datas, "bool?", vars, props);
      final selectedIcon =
          getValue(maps["selectedIcon"], datas, "Widget?", vars, props);
      final icon = getValue(maps["icon"], datas, "double?", vars, props);
      if (onPressed == null || icon == null) {
        return null;
      }
      return IconButton.filledTonal(
          key: key,
          iconSize: iconSize,
          visualDensity: visualDensity,
          padding: padding,
          alignment: alignment,
          splashRadius: splashRadius,
          color: color,
          focusColor: focusColor,
          hoverColor: hoverColor,
          highlightColor: highlightColor,
          splashColor: splashColor,
          disabledColor: disabledColor,
          onPressed: onPressed!,
          mouseCursor: mouseCursor,
          focusNode: focusNode,
          autofocus: autofocus ?? false,
          tooltip: tooltip,
          enableFeedback: enableFeedback,
          constraints: constraints,
          style: style,
          isSelected: isSelected,
          selectedIcon: selectedIcon,
          icon: icon!);
    },
    "IconButton.outlined": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final iconSize =
          getValue(maps["iconSize"], datas, "double?", vars, props);
      final visualDensity =
          getValue(maps["visualDensity"], datas, "VisualDensity?", vars, props);
      final padding =
          getValue(maps["padding"], datas, "EdgeInsetsGeometry?", vars, props);
      final alignment =
          getValue(maps["alignment"], datas, "AlignmentGeometry?", vars, props);
      final splashRadius =
          getValue(maps["splashRadius"], datas, "double?", vars, props);
      final color = getValue(maps["color"], datas, "Color?", vars, props);
      final focusColor =
          getValue(maps["focusColor"], datas, "Color?", vars, props);
      final hoverColor =
          getValue(maps["hoverColor"], datas, "Color?", vars, props);
      final highlightColor =
          getValue(maps["highlightColor"], datas, "Color?", vars, props);
      final splashColor =
          getValue(maps["splashColor"], datas, "Color?", vars, props);
      final disabledColor =
          getValue(maps["disabledColor"], datas, "Color?", vars, props);
      final onPressed =
          getValue(maps["onPressed"], datas, "VoidCallback?", vars, props);
      final mouseCursor =
          getValue(maps["mouseCursor"], datas, "MouseCursor?", vars, props);
      final focusNode =
          getValue(maps["focusNode"], datas, "FocusNode?", vars, props);
      final autofocus = getValue(maps["autofocus"], datas, "bool", vars, props);
      final tooltip = getValue(maps["tooltip"], datas, "String?", vars, props);
      final enableFeedback =
          getValue(maps["enableFeedback"], datas, "bool?", vars, props);
      final constraints =
          getValue(maps["constraints"], datas, "BoxConstraints?", vars, props);
      final style = getValue(maps["style"], datas, "ButtonStyle?", vars, props);
      final isSelected =
          getValue(maps["isSelected"], datas, "bool?", vars, props);
      final selectedIcon =
          getValue(maps["selectedIcon"], datas, "Widget?", vars, props);
      final icon = getValue(maps["icon"], datas, "double?", vars, props);
      if (onPressed == null || icon == null) {
        return null;
      }
      return IconButton.outlined(
          key: key,
          iconSize: iconSize,
          visualDensity: visualDensity,
          padding: padding,
          alignment: alignment,
          splashRadius: splashRadius,
          color: color,
          focusColor: focusColor,
          hoverColor: hoverColor,
          highlightColor: highlightColor,
          splashColor: splashColor,
          disabledColor: disabledColor,
          onPressed: onPressed!,
          mouseCursor: mouseCursor,
          focusNode: focusNode,
          autofocus: autofocus ?? false,
          tooltip: tooltip,
          enableFeedback: enableFeedback,
          constraints: constraints,
          style: style,
          isSelected: isSelected,
          selectedIcon: selectedIcon,
          icon: icon!);
    },
    "IconButtonTheme": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final data =
          getValue(maps["data"], datas, "IconButtonThemeData", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (data == null || child == null) {
        return null;
      }
      return IconButtonTheme(key: key, data: data!, child: child!);
    },
    "IconButtonThemeData": () {
      final style = getValue(maps["style"], datas, "ButtonStyle?", vars, props);
      return IconButtonThemeData(style: style);
    },
    "IconData": () {
      final codePoint = getValue(maps["0"], datas, "int", vars, props);
      final fontFamily =
          getValue(maps["fontFamily"], datas, "String?", vars, props);
      final fontPackage =
          getValue(maps["fontPackage"], datas, "String?", vars, props);
      final matchTextDirection =
          getValue(maps["matchTextDirection"], datas, "bool", vars, props);
      if (codePoint == null) {
        return null;
      }
      return IconData(codePoint!,
          fontFamily: fontFamily,
          fontPackage: fontPackage,
          matchTextDirection: matchTextDirection ?? false);
    },
    "IconTheme": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final data = getValue(maps["data"], datas, "IconThemeData", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (data == null || child == null) {
        return null;
      }
      return IconTheme(key: key, data: data!, child: child!);
    },
    "IconThemeData": () {
      final size = getValue(maps["size"], datas, "double?", vars, props);
      final fill = getValue(maps["fill"], datas, "double?", vars, props);
      final weight = getValue(maps["weight"], datas, "double?", vars, props);
      final grade = getValue(maps["grade"], datas, "double?", vars, props);
      final opticalSize =
          getValue(maps["opticalSize"], datas, "double?", vars, props);
      final color = getValue(maps["color"], datas, "Color?", vars, props);
      final opacity = getValue(maps["opacity"], datas, "double?", vars, props);
      final shadows =
          getValue(maps["shadows"], datas, "List<Shadow>?", vars, props);
      return IconThemeData(
          size: size,
          fill: fill,
          weight: weight,
          grade: grade,
          opticalSize: opticalSize,
          color: color,
          opacity: opacity,
          shadows: shadows != null ? List<Shadow>.from(shadows) : null);
    },
    "IconThemeData.fallback": () {
      return const IconThemeData.fallback();
    },
    "IdleScrollActivity": () {
      final delegate =
          getValue(maps["0"], datas, "ScrollActivityDelegate", vars, props);
      if (delegate == null) {
        return null;
      }
      return IdleScrollActivity(delegate!);
    },
    "IgnorePointer": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final ignoring = getValue(maps["ignoring"], datas, "bool", vars, props);
      final ignoringSemantics =
          getValue(maps["ignoringSemantics"], datas, "bool?", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      return IgnorePointer(
          key: key,
          ignoring: ignoring ?? true,
          ignoringSemantics: ignoringSemantics,
          child: child);
    },
    "Image": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final image =
          getValue(maps["image"], datas, "ImageProvider", vars, props);
      final frameBuilder = getValue(
          maps["frameBuilder"], datas, "ImageFrameBuilder?", vars, props);
      final loadingBuilder = getValue(
          maps["loadingBuilder"], datas, "ImageLoadingBuilder?", vars, props);
      final errorBuilder = getValue(
          maps["errorBuilder"], datas, "ImageErrorWidgetBuilder?", vars, props);
      final semanticLabel =
          getValue(maps["semanticLabel"], datas, "String?", vars, props);
      final excludeFromSemantics =
          getValue(maps["excludeFromSemantics"], datas, "bool", vars, props);
      final width = getValue(maps["width"], datas, "double?", vars, props);
      final height = getValue(maps["height"], datas, "double?", vars, props);
      final color = getValue(maps["color"], datas, "Color?", vars, props);
      final opacity =
          getValue(maps["opacity"], datas, "Animation<double>?", vars, props);
      final colorBlendMode =
          getValue(maps["colorBlendMode"], datas, "BlendMode?", vars, props);
      final fit = getValue(maps["fit"], datas, "BoxFit?", vars, props);
      final alignment =
          getValue(maps["alignment"], datas, "AlignmentGeometry", vars, props);
      final repeat =
          getValue(maps["repeat"], datas, "ImageRepeat", vars, props);
      final centerSlice =
          getValue(maps["centerSlice"], datas, "Rect?", vars, props);
      final matchTextDirection =
          getValue(maps["matchTextDirection"], datas, "bool", vars, props);
      final gaplessPlayback =
          getValue(maps["gaplessPlayback"], datas, "bool", vars, props);
      final isAntiAlias =
          getValue(maps["isAntiAlias"], datas, "bool", vars, props);
      final filterQuality =
          getValue(maps["filterQuality"], datas, "FilterQuality", vars, props);
      if (image == null) {
        return null;
      }
      return Image(
          key: key,
          image: image!,
          frameBuilder: frameBuilder,
          loadingBuilder: loadingBuilder,
          errorBuilder: errorBuilder,
          semanticLabel: semanticLabel,
          excludeFromSemantics: excludeFromSemantics ?? false,
          width: width,
          height: height,
          color: color,
          opacity: opacity,
          colorBlendMode: colorBlendMode,
          fit: fit,
          alignment: alignment ?? Alignment.center,
          repeat: repeat ?? ImageRepeat.noRepeat,
          centerSlice: centerSlice,
          matchTextDirection: matchTextDirection ?? false,
          gaplessPlayback: gaplessPlayback ?? false,
          isAntiAlias: isAntiAlias ?? false,
          filterQuality: filterQuality ?? FilterQuality.low);
    },
    "Image.network": () {
      final src = getValue(maps["0"], datas, "String", vars, props);
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final scale = getValue(maps["scale"], datas, "double", vars, props);
      final frameBuilder = getValue(
          maps["frameBuilder"], datas, "ImageFrameBuilder?", vars, props);
      final loadingBuilder = getValue(
          maps["loadingBuilder"], datas, "ImageLoadingBuilder?", vars, props);
      final errorBuilder = getValue(
          maps["errorBuilder"], datas, "ImageErrorWidgetBuilder?", vars, props);
      final semanticLabel =
          getValue(maps["semanticLabel"], datas, "String?", vars, props);
      final excludeFromSemantics =
          getValue(maps["excludeFromSemantics"], datas, "bool", vars, props);
      final width = getValue(maps["width"], datas, "double?", vars, props);
      final height = getValue(maps["height"], datas, "double?", vars, props);
      final color = getValue(maps["color"], datas, "Color?", vars, props);
      final opacity =
          getValue(maps["opacity"], datas, "Animation<double>?", vars, props);
      final colorBlendMode =
          getValue(maps["colorBlendMode"], datas, "BlendMode?", vars, props);
      final fit = getValue(maps["fit"], datas, "BoxFit?", vars, props);
      final alignment =
          getValue(maps["alignment"], datas, "AlignmentGeometry", vars, props);
      final repeat =
          getValue(maps["repeat"], datas, "ImageRepeat", vars, props);
      final centerSlice =
          getValue(maps["centerSlice"], datas, "Rect?", vars, props);
      final matchTextDirection =
          getValue(maps["matchTextDirection"], datas, "bool", vars, props);
      final gaplessPlayback =
          getValue(maps["gaplessPlayback"], datas, "bool", vars, props);
      final filterQuality =
          getValue(maps["filterQuality"], datas, "FilterQuality", vars, props);
      final isAntiAlias =
          getValue(maps["isAntiAlias"], datas, "bool", vars, props);
      final headers = getValue(
          maps["headers"], datas, "Map<String,   String>?", vars, props);
      final cacheWidth =
          getValue(maps["cacheWidth"], datas, "int?", vars, props);
      final cacheHeight =
          getValue(maps["cacheHeight"], datas, "int?", vars, props);
      if (src == null) {
        return null;
      }
      return Image.network(src!,
          key: key,
          scale: scale ?? 1.0,
          frameBuilder: frameBuilder,
          loadingBuilder: loadingBuilder,
          errorBuilder: errorBuilder,
          semanticLabel: semanticLabel,
          excludeFromSemantics: excludeFromSemantics ?? false,
          width: width,
          height: height,
          color: color,
          opacity: opacity,
          colorBlendMode: colorBlendMode,
          fit: fit,
          alignment: alignment ?? Alignment.center,
          repeat: repeat ?? ImageRepeat.noRepeat,
          centerSlice: centerSlice,
          matchTextDirection: matchTextDirection ?? false,
          gaplessPlayback: gaplessPlayback ?? false,
          filterQuality: filterQuality ?? FilterQuality.low,
          isAntiAlias: isAntiAlias ?? false,
          headers: headers != null ? Map<String, String>.from(headers) : null,
          cacheWidth: cacheWidth,
          cacheHeight: cacheHeight);
    },
    "Image.file": () {
      final file = getValue(maps["0"], datas, "File", vars, props);
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final scale = getValue(maps["scale"], datas, "double", vars, props);
      final frameBuilder = getValue(
          maps["frameBuilder"], datas, "ImageFrameBuilder?", vars, props);
      final errorBuilder = getValue(
          maps["errorBuilder"], datas, "ImageErrorWidgetBuilder?", vars, props);
      final semanticLabel =
          getValue(maps["semanticLabel"], datas, "String?", vars, props);
      final excludeFromSemantics =
          getValue(maps["excludeFromSemantics"], datas, "bool", vars, props);
      final width = getValue(maps["width"], datas, "double?", vars, props);
      final height = getValue(maps["height"], datas, "double?", vars, props);
      final color = getValue(maps["color"], datas, "Color?", vars, props);
      final opacity =
          getValue(maps["opacity"], datas, "Animation<double>?", vars, props);
      final colorBlendMode =
          getValue(maps["colorBlendMode"], datas, "BlendMode?", vars, props);
      final fit = getValue(maps["fit"], datas, "BoxFit?", vars, props);
      final alignment =
          getValue(maps["alignment"], datas, "AlignmentGeometry", vars, props);
      final repeat =
          getValue(maps["repeat"], datas, "ImageRepeat", vars, props);
      final centerSlice =
          getValue(maps["centerSlice"], datas, "Rect?", vars, props);
      final matchTextDirection =
          getValue(maps["matchTextDirection"], datas, "bool", vars, props);
      final gaplessPlayback =
          getValue(maps["gaplessPlayback"], datas, "bool", vars, props);
      final isAntiAlias =
          getValue(maps["isAntiAlias"], datas, "bool", vars, props);
      final filterQuality =
          getValue(maps["filterQuality"], datas, "FilterQuality", vars, props);
      final cacheWidth =
          getValue(maps["cacheWidth"], datas, "int?", vars, props);
      final cacheHeight =
          getValue(maps["cacheHeight"], datas, "int?", vars, props);
      if (file == null) {
        return null;
      }
      return Image.file(file!,
          key: key,
          scale: scale ?? 1.0,
          frameBuilder: frameBuilder,
          errorBuilder: errorBuilder,
          semanticLabel: semanticLabel,
          excludeFromSemantics: excludeFromSemantics ?? false,
          width: width,
          height: height,
          color: color,
          opacity: opacity,
          colorBlendMode: colorBlendMode,
          fit: fit,
          alignment: alignment ?? Alignment.center,
          repeat: repeat ?? ImageRepeat.noRepeat,
          centerSlice: centerSlice,
          matchTextDirection: matchTextDirection ?? false,
          gaplessPlayback: gaplessPlayback ?? false,
          isAntiAlias: isAntiAlias ?? false,
          filterQuality: filterQuality ?? FilterQuality.low,
          cacheWidth: cacheWidth,
          cacheHeight: cacheHeight);
    },
    "Image.asset": () {
      final name = getValue(maps["0"], datas, "String", vars, props);
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final bundle =
          getValue(maps["bundle"], datas, "AssetBundle?", vars, props);
      final frameBuilder = getValue(
          maps["frameBuilder"], datas, "ImageFrameBuilder?", vars, props);
      final errorBuilder = getValue(
          maps["errorBuilder"], datas, "ImageErrorWidgetBuilder?", vars, props);
      final semanticLabel =
          getValue(maps["semanticLabel"], datas, "String?", vars, props);
      final excludeFromSemantics =
          getValue(maps["excludeFromSemantics"], datas, "bool", vars, props);
      final scale = getValue(maps["scale"], datas, "double?", vars, props);
      final width = getValue(maps["width"], datas, "double?", vars, props);
      final height = getValue(maps["height"], datas, "double?", vars, props);
      final color = getValue(maps["color"], datas, "Color?", vars, props);
      final opacity =
          getValue(maps["opacity"], datas, "Animation<double>?", vars, props);
      final colorBlendMode =
          getValue(maps["colorBlendMode"], datas, "BlendMode?", vars, props);
      final fit = getValue(maps["fit"], datas, "BoxFit?", vars, props);
      final alignment =
          getValue(maps["alignment"], datas, "AlignmentGeometry", vars, props);
      final repeat =
          getValue(maps["repeat"], datas, "ImageRepeat", vars, props);
      final centerSlice =
          getValue(maps["centerSlice"], datas, "Rect?", vars, props);
      final matchTextDirection =
          getValue(maps["matchTextDirection"], datas, "bool", vars, props);
      final gaplessPlayback =
          getValue(maps["gaplessPlayback"], datas, "bool", vars, props);
      final isAntiAlias =
          getValue(maps["isAntiAlias"], datas, "bool", vars, props);
      final package = getValue(maps["package"], datas, "String?", vars, props);
      final filterQuality =
          getValue(maps["filterQuality"], datas, "FilterQuality", vars, props);
      final cacheWidth =
          getValue(maps["cacheWidth"], datas, "int?", vars, props);
      final cacheHeight =
          getValue(maps["cacheHeight"], datas, "int?", vars, props);
      if (name == null) {
        return null;
      }
      return Image.asset(name!,
          key: key,
          bundle: bundle,
          frameBuilder: frameBuilder,
          errorBuilder: errorBuilder,
          semanticLabel: semanticLabel,
          excludeFromSemantics: excludeFromSemantics ?? false,
          scale: scale,
          width: width,
          height: height,
          color: color,
          opacity: opacity,
          colorBlendMode: colorBlendMode,
          fit: fit,
          alignment: alignment ?? Alignment.center,
          repeat: repeat ?? ImageRepeat.noRepeat,
          centerSlice: centerSlice,
          matchTextDirection: matchTextDirection ?? false,
          gaplessPlayback: gaplessPlayback ?? false,
          isAntiAlias: isAntiAlias ?? false,
          package: package,
          filterQuality: filterQuality ?? FilterQuality.low,
          cacheWidth: cacheWidth,
          cacheHeight: cacheHeight);
    },
    "Image.memory": () {
      final bytes = getValue(maps["0"], datas, "Uint8List", vars, props);
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final scale = getValue(maps["scale"], datas, "double", vars, props);
      final frameBuilder = getValue(
          maps["frameBuilder"], datas, "ImageFrameBuilder?", vars, props);
      final errorBuilder = getValue(
          maps["errorBuilder"], datas, "ImageErrorWidgetBuilder?", vars, props);
      final semanticLabel =
          getValue(maps["semanticLabel"], datas, "String?", vars, props);
      final excludeFromSemantics =
          getValue(maps["excludeFromSemantics"], datas, "bool", vars, props);
      final width = getValue(maps["width"], datas, "double?", vars, props);
      final height = getValue(maps["height"], datas, "double?", vars, props);
      final color = getValue(maps["color"], datas, "Color?", vars, props);
      final opacity =
          getValue(maps["opacity"], datas, "Animation<double>?", vars, props);
      final colorBlendMode =
          getValue(maps["colorBlendMode"], datas, "BlendMode?", vars, props);
      final fit = getValue(maps["fit"], datas, "BoxFit?", vars, props);
      final alignment =
          getValue(maps["alignment"], datas, "AlignmentGeometry", vars, props);
      final repeat =
          getValue(maps["repeat"], datas, "ImageRepeat", vars, props);
      final centerSlice =
          getValue(maps["centerSlice"], datas, "Rect?", vars, props);
      final matchTextDirection =
          getValue(maps["matchTextDirection"], datas, "bool", vars, props);
      final gaplessPlayback =
          getValue(maps["gaplessPlayback"], datas, "bool", vars, props);
      final isAntiAlias =
          getValue(maps["isAntiAlias"], datas, "bool", vars, props);
      final filterQuality =
          getValue(maps["filterQuality"], datas, "FilterQuality", vars, props);
      final cacheWidth =
          getValue(maps["cacheWidth"], datas, "int?", vars, props);
      final cacheHeight =
          getValue(maps["cacheHeight"], datas, "int?", vars, props);
      if (bytes == null) {
        return null;
      }
      return Image.memory(bytes!,
          key: key,
          scale: scale ?? 1.0,
          frameBuilder: frameBuilder,
          errorBuilder: errorBuilder,
          semanticLabel: semanticLabel,
          excludeFromSemantics: excludeFromSemantics ?? false,
          width: width,
          height: height,
          color: color,
          opacity: opacity,
          colorBlendMode: colorBlendMode,
          fit: fit,
          alignment: alignment ?? Alignment.center,
          repeat: repeat ?? ImageRepeat.noRepeat,
          centerSlice: centerSlice,
          matchTextDirection: matchTextDirection ?? false,
          gaplessPlayback: gaplessPlayback ?? false,
          isAntiAlias: isAntiAlias ?? false,
          filterQuality: filterQuality ?? FilterQuality.low,
          cacheWidth: cacheWidth,
          cacheHeight: cacheHeight);
    },
    "ImageChunkEvent": () {
      final cumulativeBytesLoaded =
          getValue(maps["cumulativeBytesLoaded"], datas, "int", vars, props);
      final expectedTotalBytes =
          getValue(maps["expectedTotalBytes"], datas, "int?", vars, props);
      if (cumulativeBytesLoaded == null || expectedTotalBytes == null) {
        return null;
      }
      return ImageChunkEvent(
          cumulativeBytesLoaded: cumulativeBytesLoaded!,
          expectedTotalBytes: expectedTotalBytes!);
    },
    "ImageConfiguration": () {
      final bundle =
          getValue(maps["bundle"], datas, "AssetBundle?", vars, props);
      final devicePixelRatio =
          getValue(maps["devicePixelRatio"], datas, "double?", vars, props);
      final locale = getValue(maps["locale"], datas, "Locale?", vars, props);
      final textDirection =
          getValue(maps["textDirection"], datas, "TextDirection?", vars, props);
      final size = getValue(maps["size"], datas, "Size?", vars, props);
      final platform =
          getValue(maps["platform"], datas, "TargetPlatform?", vars, props);
      return ImageConfiguration(
          bundle: bundle,
          devicePixelRatio: devicePixelRatio,
          locale: locale,
          textDirection: textDirection,
          size: size,
          platform: platform);
    },
    "ImageDescriptor.raw": () {
      final buffer = getValue(maps["0"], datas, "ImmutableBuffer", vars, props);
      final width = getValue(maps["width"], datas, "int", vars, props);
      final height = getValue(maps["height"], datas, "int", vars, props);
      final rowBytes = getValue(maps["rowBytes"], datas, "int?", vars, props);
      final pixelFormat =
          getValue(maps["pixelFormat"], datas, "PixelFormat", vars, props);
      if (buffer == null ||
          width == null ||
          height == null ||
          pixelFormat == null) {
        return null;
      }
      return ui.ImageDescriptor.raw(buffer!,
          width: width!,
          height: height!,
          rowBytes: rowBytes,
          pixelFormat: pixelFormat!);
    },
    "ImageFilter.blur": () {
      final sigmaX = getValue(maps["sigmaX"], datas, "double", vars, props);
      final sigmaY = getValue(maps["sigmaY"], datas, "double", vars, props);
      final tileMode =
          getValue(maps["tileMode"], datas, "TileMode", vars, props);
      return ui.ImageFilter.blur(
          sigmaX: sigmaX ?? 0.0,
          sigmaY: sigmaY ?? 0.0,
          tileMode: tileMode ?? TileMode.clamp);
    },
    "ImageFilter.dilate": () {
      final radiusX = getValue(maps["radiusX"], datas, "double", vars, props);
      final radiusY = getValue(maps["radiusY"], datas, "double", vars, props);
      return ui.ImageFilter.dilate(
          radiusX: radiusX ?? 0.0, radiusY: radiusY ?? 0.0);
    },
    "ImageFilter.erode": () {
      final radiusX = getValue(maps["radiusX"], datas, "double", vars, props);
      final radiusY = getValue(maps["radiusY"], datas, "double", vars, props);
      return ui.ImageFilter.erode(
          radiusX: radiusX ?? 0.0, radiusY: radiusY ?? 0.0);
    },
    "ImageFilter.matrix": () {
      final matrix4 = getValue(maps["0"], datas, "Float64List", vars, props);
      final filterQuality =
          getValue(maps["filterQuality"], datas, "FilterQuality", vars, props);
      if (matrix4 == null) {
        return null;
      }
      return ui.ImageFilter.matrix(matrix4!,
          filterQuality: filterQuality ?? FilterQuality.low);
    },
    "ImageFilter.compose": () {
      final outer = getValue(maps["outer"], datas, "ImageFilter", vars, props);
      final inner = getValue(maps["inner"], datas, "ImageFilter", vars, props);
      if (outer == null || inner == null) {
        return null;
      }
      return ui.ImageFilter.compose(outer: outer!, inner: inner!);
    },
    "ImageFilterLayer": () {
      final imageFilter =
          getValue(maps["imageFilter"], datas, "ImageFilter?", vars, props);
      final offset = getValue(maps["offset"], datas, "Offset", vars, props);
      return ImageFilterLayer(
          imageFilter: imageFilter, offset: offset ?? Offset.zero);
    },
    "ImageFiltered": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final imageFilter =
          getValue(maps["imageFilter"], datas, "ImageFilter", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      final enabled = getValue(maps["enabled"], datas, "bool", vars, props);
      if (imageFilter == null) {
        return null;
      }
      return ImageFiltered(
          key: key,
          imageFilter: imageFilter!,
          child: child,
          enabled: enabled ?? true);
    },
    "ImageIcon": () {
      final image = getValue(maps["0"], datas, "ImageProvider?", vars, props);
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final size = getValue(maps["size"], datas, "double?", vars, props);
      final color = getValue(maps["color"], datas, "Color?", vars, props);
      final semanticLabel =
          getValue(maps["semanticLabel"], datas, "String?", vars, props);
      if (image == null) {
        return null;
      }
      return ImageIcon(image!,
          key: key, size: size, color: color, semanticLabel: semanticLabel);
    },
    "ImageInfo": () {
      final image = getValue(maps["image"], datas, "Image", vars, props);
      final scale = getValue(maps["scale"], datas, "double", vars, props);
      final debugLabel =
          getValue(maps["debugLabel"], datas, "String?", vars, props);
      if (image == null) {
        return null;
      }
      return ImageInfo(
          image: image!, scale: scale ?? 1.0, debugLabel: debugLabel);
    },
    "ImageShader": () {
      final image = getValue(maps["0"], datas, "Image", vars, props);
      final tmx = getValue(maps["1"], datas, "TileMode", vars, props);
      final tmy = getValue(maps["2"], datas, "TileMode", vars, props);
      final matrix4 = getValue(maps["3"], datas, "Float64List", vars, props);
      final filterQuality =
          getValue(maps["filterQuality"], datas, "FilterQuality?", vars, props);
      if (image == null || tmx == null || tmy == null || matrix4 == null) {
        return null;
      }
      return ImageShader(image!, tmx!, tmy!, matrix4!,
          filterQuality: filterQuality);
    },
    "ImageSizeInfo": () {
      final source = getValue(maps["source"], datas, "String?", vars, props);
      final displaySize =
          getValue(maps["displaySize"], datas, "Size", vars, props);
      final imageSize = getValue(maps["imageSize"], datas, "Size", vars, props);
      if (displaySize == null || imageSize == null) {
        return null;
      }
      return ImageSizeInfo(
          source: source, displaySize: displaySize!, imageSize: imageSize!);
    },
    "ImageStream": () {
      return ImageStream();
      // "ImageTilingInfo": () {
      //   final tmx = getValue(maps["tmx"], datas, "TileMode", vars, props);
      //   final tmy = getValue(maps["tmy"], datas, "TileMode", vars, props);
      //   final transform =
      //       getValue(maps["transform"], datas, "Matrix4", vars, props);
      //   if (tmx == null || tmy == null || transform == null) {
      //     return null;
      //   }
      //   return ImageTilingInfo(tmx: tmx!, tmy: tmy!, transform: transform!);
    },
    "ImmediateMultiDragGestureRecognizer": () {
      final debugOwner =
          getValue(maps["debugOwner"], datas, "Object?", vars, props);
      final supportedDevices = getValue(maps["supportedDevices"], datas,
          "Set<PointerDeviceKind>?", vars, props);
      final allowedButtonsFilter = getValue(maps["allowedButtonsFilter"], datas,
          "AllowedButtonsFilter?", vars, props);
      return ImmediateMultiDragGestureRecognizer(
          debugOwner: debugOwner,
          supportedDevices: supportedDevices
              ? Set<PointerDeviceKind>.from(supportedDevices)
              : null,
          allowedButtonsFilter: allowedButtonsFilter);
    },
    "IndexError": () {
      final invalidValue = getValue(maps["0"], datas, "int", vars, props);
      final indexable = getValue(maps["1"], datas, "dynamic", vars, props);
      final name = getValue(maps["2"], datas, "String?", vars, props);
      final message = getValue(maps["3"], datas, "String?", vars, props);
      final length = getValue(maps["4"], datas, "int?", vars, props);
      if (invalidValue == null || indexable == null) {
        return null;
      }
      return IndexError(invalidValue!, indexable!, name, message, length);
    },
    "IndexedSemantics": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final index = getValue(maps["index"], datas, "int", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      if (index == null) {
        return null;
      }
      return IndexedSemantics(key: key, index: index!, child: child);
    },
    "IndexedStack": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final alignment =
          getValue(maps["alignment"], datas, "AlignmentGeometry", vars, props);
      final textDirection =
          getValue(maps["textDirection"], datas, "TextDirection?", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      final sizing = getValue(maps["sizing"], datas, "StackFit", vars, props);
      final index = getValue(maps["index"], datas, "int?", vars, props);
      final children =
          getValue(maps["children"], datas, "List<Widget>", vars, props);
      return IndexedStack(
          key: key,
          alignment: alignment ?? AlignmentDirectional.topStart,
          textDirection: textDirection,
          clipBehavior: clipBehavior ?? Clip.hardEdge,
          sizing: sizing ?? StackFit.loose,
          index: index ?? 0,
          children: List<Widget>.from(children ?? const <Widget>[]));
    },
    "InheritedModelElement": () {
      final widget =
          getValue(maps["0"], datas, "InheritedModel<T>", vars, props);
      if (widget == null) {
        return null;
      }
      return InheritedModelElement(widget!);
    },
    "Ink": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final padding =
          getValue(maps["padding"], datas, "EdgeInsetsGeometry?", vars, props);
      final color = getValue(maps["color"], datas, "Color?", vars, props);
      final decoration =
          getValue(maps["decoration"], datas, "Decoration?", vars, props);
      final width = getValue(maps["width"], datas, "double?", vars, props);
      final height = getValue(maps["height"], datas, "double?", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      return Ink(
          key: key,
          padding: padding,
          color: color,
          decoration: decoration,
          width: width,
          height: height,
          child: child);
    },
    "Ink.image": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final padding =
          getValue(maps["padding"], datas, "EdgeInsetsGeometry?", vars, props);
      final image =
          getValue(maps["image"], datas, "ImageProvider", vars, props);
      final onImageError = getValue(
          maps["onImageError"], datas, "ImageErrorListener?", vars, props);
      final colorFilter =
          getValue(maps["colorFilter"], datas, "ColorFilter?", vars, props);
      final fit = getValue(maps["fit"], datas, "BoxFit?", vars, props);
      final alignment =
          getValue(maps["alignment"], datas, "AlignmentGeometry", vars, props);
      final centerSlice =
          getValue(maps["centerSlice"], datas, "Rect?", vars, props);
      final repeat =
          getValue(maps["repeat"], datas, "ImageRepeat", vars, props);
      final matchTextDirection =
          getValue(maps["matchTextDirection"], datas, "bool", vars, props);
      final width = getValue(maps["width"], datas, "double?", vars, props);
      final height = getValue(maps["height"], datas, "double?", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      if (image == null) {
        return null;
      }
      return Ink.image(
          key: key,
          padding: padding,
          image: image!,
          onImageError: onImageError,
          colorFilter: colorFilter,
          fit: fit,
          alignment: alignment ?? Alignment.center,
          centerSlice: centerSlice,
          repeat: repeat ?? ImageRepeat.noRepeat,
          matchTextDirection: matchTextDirection ?? false,
          width: width,
          height: height,
          child: child);
    },
    "InkDecoration": () {
      final decoration =
          getValue(maps["decoration"], datas, "Decoration?", vars, props);
      final isVisible = getValue(maps["isVisible"], datas, "bool", vars, props);
      final configuration = getValue(
          maps["configuration"], datas, "ImageConfiguration", vars, props);
      final controller = getValue(
          maps["controller"], datas, "MaterialInkController", vars, props);
      final referenceBox =
          getValue(maps["referenceBox"], datas, "RenderBox", vars, props);
      final onRemoved =
          getValue(maps["onRemoved"], datas, "VoidCallback?", vars, props);
      if (decoration == null ||
          configuration == null ||
          controller == null ||
          referenceBox == null) {
        return null;
      }
      return InkDecoration(
          decoration: decoration!,
          isVisible: isVisible ?? true,
          configuration: configuration!,
          controller: controller!,
          referenceBox: referenceBox!,
          onRemoved: onRemoved);
    },
    "InkHighlight": () {
      final controller = getValue(
          maps["controller"], datas, "MaterialInkController", vars, props);
      final referenceBox =
          getValue(maps["referenceBox"], datas, "RenderBox", vars, props);
      final color = getValue(maps["color"], datas, "Color", vars, props);
      final textDirection =
          getValue(maps["textDirection"], datas, "TextDirection", vars, props);
      final shape = getValue(maps["shape"], datas, "BoxShape", vars, props);
      final radius = getValue(maps["radius"], datas, "double?", vars, props);
      final borderRadius =
          getValue(maps["borderRadius"], datas, "BorderRadius?", vars, props);
      final customBorder =
          getValue(maps["customBorder"], datas, "ShapeBorder?", vars, props);
      final rectCallback =
          getValue(maps["rectCallback"], datas, "RectCallback?", vars, props);
      final onRemoved =
          getValue(maps["onRemoved"], datas, "VoidCallback?", vars, props);
      final fadeDuration =
          getValue(maps["fadeDuration"], datas, "Duration", vars, props);
      if (controller == null ||
          referenceBox == null ||
          color == null ||
          textDirection == null) {
        return null;
      }
      if (fadeDuration != null) {
        return InkHighlight(
            controller: controller!,
            referenceBox: referenceBox!,
            color: color!,
            textDirection: textDirection!,
            shape: shape ?? BoxShape.rectangle,
            radius: radius,
            borderRadius: borderRadius,
            customBorder: customBorder,
            rectCallback: rectCallback,
            onRemoved: onRemoved,
            fadeDuration: fadeDuration);
      }
      return InkHighlight(
          controller: controller!,
          referenceBox: referenceBox!,
          color: color!,
          textDirection: textDirection!,
          shape: shape ?? BoxShape.rectangle,
          radius: radius,
          borderRadius: borderRadius,
          customBorder: customBorder,
          rectCallback: rectCallback,
          onRemoved: onRemoved);
    },
    "InkResponse": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      final onTap =
          getValue(maps["onTap"], datas, "GestureTapCallback?", vars, props);
      final onTapDown = getValue(
          maps["onTapDown"], datas, "GestureTapDownCallback?", vars, props);
      final onTapUp = getValue(
          maps["onTapUp"], datas, "GestureTapUpCallback?", vars, props);
      final onTapCancel = getValue(
          maps["onTapCancel"], datas, "GestureTapCallback?", vars, props);
      final onDoubleTap = getValue(
          maps["onDoubleTap"], datas, "GestureTapCallback?", vars, props);
      final onLongPress = getValue(
          maps["onLongPress"], datas, "GestureLongPressCallback?", vars, props);
      final onSecondaryTap = getValue(
          maps["onSecondaryTap"], datas, "GestureTapCallback?", vars, props);
      final onSecondaryTapUp = getValue(maps["onSecondaryTapUp"], datas,
          "GestureTapUpCallback?", vars, props);
      final onSecondaryTapDown = getValue(maps["onSecondaryTapDown"], datas,
          "GestureTapDownCallback?", vars, props);
      final onSecondaryTapCancel = getValue(maps["onSecondaryTapCancel"], datas,
          "GestureTapCallback?", vars, props);
      final onHighlightChanged = getValue(maps["onHighlightChanged"], datas,
          "ValueChanged<bool>?", vars, props);
      final onHover =
          getValue(maps["onHover"], datas, "ValueChanged<bool>?", vars, props);
      final mouseCursor =
          getValue(maps["mouseCursor"], datas, "MouseCursor?", vars, props);
      final containedInkWell =
          getValue(maps["containedInkWell"], datas, "bool", vars, props);
      final highlightShape =
          getValue(maps["highlightShape"], datas, "BoxShape", vars, props);
      final radius = getValue(maps["radius"], datas, "double?", vars, props);
      final borderRadius =
          getValue(maps["borderRadius"], datas, "BorderRadius?", vars, props);
      final customBorder =
          getValue(maps["customBorder"], datas, "ShapeBorder?", vars, props);
      final focusColor =
          getValue(maps["focusColor"], datas, "Color?", vars, props);
      final hoverColor =
          getValue(maps["hoverColor"], datas, "Color?", vars, props);
      final highlightColor =
          getValue(maps["highlightColor"], datas, "Color?", vars, props);
      final overlayColor = getValue(maps["overlayColor"], datas,
          "MaterialStateProperty<Color?>?", vars, props);
      final splashColor =
          getValue(maps["splashColor"], datas, "Color?", vars, props);
      final splashFactory = getValue(maps["splashFactory"], datas,
          "InteractiveInkFeatureFactory?", vars, props);
      final enableFeedback =
          getValue(maps["enableFeedback"], datas, "bool", vars, props);
      final excludeFromSemantics =
          getValue(maps["excludeFromSemantics"], datas, "bool", vars, props);
      final focusNode =
          getValue(maps["focusNode"], datas, "FocusNode?", vars, props);
      final canRequestFocus =
          getValue(maps["canRequestFocus"], datas, "bool", vars, props);
      final onFocusChange = getValue(
          maps["onFocusChange"], datas, "ValueChanged<bool>?", vars, props);
      final autofocus = getValue(maps["autofocus"], datas, "bool", vars, props);
      final statesController = getValue(maps["statesController"], datas,
          "MaterialStatesController?", vars, props);
      return InkResponse(
          key: key,
          child: child,
          onTap: onTap,
          onTapDown: onTapDown,
          onTapUp: onTapUp,
          onTapCancel: onTapCancel,
          onDoubleTap: onDoubleTap,
          onLongPress: onLongPress,
          onSecondaryTap: onSecondaryTap,
          onSecondaryTapUp: onSecondaryTapUp,
          onSecondaryTapDown: onSecondaryTapDown,
          onSecondaryTapCancel: onSecondaryTapCancel,
          onHighlightChanged: onHighlightChanged,
          onHover: onHover,
          mouseCursor: mouseCursor,
          containedInkWell: containedInkWell ?? false,
          highlightShape: highlightShape ?? BoxShape.circle,
          radius: radius,
          borderRadius: borderRadius,
          customBorder: customBorder,
          focusColor: focusColor,
          hoverColor: hoverColor,
          highlightColor: highlightColor,
          overlayColor: overlayColor,
          splashColor: splashColor,
          splashFactory: splashFactory,
          enableFeedback: enableFeedback ?? true,
          excludeFromSemantics: excludeFromSemantics ?? false,
          focusNode: focusNode,
          canRequestFocus: canRequestFocus ?? true,
          onFocusChange: onFocusChange,
          autofocus: autofocus ?? false,
          statesController: statesController);
    },
    "InkRipple": () {
      final controller = getValue(
          maps["controller"], datas, "MaterialInkController", vars, props);
      final referenceBox =
          getValue(maps["referenceBox"], datas, "RenderBox", vars, props);
      final position = getValue(maps["position"], datas, "Offset", vars, props);
      final color = getValue(maps["color"], datas, "Color", vars, props);
      final textDirection =
          getValue(maps["textDirection"], datas, "TextDirection", vars, props);
      final containedInkWell =
          getValue(maps["containedInkWell"], datas, "bool", vars, props);
      final rectCallback =
          getValue(maps["rectCallback"], datas, "RectCallback?", vars, props);
      final borderRadius =
          getValue(maps["borderRadius"], datas, "BorderRadius?", vars, props);
      final customBorder =
          getValue(maps["customBorder"], datas, "ShapeBorder?", vars, props);
      final radius = getValue(maps["radius"], datas, "double?", vars, props);
      final onRemoved =
          getValue(maps["onRemoved"], datas, "VoidCallback?", vars, props);
      if (controller == null ||
          referenceBox == null ||
          position == null ||
          color == null ||
          textDirection == null) {
        return null;
      }
      return InkRipple(
          controller: controller!,
          referenceBox: referenceBox!,
          position: position!,
          color: color!,
          textDirection: textDirection!,
          containedInkWell: containedInkWell ?? false,
          rectCallback: rectCallback,
          borderRadius: borderRadius,
          customBorder: customBorder,
          radius: radius,
          onRemoved: onRemoved);
    },
    "InkSparkle": () {
      final controller = getValue(
          maps["controller"], datas, "MaterialInkController", vars, props);
      final referenceBox =
          getValue(maps["referenceBox"], datas, "RenderBox", vars, props);
      final color = getValue(maps["color"], datas, "Color", vars, props);
      final position = getValue(maps["position"], datas, "Offset", vars, props);
      final textDirection =
          getValue(maps["textDirection"], datas, "TextDirection", vars, props);
      final containedInkWell =
          getValue(maps["containedInkWell"], datas, "bool", vars, props);
      final rectCallback =
          getValue(maps["rectCallback"], datas, "RectCallback?", vars, props);
      final borderRadius =
          getValue(maps["borderRadius"], datas, "BorderRadius?", vars, props);
      final customBorder =
          getValue(maps["customBorder"], datas, "ShapeBorder?", vars, props);
      final radius = getValue(maps["radius"], datas, "double?", vars, props);
      final onRemoved =
          getValue(maps["onRemoved"], datas, "VoidCallback?", vars, props);
      final turbulenceSeed =
          getValue(maps["turbulenceSeed"], datas, "double?", vars, props);
      if (controller == null ||
          referenceBox == null ||
          color == null ||
          position == null ||
          textDirection == null) {
        return null;
      }
      return InkSparkle(
          controller: controller!,
          referenceBox: referenceBox!,
          color: color!,
          position: position!,
          textDirection: textDirection!,
          containedInkWell: containedInkWell ?? true,
          rectCallback: rectCallback,
          borderRadius: borderRadius,
          customBorder: customBorder,
          radius: radius,
          onRemoved: onRemoved,
          turbulenceSeed: turbulenceSeed);
    },
    "InkSplash": () {
      final controller = getValue(
          maps["controller"], datas, "MaterialInkController", vars, props);
      final referenceBox =
          getValue(maps["referenceBox"], datas, "RenderBox", vars, props);
      final textDirection =
          getValue(maps["textDirection"], datas, "TextDirection", vars, props);
      final position =
          getValue(maps["position"], datas, "Offset?", vars, props);
      final color = getValue(maps["color"], datas, "Color", vars, props);
      final containedInkWell =
          getValue(maps["containedInkWell"], datas, "bool", vars, props);
      final rectCallback =
          getValue(maps["rectCallback"], datas, "RectCallback?", vars, props);
      final borderRadius =
          getValue(maps["borderRadius"], datas, "BorderRadius?", vars, props);
      final customBorder =
          getValue(maps["customBorder"], datas, "ShapeBorder?", vars, props);
      final radius = getValue(maps["radius"], datas, "double?", vars, props);
      final onRemoved =
          getValue(maps["onRemoved"], datas, "VoidCallback?", vars, props);
      if (controller == null ||
          referenceBox == null ||
          textDirection == null ||
          color == null) {
        return null;
      }
      return InkSplash(
          controller: controller!,
          referenceBox: referenceBox!,
          textDirection: textDirection!,
          position: position,
          color: color!,
          containedInkWell: containedInkWell ?? false,
          rectCallback: rectCallback,
          borderRadius: borderRadius,
          customBorder: customBorder,
          radius: radius,
          onRemoved: onRemoved);
    },
    "InkWell": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      final onTap =
          getValue(maps["onTap"], datas, "GestureTapCallback?", vars, props);
      final onDoubleTap = getValue(
          maps["onDoubleTap"], datas, "GestureTapCallback?", vars, props);
      final onLongPress = getValue(
          maps["onLongPress"], datas, "GestureLongPressCallback?", vars, props);
      final onTapDown = getValue(
          maps["onTapDown"], datas, "GestureTapDownCallback?", vars, props);
      final onTapUp = getValue(
          maps["onTapUp"], datas, "GestureTapUpCallback?", vars, props);
      final onTapCancel = getValue(
          maps["onTapCancel"], datas, "GestureTapCallback?", vars, props);
      final onSecondaryTap = getValue(
          maps["onSecondaryTap"], datas, "GestureTapCallback?", vars, props);
      final onSecondaryTapUp = getValue(maps["onSecondaryTapUp"], datas,
          "GestureTapUpCallback?", vars, props);
      final onSecondaryTapDown = getValue(maps["onSecondaryTapDown"], datas,
          "GestureTapDownCallback?", vars, props);
      final onSecondaryTapCancel = getValue(maps["onSecondaryTapCancel"], datas,
          "GestureTapCallback?", vars, props);
      final onHighlightChanged = getValue(maps["onHighlightChanged"], datas,
          "ValueChanged<bool>?", vars, props);
      final onHover =
          getValue(maps["onHover"], datas, "ValueChanged<bool>?", vars, props);
      final mouseCursor =
          getValue(maps["mouseCursor"], datas, "MouseCursor?", vars, props);
      final focusColor =
          getValue(maps["focusColor"], datas, "Color?", vars, props);
      final hoverColor =
          getValue(maps["hoverColor"], datas, "Color?", vars, props);
      final highlightColor =
          getValue(maps["highlightColor"], datas, "Color?", vars, props);
      final overlayColor = getValue(maps["overlayColor"], datas,
          "MaterialStateProperty<Color?>?", vars, props);
      final splashColor =
          getValue(maps["splashColor"], datas, "Color?", vars, props);
      final splashFactory = getValue(maps["splashFactory"], datas,
          "InteractiveInkFeatureFactory?", vars, props);
      final radius = getValue(maps["radius"], datas, "double?", vars, props);
      final borderRadius =
          getValue(maps["borderRadius"], datas, "BorderRadius?", vars, props);
      final customBorder =
          getValue(maps["customBorder"], datas, "ShapeBorder?", vars, props);
      final enableFeedback =
          getValue(maps["enableFeedback"], datas, "bool?", vars, props);
      final excludeFromSemantics =
          getValue(maps["excludeFromSemantics"], datas, "bool", vars, props);
      final focusNode =
          getValue(maps["focusNode"], datas, "FocusNode?", vars, props);
      final canRequestFocus =
          getValue(maps["canRequestFocus"], datas, "bool", vars, props);
      final onFocusChange = getValue(
          maps["onFocusChange"], datas, "ValueChanged<bool>?", vars, props);
      final autofocus = getValue(maps["autofocus"], datas, "bool", vars, props);
      final statesController = getValue(maps["statesController"], datas,
          "MaterialStatesController?", vars, props);
      return InkWell(
          key: key,
          child: child,
          onTap: onTap,
          onDoubleTap: onDoubleTap,
          onLongPress: onLongPress,
          onTapDown: onTapDown,
          onTapUp: onTapUp,
          onTapCancel: onTapCancel,
          onSecondaryTap: onSecondaryTap,
          onSecondaryTapUp: onSecondaryTapUp,
          onSecondaryTapDown: onSecondaryTapDown,
          onSecondaryTapCancel: onSecondaryTapCancel,
          onHighlightChanged: onHighlightChanged,
          onHover: onHover,
          mouseCursor: mouseCursor,
          focusColor: focusColor,
          hoverColor: hoverColor,
          highlightColor: highlightColor,
          overlayColor: overlayColor,
          splashColor: splashColor,
          splashFactory: splashFactory,
          radius: radius,
          borderRadius: borderRadius,
          customBorder: customBorder,
          enableFeedback: enableFeedback ?? true,
          excludeFromSemantics: excludeFromSemantics ?? false,
          focusNode: focusNode,
          canRequestFocus: canRequestFocus ?? true,
          onFocusChange: onFocusChange,
          autofocus: autofocus ?? false,
          statesController: statesController);
    },
    "InlineSpanSemanticsInformation": () {
      final text = getValue(maps["0"], datas, "String", vars, props);
      final isPlaceholder =
          getValue(maps["isPlaceholder"], datas, "bool", vars, props);
      final semanticsLabel =
          getValue(maps["semanticsLabel"], datas, "String?", vars, props);
      final stringAttributes = getValue(maps["stringAttributes"], datas,
          "List<ui.StringAttribute>", vars, props);
      final recognizer = getValue(
          maps["recognizer"], datas, "GestureRecognizer?", vars, props);
      if (text == null) {
        return null;
      }
      return InlineSpanSemanticsInformation(text!,
          isPlaceholder: isPlaceholder ?? false,
          semanticsLabel: semanticsLabel,
          stringAttributes: List<ui.StringAttribute>.from(
              stringAttributes ?? const <ui.StringAttribute>[]),
          recognizer: recognizer);
    },
    "InputChip": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final avatar = getValue(maps["avatar"], datas, "Widget?", vars, props);
      final label = getValue(maps["label"], datas, "Widget", vars, props);
      final labelStyle =
          getValue(maps["labelStyle"], datas, "TextStyle?", vars, props);
      final labelPadding = getValue(
          maps["labelPadding"], datas, "EdgeInsetsGeometry?", vars, props);
      final selected = getValue(maps["selected"], datas, "bool", vars, props);
      final isEnabled = getValue(maps["isEnabled"], datas, "bool", vars, props);
      final onSelected = getValue(
          maps["onSelected"], datas, "ValueChanged<bool>?", vars, props);
      final deleteIcon =
          getValue(maps["deleteIcon"], datas, "Widget?", vars, props);
      final onDeleted =
          getValue(maps["onDeleted"], datas, "VoidCallback?", vars, props);
      final deleteIconColor =
          getValue(maps["deleteIconColor"], datas, "Color?", vars, props);
      final deleteButtonTooltipMessage = getValue(
          maps["deleteButtonTooltipMessage"], datas, "String?", vars, props);
      final onPressed =
          getValue(maps["onPressed"], datas, "VoidCallback?", vars, props);
      final pressElevation =
          getValue(maps["pressElevation"], datas, "double?", vars, props);
      final disabledColor =
          getValue(maps["disabledColor"], datas, "Color?", vars, props);
      final selectedColor =
          getValue(maps["selectedColor"], datas, "Color?", vars, props);
      final tooltip = getValue(maps["tooltip"], datas, "String?", vars, props);
      final side = getValue(maps["side"], datas, "BorderSide?", vars, props);
      final shape =
          getValue(maps["shape"], datas, "OutlinedBorder?", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      final focusNode =
          getValue(maps["focusNode"], datas, "FocusNode?", vars, props);
      final autofocus = getValue(maps["autofocus"], datas, "bool", vars, props);
      final backgroundColor =
          getValue(maps["backgroundColor"], datas, "Color?", vars, props);
      final padding =
          getValue(maps["padding"], datas, "EdgeInsetsGeometry?", vars, props);
      final visualDensity =
          getValue(maps["visualDensity"], datas, "VisualDensity?", vars, props);
      final materialTapTargetSize = getValue(maps["materialTapTargetSize"],
          datas, "MaterialTapTargetSize?", vars, props);
      final elevation =
          getValue(maps["elevation"], datas, "double?", vars, props);
      final shadowColor =
          getValue(maps["shadowColor"], datas, "Color?", vars, props);
      final surfaceTintColor =
          getValue(maps["surfaceTintColor"], datas, "Color?", vars, props);
      final iconTheme =
          getValue(maps["iconTheme"], datas, "IconThemeData?", vars, props);
      final selectedShadowColor =
          getValue(maps["selectedShadowColor"], datas, "Color?", vars, props);
      final showCheckmark =
          getValue(maps["showCheckmark"], datas, "bool?", vars, props);
      final checkmarkColor =
          getValue(maps["checkmarkColor"], datas, "Color?", vars, props);
      final avatarBorder =
          getValue(maps["avatarBorder"], datas, "ShapeBorder", vars, props);
      final useDeleteButtonTooltip =
          getValue(maps["useDeleteButtonTooltip"], datas, "bool", vars, props);
      if (label == null) {
        return null;
      }
      return InputChip(
        key: key,
        avatar: avatar,
        label: label!,
        labelStyle: labelStyle,
        labelPadding: labelPadding,
        selected: selected ?? false,
        isEnabled: isEnabled ?? true,
        onSelected: onSelected,
        deleteIcon: deleteIcon,
        onDeleted: onDeleted,
        deleteIconColor: deleteIconColor,
        deleteButtonTooltipMessage: deleteButtonTooltipMessage,
        onPressed: onPressed,
        pressElevation: pressElevation,
        disabledColor: disabledColor,
        selectedColor: selectedColor,
        tooltip: tooltip,
        side: side,
        shape: shape,
        clipBehavior: clipBehavior ?? Clip.none,
        focusNode: focusNode,
        autofocus: autofocus ?? false,
        backgroundColor: backgroundColor,
        padding: padding,
        visualDensity: visualDensity,
        materialTapTargetSize: materialTapTargetSize,
        elevation: elevation,
        shadowColor: shadowColor,
        surfaceTintColor: surfaceTintColor,
        iconTheme: iconTheme,
        selectedShadowColor: selectedShadowColor,
        showCheckmark: showCheckmark,
        checkmarkColor: checkmarkColor,
        avatarBorder: avatarBorder ?? const CircleBorder(),
        //  useDeleteButtonTooltip: useDeleteButtonTooltip ?? true,
      );
    },
    "InputDatePickerFormField": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final initialDate =
          getValue(maps["initialDate"], datas, "DateTime?", vars, props);
      final firstDate =
          getValue(maps["firstDate"], datas, "DateTime", vars, props);
      final lastDate =
          getValue(maps["lastDate"], datas, "DateTime", vars, props);
      final onDateSubmitted = getValue(maps["onDateSubmitted"], datas,
          "ValueChanged<DateTime>?", vars, props);
      final onDateSaved = getValue(
          maps["onDateSaved"], datas, "ValueChanged<DateTime>?", vars, props);
      final selectableDayPredicate = getValue(maps["selectableDayPredicate"],
          datas, "SelectableDayPredicate?", vars, props);
      final errorFormatText =
          getValue(maps["errorFormatText"], datas, "String?", vars, props);
      final errorInvalidText =
          getValue(maps["errorInvalidText"], datas, "String?", vars, props);
      final fieldHintText =
          getValue(maps["fieldHintText"], datas, "String?", vars, props);
      final fieldLabelText =
          getValue(maps["fieldLabelText"], datas, "String?", vars, props);
      final keyboardType =
          getValue(maps["keyboardType"], datas, "TextInputType?", vars, props);
      final autofocus = getValue(maps["autofocus"], datas, "bool", vars, props);
      if (firstDate == null || lastDate == null) {
        return null;
      }
      return InputDatePickerFormField(
          key: key,
          initialDate: initialDate,
          firstDate: firstDate!,
          lastDate: lastDate!,
          onDateSubmitted: onDateSubmitted,
          onDateSaved: onDateSaved,
          selectableDayPredicate: selectableDayPredicate,
          errorFormatText: errorFormatText,
          errorInvalidText: errorInvalidText,
          fieldHintText: fieldHintText,
          fieldLabelText: fieldLabelText,
          keyboardType: keyboardType,
          autofocus: autofocus ?? false);
    },
    "InputDecoration": () {
      final icon = getValue(maps["icon"], datas, "", vars, props);
      final iconColor = getValue(maps["iconColor"], datas, "", vars, props);
      final label = getValue(maps["label"], datas, "", vars, props);
      final labelText = getValue(maps["labelText"], datas, "", vars, props);
      final labelStyle = getValue(maps["labelStyle"], datas, "", vars, props);
      final floatingLabelStyle =
          getValue(maps["floatingLabelStyle"], datas, "", vars, props);
      final helperText = getValue(maps["helperText"], datas, "", vars, props);
      final helperStyle = getValue(maps["helperStyle"], datas, "", vars, props);
      final helperMaxLines =
          getValue(maps["helperMaxLines"], datas, "", vars, props);
      final hintText = getValue(maps["hintText"], datas, "", vars, props);
      final hintStyle = getValue(maps["hintStyle"], datas, "", vars, props);
      final hintTextDirection =
          getValue(maps["hintTextDirection"], datas, "", vars, props);
      final hintMaxLines =
          getValue(maps["hintMaxLines"], datas, "", vars, props);
      final errorText = getValue(maps["errorText"], datas, "", vars, props);
      final errorStyle = getValue(maps["errorStyle"], datas, "", vars, props);
      final errorMaxLines =
          getValue(maps["errorMaxLines"], datas, "", vars, props);
      final floatingLabelBehavior =
          getValue(maps["floatingLabelBehavior"], datas, "", vars, props);
      final floatingLabelAlignment =
          getValue(maps["floatingLabelAlignment"], datas, "", vars, props);
      final isCollapsed = getValue(maps["isCollapsed"], datas, "", vars, props);
      final isDense = getValue(maps["isDense"], datas, "", vars, props);
      final contentPadding =
          getValue(maps["contentPadding"], datas, "", vars, props);
      final prefixIcon = getValue(maps["prefixIcon"], datas, "", vars, props);
      final prefixIconConstraints =
          getValue(maps["prefixIconConstraints"], datas, "", vars, props);
      final prefix = getValue(maps["prefix"], datas, "", vars, props);
      final prefixText = getValue(maps["prefixText"], datas, "", vars, props);
      final prefixStyle = getValue(maps["prefixStyle"], datas, "", vars, props);
      final prefixIconColor =
          getValue(maps["prefixIconColor"], datas, "", vars, props);
      final suffixIcon = getValue(maps["suffixIcon"], datas, "", vars, props);
      final suffix = getValue(maps["suffix"], datas, "", vars, props);
      final suffixText = getValue(maps["suffixText"], datas, "", vars, props);
      final suffixStyle = getValue(maps["suffixStyle"], datas, "", vars, props);
      final suffixIconColor =
          getValue(maps["suffixIconColor"], datas, "", vars, props);
      final suffixIconConstraints =
          getValue(maps["suffixIconConstraints"], datas, "", vars, props);
      final counter = getValue(maps["counter"], datas, "", vars, props);
      final counterText = getValue(maps["counterText"], datas, "", vars, props);
      final counterStyle =
          getValue(maps["counterStyle"], datas, "", vars, props);
      final filled = getValue(maps["filled"], datas, "", vars, props);
      final fillColor = getValue(maps["fillColor"], datas, "", vars, props);
      final focusColor = getValue(maps["focusColor"], datas, "", vars, props);
      final hoverColor = getValue(maps["hoverColor"], datas, "", vars, props);
      final errorBorder = getValue(maps["errorBorder"], datas, "", vars, props);
      final focusedBorder =
          getValue(maps["focusedBorder"], datas, "", vars, props);
      final focusedErrorBorder =
          getValue(maps["focusedErrorBorder"], datas, "", vars, props);
      final disabledBorder =
          getValue(maps["disabledBorder"], datas, "", vars, props);
      final enabledBorder =
          getValue(maps["enabledBorder"], datas, "", vars, props);
      final border = getValue(maps["border"], datas, "", vars, props);
      final enabled = getValue(maps["enabled"], datas, "", vars, props);
      final semanticCounterText =
          getValue(maps["semanticCounterText"], datas, "", vars, props);
      final alignLabelWithHint =
          getValue(maps["alignLabelWithHint"], datas, "", vars, props);
      final constraints = getValue(maps["constraints"], datas, "", vars, props);
      return InputDecoration(
          icon: icon,
          iconColor: iconColor,
          label: label,
          labelText: labelText,
          labelStyle: labelStyle,
          floatingLabelStyle: floatingLabelStyle,
          helperText: helperText,
          helperStyle: helperStyle,
          helperMaxLines: helperMaxLines,
          hintText: hintText,
          hintStyle: hintStyle,
          hintTextDirection: hintTextDirection,
          hintMaxLines: hintMaxLines,
          errorText: errorText,
          errorStyle: errorStyle,
          errorMaxLines: errorMaxLines,
          floatingLabelBehavior: floatingLabelBehavior,
          floatingLabelAlignment: floatingLabelAlignment,
          isCollapsed: isCollapsed ?? false,
          isDense: isDense,
          contentPadding: contentPadding,
          prefixIcon: prefixIcon,
          prefixIconConstraints: prefixIconConstraints,
          prefix: prefix,
          prefixText: prefixText,
          prefixStyle: prefixStyle,
          prefixIconColor: prefixIconColor,
          suffixIcon: suffixIcon,
          suffix: suffix,
          suffixText: suffixText,
          suffixStyle: suffixStyle,
          suffixIconColor: suffixIconColor,
          suffixIconConstraints: suffixIconConstraints,
          counter: counter,
          counterText: counterText,
          counterStyle: counterStyle,
          filled: filled,
          fillColor: fillColor,
          focusColor: focusColor,
          hoverColor: hoverColor,
          errorBorder: errorBorder,
          focusedBorder: focusedBorder,
          focusedErrorBorder: focusedErrorBorder,
          disabledBorder: disabledBorder,
          enabledBorder: enabledBorder,
          border: border,
          enabled: enabled ?? true,
          semanticCounterText: semanticCounterText,
          alignLabelWithHint: alignLabelWithHint,
          constraints: constraints);
    },
    "InputDecorationTheme": () {
      final labelStyle =
          getValue(maps["labelStyle"], datas, "TextStyle?", vars, props);
      final floatingLabelStyle = getValue(
          maps["floatingLabelStyle"], datas, "TextStyle?", vars, props);
      final helperStyle =
          getValue(maps["helperStyle"], datas, "TextStyle?", vars, props);
      final helperMaxLines =
          getValue(maps["helperMaxLines"], datas, "int?", vars, props);
      final hintStyle =
          getValue(maps["hintStyle"], datas, "TextStyle?", vars, props);
      final errorStyle =
          getValue(maps["errorStyle"], datas, "TextStyle?", vars, props);
      final errorMaxLines =
          getValue(maps["errorMaxLines"], datas, "int?", vars, props);
      final floatingLabelBehavior = getValue(maps["floatingLabelBehavior"],
          datas, "FloatingLabelBehavior", vars, props);
      final floatingLabelAlignment = getValue(maps["floatingLabelAlignment"],
          datas, "FloatingLabelAlignment", vars, props);
      final isDense = getValue(maps["isDense"], datas, "bool", vars, props);
      final contentPadding = getValue(
          maps["contentPadding"], datas, "EdgeInsetsGeometry?", vars, props);
      final isCollapsed =
          getValue(maps["isCollapsed"], datas, "bool", vars, props);
      final iconColor =
          getValue(maps["iconColor"], datas, "Color?", vars, props);
      final prefixStyle =
          getValue(maps["prefixStyle"], datas, "TextStyle?", vars, props);
      final prefixIconColor =
          getValue(maps["prefixIconColor"], datas, "Color?", vars, props);
      final suffixStyle =
          getValue(maps["suffixStyle"], datas, "TextStyle?", vars, props);
      final suffixIconColor =
          getValue(maps["suffixIconColor"], datas, "Color?", vars, props);
      final counterStyle =
          getValue(maps["counterStyle"], datas, "TextStyle?", vars, props);
      final filled = getValue(maps["filled"], datas, "bool", vars, props);
      final fillColor =
          getValue(maps["fillColor"], datas, "Color?", vars, props);
      final activeIndicatorBorder = getValue(
          maps["activeIndicatorBorder"], datas, "BorderSide?", vars, props);
      final outlineBorder =
          getValue(maps["outlineBorder"], datas, "BorderSide?", vars, props);
      final focusColor =
          getValue(maps["focusColor"], datas, "Color?", vars, props);
      final hoverColor =
          getValue(maps["hoverColor"], datas, "Color?", vars, props);
      final errorBorder =
          getValue(maps["errorBorder"], datas, "InputBorder?", vars, props);
      final focusedBorder =
          getValue(maps["focusedBorder"], datas, "InputBorder?", vars, props);
      final focusedErrorBorder = getValue(
          maps["focusedErrorBorder"], datas, "InputBorder?", vars, props);
      final disabledBorder =
          getValue(maps["disabledBorder"], datas, "InputBorder?", vars, props);
      final enabledBorder =
          getValue(maps["enabledBorder"], datas, "InputBorder?", vars, props);
      final border =
          getValue(maps["border"], datas, "InputBorder?", vars, props);
      final alignLabelWithHint =
          getValue(maps["alignLabelWithHint"], datas, "bool", vars, props);
      final constraints =
          getValue(maps["constraints"], datas, "BoxConstraints?", vars, props);
      return InputDecorationTheme(
          labelStyle: labelStyle,
          floatingLabelStyle: floatingLabelStyle,
          helperStyle: helperStyle,
          helperMaxLines: helperMaxLines,
          hintStyle: hintStyle,
          errorStyle: errorStyle,
          errorMaxLines: errorMaxLines,
          floatingLabelBehavior:
              floatingLabelBehavior ?? FloatingLabelBehavior.auto,
          floatingLabelAlignment:
              floatingLabelAlignment ?? FloatingLabelAlignment.start,
          isDense: isDense ?? false,
          contentPadding: contentPadding,
          isCollapsed: isCollapsed ?? false,
          iconColor: iconColor,
          prefixStyle: prefixStyle,
          prefixIconColor: prefixIconColor,
          suffixStyle: suffixStyle,
          suffixIconColor: suffixIconColor,
          counterStyle: counterStyle,
          filled: filled ?? false,
          fillColor: fillColor,
          activeIndicatorBorder: activeIndicatorBorder,
          outlineBorder: outlineBorder,
          focusColor: focusColor,
          hoverColor: hoverColor,
          errorBorder: errorBorder,
          focusedBorder: focusedBorder,
          focusedErrorBorder: focusedErrorBorder,
          disabledBorder: disabledBorder,
          enabledBorder: enabledBorder,
          border: border,
          alignLabelWithHint: alignLabelWithHint ?? false,
          constraints: constraints);
    },
    "InputDecorator": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final decoration =
          getValue(maps["decoration"], datas, "InputDecoration", vars, props);
      final baseStyle =
          getValue(maps["baseStyle"], datas, "TextStyle?", vars, props);
      final textAlign =
          getValue(maps["textAlign"], datas, "TextAlign?", vars, props);
      final textAlignVertical = getValue(
          maps["textAlignVertical"], datas, "TextAlignVertical?", vars, props);
      final isFocused = getValue(maps["isFocused"], datas, "bool", vars, props);
      final isHovering =
          getValue(maps["isHovering"], datas, "bool", vars, props);
      final expands = getValue(maps["expands"], datas, "bool", vars, props);
      final isEmpty = getValue(maps["isEmpty"], datas, "bool", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      if (decoration == null) {
        return null;
      }
      return InputDecorator(
          key: key,
          decoration: decoration!,
          baseStyle: baseStyle,
          textAlign: textAlign,
          textAlignVertical: textAlignVertical,
          isFocused: isFocused ?? false,
          isHovering: isHovering ?? false,
          expands: expands ?? false,
          isEmpty: isEmpty ?? false,
          child: child);
    },
    "InspectorSerializationDelegate": () {
      final groupName =
          getValue(maps["groupName"], datas, "String?", vars, props);
      final summaryTree =
          getValue(maps["summaryTree"], datas, "bool", vars, props);
      final maxDescendantsTruncatableNode = getValue(
          maps["maxDescendantsTruncatableNode"], datas, "int", vars, props);
      final expandPropertyValues =
          getValue(maps["expandPropertyValues"], datas, "bool", vars, props);
      final subtreeDepth =
          getValue(maps["subtreeDepth"], datas, "int", vars, props);
      final includeProperties =
          getValue(maps["includeProperties"], datas, "bool", vars, props);
      final service = getValue(
          maps["service"], datas, "WidgetInspectorService", vars, props);
      final addAdditionalPropertiesCallback = getValue(
          maps["addAdditionalPropertiesCallback"],
          datas,
          "Map<String, Object>? Function(DiagnosticsNode, InspectorSerializationDelegate)?",
          vars,
          props);
      if (service == null) {
        return null;
      }
      return InspectorSerializationDelegate(
          groupName: groupName,
          summaryTree: summaryTree ?? false,
          maxDescendantsTruncatableNode: maxDescendantsTruncatableNode ?? -1,
          expandPropertyValues: expandPropertyValues ?? true,
          subtreeDepth: subtreeDepth ?? 1,
          includeProperties: includeProperties ?? false,
          service: service!,
          addAdditionalPropertiesCallback: addAdditionalPropertiesCallback);
    },
    "IntProperty": () {
      final name = getValue(maps["0"], datas, "String", vars, props);
      final value = getValue(maps["1"], datas, "T?", vars, props);
      final ifNull = getValue(maps["ifNull"], datas, "String?", vars, props);
      final showName = getValue(maps["showName"], datas, "", vars, props);
      final unit = getValue(maps["unit"], datas, "String?", vars, props);
      final defaultValue =
          getValue(maps["defaultValue"], datas, "Object?", vars, props);
      final style =
          getValue(maps["style"], datas, "DiagnosticsTreeStyle", vars, props);
      final level =
          getValue(maps["level"], datas, "DiagnosticLevel", vars, props);
      if (name == null || value == null) {
        return null;
      }
      if (defaultValue != null) {
        return IntProperty(name!, value!,
            ifNull: ifNull,
            showName: showName,
            unit: unit,
            style: style ?? DiagnosticsTreeStyle.singleLine,
            level: level ?? DiagnosticLevel.info,
            defaultValue: defaultValue);
      }
      return IntProperty(name!, value!,
          ifNull: ifNull,
          showName: showName,
          unit: unit,
          style: style ?? DiagnosticsTreeStyle.singleLine,
          level: level ?? DiagnosticLevel.info);
    },
    "IntTween": () {
      final begin = getValue(maps["begin"], datas, "T?", vars, props);
      final end = getValue(maps["end"], datas, "T?", vars, props);
      return IntTween(begin: begin, end: end);
    },
    "InteractiveViewer": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      final alignPanAxis =
          getValue(maps["alignPanAxis"], datas, "bool", vars, props);
      final panAxis = getValue(maps["panAxis"], datas, "PanAxis", vars, props);
      final boundaryMargin =
          getValue(maps["boundaryMargin"], datas, "EdgeInsets", vars, props);
      final constrained =
          getValue(maps["constrained"], datas, "bool", vars, props);
      final maxScale = getValue(maps["maxScale"], datas, "double", vars, props);
      final minScale = getValue(maps["minScale"], datas, "double", vars, props);
      final interactionEndFrictionCoefficient = getValue(
          maps["interactionEndFrictionCoefficient"],
          datas,
          "double",
          vars,
          props);
      final onInteractionEnd = getValue(maps["onInteractionEnd"], datas,
          "GestureScaleEndCallback?", vars, props);
      final onInteractionStart = getValue(maps["onInteractionStart"], datas,
          "GestureScaleStartCallback?", vars, props);
      final onInteractionUpdate = getValue(maps["onInteractionUpdate"], datas,
          "GestureScaleUpdateCallback?", vars, props);
      final panEnabled =
          getValue(maps["panEnabled"], datas, "bool", vars, props);
      final scaleEnabled =
          getValue(maps["scaleEnabled"], datas, "bool", vars, props);
      final scaleFactor =
          getValue(maps["scaleFactor"], datas, "double", vars, props);
      final transformationController = getValue(
          maps["transformationController"],
          datas,
          "TransformationController?",
          vars,
          props);
      final alignment =
          getValue(maps["alignment"], datas, "Alignment?", vars, props);
      final trackpadScrollCausesScale = getValue(
          maps["trackpadScrollCausesScale"], datas, "bool", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (child == null) {
        return null;
      }
      if (interactionEndFrictionCoefficient != null) {
        return InteractiveViewer(
            key: key,
            clipBehavior: clipBehavior ?? Clip.hardEdge,
            // alignPanAxis: alignPanAxis ?? false,
            panAxis: panAxis ?? PanAxis.free,
            boundaryMargin: boundaryMargin ?? EdgeInsets.zero,
            constrained: constrained ?? true,
            maxScale: maxScale ?? 2.5,
            minScale: minScale ?? 0.8,
            onInteractionEnd: onInteractionEnd,
            onInteractionStart: onInteractionStart,
            onInteractionUpdate: onInteractionUpdate,
            panEnabled: panEnabled ?? true,
            scaleEnabled: scaleEnabled ?? true,
            scaleFactor: scaleFactor ?? kDefaultMouseScrollToScaleFactor,
            transformationController: transformationController,
            alignment: alignment,
            trackpadScrollCausesScale: trackpadScrollCausesScale ?? false,
            child: child!,
            interactionEndFrictionCoefficient:
                interactionEndFrictionCoefficient);
      }
      return InteractiveViewer(
          key: key,
          clipBehavior: clipBehavior ?? Clip.hardEdge,
          //  alignPanAxis: alignPanAxis ?? false,
          panAxis: panAxis ?? PanAxis.free,
          boundaryMargin: boundaryMargin ?? EdgeInsets.zero,
          constrained: constrained ?? true,
          maxScale: maxScale ?? 2.5,
          minScale: minScale ?? 0.8,
          onInteractionEnd: onInteractionEnd,
          onInteractionStart: onInteractionStart,
          onInteractionUpdate: onInteractionUpdate,
          panEnabled: panEnabled ?? true,
          scaleEnabled: scaleEnabled ?? true,
          scaleFactor: scaleFactor ?? kDefaultMouseScrollToScaleFactor,
          transformationController: transformationController,
          alignment: alignment,
          trackpadScrollCausesScale: trackpadScrollCausesScale ?? false,
          child: child!);
    },
    "InteractiveViewer.builder": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      final alignPanAxis =
          getValue(maps["alignPanAxis"], datas, "bool", vars, props);
      final panAxis = getValue(maps["panAxis"], datas, "PanAxis", vars, props);
      final boundaryMargin =
          getValue(maps["boundaryMargin"], datas, "EdgeInsets", vars, props);
      final maxScale = getValue(maps["maxScale"], datas, "double", vars, props);
      final minScale = getValue(maps["minScale"], datas, "double", vars, props);
      final interactionEndFrictionCoefficient = getValue(
          maps["interactionEndFrictionCoefficient"],
          datas,
          "double",
          vars,
          props);
      final onInteractionEnd = getValue(maps["onInteractionEnd"], datas,
          "GestureScaleEndCallback?", vars, props);
      final onInteractionStart = getValue(maps["onInteractionStart"], datas,
          "GestureScaleStartCallback?", vars, props);
      final onInteractionUpdate = getValue(maps["onInteractionUpdate"], datas,
          "GestureScaleUpdateCallback?", vars, props);
      final panEnabled =
          getValue(maps["panEnabled"], datas, "bool", vars, props);
      final scaleEnabled =
          getValue(maps["scaleEnabled"], datas, "bool", vars, props);
      final scaleFactor =
          getValue(maps["scaleFactor"], datas, "double", vars, props);
      final transformationController = getValue(
          maps["transformationController"],
          datas,
          "TransformationController?",
          vars,
          props);
      final alignment =
          getValue(maps["alignment"], datas, "Alignment?", vars, props);
      final trackpadScrollCausesScale = getValue(
          maps["trackpadScrollCausesScale"], datas, "bool", vars, props);
      final builder = getValue(maps["builder"], datas,
          "InteractiveViewerWidgetBuilder", vars, props);
      if (builder == null) {
        return null;
      }
      if (interactionEndFrictionCoefficient != null) {
        return InteractiveViewer.builder(
            key: key,
            clipBehavior: clipBehavior ?? Clip.hardEdge,
            //alignPanAxis: alignPanAxis ?? false,
            panAxis: panAxis ?? PanAxis.free,
            boundaryMargin: boundaryMargin ?? EdgeInsets.zero,
            maxScale: maxScale ?? 2.5,
            minScale: minScale ?? 0.8,
            onInteractionEnd: onInteractionEnd,
            onInteractionStart: onInteractionStart,
            onInteractionUpdate: onInteractionUpdate,
            panEnabled: panEnabled ?? true,
            scaleEnabled: scaleEnabled ?? true,
            scaleFactor: scaleFactor ?? 200.0,
            transformationController: transformationController,
            alignment: alignment,
            trackpadScrollCausesScale: trackpadScrollCausesScale ?? false,
            builder: builder!,
            interactionEndFrictionCoefficient:
                interactionEndFrictionCoefficient);
      }
      return InteractiveViewer.builder(
          key: key,
          clipBehavior: clipBehavior ?? Clip.hardEdge,
          //alignPanAxis: alignPanAxis ?? false,
          panAxis: panAxis ?? PanAxis.free,
          boundaryMargin: boundaryMargin ?? EdgeInsets.zero,
          maxScale: maxScale ?? 2.5,
          minScale: minScale ?? 0.8,
          onInteractionEnd: onInteractionEnd,
          onInteractionStart: onInteractionStart,
          onInteractionUpdate: onInteractionUpdate,
          panEnabled: panEnabled ?? true,
          scaleEnabled: scaleEnabled ?? true,
          scaleFactor: scaleFactor ?? 200.0,
          transformationController: transformationController,
          alignment: alignment,
          trackpadScrollCausesScale: trackpadScrollCausesScale ?? false,
          builder: builder!);
    },
    "IntrinsicColumnWidth": () {
      final flex = getValue(maps["flex"], datas, "double?", vars, props);
      return IntrinsicColumnWidth(flex: flex);
    },
    "IntrinsicHeight": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      return IntrinsicHeight(key: key, child: child);
    },
    "IntrinsicWidth": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final stepWidth =
          getValue(maps["stepWidth"], datas, "double?", vars, props);
      final stepHeight =
          getValue(maps["stepHeight"], datas, "double?", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      return IntrinsicWidth(
          key: key, stepWidth: stepWidth, stepHeight: stepHeight, child: child);
    },
    "Invocation.method": () {
      final memberName = getValue(maps["0"], datas, "Symbol", vars, props);
      final positionalArguments =
          getValue(maps["1"], datas, "Iterable<Object?>?", vars, props);
      final namedArguments =
          getValue(maps["2"], datas, "Map<Symbol,   Object?>?", vars, props);
      if (memberName == null || positionalArguments == null) {
        return null;
      }
      return Invocation.method(memberName!, positionalArguments!,
          namedArguments ? Map<Symbol, Object?>.from(namedArguments) : null);
    },
    "Invocation.genericMethod": () {
      final memberName = getValue(maps["0"], datas, "Symbol", vars, props);
      final typeArguments =
          getValue(maps["1"], datas, "Iterable<Type>?", vars, props);
      final positionalArguments =
          getValue(maps["2"], datas, "Iterable<Object?>?", vars, props);
      final namedArguments =
          getValue(maps["3"], datas, "Map<Symbol,   Object?>?", vars, props);
      if (memberName == null ||
          typeArguments == null ||
          positionalArguments == null) {
        return null;
      }
      return Invocation.genericMethod(
          memberName!,
          typeArguments!,
          positionalArguments!,
          namedArguments ? Map<Symbol, Object?>.from(namedArguments) : null);
    },
    "Invocation.getter": () {
      final name = getValue(maps["0"], datas, "Symbol", vars, props);
      if (name == null) {
        return null;
      }
      return Invocation.getter(name!);
    },
    "Invocation.setter": () {
      final memberName = getValue(maps["0"], datas, "Symbol", vars, props);
      final argument = getValue(maps["1"], datas, "Object?", vars, props);
      if (memberName == null || argument == null) {
        return null;
      }
      return Invocation.setter(memberName!, argument!);
    },
    "IterableProperty": () {
      final name = getValue(maps["0"], datas, "String", vars, props);
      final value = getValue(maps["1"], datas, "T?", vars, props);
      final defaultValue =
          getValue(maps["defaultValue"], datas, "Object?", vars, props);
      final ifNull = getValue(maps["ifNull"], datas, "String?", vars, props);
      final ifEmpty = getValue(maps["ifEmpty"], datas, "String?", vars, props);
      final style =
          getValue(maps["style"], datas, "DiagnosticsTreeStyle", vars, props);
      final showName = getValue(maps["showName"], datas, "", vars, props);
      final showSeparator =
          getValue(maps["showSeparator"], datas, "", vars, props);
      final level =
          getValue(maps["level"], datas, "DiagnosticLevel", vars, props);
      if (name == null || value == null) {
        return null;
      }
      if (defaultValue != null) {
        return IterableProperty(name!, value!,
            ifNull: ifNull,
            ifEmpty: ifEmpty ?? '[]',
            style: style ?? DiagnosticsTreeStyle.singleLine,
            showName: showName,
            showSeparator: showSeparator,
            level: level ?? DiagnosticLevel.info,
            defaultValue: defaultValue);
      }
      return IterableProperty(name!, value!,
          ifNull: ifNull,
          ifEmpty: ifEmpty ?? '[]',
          style: style ?? DiagnosticsTreeStyle.singleLine,
          showName: showName,
          showSeparator: showSeparator,
          level: level ?? DiagnosticLevel.info);
    },
    "JSONMessageCodec": () {
      return const JSONMessageCodec();
    },
    "JSONMethodCodec": () {
      return const JSONMethodCodec();
    },
    "KeepAlive": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final keepAlive = getValue(maps["keepAlive"], datas, "bool", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (keepAlive == null || child == null) {
        return null;
      }
      return KeepAlive(key: key, keepAlive: keepAlive!, child: child!);
    },
    "KeepAliveNotification": () {
      final handle = getValue(maps["0"], datas, "Listenable", vars, props);
      if (handle == null) {
        return null;
      }
      return KeepAliveNotification(handle!);

//  },"Key.empty": () {
// return Key.empty();
    },
    "KeyDownEvent": () {
      final physicalKey = getValue(
          maps["physicalKey"], datas, "PhysicalKeyboardKey", vars, props);
      final logicalKey = getValue(
          maps["logicalKey"], datas, "LogicalKeyboardKey", vars, props);
      final character =
          getValue(maps["character"], datas, "String?", vars, props);
      final timeStamp =
          getValue(maps["timeStamp"], datas, "Duration", vars, props);
      final synthesized =
          getValue(maps["synthesized"], datas, "bool", vars, props);
      if (physicalKey == null || logicalKey == null || timeStamp == null) {
        return null;
      }
      return KeyDownEvent(
          physicalKey: physicalKey!,
          logicalKey: logicalKey!,
          character: character,
          timeStamp: timeStamp!,
          synthesized: synthesized ?? false);
    },
    "KeyEventManager": () {
      final _hardwareKeyboard =
          getValue(maps["0"], datas, "HardwareKeyboard", vars, props);
      final _rawKeyboard =
          getValue(maps["1"], datas, "RawKeyboard", vars, props);
      if (_hardwareKeyboard == null || _rawKeyboard == null) {
        return null;
      }
      return KeyEventManager(_hardwareKeyboard!, _rawKeyboard!);
    },
    "KeyMessage": () {
      final events = getValue(maps["0"], datas, "List<KeyEvent>", vars, props);
      final rawEvent = getValue(maps["1"], datas, "RawKeyEvent?", vars, props);
      if (events == null || rawEvent == null) {
        return null;
      }
      return KeyMessage(List<KeyEvent>.from(events!), rawEvent!);
    },
    "KeyRepeatEvent": () {
      final physicalKey = getValue(
          maps["physicalKey"], datas, "PhysicalKeyboardKey", vars, props);
      final logicalKey = getValue(
          maps["logicalKey"], datas, "LogicalKeyboardKey", vars, props);
      final character =
          getValue(maps["character"], datas, "String?", vars, props);
      final timeStamp =
          getValue(maps["timeStamp"], datas, "Duration", vars, props);
      if (physicalKey == null || logicalKey == null || timeStamp == null) {
        return null;
      }
      return KeyRepeatEvent(
          physicalKey: physicalKey!,
          logicalKey: logicalKey!,
          character: character,
          timeStamp: timeStamp!);
    },
    "KeySet": () {
      final key1 = getValue(maps["0"], datas, "T", vars, props);
      final key2 = getValue(maps["1"], datas, "T?", vars, props);
      final key3 = getValue(maps["2"], datas, "T?", vars, props);
      final key4 = getValue(maps["3"], datas, "T?", vars, props);
      if (key1 == null) {
        return null;
      }
      return KeySet<K>(key1!, key2, key3, key4);
    },
    "KeySet.fromSet": () {
      final keys = getValue(maps["0"], datas, "Set<T>", vars, props);
      if (keys == null) {
        return null;
      }
      return KeySet<K>.fromSet(Set<K>.from(keys!));
    },
    "KeyUpEvent": () {
      final physicalKey = getValue(
          maps["physicalKey"], datas, "PhysicalKeyboardKey", vars, props);
      final logicalKey = getValue(
          maps["logicalKey"], datas, "LogicalKeyboardKey", vars, props);
      final timeStamp =
          getValue(maps["timeStamp"], datas, "Duration", vars, props);
      final synthesized =
          getValue(maps["synthesized"], datas, "bool", vars, props);
      if (physicalKey == null || logicalKey == null || timeStamp == null) {
        return null;
      }
      return KeyUpEvent(
          physicalKey: physicalKey!,
          logicalKey: logicalKey!,
          timeStamp: timeStamp!,
          synthesized: synthesized ?? false);
    },
    "KeyboardInsertedContent": () {
      final mimeType = getValue(maps["mimeType"], datas, "String", vars, props);
      final uri = getValue(maps["uri"], datas, "String", vars, props);
      final data = getValue(maps["data"], datas, "Uint8List?", vars, props);
      if (mimeType == null || uri == null) {
        return null;
      }
      return KeyboardInsertedContent(
          mimeType: mimeType!, uri: uri!, data: data);
    },
    "KeyboardInsertedContent.fromJson": () {
      final metadata =
          getValue(maps["0"], datas, "Map<String,   dynamic>", vars, props);
      if (metadata == null) {
        return null;
      }
      return KeyboardInsertedContent.fromJson(
          Map<String, dynamic>.from(metadata!));
    },
    "KeyboardListener": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final focusNode =
          getValue(maps["focusNode"], datas, "FocusNode", vars, props);
      final autofocus = getValue(maps["autofocus"], datas, "bool", vars, props);
      final includeSemantics =
          getValue(maps["includeSemantics"], datas, "bool", vars, props);
      final onKeyEvent = getValue(
          maps["onKeyEvent"], datas, "ValueChanged<KeyEvent>?", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (focusNode == null || child == null) {
        return null;
      }
      return KeyboardListener(
          key: key,
          focusNode: focusNode!,
          autofocus: autofocus ?? false,
          includeSemantics: includeSemantics ?? true,
          onKeyEvent: onKeyEvent,
          child: child!);
    },
    "KeyedSubtree": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (child == null) {
        return null;
      }
      return KeyedSubtree(key: key, child: child!);
    },
    "KeyedSubtree.wrap": () {
      final child = getValue(maps["0"], datas, "Widget", vars, props);
      final childIndex = getValue(maps["1"], datas, "int", vars, props);
      if (child == null || childIndex == null) {
        return null;
      }
      return KeyedSubtree.wrap(child!, childIndex!);
    },
    "LabeledGlobalKey": () {
      final _debugLabel = getValue(maps["0"], datas, "String?", vars, props);
      if (_debugLabel == null) {
        return null;
      }
      return LabeledGlobalKey(_debugLabel!);
    },
    "LayoutBuilder": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final builder = getValue(
          maps["builder"],
          datas,
          "Widget Function(BuildContext context, ConstraintType constraints)",
          vars,
          props);
      if (builder == null) {
        return null;
      }
      return LayoutBuilder(key: key, builder: builder!);
    },
    "LayoutChangedNotification": () {
      return const LayoutChangedNotification();
    },
    "LayoutId": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final id = getValue(maps["id"], datas, "Object", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (id == null || child == null) {
        return null;
      }
      return LayoutId(key: key, id: id!, child: child!);
    },
    "LengthLimitingTextInputFormatter": () {
      final maxLength = getValue(maps["0"], datas, "int?", vars, props);
      final maxLengthEnforcement = getValue(maps["maxLengthEnforcement"], datas,
          "MaxLengthEnforcement?", vars, props);
      if (maxLength == null) {
        return null;
      }
      return LengthLimitingTextInputFormatter(maxLength!,
          maxLengthEnforcement: maxLengthEnforcement);
    },
    "LexicalFocusOrder": () {
      final order = getValue(maps["0"], datas, "String", vars, props);
      if (order == null) {
        return null;
      }
      return LexicalFocusOrder(order!);
    },
    "LicenseEntryWithLineBreaks": () {
      final packages = getValue(maps["0"], datas, "List<String>", vars, props);
      final text = getValue(maps["1"], datas, "String", vars, props);
      if (packages == null || text == null) {
        return null;
      }
      return LicenseEntryWithLineBreaks(List<String>.from(packages!), text!);
    },
    "LicensePage": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final applicationName =
          getValue(maps["applicationName"], datas, "String?", vars, props);
      final applicationVersion =
          getValue(maps["applicationVersion"], datas, "String?", vars, props);
      final applicationIcon =
          getValue(maps["applicationIcon"], datas, "Widget?", vars, props);
      final applicationLegalese =
          getValue(maps["applicationLegalese"], datas, "String?", vars, props);
      return LicensePage(
          key: key,
          applicationName: applicationName,
          applicationVersion: applicationVersion,
          applicationIcon: applicationIcon,
          applicationLegalese: applicationLegalese);
    },
    "LicenseParagraph": () {
      final text = getValue(maps["0"], datas, "String", vars, props);
      final indent = getValue(maps["1"], datas, "int", vars, props);
      if (text == null || indent == null) {
        return null;
      }
      return LicenseParagraph(text!, indent!);
    },
    "LimitedBox": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final maxWidth = getValue(maps["maxWidth"], datas, "double", vars, props);
      final maxHeight =
          getValue(maps["maxHeight"], datas, "double", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      return LimitedBox(
          key: key,
          maxWidth: maxWidth ?? double.infinity,
          maxHeight: maxHeight ?? double.infinity,
          child: child);
    },
    "LineBoundary": () {
      final _textLayout =
          getValue(maps["0"], datas, "TextLayoutMetrics", vars, props);
      if (_textLayout == null) {
        return null;
      }
      return LineBoundary(_textLayout!);
    },
    "LineMetrics": () {
      final hardBreak = getValue(maps["hardBreak"], datas, "bool", vars, props);
      final ascent = getValue(maps["ascent"], datas, "double", vars, props);
      final descent = getValue(maps["descent"], datas, "double", vars, props);
      final unscaledAscent =
          getValue(maps["unscaledAscent"], datas, "double", vars, props);
      final height = getValue(maps["height"], datas, "double", vars, props);
      final width = getValue(maps["width"], datas, "double", vars, props);
      final left = getValue(maps["left"], datas, "double", vars, props);
      final baseline = getValue(maps["baseline"], datas, "double", vars, props);
      final lineNumber =
          getValue(maps["lineNumber"], datas, "int", vars, props);
      if (hardBreak == null ||
          ascent == null ||
          descent == null ||
          unscaledAscent == null ||
          height == null ||
          width == null ||
          left == null ||
          baseline == null ||
          lineNumber == null) {
        return null;
      }
      return ui.LineMetrics(
          hardBreak: hardBreak!,
          ascent: ascent!,
          descent: descent!,
          unscaledAscent: unscaledAscent!,
          height: height!,
          width: width!,
          left: left!,
          baseline: baseline!,
          lineNumber: lineNumber!);
    },
    "LinearBorderEdge": () {
      final size = getValue(maps["size"], datas, "double", vars, props);
      final alignment =
          getValue(maps["alignment"], datas, "double", vars, props);
      return LinearBorderEdge(size: size ?? 1.0, alignment: alignment ?? 0.0);
    },
    "LinearGradient": () {
      final begin =
          getValue(maps["begin"], datas, "AlignmentGeometry", vars, props);
      final end =
          getValue(maps["end"], datas, "AlignmentGeometry", vars, props);
      final colors = getValue(maps["colors"], datas, "", vars, props);
      final stops = getValue(maps["stops"], datas, "", vars, props);
      final tileMode =
          getValue(maps["tileMode"], datas, "TileMode", vars, props);
      final transform = getValue(maps["transform"], datas, "", vars, props);
      if (colors == null) {
        return null;
      }
      return LinearGradient(
          begin: begin ?? Alignment.centerLeft,
          end: end ?? Alignment.centerRight,
          colors: colors!,
          stops: stops,
          tileMode: tileMode ?? TileMode.clamp,
          transform: transform);
    },
    "LinearProgressIndicator": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final value = getValue(maps["value"], datas, "double?", vars, props);
      final backgroundColor =
          getValue(maps["backgroundColor"], datas, "Color?", vars, props);
      final color = getValue(maps["color"], datas, "Color?", vars, props);
      final valueColor = getValue(
          maps["valueColor"], datas, "Animation<Color?>?", vars, props);
      final minHeight =
          getValue(maps["minHeight"], datas, "double?", vars, props);
      final semanticsLabel =
          getValue(maps["semanticsLabel"], datas, "String?", vars, props);
      final semanticsValue =
          getValue(maps["semanticsValue"], datas, "String?", vars, props);
      return LinearProgressIndicator(
          key: key,
          value: value,
          backgroundColor: backgroundColor,
          color: color,
          valueColor: valueColor,
          minHeight: minHeight,
          semanticsLabel: semanticsLabel,
          semanticsValue: semanticsValue);
    },
    "List.filled": () {
      final length = getValue(maps["0"], datas, "int", vars, props);
      final fill = getValue(maps["1"], datas, "E", vars, props);
      final growable = getValue(maps["growable"], datas, "bool", vars, props);
      if (length == null || fill == null) {
        return null;
      }
      return List.filled(length!, fill!, growable: growable ?? false);
    },
    "List.empty": () {
      return List.empty();
    },
    "List.from": () {
      final elements = getValue(maps["0"], datas, "Iterable", vars, props);
      final growable = getValue(maps["growable"], datas, "bool", vars, props);
      if (elements == null) {
        return null;
      }
      return List.from(elements!, growable: growable ?? true);
    },
    "List.of": () {
      final elements = getValue(maps["0"], datas, "Iterable<E>", vars, props);
      final growable = getValue(maps["growable"], datas, "bool", vars, props);
      if (elements == null) {
        return null;
      }
      return List.of(elements!, growable: growable ?? true);
    },
    "List.generate": () {
      final length = getValue(maps["0"], datas, "int", vars, props);
      final generator =
          getValue(maps["1"], datas, "E Function(int index)", vars, props);
      final growable = getValue(maps["growable"], datas, "bool", vars, props);
      if (length == null || generator == null) {
        return null;
      }
      return List.generate(length!, generator!, growable: growable ?? true);
    },
    "List.unmodifiable": () {
      final elements = getValue(maps["0"], datas, "Iterable", vars, props);
      if (elements == null) {
        return null;
      }
      return List.unmodifiable(elements!);
    },
    "ListBody": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final mainAxis = getValue(maps["mainAxis"], datas, "Axis", vars, props);
      final reverse = getValue(maps["reverse"], datas, "bool", vars, props);
      final children =
          getValue(maps["children"], datas, "List<Widget>", vars, props);
      return ListBody(
          key: key,
          mainAxis: mainAxis ?? Axis.vertical,
          reverse: reverse ?? false,
          children: List<Widget>.from(children ?? const <Widget>[]));
    },
    "ListTile": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final leading = getValue(maps["leading"], datas, "Widget?", vars, props);
      final title = getValue(maps["title"], datas, "Widget?", vars, props);
      final subtitle =
          getValue(maps["subtitle"], datas, "Widget?", vars, props);
      final trailing =
          getValue(maps["trailing"], datas, "Widget?", vars, props);
      final isThreeLine =
          getValue(maps["isThreeLine"], datas, "bool", vars, props);
      final dense = getValue(maps["dense"], datas, "bool?", vars, props);
      final visualDensity =
          getValue(maps["visualDensity"], datas, "VisualDensity?", vars, props);
      final shape = getValue(maps["shape"], datas, "ShapeBorder?", vars, props);
      final style =
          getValue(maps["style"], datas, "ListTileStyle?", vars, props);
      final selectedColor =
          getValue(maps["selectedColor"], datas, "Color?", vars, props);
      final iconColor =
          getValue(maps["iconColor"], datas, "Color?", vars, props);
      final textColor =
          getValue(maps["textColor"], datas, "Color?", vars, props);
      final titleTextStyle =
          getValue(maps["titleTextStyle"], datas, "TextStyle?", vars, props);
      final subtitleTextStyle =
          getValue(maps["subtitleTextStyle"], datas, "TextStyle?", vars, props);
      final leadingAndTrailingTextStyle = getValue(
          maps["leadingAndTrailingTextStyle"],
          datas,
          "TextStyle?",
          vars,
          props);
      final contentPadding = getValue(
          maps["contentPadding"], datas, "EdgeInsetsGeometry?", vars, props);
      final enabled = getValue(maps["enabled"], datas, "bool", vars, props);
      final onTap =
          getValue(maps["onTap"], datas, "GestureTapCallback?", vars, props);
      final onLongPress = getValue(
          maps["onLongPress"], datas, "GestureLongPressCallback?", vars, props);
      final onFocusChange = getValue(
          maps["onFocusChange"], datas, "ValueChanged<bool>?", vars, props);
      final mouseCursor =
          getValue(maps["mouseCursor"], datas, "MouseCursor?", vars, props);
      final selected = getValue(maps["selected"], datas, "Color?", vars, props);
      final focusColor =
          getValue(maps["focusColor"], datas, "Color?", vars, props);
      final hoverColor =
          getValue(maps["hoverColor"], datas, "Color?", vars, props);
      final splashColor =
          getValue(maps["splashColor"], datas, "Color?", vars, props);
      final focusNode =
          getValue(maps["focusNode"], datas, "FocusNode?", vars, props);
      final autofocus = getValue(maps["autofocus"], datas, "bool", vars, props);
      final tileColor =
          getValue(maps["tileColor"], datas, "Color?", vars, props);
      final selectedTileColor =
          getValue(maps["selectedTileColor"], datas, "Color?", vars, props);
      final enableFeedback =
          getValue(maps["enableFeedback"], datas, "bool?", vars, props);
      final horizontalTitleGap =
          getValue(maps["horizontalTitleGap"], datas, "double?", vars, props);
      final minVerticalPadding =
          getValue(maps["minVerticalPadding"], datas, "double?", vars, props);
      final minLeadingWidth =
          getValue(maps["minLeadingWidth"], datas, "double?", vars, props);
      final titleAlignment = getValue(maps["titleAlignment"], datas,
          "ListTileTitleAlignment?", vars, props);
      return ListTile(
          key: key,
          leading: leading,
          title: title,
          subtitle: subtitle,
          trailing: trailing,
          isThreeLine: isThreeLine ?? false,
          dense: dense,
          visualDensity: visualDensity,
          shape: shape,
          style: style,
          selectedColor: selectedColor,
          iconColor: iconColor,
          textColor: textColor,
          titleTextStyle: titleTextStyle,
          subtitleTextStyle: subtitleTextStyle,
          leadingAndTrailingTextStyle: leadingAndTrailingTextStyle,
          contentPadding: contentPadding,
          enabled: enabled ?? true,
          onTap: onTap,
          onLongPress: onLongPress,
          onFocusChange: onFocusChange,
          mouseCursor: mouseCursor,
          selected: selected ?? false,
          focusColor: focusColor,
          hoverColor: hoverColor,
          splashColor: splashColor,
          focusNode: focusNode,
          autofocus: autofocus ?? false,
          tileColor: tileColor,
          selectedTileColor: selectedTileColor,
          enableFeedback: enableFeedback,
          horizontalTitleGap: horizontalTitleGap,
          minVerticalPadding: minVerticalPadding,
          minLeadingWidth: minLeadingWidth,
          titleAlignment: titleAlignment);
    },
    "ListTileTheme": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final data =
          getValue(maps["data"], datas, "ListTileThemeData?", vars, props);
      final dense = getValue(maps["dense"], datas, "bool?", vars, props);
      final shape = getValue(maps["shape"], datas, "ShapeBorder?", vars, props);
      final style =
          getValue(maps["style"], datas, "ListTileStyle?", vars, props);
      final selectedColor =
          getValue(maps["selectedColor"], datas, "Color?", vars, props);
      final iconColor =
          getValue(maps["iconColor"], datas, "Color?", vars, props);
      final textColor =
          getValue(maps["textColor"], datas, "Color?", vars, props);
      final contentPadding = getValue(
          maps["contentPadding"], datas, "EdgeInsetsGeometry?", vars, props);
      final tileColor =
          getValue(maps["tileColor"], datas, "Color?", vars, props);
      final selectedTileColor =
          getValue(maps["selectedTileColor"], datas, "Color?", vars, props);
      final enableFeedback =
          getValue(maps["enableFeedback"], datas, "bool?", vars, props);
      final mouseCursor = getValue(maps["mouseCursor"], datas,
          "MaterialStateProperty<MouseCursor?>?", vars, props);
      final horizontalTitleGap =
          getValue(maps["horizontalTitleGap"], datas, "double?", vars, props);
      final minVerticalPadding =
          getValue(maps["minVerticalPadding"], datas, "double?", vars, props);
      final minLeadingWidth =
          getValue(maps["minLeadingWidth"], datas, "double?", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (child == null) {
        return null;
      }
      return ListTileTheme(
          key: key,
          data: data,
          dense: dense,
          shape: shape,
          style: style,
          selectedColor: selectedColor,
          iconColor: iconColor,
          textColor: textColor,
          contentPadding: contentPadding,
          tileColor: tileColor,
          selectedTileColor: selectedTileColor,
          enableFeedback: enableFeedback,
          mouseCursor: mouseCursor,
          horizontalTitleGap: horizontalTitleGap,
          minVerticalPadding: minVerticalPadding,
          minLeadingWidth: minLeadingWidth,
          child: child!);
    },
    "ListView": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final scrollDirection =
          getValue(maps["scrollDirection"], datas, "Axis", vars, props);
      final reverse = getValue(maps["reverse"], datas, "bool", vars, props);
      final controller =
          getValue(maps["controller"], datas, "ScrollController?", vars, props);
      final primary = getValue(maps["primary"], datas, "bool?", vars, props);
      final physics =
          getValue(maps["physics"], datas, "ScrollPhysics?", vars, props);
      final shrinkWrap =
          getValue(maps["shrinkWrap"], datas, "bool", vars, props);
      final padding =
          getValue(maps["padding"], datas, "EdgeInsetsGeometry?", vars, props);
      final itemExtent =
          getValue(maps["itemExtent"], datas, "double?", vars, props);
      final prototypeItem =
          getValue(maps["prototypeItem"], datas, "Widget?", vars, props);
      final addAutomaticKeepAlives =
          getValue(maps["addAutomaticKeepAlives"], datas, "bool", vars, props);
      final addRepaintBoundaries =
          getValue(maps["addRepaintBoundaries"], datas, "bool", vars, props);
      final addSemanticIndexes =
          getValue(maps["addSemanticIndexes"], datas, "bool", vars, props);
      final cacheExtent =
          getValue(maps["cacheExtent"], datas, "double?", vars, props);
      final children =
          getValue(maps["children"], datas, "List<Widget>", vars, props);
      final semanticChildCount =
          getValue(maps["semanticChildCount"], datas, "int?", vars, props);
      final dragStartBehavior = getValue(
          maps["dragStartBehavior"], datas, "DragStartBehavior", vars, props);
      final keyboardDismissBehavior = getValue(maps["keyboardDismissBehavior"],
          datas, "ScrollViewKeyboardDismissBehavior", vars, props);
      final restorationId =
          getValue(maps["restorationId"], datas, "String?", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      return ListView(
          key: key,
          scrollDirection: scrollDirection ?? Axis.vertical,
          reverse: reverse ?? false,
          controller: controller,
          primary: primary,
          physics: physics,
          shrinkWrap: shrinkWrap ?? false,
          padding: padding,
          itemExtent: itemExtent,
          prototypeItem: prototypeItem,
          addAutomaticKeepAlives: addAutomaticKeepAlives ?? true,
          addRepaintBoundaries: addRepaintBoundaries ?? true,
          addSemanticIndexes: addSemanticIndexes ?? true,
          cacheExtent: cacheExtent,
          semanticChildCount: semanticChildCount,
          dragStartBehavior: dragStartBehavior ?? DragStartBehavior.start,
          keyboardDismissBehavior: keyboardDismissBehavior ??
              ScrollViewKeyboardDismissBehavior.manual,
          restorationId: restorationId,
          clipBehavior: clipBehavior ?? Clip.hardEdge,
          children: List<Widget>.from(children ?? const <Widget>[]));
    },
    "ListView.builder": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final scrollDirection =
          getValue(maps["scrollDirection"], datas, "Axis", vars, props);
      final reverse = getValue(maps["reverse"], datas, "bool", vars, props);
      final controller =
          getValue(maps["controller"], datas, "ScrollController?", vars, props);
      final primary = getValue(maps["primary"], datas, "bool?", vars, props);
      final physics =
          getValue(maps["physics"], datas, "ScrollPhysics?", vars, props);
      final shrinkWrap =
          getValue(maps["shrinkWrap"], datas, "bool", vars, props);
      final padding =
          getValue(maps["padding"], datas, "EdgeInsetsGeometry?", vars, props);
      final itemExtent =
          getValue(maps["itemExtent"], datas, "double?", vars, props);
      final prototypeItem =
          getValue(maps["prototypeItem"], datas, "Widget?", vars, props);
      final itemBuilder = getValue(maps["itemBuilder"], datas,
          "NullableIndexedWidgetBuilder", vars, props);
      final findChildIndexCallback = getValue(maps["findChildIndexCallback"],
          datas, "ChildIndexGetter?", vars, props);
      final itemCount = getValue(maps["itemCount"], datas, "int?", vars, props);
      final addAutomaticKeepAlives =
          getValue(maps["addAutomaticKeepAlives"], datas, "bool", vars, props);
      final addRepaintBoundaries =
          getValue(maps["addRepaintBoundaries"], datas, "bool", vars, props);
      final addSemanticIndexes =
          getValue(maps["addSemanticIndexes"], datas, "bool", vars, props);
      final cacheExtent =
          getValue(maps["cacheExtent"], datas, "double?", vars, props);
      final semanticChildCount =
          getValue(maps["semanticChildCount"], datas, "int?", vars, props);
      final dragStartBehavior = getValue(
          maps["dragStartBehavior"], datas, "DragStartBehavior", vars, props);
      final keyboardDismissBehavior = getValue(maps["keyboardDismissBehavior"],
          datas, "ScrollViewKeyboardDismissBehavior", vars, props);
      final restorationId =
          getValue(maps["restorationId"], datas, "String?", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      if (itemBuilder == null) {
        return null;
      }
      return ListView.builder(
          key: key,
          scrollDirection: scrollDirection ?? Axis.vertical,
          reverse: reverse ?? false,
          controller: controller,
          primary: primary,
          physics: physics,
          shrinkWrap: shrinkWrap ?? false,
          padding: padding,
          itemExtent: itemExtent,
          prototypeItem: prototypeItem,
          itemBuilder: itemBuilder!,
          findChildIndexCallback: findChildIndexCallback,
          itemCount: itemCount,
          addAutomaticKeepAlives: addAutomaticKeepAlives ?? true,
          addRepaintBoundaries: addRepaintBoundaries ?? true,
          addSemanticIndexes: addSemanticIndexes ?? true,
          cacheExtent: cacheExtent,
          semanticChildCount: semanticChildCount,
          dragStartBehavior: dragStartBehavior ?? DragStartBehavior.start,
          keyboardDismissBehavior: keyboardDismissBehavior ??
              ScrollViewKeyboardDismissBehavior.manual,
          restorationId: restorationId,
          clipBehavior: clipBehavior ?? Clip.hardEdge);
    },
    "ListView.separated": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final scrollDirection =
          getValue(maps["scrollDirection"], datas, "Axis", vars, props);
      final reverse = getValue(maps["reverse"], datas, "bool", vars, props);
      final controller =
          getValue(maps["controller"], datas, "ScrollController?", vars, props);
      final primary = getValue(maps["primary"], datas, "bool?", vars, props);
      final physics =
          getValue(maps["physics"], datas, "ScrollPhysics?", vars, props);
      final shrinkWrap =
          getValue(maps["shrinkWrap"], datas, "bool", vars, props);
      final padding =
          getValue(maps["padding"], datas, "EdgeInsetsGeometry?", vars, props);
      final itemBuilder = getValue(maps["itemBuilder"], datas,
          "NullableIndexedWidgetBuilder", vars, props);
      final findChildIndexCallback = getValue(maps["findChildIndexCallback"],
          datas, "ChildIndexGetter?", vars, props);
      final separatorBuilder = getValue(
          maps["separatorBuilder"], datas, "IndexedWidgetBuilder", vars, props);
      final itemCount = getValue(maps["itemCount"], datas, "int", vars, props);
      final addAutomaticKeepAlives =
          getValue(maps["addAutomaticKeepAlives"], datas, "bool", vars, props);
      final addRepaintBoundaries =
          getValue(maps["addRepaintBoundaries"], datas, "bool", vars, props);
      final addSemanticIndexes =
          getValue(maps["addSemanticIndexes"], datas, "bool", vars, props);
      final cacheExtent =
          getValue(maps["cacheExtent"], datas, "double?", vars, props);
      final dragStartBehavior = getValue(
          maps["dragStartBehavior"], datas, "DragStartBehavior", vars, props);
      final keyboardDismissBehavior = getValue(maps["keyboardDismissBehavior"],
          datas, "ScrollViewKeyboardDismissBehavior", vars, props);
      final restorationId =
          getValue(maps["restorationId"], datas, "String?", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      if (itemBuilder == null ||
          separatorBuilder == null ||
          itemCount == null) {
        return null;
      }
      return ListView.separated(
          key: key,
          scrollDirection: scrollDirection ?? Axis.vertical,
          reverse: reverse ?? false,
          controller: controller,
          primary: primary,
          physics: physics,
          shrinkWrap: shrinkWrap ?? false,
          padding: padding,
          itemBuilder: itemBuilder!,
          findChildIndexCallback: findChildIndexCallback,
          separatorBuilder: separatorBuilder!,
          itemCount: itemCount!,
          addAutomaticKeepAlives: addAutomaticKeepAlives ?? true,
          addRepaintBoundaries: addRepaintBoundaries ?? true,
          addSemanticIndexes: addSemanticIndexes ?? true,
          cacheExtent: cacheExtent,
          dragStartBehavior: dragStartBehavior ?? DragStartBehavior.start,
          keyboardDismissBehavior: keyboardDismissBehavior ??
              ScrollViewKeyboardDismissBehavior.manual,
          restorationId: restorationId,
          clipBehavior: clipBehavior ?? Clip.hardEdge);
    },
    "ListView.custom": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final scrollDirection =
          getValue(maps["scrollDirection"], datas, "Axis", vars, props);
      final reverse = getValue(maps["reverse"], datas, "bool", vars, props);
      final controller =
          getValue(maps["controller"], datas, "ScrollController?", vars, props);
      final primary = getValue(maps["primary"], datas, "bool?", vars, props);
      final physics =
          getValue(maps["physics"], datas, "ScrollPhysics?", vars, props);
      final shrinkWrap =
          getValue(maps["shrinkWrap"], datas, "bool", vars, props);
      final padding =
          getValue(maps["padding"], datas, "EdgeInsetsGeometry?", vars, props);
      final itemExtent =
          getValue(maps["itemExtent"], datas, "double?", vars, props);
      final prototypeItem =
          getValue(maps["prototypeItem"], datas, "Widget?", vars, props);
      final childrenDelegate = getValue(
          maps["childrenDelegate"], datas, "SliverChildDelegate", vars, props);
      final cacheExtent =
          getValue(maps["cacheExtent"], datas, "double?", vars, props);
      final semanticChildCount =
          getValue(maps["semanticChildCount"], datas, "int?", vars, props);
      final dragStartBehavior = getValue(
          maps["dragStartBehavior"], datas, "DragStartBehavior", vars, props);
      final keyboardDismissBehavior = getValue(maps["keyboardDismissBehavior"],
          datas, "ScrollViewKeyboardDismissBehavior", vars, props);
      final restorationId =
          getValue(maps["restorationId"], datas, "String?", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      if (childrenDelegate == null) {
        return null;
      }
      return ListView.custom(
          key: key,
          scrollDirection: scrollDirection ?? Axis.vertical,
          reverse: reverse ?? false,
          controller: controller,
          primary: primary,
          physics: physics,
          shrinkWrap: shrinkWrap ?? false,
          padding: padding,
          itemExtent: itemExtent,
          prototypeItem: prototypeItem,
          childrenDelegate: childrenDelegate!,
          cacheExtent: cacheExtent,
          semanticChildCount: semanticChildCount,
          dragStartBehavior: dragStartBehavior ?? DragStartBehavior.start,
          keyboardDismissBehavior: keyboardDismissBehavior ??
              ScrollViewKeyboardDismissBehavior.manual,
          restorationId: restorationId,
          clipBehavior: clipBehavior ?? Clip.hardEdge);
    },
    "ListWheelChildBuilderDelegate": () {
      final builder = getValue(
          maps["builder"], datas, "NullableIndexedWidgetBuilder", vars, props);
      final childCount =
          getValue(maps["childCount"], datas, "int?", vars, props);
      if (builder == null) {
        return null;
      }
      return ListWheelChildBuilderDelegate(
          builder: builder!, childCount: childCount);
    },
    "ListWheelChildListDelegate": () {
      final children =
          getValue(maps["children"], datas, "List<Widget>", vars, props);
      if (children == null) {
        return null;
      }
      return ListWheelChildListDelegate(children: List<Widget>.from(children!));
    },
    "ListWheelChildLoopingListDelegate": () {
      final children =
          getValue(maps["children"], datas, "List<Widget>", vars, props);
      if (children == null) {
        return null;
      }
      return ListWheelChildLoopingListDelegate(
          children: List<Widget>.from(children!));
    },
    "ListWheelElement": () {
      final widget =
          getValue(maps["0"], datas, "ListWheelViewport", vars, props);
      if (widget == null) {
        return null;
      }
      return ListWheelElement(widget!);
    },
    "ListWheelScrollView": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final controller =
          getValue(maps["controller"], datas, "ScrollController?", vars, props);
      final physics =
          getValue(maps["physics"], datas, "ScrollPhysics?", vars, props);
      final diameterRatio =
          getValue(maps["diameterRatio"], datas, "double", vars, props);
      final perspective =
          getValue(maps["perspective"], datas, "double", vars, props);
      final offAxisFraction =
          getValue(maps["offAxisFraction"], datas, "double", vars, props);
      final useMagnifier =
          getValue(maps["useMagnifier"], datas, "bool", vars, props);
      final magnification =
          getValue(maps["magnification"], datas, "double", vars, props);
      final overAndUnderCenterOpacity = getValue(
          maps["overAndUnderCenterOpacity"], datas, "double", vars, props);
      final itemExtent =
          getValue(maps["itemExtent"], datas, "double", vars, props);
      final squeeze = getValue(maps["squeeze"], datas, "double", vars, props);
      final onSelectedItemChanged = getValue(maps["onSelectedItemChanged"],
          datas, "ValueChanged<int>?", vars, props);
      final renderChildrenOutsideViewport = getValue(
          maps["renderChildrenOutsideViewport"], datas, "bool", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      final restorationId =
          getValue(maps["restorationId"], datas, "String?", vars, props);
      final scrollBehavior = getValue(
          maps["scrollBehavior"], datas, "ScrollBehavior?", vars, props);
      final children =
          getValue(maps["children"], datas, "List<Widget>", vars, props);
      if (itemExtent == null || children == null) {
        return null;
      }
      return ListWheelScrollView(
          key: key,
          controller: controller,
          physics: physics,
          diameterRatio:
              diameterRatio ?? RenderListWheelViewport.defaultDiameterRatio,
          perspective:
              perspective ?? RenderListWheelViewport.defaultPerspective,
          offAxisFraction: offAxisFraction ?? 0.0,
          useMagnifier: useMagnifier ?? false,
          magnification: magnification ?? 1.0,
          overAndUnderCenterOpacity: overAndUnderCenterOpacity ?? 1.0,
          itemExtent: itemExtent!,
          squeeze: squeeze ?? 1.0,
          onSelectedItemChanged: onSelectedItemChanged,
          renderChildrenOutsideViewport: renderChildrenOutsideViewport ?? false,
          clipBehavior: clipBehavior ?? Clip.hardEdge,
          restorationId: restorationId,
          scrollBehavior: scrollBehavior,
          children: List<Widget>.from(children!));
    },
    "ListWheelScrollView.useDelegate": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final controller =
          getValue(maps["controller"], datas, "ScrollController?", vars, props);
      final physics =
          getValue(maps["physics"], datas, "ScrollPhysics?", vars, props);
      final diameterRatio =
          getValue(maps["diameterRatio"], datas, "double", vars, props);
      final perspective =
          getValue(maps["perspective"], datas, "double", vars, props);
      final offAxisFraction =
          getValue(maps["offAxisFraction"], datas, "double", vars, props);
      final useMagnifier =
          getValue(maps["useMagnifier"], datas, "bool", vars, props);
      final magnification =
          getValue(maps["magnification"], datas, "double", vars, props);
      final overAndUnderCenterOpacity = getValue(
          maps["overAndUnderCenterOpacity"], datas, "double", vars, props);
      final itemExtent =
          getValue(maps["itemExtent"], datas, "double", vars, props);
      final squeeze = getValue(maps["squeeze"], datas, "double", vars, props);
      final onSelectedItemChanged = getValue(maps["onSelectedItemChanged"],
          datas, "ValueChanged<int>?", vars, props);
      final renderChildrenOutsideViewport = getValue(
          maps["renderChildrenOutsideViewport"], datas, "bool", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      final restorationId =
          getValue(maps["restorationId"], datas, "String?", vars, props);
      final scrollBehavior = getValue(
          maps["scrollBehavior"], datas, "ScrollBehavior?", vars, props);
      final childDelegate = getValue(
          maps["childDelegate"], datas, "ListWheelChildDelegate", vars, props);
      if (itemExtent == null || childDelegate == null) {
        return null;
      }
      return ListWheelScrollView.useDelegate(
          key: key,
          controller: controller,
          physics: physics,
          diameterRatio:
              diameterRatio ?? RenderListWheelViewport.defaultDiameterRatio,
          perspective:
              perspective ?? RenderListWheelViewport.defaultPerspective,
          offAxisFraction: offAxisFraction ?? 0.0,
          useMagnifier: useMagnifier ?? false,
          magnification: magnification ?? 1.0,
          overAndUnderCenterOpacity: overAndUnderCenterOpacity ?? 1.0,
          itemExtent: itemExtent!,
          squeeze: squeeze ?? 1.0,
          onSelectedItemChanged: onSelectedItemChanged,
          renderChildrenOutsideViewport: renderChildrenOutsideViewport ?? false,
          clipBehavior: clipBehavior ?? Clip.hardEdge,
          restorationId: restorationId,
          scrollBehavior: scrollBehavior,
          childDelegate: childDelegate!);
    },
    "ListWheelViewport": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final diameterRatio =
          getValue(maps["diameterRatio"], datas, "double", vars, props);
      final perspective =
          getValue(maps["perspective"], datas, "double", vars, props);
      final offAxisFraction =
          getValue(maps["offAxisFraction"], datas, "double", vars, props);
      final useMagnifier =
          getValue(maps["useMagnifier"], datas, "bool", vars, props);
      final magnification =
          getValue(maps["magnification"], datas, "double", vars, props);
      final overAndUnderCenterOpacity = getValue(
          maps["overAndUnderCenterOpacity"], datas, "double", vars, props);
      final itemExtent =
          getValue(maps["itemExtent"], datas, "double", vars, props);
      final squeeze = getValue(maps["squeeze"], datas, "double", vars, props);
      final renderChildrenOutsideViewport = getValue(
          maps["renderChildrenOutsideViewport"], datas, "bool", vars, props);
      final offset =
          getValue(maps["offset"], datas, "ViewportOffset", vars, props);
      final childDelegate = getValue(
          maps["childDelegate"], datas, "ListWheelChildDelegate", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      if (itemExtent == null || offset == null || childDelegate == null) {
        return null;
      }
      return ListWheelViewport(
          key: key,
          diameterRatio:
              diameterRatio ?? RenderListWheelViewport.defaultDiameterRatio,
          perspective:
              perspective ?? RenderListWheelViewport.defaultPerspective,
          offAxisFraction: offAxisFraction ?? 0.0,
          useMagnifier: useMagnifier ?? false,
          magnification: magnification ?? 1.0,
          overAndUnderCenterOpacity: overAndUnderCenterOpacity ?? 1.0,
          itemExtent: itemExtent!,
          squeeze: squeeze ?? 1.0,
          renderChildrenOutsideViewport: renderChildrenOutsideViewport ?? false,
          offset: offset!,
          childDelegate: childDelegate!,
          clipBehavior: clipBehavior ?? Clip.hardEdge);
    },
    "Listenable.merge": () {
      final listenables =
          getValue(maps["0"], datas, "List<Listenable?>", vars, props);
      if (listenables == null) {
        return null;
      }
      return Listenable.merge(List<Listenable?>.from(listenables!));
    },
    "ListenableBuilder": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final listenable =
          getValue(maps["listenable"], datas, "Listenable", vars, props);
      final builder =
          getValue(maps["builder"], datas, "TransitionBuilder", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      if (listenable == null || builder == null) {
        return null;
      }
      return ListenableBuilder(
          key: key, listenable: listenable!, builder: builder!, child: child);
    },
    "Listener": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final onPointerDown = getValue(maps["onPointerDown"], datas,
          "PointerDownEventListener?", vars, props);
      final onPointerMove = getValue(maps["onPointerMove"], datas,
          "PointerMoveEventListener?", vars, props);
      final onPointerUp = getValue(
          maps["onPointerUp"], datas, "PointerUpEventListener?", vars, props);
      final onPointerHover = getValue(maps["onPointerHover"], datas,
          "PointerHoverEventListener?", vars, props);
      final onPointerCancel = getValue(maps["onPointerCancel"], datas,
          "PointerCancelEventListener?", vars, props);
      final onPointerPanZoomStart = getValue(maps["onPointerPanZoomStart"],
          datas, "PointerPanZoomStartEventListener?", vars, props);
      final onPointerPanZoomUpdate = getValue(maps["onPointerPanZoomUpdate"],
          datas, "PointerPanZoomUpdateEventListener?", vars, props);
      final onPointerPanZoomEnd = getValue(maps["onPointerPanZoomEnd"], datas,
          "PointerPanZoomEndEventListener?", vars, props);
      final onPointerSignal = getValue(maps["onPointerSignal"], datas,
          "PointerSignalEventListener?", vars, props);
      final behavior =
          getValue(maps["behavior"], datas, "HitTestBehavior", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      return Listener(
          key: key,
          onPointerDown: onPointerDown,
          onPointerMove: onPointerMove,
          onPointerUp: onPointerUp,
          onPointerHover: onPointerHover,
          onPointerCancel: onPointerCancel,
          onPointerPanZoomStart: onPointerPanZoomStart,
          onPointerPanZoomUpdate: onPointerPanZoomUpdate,
          onPointerPanZoomEnd: onPointerPanZoomEnd,
          onPointerSignal: onPointerSignal,
          behavior: behavior ?? HitTestBehavior.deferToChild,
          child: child);
    },
    "LocaleStringAttribute": () {
      final range = getValue(maps["range"], datas, "TextRange", vars, props);
      final locale = getValue(maps["locale"], datas, "Locale", vars, props);
      if (range == null || locale == null) {
        return null;
      }
      return LocaleStringAttribute(range: range!, locale: locale!);
    },
    "Localizations": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final locale = getValue(maps["locale"], datas, "Locale", vars, props);
      final delegates = getValue(maps["delegates"], datas,
          "List<LocalizationsDelegate<dynamic>>", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      if (locale == null || delegates == null) {
        return null;
      }
      return Localizations(
          key: key,
          locale: locale!,
          delegates: List<LocalizationsDelegate<dynamic>>.from(delegates!),
          child: child);
    },
    "Localizations.override": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final context =
          getValue(maps["context"], datas, "BuildContext", vars, props);
      final locale = getValue(maps["locale"], datas, "Locale?", vars, props);
      final delegates = getValue(maps["delegates"], datas,
          "List<LocalizationsDelegate<dynamic>>?", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      if (context == null) {
        return null;
      }
      return Localizations.override(
          key: key,
          context: context!,
          locale: locale,
          delegates: delegates != null
              ? List<LocalizationsDelegate<dynamic>>.from(delegates)
              : null,
          child: child);
    },
    "LogicalKeySet": () {
      final key1 = getValue(maps["0"], datas, "T", vars, props);
      final key2 = getValue(maps["1"], datas, "T?", vars, props);
      final key3 = getValue(maps["2"], datas, "T?", vars, props);
      final key4 = getValue(maps["3"], datas, "T?", vars, props);
      if (key1 == null) {
        return null;
      }
      return LogicalKeySet(key1!, key2, key3, key4);
    },
    "LogicalKeySet.fromSet": () {
      final keys = getValue(maps["0"], datas, "", vars, props);
      if (keys == null) {
        return null;
      }
      return LogicalKeySet.fromSet(keys!);
    },
    "LogicalKeyboardKey": () {
      final keyId = getValue(maps["0"], datas, "int", vars, props);
      if (keyId == null) {
        return null;
      }
      return LogicalKeyboardKey(keyId!);
    },
    "LongPressDownDetails": () {
      final globalPosition =
          getValue(maps["globalPosition"], datas, "Offset", vars, props);
      final localPosition =
          getValue(maps["localPosition"], datas, "Offset?", vars, props);
      final kind =
          getValue(maps["kind"], datas, "PointerDeviceKind?", vars, props);
      return LongPressDownDetails(
          globalPosition: globalPosition ?? Offset.zero,
          localPosition: localPosition,
          kind: kind);
    },
    "LongPressDraggable": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      final feedback = getValue(maps["feedback"], datas, "Widget", vars, props);
      final data = getValue(maps["data"], datas, "T?", vars, props);
      final axis = getValue(maps["axis"], datas, "Axis?", vars, props);
      final childWhenDragging =
          getValue(maps["childWhenDragging"], datas, "Widget?", vars, props);
      final feedbackOffset =
          getValue(maps["feedbackOffset"], datas, "Offset", vars, props);
      final dragAnchorStrategy = getValue(
          maps["dragAnchorStrategy"], datas, "DragAnchorStrategy", vars, props);
      final maxSimultaneousDrags =
          getValue(maps["maxSimultaneousDrags"], datas, "int?", vars, props);
      final onDragStarted =
          getValue(maps["onDragStarted"], datas, "VoidCallback?", vars, props);
      final onDragUpdate = getValue(
          maps["onDragUpdate"], datas, "DragUpdateCallback?", vars, props);
      final onDraggableCanceled = getValue(maps["onDraggableCanceled"], datas,
          "DraggableCanceledCallback?", vars, props);
      final onDragEnd =
          getValue(maps["onDragEnd"], datas, "DragEndCallback?", vars, props);
      final onDragCompleted = getValue(
          maps["onDragCompleted"], datas, "VoidCallback?", vars, props);
      final hapticFeedbackOnStart =
          getValue(maps["hapticFeedbackOnStart"], datas, "bool", vars, props);
      final ignoringFeedbackSemantics = getValue(
          maps["ignoringFeedbackSemantics"], datas, "bool", vars, props);
      final ignoringFeedbackPointer =
          getValue(maps["ignoringFeedbackPointer"], datas, "bool", vars, props);
      final delay = getValue(maps["delay"], datas, "Duration", vars, props);
      final allowedButtonsFilter = getValue(maps["allowedButtonsFilter"], datas,
          "AllowedButtonsFilter?", vars, props);
      if (child == null || feedback == null) {
        return null;
      }
      if (dragAnchorStrategy != null) {
        return LongPressDraggable(
            key: key,
            child: child!,
            feedback: feedback!,
            data: data,
            axis: axis,
            childWhenDragging: childWhenDragging,
            feedbackOffset: feedbackOffset ?? Offset.zero,
            maxSimultaneousDrags: maxSimultaneousDrags,
            onDragStarted: onDragStarted,
            onDragUpdate: onDragUpdate,
            onDraggableCanceled: onDraggableCanceled,
            onDragEnd: onDragEnd,
            onDragCompleted: onDragCompleted,
            hapticFeedbackOnStart: hapticFeedbackOnStart ?? true,
            ignoringFeedbackSemantics: ignoringFeedbackSemantics ?? true,
            ignoringFeedbackPointer: ignoringFeedbackPointer ?? true,
            delay: delay ?? kLongPressTimeout,
            allowedButtonsFilter: allowedButtonsFilter,
            dragAnchorStrategy: dragAnchorStrategy);
      }
      return LongPressDraggable(
          key: key,
          child: child!,
          feedback: feedback!,
          data: data,
          axis: axis,
          childWhenDragging: childWhenDragging,
          feedbackOffset: feedbackOffset ?? Offset.zero,
          maxSimultaneousDrags: maxSimultaneousDrags,
          onDragStarted: onDragStarted,
          onDragUpdate: onDragUpdate,
          onDraggableCanceled: onDraggableCanceled,
          onDragEnd: onDragEnd,
          onDragCompleted: onDragCompleted,
          hapticFeedbackOnStart: hapticFeedbackOnStart ?? true,
          ignoringFeedbackSemantics: ignoringFeedbackSemantics ?? true,
          ignoringFeedbackPointer: ignoringFeedbackPointer ?? true,
          delay: delay ?? kLongPressTimeout,
          allowedButtonsFilter: allowedButtonsFilter);
    },
    "LongPressEndDetails": () {
      final globalPosition =
          getValue(maps["globalPosition"], datas, "Offset", vars, props);
      final localPosition =
          getValue(maps["localPosition"], datas, "Offset?", vars, props);
      final velocity =
          getValue(maps["velocity"], datas, "Velocity", vars, props);
      return LongPressEndDetails(
          globalPosition: globalPosition ?? Offset.zero,
          localPosition: localPosition,
          velocity: velocity ?? Velocity.zero);
    },
    "LongPressGestureRecognizer": () {
      final duration =
          getValue(maps["duration"], datas, "Duration?", vars, props);
      final postAcceptSlopTolerance = getValue(
          maps["postAcceptSlopTolerance"], datas, "double?", vars, props);
      final supportedDevices =
          getValue(maps["supportedDevices"], datas, "", vars, props);
      final debugOwner = getValue(maps["debugOwner"], datas, "", vars, props);
      final allowedButtonsFilter = getValue(maps["allowedButtonsFilter"], datas,
          "AllowedButtonsFilter?", vars, props);
      return LongPressGestureRecognizer(
          duration: duration,
          postAcceptSlopTolerance: postAcceptSlopTolerance ?? null,
          supportedDevices: supportedDevices,
          debugOwner: debugOwner,
          allowedButtonsFilter: allowedButtonsFilter);
    },
    "LongPressMoveUpdateDetails": () {
      final globalPosition =
          getValue(maps["globalPosition"], datas, "Offset", vars, props);
      final localPosition =
          getValue(maps["localPosition"], datas, "Offset?", vars, props);
      final offsetFromOrigin =
          getValue(maps["offsetFromOrigin"], datas, "Offset", vars, props);
      final localOffsetFromOrigin = getValue(
          maps["localOffsetFromOrigin"], datas, "Offset?", vars, props);
      return LongPressMoveUpdateDetails(
          globalPosition: globalPosition ?? Offset.zero,
          localPosition: localPosition,
          offsetFromOrigin: offsetFromOrigin ?? Offset.zero,
          localOffsetFromOrigin: localOffsetFromOrigin);
    },
    "LongPressSemanticsEvent": () {
      return const LongPressSemanticsEvent();
    },
    "LongPressStartDetails": () {
      final globalPosition =
          getValue(maps["globalPosition"], datas, "Offset", vars, props);
      final localPosition =
          getValue(maps["localPosition"], datas, "Offset?", vars, props);
      return LongPressStartDetails(
          globalPosition: globalPosition ?? Offset.zero,
          localPosition: localPosition);
    },
    "LookupBoundary": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (child == null) {
        return null;
      }
      return LookupBoundary(key: key, child: child!);
    },
    "MacOSScrollViewFlingVelocityTracker": () {
      final kind = getValue(maps["0"], datas, "", vars, props);
      if (kind == null) {
        return null;
      }
      return MacOSScrollViewFlingVelocityTracker(kind!);
    },
    "Magnifier": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final additionalFocalPointOffset = getValue(
          maps["additionalFocalPointOffset"], datas, "Offset", vars, props);
      final borderRadius =
          getValue(maps["borderRadius"], datas, "double", vars, props);
      final filmColor =
          getValue(maps["filmColor"], datas, "Color", vars, props);
      final shadows =
          getValue(maps["shadows"], datas, "List<BoxShadow>", vars, props);
      final size = getValue(maps["size"], datas, "Size", vars, props);
      return Magnifier(
          key: key,
          additionalFocalPointOffset: additionalFocalPointOffset ?? Offset.zero,
          borderRadius: borderRadius ??
              const BorderRadius.all(Radius.circular(_borderRadius)),
          filmColor: filmColor ?? const Color.fromARGB(8, 158, 158, 158),
          shadows: List<BoxShadow>.from(shadows ??
              const <BoxShadow>[
                BoxShadow(
                    blurRadius: 1.5,
                    offset: Offset(0, 2),
                    spreadRadius: 0.75,
                    color: Color.fromARGB(25, 0, 0, 0))
              ]),
          size: size ?? Magnifier.kDefaultMagnifierSize);
    },
    "MagnifierController": () {
      final animationController = getValue(maps["animationController"], datas,
          "AnimationController?", vars, props);
      return MagnifierController(animationController: animationController);
    },
    "MagnifierDecoration": () {
      final opacity = getValue(maps["opacity"], datas, "double", vars, props);
      final shadows =
          getValue(maps["shadows"], datas, "List<BoxShadow>?", vars, props);
      final shape = getValue(maps["shape"], datas, "ShapeBorder", vars, props);
      return MagnifierDecoration(
          opacity: opacity ?? 1,
          shadows: shadows != null ? List<BoxShadow>.from(shadows) : null,
          shape: shape ?? const RoundedRectangleBorder());
    },
    "MagnifierInfo": () {
      final globalGesturePosition =
          getValue(maps["globalGesturePosition"], datas, "Offset", vars, props);
      final caretRect = getValue(maps["caretRect"], datas, "Rect", vars, props);
      final fieldBounds =
          getValue(maps["fieldBounds"], datas, "Rect", vars, props);
      final currentLineBoundaries =
          getValue(maps["currentLineBoundaries"], datas, "Rect", vars, props);
      if (globalGesturePosition == null ||
          caretRect == null ||
          fieldBounds == null ||
          currentLineBoundaries == null) {
        return null;
      }
      return MagnifierInfo(
          globalGesturePosition: globalGesturePosition!,
          caretRect: caretRect!,
          fieldBounds: fieldBounds!,
          currentLineBoundaries: currentLineBoundaries!);
    },
    "Map.from": () {
      final other = getValue(maps["0"], datas, "Map", vars, props);
      if (other == null) {
        return null;
      }
      return Map.from(other!);
    },
    "Map.of": () {
      final other = getValue(maps["0"], datas, "Map<J, V>", vars, props);
      if (other == null) {
        return null;
      }
      return Map.of(Map<J, V>.from(other!));
    },
    "Map.unmodifiable": () {
      final other =
          getValue(maps["0"], datas, "Map<dynamic,   dynamic>", vars, props);
      if (other == null) {
        return null;
      }
      return Map.unmodifiable(Map<dynamic, dynamic>.from(other!));
    },
    "Map.identity": () {
      return Map.identity();
    },
    "Map.fromIterable": () {
      final iterable = getValue(maps["0"], datas, "Iterable", vars, props);
      final key = getValue(
          maps["key"], datas, "K Function(dynamic element)?", vars, props);
      final value = getValue(
          maps["value"], datas, "V Function(dynamic element)?", vars, props);
      if (iterable == null) {
        return null;
      }
      return Map.fromIterable(iterable!, key: key, value: value);
    },
    "Map.fromIterables": () {
      final keys = getValue(maps["0"], datas, "Iterable<K>", vars, props);
      final values = getValue(maps["1"], datas, "Iterable<V>", vars, props);
      if (keys == null || values == null) {
        return null;
      }
      return Map.fromIterables(keys!, values!);
    },
    "Map.fromEntries": () {
      final entries =
          getValue(maps["0"], datas, "Iterable<MapEntry<K,   V>>", vars, props);
      if (entries == null) {
        return null;
      }
      return Map.fromEntries(entries!);
    },
    "MapEntry": () {
      final key = getValue(maps["0"], datas, "K", vars, props);
      final value = getValue(maps["1"], datas, "V", vars, props);
      if (key == null || value == null) {
        return null;
      }
      return MapEntry(key!, value!);
    },
    "MaskFilter.blur": () {
      final _style = getValue(maps["0"], datas, "BlurStyle", vars, props);
      final _sigma = getValue(maps["1"], datas, "double", vars, props);
      if (_style == null || _sigma == null) {
        return null;
      }
      return MaskFilter.blur(_style!, _sigma!);
    },
    "Material": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final type = getValue(maps["type"], datas, "MaterialType", vars, props);
      final elevation =
          getValue(maps["elevation"], datas, "double", vars, props);
      final color = getValue(maps["color"], datas, "Color?", vars, props);
      final shadowColor =
          getValue(maps["shadowColor"], datas, "Color?", vars, props);
      final surfaceTintColor =
          getValue(maps["surfaceTintColor"], datas, "Color?", vars, props);
      final textStyle =
          getValue(maps["textStyle"], datas, "TextStyle?", vars, props);
      final borderRadius = getValue(
          maps["borderRadius"], datas, "BorderRadiusGeometry?", vars, props);
      final shape = getValue(maps["shape"], datas, "ShapeBorder?", vars, props);
      final borderOnForeground =
          getValue(maps["borderOnForeground"], datas, "bool", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      final animationDuration =
          getValue(maps["animationDuration"], datas, "Duration", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      return Material(
          key: key,
          type: type ?? MaterialType.canvas,
          elevation: elevation ?? 0.0,
          color: color,
          shadowColor: shadowColor,
          surfaceTintColor: surfaceTintColor,
          textStyle: textStyle,
          borderRadius: borderRadius,
          shape: shape,
          borderOnForeground: borderOnForeground ?? true,
          clipBehavior: clipBehavior ?? Clip.none,
          animationDuration: animationDuration ?? kThemeChangeDuration,
          child: child);
    },
    "MaterialAccentColor": () {
      final primary = getValue(maps["0"], datas, "", vars, props);
      final swatch = getValue(maps["1"], datas, "", vars, props);
      if (primary == null || swatch == null) {
        return null;
      }
      return MaterialAccentColor(primary!, swatch!);
    },
    "MaterialApp": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final navigatorKey = getValue(maps["navigatorKey"], datas,
          "GlobalKey<NavigatorState>?", vars, props);
      final scaffoldMessengerKey = getValue(maps["scaffoldMessengerKey"], datas,
          "GlobalKey<ScaffoldMessengerState>?", vars, props);
      final home = getValue(maps["home"], datas, "Widget?", vars, props);
      final routes = getValue(
          maps["routes"], datas, "Map<String,   WidgetBuilder>", vars, props);
      final initialRoute =
          getValue(maps["initialRoute"], datas, "String?", vars, props);
      final onGenerateRoute = getValue(
          maps["onGenerateRoute"], datas, "RouteFactory?", vars, props);
      final onGenerateInitialRoutes = getValue(maps["onGenerateInitialRoutes"],
          datas, "InitialRouteListFactory?", vars, props);
      final onUnknownRoute =
          getValue(maps["onUnknownRoute"], datas, "RouteFactory?", vars, props);
      final navigatorObservers = getValue(maps["navigatorObservers"], datas,
          "List<NavigatorObserver>", vars, props);
      final builder =
          getValue(maps["builder"], datas, "TransitionBuilder?", vars, props);
      final title = getValue(maps["title"], datas, "String", vars, props);
      final onGenerateTitle = getValue(
          maps["onGenerateTitle"], datas, "GenerateAppTitle?", vars, props);
      final color = getValue(maps["color"], datas, "Color?", vars, props);
      final theme = getValue(maps["theme"], datas, "ThemeData?", vars, props);
      final darkTheme =
          getValue(maps["darkTheme"], datas, "ThemeData?", vars, props);
      final highContrastTheme =
          getValue(maps["highContrastTheme"], datas, "ThemeData?", vars, props);
      final highContrastDarkTheme = getValue(
          maps["highContrastDarkTheme"], datas, "ThemeData?", vars, props);
      final themeMode =
          getValue(maps["themeMode"], datas, "ThemeMode?", vars, props);
      final themeAnimationDuration = getValue(
          maps["themeAnimationDuration"], datas, "Duration", vars, props);
      final themeAnimationCurve =
          getValue(maps["themeAnimationCurve"], datas, "Curve", vars, props);
      final locale = getValue(maps["locale"], datas, "Locale?", vars, props);
      final localizationsDelegates = getValue(maps["localizationsDelegates"],
          datas, "Iterable<LocalizationsDelegate<dynamic>>?", vars, props);
      final localeListResolutionCallback = getValue(
          maps["localeListResolutionCallback"],
          datas,
          "LocaleListResolutionCallback?",
          vars,
          props);
      final localeResolutionCallback = getValue(
          maps["localeResolutionCallback"],
          datas,
          "LocaleResolutionCallback?",
          vars,
          props);
      final supportedLocales = getValue(
          maps["supportedLocales"], datas, "Iterable<Locale>", vars, props);
      final debugShowMaterialGrid =
          getValue(maps["debugShowMaterialGrid"], datas, "bool", vars, props);
      final showPerformanceOverlay =
          getValue(maps["showPerformanceOverlay"], datas, "bool", vars, props);
      final checkerboardRasterCacheImages = getValue(
          maps["checkerboardRasterCacheImages"], datas, "bool", vars, props);
      final checkerboardOffscreenLayers = getValue(
          maps["checkerboardOffscreenLayers"], datas, "bool", vars, props);
      final showSemanticsDebugger =
          getValue(maps["showSemanticsDebugger"], datas, "bool", vars, props);
      final debugShowCheckedModeBanner = getValue(
          maps["debugShowCheckedModeBanner"], datas, "bool", vars, props);
      final shortcuts = getValue(maps["shortcuts"], datas,
          "Map<ShortcutActivator, Intent>?", vars, props);
      final actions = getValue(
          maps["actions"], datas, "Map<Type, Action<Intent>>?", vars, props);
      final restorationScopeId =
          getValue(maps["restorationScopeId"], datas, "String?", vars, props);
      final scrollBehavior = getValue(
          maps["scrollBehavior"], datas, "ScrollBehavior?", vars, props);
      final useInheritedMediaQuery =
          getValue(maps["useInheritedMediaQuery"], datas, "bool", vars, props);
      return MaterialApp(
          key: key,
          navigatorKey: navigatorKey,
          scaffoldMessengerKey: scaffoldMessengerKey,
          home: home,
          routes: Map<String, WidgetBuilder>.from(
              routes ?? const <String, WidgetBuilder>{}),
          initialRoute: initialRoute,
          onGenerateRoute: onGenerateRoute,
          onGenerateInitialRoutes: onGenerateInitialRoutes,
          onUnknownRoute: onUnknownRoute,
          navigatorObservers: List<NavigatorObserver>.from(
              navigatorObservers ?? const <NavigatorObserver>[]),
          builder: builder,
          title: title ?? '',
          onGenerateTitle: onGenerateTitle,
          color: color,
          theme: theme,
          darkTheme: darkTheme,
          highContrastTheme: highContrastTheme,
          highContrastDarkTheme: highContrastDarkTheme,
          themeMode: themeMode ?? ThemeMode.system,
          themeAnimationDuration:
              themeAnimationDuration ?? kThemeAnimationDuration,
          themeAnimationCurve: themeAnimationCurve ?? Curves.linear,
          locale: locale,
          localizationsDelegates: localizationsDelegates,
          localeListResolutionCallback: localeListResolutionCallback,
          localeResolutionCallback: localeResolutionCallback,
          supportedLocales:
              supportedLocales ?? const <Locale>[Locale('en', 'US')],
          debugShowMaterialGrid: debugShowMaterialGrid ?? false,
          showPerformanceOverlay: showPerformanceOverlay ?? false,
          checkerboardRasterCacheImages: checkerboardRasterCacheImages ?? false,
          checkerboardOffscreenLayers: checkerboardOffscreenLayers ?? false,
          showSemanticsDebugger: showSemanticsDebugger ?? false,
          debugShowCheckedModeBanner: debugShowCheckedModeBanner ?? true,
          shortcuts:
              shortcuts ? Map<ShortcutActivator, Intent>.from(shortcuts) : null,
          actions: actions ? Map<Type, Action<Intent>>.from(actions) : null,
          restorationScopeId: restorationScopeId,
          scrollBehavior: scrollBehavior,
          useInheritedMediaQuery: useInheritedMediaQuery ?? false);
    },
    "MaterialApp.router": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final scaffoldMessengerKey = getValue(maps["scaffoldMessengerKey"], datas,
          "GlobalKey<ScaffoldMessengerState>?", vars, props);
      final routeInformationProvider = getValue(
          maps["routeInformationProvider"],
          datas,
          "RouteInformationProvider?",
          vars,
          props);
      final routeInformationParser = getValue(maps["routeInformationParser"],
          datas, "RouteInformationParser<Object>?", vars, props);
      final routerDelegate = getValue(maps["routerDelegate"], datas,
          "RouterDelegate<Object>?", vars, props);
      final routerConfig = getValue(
          maps["routerConfig"], datas, "RouterConfig<Object>?", vars, props);
      final backButtonDispatcher = getValue(maps["backButtonDispatcher"], datas,
          "BackButtonDispatcher?", vars, props);
      final builder =
          getValue(maps["builder"], datas, "TransitionBuilder?", vars, props);
      final title = getValue(maps["title"], datas, "String", vars, props);
      final onGenerateTitle = getValue(
          maps["onGenerateTitle"], datas, "GenerateAppTitle?", vars, props);
      final color = getValue(maps["color"], datas, "Color?", vars, props);
      final theme = getValue(maps["theme"], datas, "ThemeData?", vars, props);
      final darkTheme =
          getValue(maps["darkTheme"], datas, "ThemeData?", vars, props);
      final highContrastTheme =
          getValue(maps["highContrastTheme"], datas, "ThemeData?", vars, props);
      final highContrastDarkTheme = getValue(
          maps["highContrastDarkTheme"], datas, "ThemeData?", vars, props);
      final themeMode =
          getValue(maps["themeMode"], datas, "ThemeMode?", vars, props);
      final themeAnimationDuration = getValue(
          maps["themeAnimationDuration"], datas, "Duration", vars, props);
      final themeAnimationCurve =
          getValue(maps["themeAnimationCurve"], datas, "Curve", vars, props);
      final locale = getValue(maps["locale"], datas, "Locale?", vars, props);
      final localizationsDelegates = getValue(maps["localizationsDelegates"],
          datas, "Iterable<LocalizationsDelegate<dynamic>>?", vars, props);
      final localeListResolutionCallback = getValue(
          maps["localeListResolutionCallback"],
          datas,
          "LocaleListResolutionCallback?",
          vars,
          props);
      final localeResolutionCallback = getValue(
          maps["localeResolutionCallback"],
          datas,
          "LocaleResolutionCallback?",
          vars,
          props);
      final supportedLocales = getValue(
          maps["supportedLocales"], datas, "Iterable<Locale>", vars, props);
      final debugShowMaterialGrid =
          getValue(maps["debugShowMaterialGrid"], datas, "bool", vars, props);
      final showPerformanceOverlay =
          getValue(maps["showPerformanceOverlay"], datas, "bool", vars, props);
      final checkerboardRasterCacheImages = getValue(
          maps["checkerboardRasterCacheImages"], datas, "bool", vars, props);
      final checkerboardOffscreenLayers = getValue(
          maps["checkerboardOffscreenLayers"], datas, "bool", vars, props);
      final showSemanticsDebugger =
          getValue(maps["showSemanticsDebugger"], datas, "bool", vars, props);
      final debugShowCheckedModeBanner = getValue(
          maps["debugShowCheckedModeBanner"], datas, "bool", vars, props);
      final shortcuts = getValue(maps["shortcuts"], datas,
          "Map<ShortcutActivator, Intent>?", vars, props);
      final actions = getValue(
          maps["actions"], datas, "Map<Type, Action<Intent>>?", vars, props);
      final restorationScopeId =
          getValue(maps["restorationScopeId"], datas, "String?", vars, props);
      final scrollBehavior = getValue(
          maps["scrollBehavior"], datas, "ScrollBehavior?", vars, props);
      final useInheritedMediaQuery =
          getValue(maps["useInheritedMediaQuery"], datas, "bool", vars, props);
      return MaterialApp.router(
          key: key,
          scaffoldMessengerKey: scaffoldMessengerKey,
          routeInformationProvider: routeInformationProvider,
          routeInformationParser: routeInformationParser,
          routerDelegate: routerDelegate,
          routerConfig: routerConfig,
          backButtonDispatcher: backButtonDispatcher,
          builder: builder,
          title: title ?? '',
          onGenerateTitle: onGenerateTitle,
          color: color,
          theme: theme,
          darkTheme: darkTheme,
          highContrastTheme: highContrastTheme,
          highContrastDarkTheme: highContrastDarkTheme,
          themeMode: themeMode ?? ThemeMode.system,
          themeAnimationDuration:
              themeAnimationDuration ?? kThemeAnimationDuration,
          themeAnimationCurve: themeAnimationCurve ?? Curves.linear,
          locale: locale,
          localizationsDelegates: localizationsDelegates,
          localeListResolutionCallback: localeListResolutionCallback,
          localeResolutionCallback: localeResolutionCallback,
          supportedLocales:
              supportedLocales ?? const <Locale>[Locale('en', 'US')],
          debugShowMaterialGrid: debugShowMaterialGrid ?? false,
          showPerformanceOverlay: showPerformanceOverlay ?? false,
          checkerboardRasterCacheImages: checkerboardRasterCacheImages ?? false,
          checkerboardOffscreenLayers: checkerboardOffscreenLayers ?? false,
          showSemanticsDebugger: showSemanticsDebugger ?? false,
          debugShowCheckedModeBanner: debugShowCheckedModeBanner ?? true,
          shortcuts:
              shortcuts ? Map<ShortcutActivator, Intent>.from(shortcuts) : null,
          actions: actions ? Map<Type, Action<Intent>>.from(actions) : null,
          restorationScopeId: restorationScopeId,
          scrollBehavior: scrollBehavior,
          useInheritedMediaQuery: useInheritedMediaQuery ?? false);
    },
    "MaterialBanner": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final content = getValue(maps["content"], datas, "Widget", vars, props);
      final contentTextStyle =
          getValue(maps["contentTextStyle"], datas, "TextStyle?", vars, props);
      final actions =
          getValue(maps["actions"], datas, "List<Widget>", vars, props);
      final elevation =
          getValue(maps["elevation"], datas, "double?", vars, props);
      final leading = getValue(maps["leading"], datas, "Widget?", vars, props);
      final backgroundColor =
          getValue(maps["backgroundColor"], datas, "Color?", vars, props);
      final surfaceTintColor =
          getValue(maps["surfaceTintColor"], datas, "Color?", vars, props);
      final shadowColor =
          getValue(maps["shadowColor"], datas, "Color?", vars, props);
      final dividerColor =
          getValue(maps["dividerColor"], datas, "Color?", vars, props);
      final padding =
          getValue(maps["padding"], datas, "EdgeInsetsGeometry?", vars, props);
      final margin =
          getValue(maps["margin"], datas, "EdgeInsetsGeometry?", vars, props);
      final leadingPadding = getValue(
          maps["leadingPadding"], datas, "EdgeInsetsGeometry?", vars, props);
      final forceActionsBelow =
          getValue(maps["forceActionsBelow"], datas, "bool", vars, props);
      final overflowAlignment = getValue(maps["overflowAlignment"], datas,
          "OverflowBarAlignment", vars, props);
      final animation =
          getValue(maps["animation"], datas, "Animation<double>?", vars, props);
      final onVisible =
          getValue(maps["onVisible"], datas, "VoidCallback?", vars, props);
      if (content == null || actions == null) {
        return null;
      }
      return MaterialBanner(
          key: key,
          content: content!,
          contentTextStyle: contentTextStyle,
          actions: List<Widget>.from(actions!),
          elevation: elevation,
          leading: leading,
          backgroundColor: backgroundColor,
          surfaceTintColor: surfaceTintColor,
          shadowColor: shadowColor,
          dividerColor: dividerColor,
          padding: padding,
          margin: margin,
          leadingPadding: leadingPadding,
          forceActionsBelow: forceActionsBelow ?? false,
          overflowAlignment: overflowAlignment ?? OverflowBarAlignment.end,
          animation: animation,
          onVisible: onVisible);
    },
    "MaterialBannerTheme": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final data = getValue(
          maps["data"], datas, "MaterialBannerThemeData?", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (child == null) {
        return null;
      }
      return MaterialBannerTheme(key: key, data: data, child: child!);
    },
    "MaterialBannerThemeData": () {
      final backgroundColor =
          getValue(maps["backgroundColor"], datas, "Color?", vars, props);
      final surfaceTintColor =
          getValue(maps["surfaceTintColor"], datas, "Color?", vars, props);
      final shadowColor =
          getValue(maps["shadowColor"], datas, "Color?", vars, props);
      final dividerColor =
          getValue(maps["dividerColor"], datas, "Color?", vars, props);
      final contentTextStyle =
          getValue(maps["contentTextStyle"], datas, "TextStyle?", vars, props);
      final elevation =
          getValue(maps["elevation"], datas, "double?", vars, props);
      final padding =
          getValue(maps["padding"], datas, "EdgeInsetsGeometry?", vars, props);
      final leadingPadding = getValue(
          maps["leadingPadding"], datas, "EdgeInsetsGeometry?", vars, props);
      return MaterialBannerThemeData(
          backgroundColor: backgroundColor,
          surfaceTintColor: surfaceTintColor,
          shadowColor: shadowColor,
          dividerColor: dividerColor,
          contentTextStyle: contentTextStyle,
          elevation: elevation,
          padding: padding,
          leadingPadding: leadingPadding);
    },
    "MaterialBasedCupertinoThemeData": () {
      final materialTheme =
          getValue(maps["materialTheme"], datas, "ThemeData", vars, props);
      if (materialTheme == null) {
        return null;
      }
      return MaterialBasedCupertinoThemeData(materialTheme: materialTheme!);
    },
    "MaterialButton": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final onPressed =
          getValue(maps["onPressed"], datas, "VoidCallback?", vars, props);
      final onLongPress =
          getValue(maps["onLongPress"], datas, "VoidCallback?", vars, props);
      final onHighlightChanged = getValue(maps["onHighlightChanged"], datas,
          "ValueChanged<bool>?", vars, props);
      final mouseCursor =
          getValue(maps["mouseCursor"], datas, "MouseCursor?", vars, props);
      final textTheme =
          getValue(maps["textTheme"], datas, "ButtonTextTheme?", vars, props);
      final textColor =
          getValue(maps["textColor"], datas, "Color?", vars, props);
      final disabledTextColor =
          getValue(maps["disabledTextColor"], datas, "Color?", vars, props);
      final color = getValue(maps["color"], datas, "Color?", vars, props);
      final disabledColor =
          getValue(maps["disabledColor"], datas, "Color?", vars, props);
      final focusColor =
          getValue(maps["focusColor"], datas, "Color?", vars, props);
      final hoverColor =
          getValue(maps["hoverColor"], datas, "Color?", vars, props);
      final highlightColor =
          getValue(maps["highlightColor"], datas, "Color?", vars, props);
      final splashColor =
          getValue(maps["splashColor"], datas, "Color?", vars, props);
      final colorBrightness =
          getValue(maps["colorBrightness"], datas, "Brightness?", vars, props);
      final elevation =
          getValue(maps["elevation"], datas, "double?", vars, props);
      final focusElevation =
          getValue(maps["focusElevation"], datas, "double?", vars, props);
      final hoverElevation =
          getValue(maps["hoverElevation"], datas, "double?", vars, props);
      final highlightElevation =
          getValue(maps["highlightElevation"], datas, "double?", vars, props);
      final disabledElevation =
          getValue(maps["disabledElevation"], datas, "double?", vars, props);
      final padding =
          getValue(maps["padding"], datas, "EdgeInsetsGeometry?", vars, props);
      final visualDensity =
          getValue(maps["visualDensity"], datas, "VisualDensity?", vars, props);
      final shape = getValue(maps["shape"], datas, "ShapeBorder?", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      final focusNode =
          getValue(maps["focusNode"], datas, "FocusNode?", vars, props);
      final autofocus = getValue(maps["autofocus"], datas, "bool", vars, props);
      final materialTapTargetSize = getValue(maps["materialTapTargetSize"],
          datas, "MaterialTapTargetSize?", vars, props);
      final animationDuration =
          getValue(maps["animationDuration"], datas, "Duration?", vars, props);
      final minWidth =
          getValue(maps["minWidth"], datas, "double?", vars, props);
      final height = getValue(maps["height"], datas, "double?", vars, props);
      final enableFeedback =
          getValue(maps["enableFeedback"], datas, "bool", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      if (onPressed == null) {
        return null;
      }
      return MaterialButton(
          key: key,
          onPressed: onPressed!,
          onLongPress: onLongPress,
          onHighlightChanged: onHighlightChanged,
          mouseCursor: mouseCursor,
          textTheme: textTheme,
          textColor: textColor,
          disabledTextColor: disabledTextColor,
          color: color,
          disabledColor: disabledColor,
          focusColor: focusColor,
          hoverColor: hoverColor,
          highlightColor: highlightColor,
          splashColor: splashColor,
          colorBrightness: colorBrightness,
          elevation: elevation,
          focusElevation: focusElevation,
          hoverElevation: hoverElevation,
          highlightElevation: highlightElevation,
          disabledElevation: disabledElevation,
          padding: padding,
          visualDensity: visualDensity,
          shape: shape,
          clipBehavior: clipBehavior ?? Clip.none,
          focusNode: focusNode,
          autofocus: autofocus ?? false,
          materialTapTargetSize: materialTapTargetSize,
          animationDuration: animationDuration,
          minWidth: minWidth,
          height: height,
          enableFeedback: enableFeedback ?? true,
          child: child);
    },
    "MaterialColor": () {
      final primary = getValue(maps["0"], datas, "", vars, props);
      final swatch = getValue(maps["1"], datas, "", vars, props);
      if (primary == null || swatch == null) {
        return null;
      }
      return MaterialColor(primary!, swatch!);
    },
    "MaterialGap": () {
      final key = getValue(maps["key"], datas, "LocalKey", vars, props);
      final size = getValue(maps["size"], datas, "double", vars, props);
      if (key == null) {
        return null;
      }
      return MaterialGap(key: key!, size: size ?? 16.0);
    },
    "MaterialPage": () {
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      final maintainState =
          getValue(maps["maintainState"], datas, "bool", vars, props);
      final fullscreenDialog =
          getValue(maps["fullscreenDialog"], datas, "bool", vars, props);
      final allowSnapshotting =
          getValue(maps["allowSnapshotting"], datas, "bool", vars, props);
      final key = getValue(maps["key"], datas, "", vars, props);
      final name = getValue(maps["name"], datas, "", vars, props);
      final arguments = getValue(maps["arguments"], datas, "", vars, props);
      final restorationId =
          getValue(maps["restorationId"], datas, "", vars, props);
      if (child == null) {
        return null;
      }
      return MaterialPage(
          child: child!,
          maintainState: maintainState ?? true,
          fullscreenDialog: fullscreenDialog ?? false,
          allowSnapshotting: allowSnapshotting ?? true,
          key: key,
          name: name,
          arguments: arguments,
          restorationId: restorationId);
    },
    "MaterialPageRoute": () {
      final builder =
          getValue(maps["builder"], datas, "WidgetBuilder", vars, props);
      final settings =
          getValue(maps["settings"], datas, "RouteSettings?", vars, props);
      final maintainState =
          getValue(maps["maintainState"], datas, "bool", vars, props);
      final fullscreenDialog =
          getValue(maps["fullscreenDialog"], datas, "bool", vars, props);
      final allowSnapshotting =
          getValue(maps["allowSnapshotting"], datas, "bool", vars, props);
      if (builder == null) {
        return null;
      }
      return MaterialPageRoute(
          builder: builder!,
          settings: settings,
          maintainState: maintainState ?? true,
          fullscreenDialog: fullscreenDialog ?? false,
          allowSnapshotting: allowSnapshotting ?? true);
    },
    "MaterialPointArcTween": () {
      final begin = getValue(maps["begin"], datas, "T?", vars, props);
      final end = getValue(maps["end"], datas, "T?", vars, props);
      return MaterialPointArcTween(begin: begin, end: end);
    },
    "MaterialRectArcTween": () {
      final begin = getValue(maps["begin"], datas, "T?", vars, props);
      final end = getValue(maps["end"], datas, "T?", vars, props);
      return MaterialRectArcTween(begin: begin, end: end);
    },
    "MaterialScrollBehavior": () {
      // final androidOverscrollIndicator = getValue(
      //     maps["androidOverscrollIndicator"],
      //     datas,
      //     },"AndroidOverscrollIndicator?",
      //     vars,
      //     props);
      return const MaterialScrollBehavior(
          // androidOverscrollIndicator: androidOverscrollIndicator
          );
    },
    "MaterialSlice": () {
      final key = getValue(maps["key"], datas, "LocalKey", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      final color = getValue(maps["color"], datas, "Color?", vars, props);
      if (key == null || child == null) {
        return null;
      }
      return MaterialSlice(key: key!, child: child!, color: color);
    },
    "MaterialStatePropertyAll": () {
      final value = getValue(maps["0"], datas, "T", vars, props);
      if (value == null) {
        return null;
      }
      return MaterialStatePropertyAll(value!);
    },
    "Matrix4Tween": () {
      final begin = getValue(maps["begin"], datas, "T?", vars, props);
      final end = getValue(maps["end"], datas, "T?", vars, props);
      return Matrix4Tween(begin: begin, end: end);
    },
    "MediaQuery": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final data = getValue(maps["data"], datas, "MediaQueryData", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (data == null || child == null) {
        return null;
      }
      return MediaQuery(key: key, data: data!, child: child!);
    },
    "MediaQuery.removePadding": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final context =
          getValue(maps["context"], datas, "BuildContext", vars, props);
      final removeLeft =
          getValue(maps["removeLeft"], datas, "bool", vars, props);
      final removeTop = getValue(maps["removeTop"], datas, "bool", vars, props);
      final removeRight =
          getValue(maps["removeRight"], datas, "bool", vars, props);
      final removeBottom =
          getValue(maps["removeBottom"], datas, "bool", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (context == null || child == null) {
        return null;
      }
      return MediaQuery.removePadding(
          key: key,
          context: context!,
          removeLeft: removeLeft ?? false,
          removeTop: removeTop ?? false,
          removeRight: removeRight ?? false,
          removeBottom: removeBottom ?? false,
          child: child!);
    },
    "MediaQuery.removeViewInsets": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final context =
          getValue(maps["context"], datas, "BuildContext", vars, props);
      final removeLeft =
          getValue(maps["removeLeft"], datas, "bool", vars, props);
      final removeTop = getValue(maps["removeTop"], datas, "bool", vars, props);
      final removeRight =
          getValue(maps["removeRight"], datas, "bool", vars, props);
      final removeBottom =
          getValue(maps["removeBottom"], datas, "bool", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (context == null || child == null) {
        return null;
      }
      return MediaQuery.removeViewInsets(
          key: key,
          context: context!,
          removeLeft: removeLeft ?? false,
          removeTop: removeTop ?? false,
          removeRight: removeRight ?? false,
          removeBottom: removeBottom ?? false,
          child: child!);
    },
    "MediaQuery.removeViewPadding": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final context =
          getValue(maps["context"], datas, "BuildContext", vars, props);
      final removeLeft =
          getValue(maps["removeLeft"], datas, "bool", vars, props);
      final removeTop = getValue(maps["removeTop"], datas, "bool", vars, props);
      final removeRight =
          getValue(maps["removeRight"], datas, "bool", vars, props);
      final removeBottom =
          getValue(maps["removeBottom"], datas, "bool", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (context == null || child == null) {
        return null;
      }
      return MediaQuery.removeViewPadding(
          key: key,
          context: context!,
          removeLeft: removeLeft ?? false,
          removeTop: removeTop ?? false,
          removeRight: removeRight ?? false,
          removeBottom: removeBottom ?? false,
          child: child!);
    },
    "MediaQueryData": () {
      final size = getValue(maps["size"], datas, "Size", vars, props);
      final devicePixelRatio =
          getValue(maps["devicePixelRatio"], datas, "double", vars, props);
      final textScaleFactor =
          getValue(maps["textScaleFactor"], datas, "double", vars, props);
      final platformBrightness = getValue(
          maps["platformBrightness"], datas, "Brightness", vars, props);
      final padding =
          getValue(maps["padding"], datas, "EdgeInsets", vars, props);
      final viewInsets =
          getValue(maps["viewInsets"], datas, "EdgeInsets", vars, props);
      final systemGestureInsets = getValue(
          maps["systemGestureInsets"], datas, "EdgeInsets", vars, props);
      final viewPadding =
          getValue(maps["viewPadding"], datas, "EdgeInsets", vars, props);
      final alwaysUse24HourFormat =
          getValue(maps["alwaysUse24HourFormat"], datas, "bool", vars, props);
      final accessibleNavigation =
          getValue(maps["accessibleNavigation"], datas, "bool", vars, props);
      final invertColors =
          getValue(maps["invertColors"], datas, "bool", vars, props);
      final highContrast =
          getValue(maps["highContrast"], datas, "bool", vars, props);
      final disableAnimations =
          getValue(maps["disableAnimations"], datas, "bool", vars, props);
      final boldText = getValue(maps["boldText"], datas, "bool", vars, props);
      final navigationMode = getValue(
          maps["navigationMode"], datas, "NavigationMode", vars, props);
      final gestureSettings = getValue(
          maps["gestureSettings"], datas, "DeviceGestureSettings", vars, props);
      final displayFeatures = getValue(maps["displayFeatures"], datas,
          "List<ui.DisplayFeature>", vars, props);
      return MediaQueryData(
          size: size ?? Size.zero,
          devicePixelRatio: devicePixelRatio ?? 1.0,
          textScaleFactor: textScaleFactor ?? 1.0,
          platformBrightness: platformBrightness ?? Brightness.light,
          padding: padding ?? EdgeInsets.zero,
          viewInsets: viewInsets ?? EdgeInsets.zero,
          systemGestureInsets: systemGestureInsets ?? EdgeInsets.zero,
          viewPadding: viewPadding ?? EdgeInsets.zero,
          alwaysUse24HourFormat: alwaysUse24HourFormat ?? false,
          accessibleNavigation: accessibleNavigation ?? false,
          invertColors: invertColors ?? false,
          highContrast: highContrast ?? false,
          disableAnimations: disableAnimations ?? false,
          boldText: boldText ?? false,
          navigationMode: navigationMode ?? NavigationMode.traditional,
          gestureSettings: gestureSettings ??
              const DeviceGestureSettings(touchSlop: kTouchSlop),
          displayFeatures: List<ui.DisplayFeature>.from(
              displayFeatures ?? const <ui.DisplayFeature>[]));
    },
    "MediaQueryData.fromWindow": () {
      final window = getValue(maps["0"], datas, "FlutterView", vars, props);
      if (window == null) {
        return null;
      }
      return MediaQueryData.fromWindow(window!);
    },
    "MediaQueryData.fromView": () {
      final view = getValue(maps["0"], datas, "FlutterView", vars, props);
      final platformData =
          getValue(maps["platformData"], datas, "MediaQueryData?", vars, props);
      if (view == null) {
        return null;
      }
      return MediaQueryData.fromView(view!, platformData: platformData);
    },
    "MenuAnchor": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final controller =
          getValue(maps["controller"], datas, "MenuController?", vars, props);
      final childFocusNode =
          getValue(maps["childFocusNode"], datas, "FocusNode?", vars, props);
      final style = getValue(maps["style"], datas, "MenuStyle?", vars, props);
      final alignmentOffset =
          getValue(maps["alignmentOffset"], datas, "Offset?", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      final anchorTapClosesMenu =
          getValue(maps["anchorTapClosesMenu"], datas, "bool", vars, props);
      final onOpen =
          getValue(maps["onOpen"], datas, "VoidCallback?", vars, props);
      final onClose =
          getValue(maps["onClose"], datas, "VoidCallback?", vars, props);
      final crossAxisUnconstrained =
          getValue(maps["crossAxisUnconstrained"], datas, "bool", vars, props);
      final menuChildren =
          getValue(maps["menuChildren"], datas, "List<Widget>", vars, props);
      final builder = getValue(
          maps["builder"], datas, "MenuAnchorChildBuilder?", vars, props);
      final child = getValue(maps["child"], datas, "FocusNode?", vars, props);
      if (menuChildren == null) {
        return null;
      }
      return MenuAnchor(
          key: key,
          controller: controller,
          childFocusNode: childFocusNode,
          style: style,
          alignmentOffset: alignmentOffset ?? Offset.zero,
          clipBehavior: clipBehavior ?? Clip.hardEdge,
          anchorTapClosesMenu: anchorTapClosesMenu ?? false,
          onOpen: onOpen,
          onClose: onClose,
          crossAxisUnconstrained: crossAxisUnconstrained ?? true,
          menuChildren: List<Widget>.from(menuChildren!),
          builder: builder,
          child: child);
    },
    "MenuBar": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final style = getValue(maps["style"], datas, "MenuStyle?", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      final controller =
          getValue(maps["controller"], datas, "MenuController?", vars, props);
      final children =
          getValue(maps["children"], datas, "List<Widget>", vars, props);
      if (children == null) {
        return null;
      }
      return MenuBar(
          key: key,
          style: style,
          clipBehavior: clipBehavior ?? Clip.none,
          controller: controller,
          children: List<Widget>.from(children!));
    },
    "MenuBarTheme": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final data =
          getValue(maps["data"], datas, "MenuBarThemeData", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (data == null || child == null) {
        return null;
      }
      return MenuBarTheme(key: key, data: data!, child: child!);
    },
    "MenuBarThemeData": () {
      final style = getValue(maps["style"], datas, "MenuStyle?", vars, props);
      return MenuBarThemeData(style: style);
    },
    "MenuButtonTheme": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final data =
          getValue(maps["data"], datas, "MenuButtonThemeData", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (data == null || child == null) {
        return null;
      }
      return MenuButtonTheme(key: key, data: data!, child: child!);
    },
    "MenuButtonThemeData": () {
      final style = getValue(maps["style"], datas, "ButtonStyle?", vars, props);
      return MenuButtonThemeData(style: style);
    },
    "MenuItemButton": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final onPressed =
          getValue(maps["onPressed"], datas, "VoidCallback?", vars, props);
      final onHover =
          getValue(maps["onHover"], datas, "ValueChanged<bool>?", vars, props);
      final requestFocusOnHover =
          getValue(maps["requestFocusOnHover"], datas, "bool", vars, props);
      final onFocusChange = getValue(
          maps["onFocusChange"], datas, "ValueChanged<bool>?", vars, props);
      final focusNode =
          getValue(maps["focusNode"], datas, "FocusNode?", vars, props);
      final shortcut = getValue(
          maps["shortcut"], datas, "MenuSerializableShortcut?", vars, props);
      final style = getValue(maps["style"], datas, "ButtonStyle?", vars, props);
      final statesController = getValue(maps["statesController"], datas,
          "MaterialStatesController?", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      final leadingIcon =
          getValue(maps["leadingIcon"], datas, "Widget?", vars, props);
      final trailingIcon =
          getValue(maps["trailingIcon"], datas, "Widget?", vars, props);
      final closeOnActivate =
          getValue(maps["closeOnActivate"], datas, "bool", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      if (child == null) {
        return null;
      }
      return MenuItemButton(
          key: key,
          onPressed: onPressed,
          onHover: onHover,
          requestFocusOnHover: requestFocusOnHover ?? true,
          onFocusChange: onFocusChange,
          focusNode: focusNode,
          shortcut: shortcut,
          style: style,
          statesController: statesController,
          clipBehavior: clipBehavior ?? Clip.none,
          leadingIcon: leadingIcon,
          trailingIcon: trailingIcon,
          closeOnActivate: closeOnActivate ?? true,
          child: child!);
    },
    "MenuStyle": () {
      final backgroundColor = getValue(maps["backgroundColor"], datas,
          "MaterialStateProperty<Color?>?", vars, props);
      final shadowColor = getValue(maps["shadowColor"], datas,
          "MaterialStateProperty<Color?>?", vars, props);
      final surfaceTintColor = getValue(maps["surfaceTintColor"], datas,
          "MaterialStateProperty<Color?>?", vars, props);
      final elevation = getValue(maps["elevation"], datas,
          "MaterialStateProperty<double?>?", vars, props);
      final padding = getValue(maps["padding"], datas,
          "MaterialStateProperty<EdgeInsetsGeometry?>?", vars, props);
      final minimumSize = getValue(maps["minimumSize"], datas,
          "MaterialStateProperty<Size?>?", vars, props);
      final fixedSize = getValue(maps["fixedSize"], datas,
          "MaterialStateProperty<Size?>?", vars, props);
      final maximumSize = getValue(maps["maximumSize"], datas,
          "MaterialStateProperty<Size?>?", vars, props);
      final side = getValue(maps["side"], datas,
          "MaterialStateProperty<BorderSide?>?", vars, props);
      final shape = getValue(maps["shape"], datas,
          "MaterialStateProperty<OutlinedBorder?>?", vars, props);
      final mouseCursor = getValue(maps["mouseCursor"], datas,
          "MaterialStateProperty<MouseCursor?>?", vars, props);
      final visualDensity =
          getValue(maps["visualDensity"], datas, "VisualDensity?", vars, props);
      final alignment =
          getValue(maps["alignment"], datas, "AlignmentGeometry?", vars, props);
      return MenuStyle(
          backgroundColor: backgroundColor,
          shadowColor: shadowColor,
          surfaceTintColor: surfaceTintColor,
          elevation: elevation,
          padding: padding,
          minimumSize: minimumSize,
          fixedSize: fixedSize,
          maximumSize: maximumSize,
          side: side,
          shape: shape,
          mouseCursor: mouseCursor,
          visualDensity: visualDensity,
          alignment: alignment);
    },
    "MenuTheme": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final data = getValue(maps["data"], datas, "MenuThemeData", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (data == null || child == null) {
        return null;
      }
      return MenuTheme(key: key, data: data!, child: child!);
    },
    "MenuThemeData": () {
      final style = getValue(maps["style"], datas, "MenuStyle?", vars, props);
      return MenuThemeData(style: style);
    },
    "MergeSemantics": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      return MergeSemantics(key: key, child: child);
    },
    "MergeableMaterial": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final mainAxis = getValue(maps["mainAxis"], datas, "Axis", vars, props);
      final elevation =
          getValue(maps["elevation"], datas, "double", vars, props);
      final hasDividers =
          getValue(maps["hasDividers"], datas, "bool", vars, props);
      final children = getValue(
          maps["children"], datas, "List<MergeableMaterialItem>", vars, props);
      final dividerColor =
          getValue(maps["dividerColor"], datas, "Color?", vars, props);
      return MergeableMaterial(
          key: key,
          mainAxis: mainAxis ?? Axis.vertical,
          elevation: elevation ?? 2,
          hasDividers: hasDividers ?? false,
          children: List<MergeableMaterialItem>.from(
              children ?? const <MergeableMaterialItem>[]),
          dividerColor: dividerColor);
    },
    "MessageProperty": () {
      final name = getValue(maps["0"], datas, "String", vars, props);
      final message = getValue(maps["1"], datas, "String", vars, props);
      final style =
          getValue(maps["style"], datas, "DiagnosticsTreeStyle", vars, props);
      final level =
          getValue(maps["level"], datas, "DiagnosticLevel", vars, props);
      if (name == null || message == null) {
        return null;
      }
      return MessageProperty(name!, message!,
          style: style ?? DiagnosticsTreeStyle.singleLine,
          level: level ?? DiagnosticLevel.info);
    },
    "MetaData": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final metaData =
          getValue(maps["metaData"], datas, "dynamic", vars, props);
      final behavior =
          getValue(maps["behavior"], datas, "HitTestBehavior", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      return MetaData(
          key: key,
          metaData: metaData,
          behavior: behavior ?? HitTestBehavior.deferToChild,
          child: child);
    },
    "MethodCall": () {
      final method = getValue(maps["0"], datas, "String", vars, props);
      final arguments = getValue(maps["1"], datas, "dynamic", vars, props);
      if (method == null) {
        return null;
      }
      return MethodCall(method!, arguments);
    },
    "MethodChannel": () {
      final name = getValue(maps["0"], datas, "String", vars, props);
      final codec = getValue(maps["1"], datas, "MethodCodec", vars, props);
      final binaryMessenger =
          getValue(maps["2"], datas, "BinaryMessenger?", vars, props);
      if (name == null) {
        return null;
      }
      return MethodChannel(
          name!, codec ?? const StandardMethodCodec(), binaryMessenger);
    },
    "MissingPluginException": () {
      final message = getValue(maps["0"], datas, "String?", vars, props);
      return MissingPluginException(message);
    },
    "ModalBarrier": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final color = getValue(maps["color"], datas, "Color?", vars, props);
      final dismissible =
          getValue(maps["dismissible"], datas, "bool", vars, props);
      final onDismiss =
          getValue(maps["onDismiss"], datas, "VoidCallback?", vars, props);
      final semanticsLabel =
          getValue(maps["semanticsLabel"], datas, "String?", vars, props);
      final barrierSemanticsDismissible = getValue(
          maps["barrierSemanticsDismissible"], datas, "bool?", vars, props);
      final clipDetailsNotifier = getValue(maps["clipDetailsNotifier"], datas,
          "ValueNotifier<EdgeInsets>?", vars, props);
      final semanticsOnTapHint =
          getValue(maps["semanticsOnTapHint"], datas, "String?", vars, props);
      return ModalBarrier(
          key: key,
          color: color,
          dismissible: dismissible ?? true,
          onDismiss: onDismiss,
          semanticsLabel: semanticsLabel,
          barrierSemanticsDismissible: barrierSemanticsDismissible ?? true,
          clipDetailsNotifier: clipDetailsNotifier,
          semanticsOnTapHint: semanticsOnTapHint);
    },
    "ModalBottomSheetRoute": () {
      final builder =
          getValue(maps["builder"], datas, "WidgetBuilder", vars, props);
      final capturedThemes = getValue(
          maps["capturedThemes"], datas, "CapturedThemes?", vars, props);
      final barrierLabel =
          getValue(maps["barrierLabel"], datas, "String?", vars, props);
      final barrierOnTapHint =
          getValue(maps["barrierOnTapHint"], datas, "String?", vars, props);
      final backgroundColor =
          getValue(maps["backgroundColor"], datas, "Color?", vars, props);
      final elevation =
          getValue(maps["elevation"], datas, "double?", vars, props);
      final shape = getValue(maps["shape"], datas, "ShapeBorder?", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip?", vars, props);
      final constraints =
          getValue(maps["constraints"], datas, "BoxConstraints?", vars, props);
      final modalBarrierColor =
          getValue(maps["modalBarrierColor"], datas, "Color?", vars, props);
      final isDismissible =
          getValue(maps["isDismissible"], datas, "bool", vars, props);
      final enableDrag =
          getValue(maps["enableDrag"], datas, "bool", vars, props);
      final showDragHandle =
          getValue(maps["showDragHandle"], datas, "bool?", vars, props);
      final isScrollControlled =
          getValue(maps["isScrollControlled"], datas, "bool", vars, props);
      final settings = getValue(maps["settings"], datas, "", vars, props);
      final transitionAnimationController = getValue(
          maps["transitionAnimationController"],
          datas,
          "AnimationController?",
          vars,
          props);
      final anchorPoint =
          getValue(maps["anchorPoint"], datas, "Offset?", vars, props);
      final useSafeArea =
          getValue(maps["useSafeArea"], datas, "bool", vars, props);
      if (builder == null || isScrollControlled == null) {
        return null;
      }
      return ModalBottomSheetRoute(
          builder: builder!,
          capturedThemes: capturedThemes,
          barrierLabel: barrierLabel,
          barrierOnTapHint: barrierOnTapHint,
          backgroundColor: backgroundColor,
          elevation: elevation,
          shape: shape,
          clipBehavior: clipBehavior,
          constraints: constraints,
          modalBarrierColor: modalBarrierColor,
          isDismissible: isDismissible ?? true,
          enableDrag: enableDrag ?? true,
          showDragHandle: showDragHandle,
          isScrollControlled: isScrollControlled!,
          settings: settings,
          transitionAnimationController: transitionAnimationController,
          anchorPoint: anchorPoint,
          useSafeArea: useSafeArea ?? false);
    },
    "MouseCursorManager": () {
      final fallbackMouseCursor =
          getValue(maps["0"], datas, "MouseCursor", vars, props);
      if (fallbackMouseCursor == null) {
        return null;
      }
      return MouseCursorManager(fallbackMouseCursor!);
    },
    "MouseRegion": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final onEnter = getValue(
          maps["onEnter"], datas, "PointerEnterEventListener?", vars, props);
      final onExit = getValue(
          maps["onExit"], datas, "PointerExitEventListener?", vars, props);
      final onHover = getValue(
          maps["onHover"], datas, "PointerHoverEventListener?", vars, props);
      final cursor =
          getValue(maps["cursor"], datas, "MouseCursor", vars, props);
      final opaque = getValue(maps["opaque"], datas, "bool", vars, props);
      final hitTestBehavior = getValue(
          maps["hitTestBehavior"], datas, "HitTestBehavior?", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      return MouseRegion(
          key: key,
          onEnter: onEnter,
          onExit: onExit,
          onHover: onHover,
          cursor: cursor ?? MouseCursor.defer,
          opaque: opaque ?? true,
          hitTestBehavior: hitTestBehavior,
          child: child);
    },
    "MouseTrackerAnnotation": () {
      final onEnter = getValue(
          maps["onEnter"], datas, "PointerEnterEventListener?", vars, props);
      final onExit = getValue(
          maps["onExit"], datas, "PointerExitEventListener?", vars, props);
      final cursor =
          getValue(maps["cursor"], datas, "MouseCursor", vars, props);
      final validForMouseTracker =
          getValue(maps["validForMouseTracker"], datas, "bool", vars, props);
      return MouseTrackerAnnotation(
          onEnter: onEnter,
          onExit: onExit,
          cursor: cursor ?? MouseCursor.defer,
          validForMouseTracker: validForMouseTracker ?? true);
    },
    "MultiFrameImageStreamCompleter": () {
      final codec =
          getValue(maps["codec"], datas, "Future<ui.Codec>", vars, props);
      final scale = getValue(maps["scale"], datas, "double", vars, props);
      final debugLabel =
          getValue(maps["debugLabel"], datas, "String?", vars, props);
      final chunkEvents = getValue(
          maps["chunkEvents"], datas, "Stream<ImageChunkEvent>?", vars, props);
      final informationCollector = getValue(maps["informationCollector"], datas,
          "InformationCollector?", vars, props);
      if (codec == null || scale == null) {
        return null;
      }
      return MultiFrameImageStreamCompleter(
          codec: codec!,
          scale: scale!,
          debugLabel: debugLabel,
          chunkEvents: chunkEvents,
          informationCollector: informationCollector);
    },
    "MultiTapGestureRecognizer": () {
      final longTapDelay =
          getValue(maps["longTapDelay"], datas, "Duration", vars, props);
      final debugOwner =
          getValue(maps["debugOwner"], datas, "Object?", vars, props);
      final supportedDevices = getValue(maps["supportedDevices"], datas,
          "Set<PointerDeviceKind>?", vars, props);
      final allowedButtonsFilter = getValue(maps["allowedButtonsFilter"], datas,
          "AllowedButtonsFilter?", vars, props);
      return MultiTapGestureRecognizer(
          longTapDelay: longTapDelay ?? Duration.zero,
          debugOwner: debugOwner,
          supportedDevices: supportedDevices
              ? Set<PointerDeviceKind>.from(supportedDevices)
              : null,
          allowedButtonsFilter: allowedButtonsFilter);
    },
    "NavigationBar": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final animationDuration =
          getValue(maps["animationDuration"], datas, "Duration?", vars, props);
      final selectedIndex =
          getValue(maps["selectedIndex"], datas, "int", vars, props);
      final destinations =
          getValue(maps["destinations"], datas, "List<Widget>", vars, props);
      final onDestinationSelected = getValue(maps["onDestinationSelected"],
          datas, "ValueChanged<int>?", vars, props);
      final backgroundColor =
          getValue(maps["backgroundColor"], datas, "Color?", vars, props);
      final elevation =
          getValue(maps["elevation"], datas, "double?", vars, props);
      final shadowColor =
          getValue(maps["shadowColor"], datas, "Color?", vars, props);
      final surfaceTintColor =
          getValue(maps["surfaceTintColor"], datas, "Color?", vars, props);
      final indicatorColor =
          getValue(maps["indicatorColor"], datas, "Color?", vars, props);
      final indicatorShape =
          getValue(maps["indicatorShape"], datas, "ShapeBorder?", vars, props);
      final height = getValue(maps["height"], datas, "double?", vars, props);
      final labelBehavior = getValue(maps["labelBehavior"], datas,
          "NavigationDestinationLabelBehavior?", vars, props);
      if (destinations == null) {
        return null;
      }
      return NavigationBar(
          key: key,
          animationDuration: animationDuration,
          selectedIndex: selectedIndex ?? 0,
          destinations: List<Widget>.from(destinations!),
          onDestinationSelected: onDestinationSelected,
          backgroundColor: backgroundColor,
          elevation: elevation,
          shadowColor: shadowColor,
          surfaceTintColor: surfaceTintColor,
          indicatorColor: indicatorColor,
          indicatorShape: indicatorShape,
          height: height,
          labelBehavior: labelBehavior);
    },
    "NavigationBarTheme": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final data =
          getValue(maps["data"], datas, "NavigationBarThemeData", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (data == null || child == null) {
        return null;
      }
      return NavigationBarTheme(key: key, data: data!, child: child!);
    },
    "NavigationBarThemeData": () {
      final height = getValue(maps["height"], datas, "double?", vars, props);
      final backgroundColor =
          getValue(maps["backgroundColor"], datas, "Color?", vars, props);
      final elevation =
          getValue(maps["elevation"], datas, "double?", vars, props);
      final shadowColor =
          getValue(maps["shadowColor"], datas, "Color?", vars, props);
      final surfaceTintColor =
          getValue(maps["surfaceTintColor"], datas, "Color?", vars, props);
      final indicatorColor =
          getValue(maps["indicatorColor"], datas, "Color?", vars, props);
      final indicatorShape =
          getValue(maps["indicatorShape"], datas, "ShapeBorder?", vars, props);
      final labelTextStyle = getValue(maps["labelTextStyle"], datas,
          "MaterialStateProperty<TextStyle?>?", vars, props);
      final iconTheme = getValue(maps["iconTheme"], datas,
          "MaterialStateProperty<IconThemeData?>?", vars, props);
      final labelBehavior = getValue(maps["labelBehavior"], datas,
          "NavigationDestinationLabelBehavior?", vars, props);
      return NavigationBarThemeData(
          height: height,
          backgroundColor: backgroundColor,
          elevation: elevation,
          shadowColor: shadowColor,
          surfaceTintColor: surfaceTintColor,
          indicatorColor: indicatorColor,
          indicatorShape: indicatorShape,
          labelTextStyle: labelTextStyle,
          iconTheme: iconTheme,
          labelBehavior: labelBehavior);
    },
    "NavigationDestination": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final icon = getValue(maps["icon"], datas, "Widget", vars, props);
      final selectedIcon =
          getValue(maps["selectedIcon"], datas, "Widget?", vars, props);
      final label = getValue(maps["label"], datas, "String", vars, props);
      final tooltip = getValue(maps["tooltip"], datas, "String?", vars, props);
      if (icon == null || label == null) {
        return null;
      }
      return NavigationDestination(
          key: key,
          icon: icon!,
          selectedIcon: selectedIcon,
          label: label!,
          tooltip: tooltip);
    },
    "NavigationDrawer": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final children =
          getValue(maps["children"], datas, "List<Widget>", vars, props);
      final backgroundColor =
          getValue(maps["backgroundColor"], datas, "Color?", vars, props);
      final shadowColor =
          getValue(maps["shadowColor"], datas, "Color?", vars, props);
      final surfaceTintColor =
          getValue(maps["surfaceTintColor"], datas, "Color?", vars, props);
      final elevation =
          getValue(maps["elevation"], datas, "double?", vars, props);
      final indicatorColor =
          getValue(maps["indicatorColor"], datas, "Color?", vars, props);
      final indicatorShape =
          getValue(maps["indicatorShape"], datas, "ShapeBorder?", vars, props);
      final onDestinationSelected = getValue(maps["onDestinationSelected"],
          datas, "ValueChanged<int>?", vars, props);
      final selectedIndex =
          getValue(maps["selectedIndex"], datas, "int?", vars, props);
      if (children == null) {
        return null;
      }
      return NavigationDrawer(
          key: key,
          backgroundColor: backgroundColor,
          shadowColor: shadowColor,
          surfaceTintColor: surfaceTintColor,
          elevation: elevation,
          indicatorColor: indicatorColor,
          indicatorShape: indicatorShape,
          onDestinationSelected: onDestinationSelected,
          selectedIndex: selectedIndex ?? 0,
          children: List<Widget>.from(children!));
    },
    "NavigationDrawerDestination": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final backgroundColor =
          getValue(maps["backgroundColor"], datas, "Color?", vars, props);
      final icon = getValue(maps["icon"], datas, "Widget", vars, props);
      final selectedIcon =
          getValue(maps["selectedIcon"], datas, "Widget?", vars, props);
      final label = getValue(maps["label"], datas, "Widget", vars, props);
      if (icon == null || label == null) {
        return null;
      }
      return NavigationDrawerDestination(
          key: key,
          backgroundColor: backgroundColor,
          icon: icon!,
          selectedIcon: selectedIcon,
          label: label!);
    },
    "NavigationDrawerTheme": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final data = getValue(
          maps["data"], datas, "NavigationDrawerThemeData", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (data == null || child == null) {
        return null;
      }
      return NavigationDrawerTheme(key: key, data: data!, child: child!);
    },
    "NavigationDrawerThemeData": () {
      final tileHeight =
          getValue(maps["tileHeight"], datas, "double?", vars, props);
      final backgroundColor =
          getValue(maps["backgroundColor"], datas, "Color?", vars, props);
      final elevation =
          getValue(maps["elevation"], datas, "double?", vars, props);
      final shadowColor =
          getValue(maps["shadowColor"], datas, "Color?", vars, props);
      final surfaceTintColor =
          getValue(maps["surfaceTintColor"], datas, "Color?", vars, props);
      final indicatorColor =
          getValue(maps["indicatorColor"], datas, "Color?", vars, props);
      final indicatorShape =
          getValue(maps["indicatorShape"], datas, "ShapeBorder?", vars, props);
      final indicatorSize =
          getValue(maps["indicatorSize"], datas, "Size?", vars, props);
      final labelTextStyle = getValue(maps["labelTextStyle"], datas,
          "MaterialStateProperty<TextStyle?>?", vars, props);
      final iconTheme = getValue(maps["iconTheme"], datas,
          "MaterialStateProperty<IconThemeData?>?", vars, props);
      return NavigationDrawerThemeData(
          tileHeight: tileHeight,
          backgroundColor: backgroundColor,
          elevation: elevation,
          shadowColor: shadowColor,
          surfaceTintColor: surfaceTintColor,
          indicatorColor: indicatorColor,
          indicatorShape: indicatorShape,
          indicatorSize: indicatorSize,
          labelTextStyle: labelTextStyle,
          iconTheme: iconTheme);
    },
    "NavigationIndicator": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final animation =
          getValue(maps["animation"], datas, "Animation<double>", vars, props);
      final color = getValue(maps["color"], datas, "Color?", vars, props);
      final width = getValue(maps["width"], datas, "double", vars, props);
      final height = getValue(maps["height"], datas, "double", vars, props);
      final borderRadius =
          getValue(maps["borderRadius"], datas, "BorderRadius", vars, props);
      final shape = getValue(maps["shape"], datas, "ShapeBorder?", vars, props);
      if (animation == null) {
        return null;
      }
      if (width != null && height != null) {
        return NavigationIndicator(
            key: key,
            animation: animation!,
            color: color,
            borderRadius:
                borderRadius ?? const BorderRadius.all(Radius.circular(16)),
            shape: shape,
            width: width,
            height: height);
      }
      if (width != null) {
        return NavigationIndicator(
            key: key,
            animation: animation!,
            color: color,
            borderRadius:
                borderRadius ?? const BorderRadius.all(Radius.circular(16)),
            shape: shape,
            width: width);
      }
      if (height != null) {
        return NavigationIndicator(
            key: key,
            animation: animation!,
            color: color,
            borderRadius:
                borderRadius ?? const BorderRadius.all(Radius.circular(16)),
            shape: shape,
            height: height);
      }
      return NavigationIndicator(
          key: key,
          animation: animation!,
          color: color,
          borderRadius:
              borderRadius ?? const BorderRadius.all(Radius.circular(16)),
          shape: shape);
    },
    "NavigationRail": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final backgroundColor =
          getValue(maps["backgroundColor"], datas, "Color?", vars, props);
      final extended = getValue(maps["extended"], datas, "bool", vars, props);
      final leading = getValue(maps["leading"], datas, "Widget?", vars, props);
      final trailing =
          getValue(maps["trailing"], datas, "Widget?", vars, props);
      final destinations = getValue(maps["destinations"], datas,
          "List<NavigationRailDestination>", vars, props);
      final selectedIndex =
          getValue(maps["selectedIndex"], datas, "int?", vars, props);
      final onDestinationSelected = getValue(maps["onDestinationSelected"],
          datas, "ValueChanged<int>?", vars, props);
      final elevation =
          getValue(maps["elevation"], datas, "double?", vars, props);
      final groupAlignment =
          getValue(maps["groupAlignment"], datas, "double?", vars, props);
      final labelType = getValue(
          maps["labelType"], datas, "NavigationRailLabelType?", vars, props);
      final unselectedLabelTextStyle = getValue(
          maps["unselectedLabelTextStyle"], datas, "TextStyle?", vars, props);
      final selectedLabelTextStyle = getValue(
          maps["selectedLabelTextStyle"], datas, "TextStyle?", vars, props);
      final unselectedIconTheme = getValue(
          maps["unselectedIconTheme"], datas, "IconThemeData?", vars, props);
      final selectedIconTheme = getValue(
          maps["selectedIconTheme"], datas, "IconThemeData?", vars, props);
      final minWidth =
          getValue(maps["minWidth"], datas, "double?", vars, props);
      final minExtendedWidth =
          getValue(maps["minExtendedWidth"], datas, "double?", vars, props);
      final useIndicator =
          getValue(maps["useIndicator"], datas, "bool?", vars, props);
      final indicatorColor =
          getValue(maps["indicatorColor"], datas, "Color?", vars, props);
      final indicatorShape =
          getValue(maps["indicatorShape"], datas, "ShapeBorder?", vars, props);
      if (destinations == null || selectedIndex == null) {
        return null;
      }
      return NavigationRail(
          key: key,
          backgroundColor: backgroundColor,
          extended: extended ?? false,
          leading: leading,
          trailing: trailing,
          destinations: List<NavigationRailDestination>.from(destinations!),
          selectedIndex: selectedIndex!,
          onDestinationSelected: onDestinationSelected,
          elevation: elevation,
          groupAlignment: groupAlignment,
          labelType: labelType,
          unselectedLabelTextStyle: unselectedLabelTextStyle,
          selectedLabelTextStyle: selectedLabelTextStyle,
          unselectedIconTheme: unselectedIconTheme,
          selectedIconTheme: selectedIconTheme,
          minWidth: minWidth,
          minExtendedWidth: minExtendedWidth,
          useIndicator: useIndicator,
          indicatorColor: indicatorColor,
          indicatorShape: indicatorShape);
    },
    "NavigationRailDestination": () {
      final icon = getValue(maps["icon"], datas, "Widget", vars, props);
      final selectedIcon =
          getValue(maps["selectedIcon"], datas, "Widget?", vars, props);
      final indicatorColor =
          getValue(maps["indicatorColor"], datas, "Color?", vars, props);
      final indicatorShape =
          getValue(maps["indicatorShape"], datas, "ShapeBorder?", vars, props);
      final label = getValue(maps["label"], datas, "Widget", vars, props);
      final padding =
          getValue(maps["padding"], datas, "EdgeInsetsGeometry?", vars, props);
      if (icon == null || label == null) {
        return null;
      }
      return NavigationRailDestination(
          icon: icon!,
          selectedIcon: selectedIcon,
          indicatorColor: indicatorColor,
          indicatorShape: indicatorShape,
          label: label!,
          padding: padding);
    },
    "NavigationRailTheme": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final data =
          getValue(maps["data"], datas, "NavigationRailThemeData", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (data == null || child == null) {
        return null;
      }
      return NavigationRailTheme(key: key, data: data!, child: child!);
    },
    "NavigationRailThemeData": () {
      final backgroundColor =
          getValue(maps["backgroundColor"], datas, "Color?", vars, props);
      final elevation =
          getValue(maps["elevation"], datas, "double?", vars, props);
      final unselectedLabelTextStyle = getValue(
          maps["unselectedLabelTextStyle"], datas, "TextStyle?", vars, props);
      final selectedLabelTextStyle = getValue(
          maps["selectedLabelTextStyle"], datas, "TextStyle?", vars, props);
      final unselectedIconTheme = getValue(
          maps["unselectedIconTheme"], datas, "IconThemeData?", vars, props);
      final selectedIconTheme = getValue(
          maps["selectedIconTheme"], datas, "IconThemeData?", vars, props);
      final groupAlignment =
          getValue(maps["groupAlignment"], datas, "double?", vars, props);
      final labelType = getValue(
          maps["labelType"], datas, "NavigationRailLabelType?", vars, props);
      final useIndicator =
          getValue(maps["useIndicator"], datas, "bool?", vars, props);
      final indicatorColor =
          getValue(maps["indicatorColor"], datas, "Color?", vars, props);
      final indicatorShape =
          getValue(maps["indicatorShape"], datas, "ShapeBorder?", vars, props);
      final minWidth =
          getValue(maps["minWidth"], datas, "double?", vars, props);
      final minExtendedWidth =
          getValue(maps["minExtendedWidth"], datas, "double?", vars, props);
      return NavigationRailThemeData(
          backgroundColor: backgroundColor,
          elevation: elevation,
          unselectedLabelTextStyle: unselectedLabelTextStyle,
          selectedLabelTextStyle: selectedLabelTextStyle,
          unselectedIconTheme: unselectedIconTheme,
          selectedIconTheme: selectedIconTheme,
          groupAlignment: groupAlignment,
          labelType: labelType,
          useIndicator: useIndicator,
          indicatorColor: indicatorColor,
          indicatorShape: indicatorShape,
          minWidth: minWidth,
          minExtendedWidth: minExtendedWidth);
    },
    "NavigationToolbar": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final leading = getValue(maps["leading"], datas, "Widget?", vars, props);
      final middle = getValue(maps["middle"], datas, "Widget?", vars, props);
      final trailing =
          getValue(maps["trailing"], datas, "Widget?", vars, props);
      final centerMiddle =
          getValue(maps["centerMiddle"], datas, "bool", vars, props);
      final middleSpacing =
          getValue(maps["middleSpacing"], datas, "double", vars, props);
      if (middleSpacing != null) {
        return NavigationToolbar(
            key: key,
            leading: leading,
            middle: middle,
            trailing: trailing,
            centerMiddle: centerMiddle ?? true,
            middleSpacing: middleSpacing);
      }
      return NavigationToolbar(
          key: key,
          leading: leading,
          middle: middle,
          trailing: trailing,
          centerMiddle: centerMiddle ?? true);
    },
    "Navigator": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final pages =
          getValue(maps["pages"], datas, "List<Page<dynamic>>", vars, props);
      final onPopPage =
          getValue(maps["onPopPage"], datas, "PopPageCallback?", vars, props);
      final initialRoute =
          getValue(maps["initialRoute"], datas, "String?", vars, props);
      final onGenerateInitialRoutes = getValue(maps["onGenerateInitialRoutes"],
          datas, "RouteListFactory", vars, props);
      final onGenerateRoute = getValue(
          maps["onGenerateRoute"], datas, "RouteFactory?", vars, props);
      final onUnknownRoute =
          getValue(maps["onUnknownRoute"], datas, "RouteFactory?", vars, props);
      final transitionDelegate = getValue(maps["transitionDelegate"], datas,
          "TransitionDelegate<dynamic>", vars, props);
      final reportsRouteUpdateToEngine = getValue(
          maps["reportsRouteUpdateToEngine"], datas, "bool", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      final observers = getValue(
          maps["observers"], datas, "List<NavigatorObserver>", vars, props);
      final requestFocus =
          getValue(maps["requestFocus"], datas, "bool", vars, props);
      final restorationScopeId =
          getValue(maps["restorationScopeId"], datas, "String?", vars, props);
      final routeTraversalEdgeBehavior = getValue(
          maps["routeTraversalEdgeBehavior"],
          datas,
          "TraversalEdgeBehavior",
          vars,
          props);
      if (routeTraversalEdgeBehavior != null) {
        return Navigator(
            key: key,
            pages: List<Page<dynamic>>.from(pages ?? const <Page<dynamic>>[]),
            onPopPage: onPopPage,
            initialRoute: initialRoute,
            onGenerateInitialRoutes: onGenerateInitialRoutes ??
                Navigator.defaultGenerateInitialRoutes,
            onGenerateRoute: onGenerateRoute,
            onUnknownRoute: onUnknownRoute,
            transitionDelegate: transitionDelegate ??
                const DefaultTransitionDelegate<dynamic>(),
            reportsRouteUpdateToEngine: reportsRouteUpdateToEngine ?? false,
            clipBehavior: clipBehavior ?? Clip.hardEdge,
            observers: List<NavigatorObserver>.from(
                observers ?? const <NavigatorObserver>[]),
            requestFocus: requestFocus ?? true,
            restorationScopeId: restorationScopeId,
            routeTraversalEdgeBehavior: routeTraversalEdgeBehavior);
      }
      return Navigator(
          key: key,
          pages: List<Page<dynamic>>.from(pages ?? const <Page<dynamic>>[]),
          onPopPage: onPopPage,
          initialRoute: initialRoute,
          onGenerateInitialRoutes:
              onGenerateInitialRoutes ?? Navigator.defaultGenerateInitialRoutes,
          onGenerateRoute: onGenerateRoute,
          onUnknownRoute: onUnknownRoute,
          transitionDelegate:
              transitionDelegate ?? const DefaultTransitionDelegate<dynamic>(),
          reportsRouteUpdateToEngine: reportsRouteUpdateToEngine ?? false,
          clipBehavior: clipBehavior ?? Clip.hardEdge,
          observers: List<NavigatorObserver>.from(
              observers ?? const <NavigatorObserver>[]),
          requestFocus: requestFocus ?? true,
          restorationScopeId: restorationScopeId);
    },
    "NestedScrollView": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final controller =
          getValue(maps["controller"], datas, "ScrollController?", vars, props);
      final scrollDirection =
          getValue(maps["scrollDirection"], datas, "Axis", vars, props);
      final reverse = getValue(maps["reverse"], datas, "bool", vars, props);
      final physics =
          getValue(maps["physics"], datas, "ScrollPhysics?", vars, props);
      final headerSliverBuilder = getValue(maps["headerSliverBuilder"], datas,
          "NestedScrollViewHeaderSliversBuilder", vars, props);
      final body = getValue(maps["body"], datas, "Widget", vars, props);
      final dragStartBehavior = getValue(
          maps["dragStartBehavior"], datas, "DragStartBehavior", vars, props);
      final floatHeaderSlivers =
          getValue(maps["floatHeaderSlivers"], datas, "bool", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      final restorationId =
          getValue(maps["restorationId"], datas, "String?", vars, props);
      final scrollBehavior = getValue(
          maps["scrollBehavior"], datas, "ScrollBehavior?", vars, props);
      if (headerSliverBuilder == null || body == null) {
        return null;
      }
      return NestedScrollView(
          key: key,
          controller: controller,
          scrollDirection: scrollDirection ?? Axis.vertical,
          reverse: reverse ?? false,
          physics: physics,
          headerSliverBuilder: headerSliverBuilder!,
          body: body!,
          dragStartBehavior: dragStartBehavior ?? DragStartBehavior.start,
          floatHeaderSlivers: floatHeaderSlivers ?? false,
          clipBehavior: clipBehavior ?? Clip.hardEdge,
          restorationId: restorationId,
          scrollBehavior: scrollBehavior);
    },
    "NestedScrollViewViewport": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final axisDirection =
          getValue(maps["axisDirection"], datas, "AxisDirection", vars, props);
      final crossAxisDirection = getValue(
          maps["crossAxisDirection"], datas, "AxisDirection?", vars, props);
      final anchor = getValue(maps["anchor"], datas, "double", vars, props);
      final offset =
          getValue(maps["offset"], datas, "ViewportOffset", vars, props);
      final center = getValue(maps["center"], datas, "Key?", vars, props);
      final slivers =
          getValue(maps["slivers"], datas, "List<Widget>", vars, props);
      final handle = getValue(
          maps["handle"], datas, "SliverOverlapAbsorberHandle", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      if (offset == null || handle == null) {
        return null;
      }
      return NestedScrollViewViewport(
          key: key,
          axisDirection: axisDirection ?? AxisDirection.down,
          crossAxisDirection: crossAxisDirection,
          anchor: anchor ?? 0.0,
          offset: offset!,
          center: center,
          slivers: List<Widget>.from(slivers ?? const <Widget>[]),
          handle: handle!,
          clipBehavior: clipBehavior ?? Clip.hardEdge);
    },
    "NetworkAssetBundle": () {
      final baseUrl = getValue(maps["0"], datas, "Uri", vars, props);
      if (baseUrl == null) {
        return null;
      }
      return NetworkAssetBundle(baseUrl!);
    },
    "NetworkImage": () {
      final url = getValue(maps["0"], datas, "String", vars, props);
      final scale = getValue(maps["scale"], datas, "double", vars, props);
      final headers = getValue(
          maps["headers"], datas, "Map<String,   String>?", vars, props);
      if (url == null) {
        return null;
      }
      return NetworkImage(url!,
          scale: scale,
          headers: headers ? Map<String, String>.from(headers) : null);
    },
    "NetworkImageLoadException": () {
      final statusCode =
          getValue(maps["statusCode"], datas, "int", vars, props);
      final uri = getValue(maps["uri"], datas, "Uri", vars, props);
      if (statusCode == null || uri == null) {
        return null;
      }
      return NetworkImageLoadException(statusCode: statusCode!, uri: uri!);
    },
    "NeverScrollableScrollPhysics": () {
      final parent =
          getValue(maps["parent"], datas, "ScrollPhysics?", vars, props);
      return NeverScrollableScrollPhysics(parent: parent);
    },
    "NextFocusIntent": () {
      return const NextFocusIntent();
    },
    "NoDefaultCupertinoThemeData": () {
      final brightness =
          getValue(maps["brightness"], datas, "Brightness?", vars, props);
      final primaryColor =
          getValue(maps["primaryColor"], datas, "Color?", vars, props);
      final primaryContrastingColor = getValue(
          maps["primaryContrastingColor"], datas, "Color?", vars, props);
      final textTheme = getValue(
          maps["textTheme"], datas, "CupertinoTextThemeData?", vars, props);
      final barBackgroundColor =
          getValue(maps["barBackgroundColor"], datas, "Color?", vars, props);
      final scaffoldBackgroundColor = getValue(
          maps["scaffoldBackgroundColor"], datas, "Color?", vars, props);
      final applyThemeToAll =
          getValue(maps["applyThemeToAll"], datas, "bool?", vars, props);
      return NoDefaultCupertinoThemeData(
          brightness: brightness,
          primaryColor: primaryColor,
          primaryContrastingColor: primaryContrastingColor,
          textTheme: textTheme,
          barBackgroundColor: barBackgroundColor,
          scaffoldBackgroundColor: scaffoldBackgroundColor,
          applyThemeToAll: applyThemeToAll);
    },
    "NoSplash": () {
      final controller = getValue(
          maps["controller"], datas, "MaterialInkController", vars, props);
      final referenceBox =
          getValue(maps["referenceBox"], datas, "RenderBox", vars, props);
      final color = getValue(maps["color"], datas, "Color", vars, props);
      final onRemoved =
          getValue(maps["onRemoved"], datas, "VoidCallback?", vars, props);
      if (controller == null || referenceBox == null || color == null) {
        return null;
      }
      return NoSplash(
          controller: controller!,
          referenceBox: referenceBox!,
          color: color!,
          onRemoved: onRemoved);
    },
    "NoSuchMethodError.withInvocation": () {
      final receiver = getValue(maps["0"], datas, "Object?", vars, props);
      final invocation = getValue(maps["1"], datas, "Invocation", vars, props);
      if (receiver == null || invocation == null) {
        return null;
      }
      return NoSuchMethodError.withInvocation(receiver!, invocation!);
    },
    "NotificationListener": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      final onNotification = getValue(maps["onNotification"], datas,
          "NotificationListenerCallback<T>?", vars, props);
      if (child == null) {
        return null;
      }
      return NotificationListener(
          key: key, child: child!, onNotification: onNotification);
    },
    "NumericFocusOrder": () {
      final order = getValue(maps["0"], datas, "double", vars, props);
      if (order == null) {
        return null;
      }
      return NumericFocusOrder(order!);
    },
    "Object": () {
      return Object();
    },
    "ObjectCreated": () {
      final library = getValue(maps["library"], datas, "String", vars, props);
      final className =
          getValue(maps["className"], datas, "String", vars, props);
      final object = getValue(maps["object"], datas, "Object", vars, props);
      if (library == null || className == null || object == null) {
        return null;
      }
      return ObjectCreated(
          library: library!, className: className!, object: object!);
    },
    "ObjectDisposed": () {
      final object = getValue(maps["object"], datas, "Object", vars, props);
      if (object == null) {
        return null;
      }
      return ObjectDisposed(object: object!);
    },
    "ObjectFlagProperty": () {
      final name = getValue(maps["0"], datas, "String", vars, props);
      final value = getValue(maps["1"], datas, "T?", vars, props);
      final ifPresent =
          getValue(maps["ifPresent"], datas, "String?", vars, props);
      final ifNull = getValue(maps["ifNull"], datas, "String?", vars, props);
      final showName = getValue(maps["showName"], datas, "", vars, props);
      final level =
          getValue(maps["level"], datas, "DiagnosticLevel", vars, props);
      if (name == null || value == null) {
        return null;
      }
      return ObjectFlagProperty(name!, value!,
          ifPresent: ifPresent,
          ifNull: ifNull,
          showName: showName ?? false,
          level: level ?? DiagnosticLevel.info);
    },
    "ObjectFlagProperty.has": () {
      final name = getValue(maps["0"], datas, "String", vars, props);
      final value = getValue(maps["1"], datas, "T?", vars, props);
      final level =
          getValue(maps["level"], datas, "DiagnosticLevel", vars, props);
      if (name == null || value == null) {
        return null;
      }
      return ObjectFlagProperty.has(name!, value!,
          level: level ?? DiagnosticLevel.info);
    },
    "ObjectKey": () {
      final value = getValue(maps["0"], datas, "Object?", vars, props);
      if (value == null) {
        return null;
      }
      return ObjectKey(value!);
    },
    "Offset": () {
      final dx = getValue(maps["0"], datas, "double", vars, props);
      final dy = getValue(maps["1"], datas, "double", vars, props);
      if (dx == null || dy == null) {
        return null;
      }
      return Offset(dx!, dy!);
    },
    "Offset.fromDirection": () {
      final direction = getValue(maps["0"], datas, "double", vars, props);
      final distance = getValue(maps["1"], datas, "double", vars, props);
      if (direction == null) {
        return null;
      }
      return Offset.fromDirection(direction!, distance ?? 1.0);
    },
    "OffsetLayer": () {
      final offset = getValue(maps["offset"], datas, "Offset", vars, props);
      return OffsetLayer(offset: offset ?? Offset.zero);
    },
    "OffsetPair": () {
      final local = getValue(maps["local"], datas, "Offset", vars, props);
      final global = getValue(maps["global"], datas, "Offset", vars, props);
      if (local == null || global == null) {
        return null;
      }
      return OffsetPair(local: local!, global: global!);
    },
    "OffsetPair.fromEventPosition": () {
      final event = getValue(maps["0"], datas, "PointerEvent", vars, props);
      if (event == null) {
        return null;
      }
      return OffsetPair.fromEventPosition(event!);
    },
    "OffsetPair.fromEventDelta": () {
      final event = getValue(maps["0"], datas, "PointerEvent", vars, props);
      if (event == null) {
        return null;
      }
      return OffsetPair.fromEventDelta(event!);
    },
    "Offstage": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final offstage = getValue(maps["offstage"], datas, "bool", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      return Offstage(key: key, offstage: offstage ?? true, child: child);
    },
    "OneFrameImageStreamCompleter": () {
      final image =
          getValue(maps["0"], datas, "Future<ImageInfo>", vars, props);
      final informationCollector = getValue(maps["informationCollector"], datas,
          "InformationCollector?", vars, props);
      if (image == null) {
        return null;
      }
      return OneFrameImageStreamCompleter(image!,
          informationCollector: informationCollector);
    },
    "Opacity": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final opacity = getValue(maps["opacity"], datas, "double", vars, props);
      final alwaysIncludeSemantics =
          getValue(maps["alwaysIncludeSemantics"], datas, "bool", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      if (opacity == null) {
        return null;
      }
      return Opacity(
          key: key,
          opacity: opacity!,
          alwaysIncludeSemantics: alwaysIncludeSemantics ?? false,
          child: child);
    },
    "OpacityLayer": () {
      final alpha = getValue(maps["alpha"], datas, "int?", vars, props);
      final offset = getValue(maps["offset"], datas, "Offset", vars, props);
      return OpacityLayer(alpha: alpha, offset: offset ?? Offset.zero);
    },
    "OpenUpwardsPageTransitionsBuilder": () {
      return const OpenUpwardsPageTransitionsBuilder();
    },
    "OptionalMethodChannel": () {
      final name = getValue(maps["0"], datas, "String", vars, props);
      final codec = getValue(maps["1"], datas, "MethodCodec", vars, props);
      final binaryMessenger =
          getValue(maps["2"], datas, "BinaryMessenger?", vars, props);
      if (name == null) {
        return null;
      }
      return OptionalMethodChannel(
          name!, codec ?? const StandardMethodCodec(), binaryMessenger);
    },
    "OrderedTraversalPolicy": () {
      final secondary = getValue(
          maps["secondary"], datas, "FocusTraversalPolicy?", vars, props);
      return OrderedTraversalPolicy(secondary: secondary);
    },
    "OrdinalSortKey": () {
      final order = getValue(maps["0"], datas, "double", vars, props);
      final name = getValue(maps["name"], datas, "String?", vars, props);
      if (order == null) {
        return null;
      }
      return OrdinalSortKey(order!, name: name);
    },
    "OrientationBuilder": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final builder = getValue(
          maps["builder"], datas, "OrientationWidgetBuilder", vars, props);
      if (builder == null) {
        return null;
      }
      return OrientationBuilder(key: key, builder: builder!);
    },
    "OutOfMemoryError": () {
      return const OutOfMemoryError();
    },
    "OutlineInputBorder": () {
      final borderSide =
          getValue(maps["borderSide"], datas, "BorderSide", vars, props);
      final borderRadius =
          getValue(maps["borderRadius"], datas, "BorderRadius", vars, props);
      final gapPadding =
          getValue(maps["gapPadding"], datas, "double", vars, props);
      return OutlineInputBorder(
          borderSide: borderSide ?? const BorderSide(),
          borderRadius:
              borderRadius ?? const BorderRadius.all(Radius.circular(4.0)),
          gapPadding: gapPadding ?? 4.0);
    },
    "OutlinedButton": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final onPressed =
          getValue(maps["onPressed"], datas, "VoidCallback?", vars, props);
      final onLongPress =
          getValue(maps["onLongPress"], datas, "VoidCallback?", vars, props);
      final onHover =
          getValue(maps["onHover"], datas, "ValueChanged<bool>?", vars, props);
      final onFocusChange = getValue(
          maps["onFocusChange"], datas, "ValueChanged<bool>?", vars, props);
      final style = getValue(maps["style"], datas, "ButtonStyle?", vars, props);
      final focusNode =
          getValue(maps["focusNode"], datas, "FocusNode?", vars, props);
      final autofocus = getValue(maps["autofocus"], datas, "bool", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      final statesController = getValue(maps["statesController"], datas,
          "MaterialStatesController?", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      if (onPressed == null || child == null) {
        return null;
      }
      return OutlinedButton(
          key: key,
          onPressed: onPressed!,
          onLongPress: onLongPress,
          onHover: onHover,
          onFocusChange: onFocusChange,
          style: style,
          focusNode: focusNode,
          autofocus: autofocus ?? false,
          clipBehavior: clipBehavior ?? Clip.none,
          statesController: statesController,
          child: child!);
    },
    "OutlinedButton.icon": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final onPressed =
          getValue(maps["onPressed"], datas, "VoidCallback?", vars, props);
      final onLongPress =
          getValue(maps["onLongPress"], datas, "VoidCallback?", vars, props);
      final style = getValue(maps["style"], datas, "ButtonStyle?", vars, props);
      final focusNode =
          getValue(maps["focusNode"], datas, "FocusNode?", vars, props);
      final autofocus =
          getValue(maps["autofocus"], datas, "bool?", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip?", vars, props);
      final statesController = getValue(maps["statesController"], datas,
          "MaterialStatesController?", vars, props);
      final icon = getValue(maps["icon"], datas, "Widget", vars, props);
      final label = getValue(maps["label"], datas, "Widget", vars, props);
      if (onPressed == null || icon == null || label == null) {
        return null;
      }
      return OutlinedButton.icon(
          key: key,
          onPressed: onPressed!,
          onLongPress: onLongPress,
          style: style,
          focusNode: focusNode,
          autofocus: autofocus,
          clipBehavior: clipBehavior,
          statesController: statesController,
          icon: icon!,
          label: label!);
    },
    "OutlinedButtonTheme": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final data =
          getValue(maps["data"], datas, "OutlinedButtonThemeData", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (data == null || child == null) {
        return null;
      }
      return OutlinedButtonTheme(key: key, data: data!, child: child!);
    },
    "OutlinedButtonThemeData": () {
      final style = getValue(maps["style"], datas, "ButtonStyle?", vars, props);
      return OutlinedButtonThemeData(style: style);
    },
    "OvalBorder": () {
      final side = getValue(maps["side"], datas, "", vars, props);
      final eccentricity =
          getValue(maps["eccentricity"], datas, "", vars, props);
      return OvalBorder(side: side, eccentricity: eccentricity ?? 1.0);
    },
    "OverScrollHeaderStretchConfiguration": () {
      final stretchTriggerOffset =
          getValue(maps["stretchTriggerOffset"], datas, "double", vars, props);
      final onStretchTrigger = getValue(
          maps["onStretchTrigger"], datas, "AsyncCallback?", vars, props);
      return OverScrollHeaderStretchConfiguration(
          stretchTriggerOffset: stretchTriggerOffset ?? 100.0,
          onStretchTrigger: onStretchTrigger);
    },
    "OverflowBar": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final spacing = getValue(maps["spacing"], datas, "double", vars, props);
      final alignment =
          getValue(maps["alignment"], datas, "MainAxisAlignment?", vars, props);
      final overflowSpacing =
          getValue(maps["overflowSpacing"], datas, "double", vars, props);
      final overflowAlignment = getValue(maps["overflowAlignment"], datas,
          "OverflowBarAlignment", vars, props);
      final overflowDirection = getValue(
          maps["overflowDirection"], datas, "VerticalDirection", vars, props);
      final textDirection =
          getValue(maps["textDirection"], datas, "TextDirection?", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      final children =
          getValue(maps["children"], datas, "List<Widget>", vars, props);
      return OverflowBar(
          key: key,
          spacing: spacing ?? 0.0,
          alignment: alignment,
          overflowSpacing: overflowSpacing ?? 0.0,
          overflowAlignment: overflowAlignment ?? OverflowBarAlignment.start,
          overflowDirection: overflowDirection ?? VerticalDirection.down,
          textDirection: textDirection,
          //clipBehavior: clipBehavior ?? Clip.none,
          children: List<Widget>.from(children ?? const <Widget>[]));
    },
    "OverflowBox": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final alignment =
          getValue(maps["alignment"], datas, "AlignmentGeometry", vars, props);
      final minWidth =
          getValue(maps["minWidth"], datas, "double?", vars, props);
      final maxWidth =
          getValue(maps["maxWidth"], datas, "double?", vars, props);
      final minHeight =
          getValue(maps["minHeight"], datas, "double?", vars, props);
      final maxHeight =
          getValue(maps["maxHeight"], datas, "double?", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      return OverflowBox(
          key: key,
          alignment: alignment ?? Alignment.center,
          minWidth: minWidth,
          maxWidth: maxWidth,
          minHeight: minHeight,
          maxHeight: maxHeight,
          child: child);
    },
    "Overlay": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final initialEntries = getValue(
          maps["initialEntries"], datas, "List<OverlayEntry>", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      return Overlay(
          key: key,
          initialEntries:
              List<OverlayEntry>.from(initialEntries ?? const <OverlayEntry>[]),
          clipBehavior: clipBehavior ?? Clip.hardEdge);
    },
    "OverlayEntry": () {
      final builder =
          getValue(maps["builder"], datas, "WidgetBuilder", vars, props);
      final opaque = getValue(maps["opaque"], datas, "bool", vars, props);
      final maintainState =
          getValue(maps["maintainState"], datas, "bool", vars, props);
      if (builder == null) {
        return null;
      }
      return OverlayEntry(
          builder: builder!,
          opaque: opaque ?? false,
          maintainState: maintainState ?? false);
    },
    "OverlayPortalController": () {
      final debugLabel =
          getValue(maps["debugLabel"], datas, "String?", vars, props);
      return OverlayPortalController(debugLabel: debugLabel);
    },
    "OverscrollNotification": () {
      final metrics =
          getValue(maps["metrics"], datas, "ScrollMetrics", vars, props);
      final context =
          getValue(maps["context"], datas, "BuildContext", vars, props);
      final dragDetails = getValue(
          maps["dragDetails"], datas, "DragUpdateDetails?", vars, props);
      final overscroll =
          getValue(maps["overscroll"], datas, "double", vars, props);
      final velocity = getValue(maps["velocity"], datas, "double", vars, props);
      if (metrics == null || context == null || overscroll == null) {
        return null;
      }
      return OverscrollNotification(
          metrics: metrics!,
          context: context!,
          dragDetails: dragDetails,
          overscroll: overscroll!,
          velocity: velocity ?? 0.0);
    },
    "Padding": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final padding =
          getValue(maps["padding"], datas, "EdgeInsetsGeometry", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      if (padding == null) {
        return null;
      }
      return Padding(key: key, padding: padding!, child: child);
    },
    "PaddleRangeSliderValueIndicatorShape": () {
      return const PaddleRangeSliderValueIndicatorShape();
    },
    "PaddleSliderValueIndicatorShape": () {
      return const PaddleSliderValueIndicatorShape();
    },
    "PageController": () {
      final initialPage =
          getValue(maps["initialPage"], datas, "int", vars, props);
      final keepPage = getValue(maps["keepPage"], datas, "bool", vars, props);
      final viewportFraction =
          getValue(maps["viewportFraction"], datas, "double", vars, props);
      return PageController(
          initialPage: initialPage ?? 0,
          keepPage: keepPage ?? true,
          viewportFraction: viewportFraction ?? 1.0);
    },
    "PageMetrics": () {
      final minScrollExtent =
          getValue(maps["minScrollExtent"], datas, "double?", vars, props);
      final maxScrollExtent =
          getValue(maps["maxScrollExtent"], datas, "double?", vars, props);
      final pixels = getValue(maps["pixels"], datas, "double?", vars, props);
      final viewportDimension =
          getValue(maps["viewportDimension"], datas, "double?", vars, props);
      final axisDirection =
          getValue(maps["axisDirection"], datas, "AxisDirection", vars, props);
      final viewportFraction =
          getValue(maps["viewportFraction"], datas, "double", vars, props);
      final devicePixelRatio =
          getValue(maps["devicePixelRatio"], datas, "double", vars, props);
      if (minScrollExtent == null ||
          maxScrollExtent == null ||
          pixels == null ||
          viewportDimension == null ||
          axisDirection == null ||
          viewportFraction == null ||
          devicePixelRatio == null) {
        return null;
      }
      return PageMetrics(
          minScrollExtent: minScrollExtent!,
          maxScrollExtent: maxScrollExtent!,
          pixels: pixels!,
          viewportDimension: viewportDimension!,
          axisDirection: axisDirection!,
          viewportFraction: viewportFraction!,
          devicePixelRatio: devicePixelRatio!);
    },
    "PageRouteBuilder": () {
      final settings =
          getValue(maps["settings"], datas, "RouteSettings?", vars, props);
      final pageBuilder =
          getValue(maps["pageBuilder"], datas, "RoutePageBuilder", vars, props);
      final transitionsBuilder = getValue(maps["transitionsBuilder"], datas,
          "RouteTransitionsBuilder", vars, props);
      final transitionDuration =
          getValue(maps["transitionDuration"], datas, "Duration", vars, props);
      final reverseTransitionDuration = getValue(
          maps["reverseTransitionDuration"], datas, "Duration", vars, props);
      final opaque = getValue(maps["opaque"], datas, "bool", vars, props);
      final barrierDismissible =
          getValue(maps["barrierDismissible"], datas, "bool", vars, props);
      final barrierColor =
          getValue(maps["barrierColor"], datas, "Color?", vars, props);
      final barrierLabel =
          getValue(maps["barrierLabel"], datas, "String?", vars, props);
      final maintainState =
          getValue(maps["maintainState"], datas, "bool", vars, props);
      final fullscreenDialog =
          getValue(maps["fullscreenDialog"], datas, "bool", vars, props);
      final allowSnapshotting =
          getValue(maps["allowSnapshotting"], datas, "bool", vars, props);
      if (pageBuilder == null) {
        return null;
      }
      if (transitionsBuilder != null) {
        return PageRouteBuilder(
            settings: settings,
            pageBuilder: pageBuilder!,
            transitionDuration:
                transitionDuration ?? const Duration(milliseconds: 300),
            reverseTransitionDuration:
                reverseTransitionDuration ?? const Duration(milliseconds: 300),
            opaque: opaque ?? true,
            barrierDismissible: barrierDismissible ?? false,
            barrierColor: barrierColor,
            barrierLabel: barrierLabel,
            maintainState: maintainState ?? true,
            fullscreenDialog: fullscreenDialog ?? false,
            allowSnapshotting: allowSnapshotting ?? true,
            transitionsBuilder: transitionsBuilder);
      }
      return PageRouteBuilder(
          settings: settings,
          pageBuilder: pageBuilder!,
          transitionDuration:
              transitionDuration ?? const Duration(milliseconds: 300),
          reverseTransitionDuration:
              reverseTransitionDuration ?? const Duration(milliseconds: 300),
          opaque: opaque ?? true,
          barrierDismissible: barrierDismissible ?? false,
          barrierColor: barrierColor,
          barrierLabel: barrierLabel,
          maintainState: maintainState ?? true,
          fullscreenDialog: fullscreenDialog ?? false,
          allowSnapshotting: allowSnapshotting ?? true);
    },
    "PageScrollPhysics": () {
      final parent =
          getValue(maps["parent"], datas, "ScrollPhysics?", vars, props);
      return PageScrollPhysics(parent: parent);
    },
    "PageStorage": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final bucket =
          getValue(maps["bucket"], datas, "PageStorageBucket", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (bucket == null || child == null) {
        return null;
      }
      return PageStorage(key: key, bucket: bucket!, child: child!);
    },
    "PageStorageKey": () {
      final value = getValue(maps["0"], datas, "T", vars, props);
      if (value == null) {
        return null;
      }
      return PageStorageKey(value!);
    },
    "PageTransitionsTheme": () {
      final builders = getValue(maps["builders"], datas,
          "Map<TargetPlatform,   PageTransitionsBuilder>", vars, props);
      if (builders != null) {
        return PageTransitionsTheme(
            builders:
                Map<TargetPlatform, PageTransitionsBuilder>.from(builders));
      }
      return const PageTransitionsTheme();
    },
    "PageView": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final scrollDirection =
          getValue(maps["scrollDirection"], datas, "Axis", vars, props);
      final reverse = getValue(maps["reverse"], datas, "bool", vars, props);
      final controller =
          getValue(maps["controller"], datas, "PageController?", vars, props);
      final physics =
          getValue(maps["physics"], datas, "ScrollPhysics?", vars, props);
      final pageSnapping =
          getValue(maps["pageSnapping"], datas, "bool", vars, props);
      final onPageChanged = getValue(
          maps["onPageChanged"], datas, "ValueChanged<int>?", vars, props);
      final children =
          getValue(maps["children"], datas, "List<Widget>", vars, props);
      final dragStartBehavior = getValue(
          maps["dragStartBehavior"], datas, "DragStartBehavior", vars, props);
      final allowImplicitScrolling =
          getValue(maps["allowImplicitScrolling"], datas, "bool", vars, props);
      final restorationId =
          getValue(maps["restorationId"], datas, "String?", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      final scrollBehavior = getValue(
          maps["scrollBehavior"], datas, "ScrollBehavior?", vars, props);
      final padEnds = getValue(maps["padEnds"], datas, "bool", vars, props);
      return PageView(
          key: key,
          scrollDirection: scrollDirection ?? Axis.horizontal,
          reverse: reverse ?? false,
          controller: controller,
          physics: physics,
          pageSnapping: pageSnapping ?? true,
          onPageChanged: onPageChanged,
          dragStartBehavior: dragStartBehavior ?? DragStartBehavior.start,
          allowImplicitScrolling: allowImplicitScrolling ?? false,
          restorationId: restorationId,
          clipBehavior: clipBehavior ?? Clip.hardEdge,
          scrollBehavior: scrollBehavior,
          padEnds: padEnds ?? true,
          children: List<Widget>.from(children ?? const <Widget>[]));
    },
    "PageView.builder": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final scrollDirection =
          getValue(maps["scrollDirection"], datas, "Axis", vars, props);
      final reverse = getValue(maps["reverse"], datas, "bool", vars, props);
      final controller =
          getValue(maps["controller"], datas, "PageController?", vars, props);
      final physics =
          getValue(maps["physics"], datas, "ScrollPhysics?", vars, props);
      final pageSnapping =
          getValue(maps["pageSnapping"], datas, "bool", vars, props);
      final onPageChanged = getValue(
          maps["onPageChanged"], datas, "ValueChanged<int>?", vars, props);
      final itemBuilder = getValue(maps["itemBuilder"], datas,
          "NullableIndexedWidgetBuilder", vars, props);
      final findChildIndexCallback = getValue(maps["findChildIndexCallback"],
          datas, "ChildIndexGetter?", vars, props);
      final itemCount = getValue(maps["itemCount"], datas, "int?", vars, props);
      final dragStartBehavior = getValue(
          maps["dragStartBehavior"], datas, "DragStartBehavior", vars, props);
      final allowImplicitScrolling =
          getValue(maps["allowImplicitScrolling"], datas, "bool", vars, props);
      final restorationId =
          getValue(maps["restorationId"], datas, "String?", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      final scrollBehavior = getValue(
          maps["scrollBehavior"], datas, "ScrollBehavior?", vars, props);
      final padEnds = getValue(maps["padEnds"], datas, "bool", vars, props);
      if (itemBuilder == null) {
        return null;
      }
      return PageView.builder(
          key: key,
          scrollDirection: scrollDirection ?? Axis.horizontal,
          reverse: reverse ?? false,
          controller: controller,
          physics: physics,
          pageSnapping: pageSnapping ?? true,
          onPageChanged: onPageChanged,
          itemBuilder: itemBuilder!,
          findChildIndexCallback: findChildIndexCallback,
          itemCount: itemCount,
          dragStartBehavior: dragStartBehavior ?? DragStartBehavior.start,
          allowImplicitScrolling: allowImplicitScrolling ?? false,
          restorationId: restorationId,
          clipBehavior: clipBehavior ?? Clip.hardEdge,
          scrollBehavior: scrollBehavior,
          padEnds: padEnds ?? true);
    },
    "PageView.custom": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final scrollDirection =
          getValue(maps["scrollDirection"], datas, "Axis", vars, props);
      final reverse = getValue(maps["reverse"], datas, "bool", vars, props);
      final controller =
          getValue(maps["controller"], datas, "PageController?", vars, props);
      final physics =
          getValue(maps["physics"], datas, "ScrollPhysics?", vars, props);
      final pageSnapping =
          getValue(maps["pageSnapping"], datas, "bool", vars, props);
      final onPageChanged = getValue(
          maps["onPageChanged"], datas, "ValueChanged<int>?", vars, props);
      final childrenDelegate = getValue(
          maps["childrenDelegate"], datas, "SliverChildDelegate", vars, props);
      final dragStartBehavior = getValue(
          maps["dragStartBehavior"], datas, "DragStartBehavior", vars, props);
      final allowImplicitScrolling =
          getValue(maps["allowImplicitScrolling"], datas, "bool", vars, props);
      final restorationId =
          getValue(maps["restorationId"], datas, "String?", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      final scrollBehavior = getValue(
          maps["scrollBehavior"], datas, "ScrollBehavior?", vars, props);
      final padEnds = getValue(maps["padEnds"], datas, "bool", vars, props);
      if (childrenDelegate == null) {
        return null;
      }
      return PageView.custom(
          key: key,
          scrollDirection: scrollDirection ?? Axis.horizontal,
          reverse: reverse ?? false,
          controller: controller,
          physics: physics,
          pageSnapping: pageSnapping ?? true,
          onPageChanged: onPageChanged,
          childrenDelegate: childrenDelegate!,
          dragStartBehavior: dragStartBehavior ?? DragStartBehavior.start,
          allowImplicitScrolling: allowImplicitScrolling ?? false,
          restorationId: restorationId,
          clipBehavior: clipBehavior ?? Clip.hardEdge,
          scrollBehavior: scrollBehavior,
          padEnds: padEnds ?? true);
    },
    "PaginatedDataTable": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final header = getValue(maps["header"], datas, "", vars, props);
      final actions = getValue(maps["actions"], datas, "", vars, props);
      final columns = getValue(maps["columns"], datas, "", vars, props);
      final sortColumnIndex =
          getValue(maps["sortColumnIndex"], datas, "", vars, props);
      final sortAscending =
          getValue(maps["sortAscending"], datas, "", vars, props);
      final onSelectAll = getValue(maps["onSelectAll"], datas, "", vars, props);
      final dataRowHeight =
          getValue(maps["dataRowHeight"], datas, "double?", vars, props);
      final dataRowMinHeight =
          getValue(maps["dataRowMinHeight"], datas, "double?", vars, props);
      final dataRowMaxHeight =
          getValue(maps["dataRowMaxHeight"], datas, "double?", vars, props);
      final headingRowHeight =
          getValue(maps["headingRowHeight"], datas, "", vars, props);
      final horizontalMargin =
          getValue(maps["horizontalMargin"], datas, "", vars, props);
      final columnSpacing =
          getValue(maps["columnSpacing"], datas, "", vars, props);
      final showCheckboxColumn =
          getValue(maps["showCheckboxColumn"], datas, "", vars, props);
      final showFirstLastButtons =
          getValue(maps["showFirstLastButtons"], datas, "", vars, props);
      final initialFirstRowIndex =
          getValue(maps["initialFirstRowIndex"], datas, "", vars, props);
      final onPageChanged =
          getValue(maps["onPageChanged"], datas, "", vars, props);
      final rowsPerPage = getValue(maps["rowsPerPage"], datas, "", vars, props);
      final availableRowsPerPage =
          getValue(maps["availableRowsPerPage"], datas, "", vars, props);
      final onRowsPerPageChanged =
          getValue(maps["onRowsPerPageChanged"], datas, "", vars, props);
      final dragStartBehavior =
          getValue(maps["dragStartBehavior"], datas, "", vars, props);
      final arrowHeadColor =
          getValue(maps["arrowHeadColor"], datas, "", vars, props);
      final source = getValue(maps["source"], datas, "", vars, props);
      final checkboxHorizontalMargin =
          getValue(maps["checkboxHorizontalMargin"], datas, "", vars, props);
      final controller = getValue(maps["controller"], datas, "", vars, props);
      final primary = getValue(maps["primary"], datas, "", vars, props);
      if (columns == null || source == null) {
        return null;
      }
      return PaginatedDataTable(
          key: key,
          header: header,
          actions: actions,
          columns: columns!,
          sortColumnIndex: sortColumnIndex,
          sortAscending: sortAscending ?? true,
          onSelectAll: onSelectAll,
          dataRowHeight: dataRowHeight,
          dataRowMinHeight: dataRowMinHeight,
          dataRowMaxHeight: dataRowMaxHeight,
          headingRowHeight: headingRowHeight ?? 56.0,
          horizontalMargin: horizontalMargin ?? 24.0,
          columnSpacing: columnSpacing ?? 56.0,
          showCheckboxColumn: showCheckboxColumn ?? true,
          showFirstLastButtons: showFirstLastButtons ?? false,
          initialFirstRowIndex: initialFirstRowIndex ?? 0,
          onPageChanged: onPageChanged,
          rowsPerPage: rowsPerPage ?? defaultRowsPerPage,
          availableRowsPerPage: availableRowsPerPage ??
              const <int>[
                defaultRowsPerPage,
                defaultRowsPerPage * 2,
                defaultRowsPerPage * 5,
                defaultRowsPerPage * 10
              ],
          onRowsPerPageChanged: onRowsPerPageChanged,
          dragStartBehavior: dragStartBehavior ?? DragStartBehavior.start,
          arrowHeadColor: arrowHeadColor,
          source: source!,
          checkboxHorizontalMargin: checkboxHorizontalMargin,
          controller: controller,
          primary: primary);
    },
    "Paint": () {
      return Paint();
    },
    "PaintingContext": () {
      final _containerLayer =
          getValue(maps["0"], datas, "ContainerLayer", vars, props);
      final estimatedBounds = getValue(maps["1"], datas, "Rect", vars, props);
      if (_containerLayer == null || estimatedBounds == null) {
        return null;
      }
      return PaintingContext(_containerLayer!, estimatedBounds!);
    },
    "PanGestureRecognizer": () {
      final debugOwner = getValue(maps["debugOwner"], datas, "", vars, props);
      final supportedDevices =
          getValue(maps["supportedDevices"], datas, "", vars, props);
      final allowedButtonsFilter = getValue(maps["allowedButtonsFilter"], datas,
          "AllowedButtonsFilter?", vars, props);
      return PanGestureRecognizer(
          debugOwner: debugOwner,
          supportedDevices: supportedDevices,
          allowedButtonsFilter: allowedButtonsFilter);
    },
    "ParagraphBoundary": () {
      final _text = getValue(maps["0"], datas, "String", vars, props);
      if (_text == null) {
        return null;
      }
      return ParagraphBoundary(_text!);
    },
    "ParagraphBuilder": () {
      final style = getValue(maps["0"], datas, "ParagraphStyle", vars, props);
      if (style == null) {
        return null;
      }
      return ui.ParagraphBuilder(style!);
    },
    "ParagraphConstraints": () {
      final width = getValue(maps["width"], datas, "double", vars, props);
      if (width == null) {
        return null;
      }
      return ui.ParagraphConstraints(width: width!);
    },
    "ParagraphStyle": () {
      final textAlign =
          getValue(maps["textAlign"], datas, "TextAlign?", vars, props);
      final textDirection =
          getValue(maps["textDirection"], datas, "TextDirection?", vars, props);
      final maxLines = getValue(maps["maxLines"], datas, "int?", vars, props);
      final fontFamily =
          getValue(maps["fontFamily"], datas, "String?", vars, props);
      final fontSize =
          getValue(maps["fontSize"], datas, "double?", vars, props);
      final height = getValue(maps["height"], datas, "double?", vars, props);
      final textHeightBehavior = getValue(maps["textHeightBehavior"], datas,
          "TextHeightBehavior?", vars, props);
      final fontWeight =
          getValue(maps["fontWeight"], datas, "FontWeight?", vars, props);
      final fontStyle =
          getValue(maps["fontStyle"], datas, "FontStyle?", vars, props);
      final strutStyle =
          getValue(maps["strutStyle"], datas, "StrutStyle?", vars, props);
      final ellipsis =
          getValue(maps["ellipsis"], datas, "String?", vars, props);
      final locale = getValue(maps["locale"], datas, "Locale?", vars, props);
      return ui.ParagraphStyle(
          textAlign: textAlign,
          textDirection: textDirection,
          maxLines: maxLines,
          fontFamily: fontFamily,
          fontSize: fontSize,
          height: height,
          textHeightBehavior: textHeightBehavior,
          fontWeight: fontWeight,
          fontStyle: fontStyle,
          strutStyle: strutStyle,
          ellipsis: ellipsis,
          locale: locale);
    },
    "PartialStackFrame": () {
      final package = getValue(maps["package"], datas, "Pattern", vars, props);
      final className =
          getValue(maps["className"], datas, "String", vars, props);
      final method = getValue(maps["method"], datas, "String", vars, props);
      if (package == null || className == null || method == null) {
        return null;
      }
      return PartialStackFrame(
          package: package!, className: className!, method: method!);
    },
    "PasteTextIntent": () {
      final cause =
          getValue(maps["0"], datas, "SelectionChangedCause", vars, props);
      if (cause == null) {
        return null;
      }
      return PasteTextIntent(cause!);
    },
    "Path": () {
      return Path();
    },
    "Path.from": () {
      final source = getValue(maps["0"], datas, "Path", vars, props);
      if (source == null) {
        return null;
      }
      return Path.from(source!);
    },
    "PercentProperty": () {
      final name = getValue(maps["0"], datas, "String", vars, props);
      final fraction = getValue(maps["1"], datas, "", vars, props);
      final ifNull = getValue(maps["ifNull"], datas, "String?", vars, props);
      final showName = getValue(maps["showName"], datas, "", vars, props);
      final tooltip = getValue(maps["tooltip"], datas, "String?", vars, props);
      final unit = getValue(maps["unit"], datas, "String?", vars, props);
      final level =
          getValue(maps["level"], datas, "DiagnosticLevel", vars, props);
      if (name == null || fraction == null) {
        return null;
      }
      return PercentProperty(name!, fraction!,
          ifNull: ifNull,
          showName: showName,
          tooltip: tooltip,
          unit: unit,
          level: level ?? DiagnosticLevel.info);
    },
    "PerformanceOverlay": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final optionsMask =
          getValue(maps["optionsMask"], datas, "int", vars, props);
      final rasterizerThreshold =
          getValue(maps["rasterizerThreshold"], datas, "int", vars, props);
      final checkerboardRasterCacheImages = getValue(
          maps["checkerboardRasterCacheImages"], datas, "bool", vars, props);
      final checkerboardOffscreenLayers = getValue(
          maps["checkerboardOffscreenLayers"], datas, "bool", vars, props);
      return PerformanceOverlay(
          key: key,
          optionsMask: optionsMask ?? 0,
          rasterizerThreshold: rasterizerThreshold ?? 0,
          checkerboardRasterCacheImages: checkerboardRasterCacheImages ?? false,
          checkerboardOffscreenLayers: checkerboardOffscreenLayers ?? false);
    },
    "PerformanceOverlay.allEnabled": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final rasterizerThreshold =
          getValue(maps["rasterizerThreshold"], datas, "int", vars, props);
      final checkerboardRasterCacheImages = getValue(
          maps["checkerboardRasterCacheImages"], datas, "bool", vars, props);
      final checkerboardOffscreenLayers = getValue(
          maps["checkerboardOffscreenLayers"], datas, "bool", vars, props);
      return PerformanceOverlay.allEnabled(
          key: key,
          rasterizerThreshold: rasterizerThreshold ?? 0,
          checkerboardRasterCacheImages: checkerboardRasterCacheImages ?? false,
          checkerboardOffscreenLayers: checkerboardOffscreenLayers ?? false);
    },
    "PerformanceOverlayLayer": () {
      final overlayRect =
          getValue(maps["overlayRect"], datas, "Rect", vars, props);
      final optionsMask =
          getValue(maps["optionsMask"], datas, "int", vars, props);
      final rasterizerThreshold =
          getValue(maps["rasterizerThreshold"], datas, "int", vars, props);
      final checkerboardRasterCacheImages = getValue(
          maps["checkerboardRasterCacheImages"], datas, "bool", vars, props);
      final checkerboardOffscreenLayers = getValue(
          maps["checkerboardOffscreenLayers"], datas, "bool", vars, props);
      if (overlayRect == null ||
          optionsMask == null ||
          rasterizerThreshold == null ||
          checkerboardRasterCacheImages == null ||
          checkerboardOffscreenLayers == null) {
        return null;
      }
      return PerformanceOverlayLayer(
          overlayRect: overlayRect!,
          optionsMask: optionsMask!,
          rasterizerThreshold: rasterizerThreshold!,
          checkerboardRasterCacheImages: checkerboardRasterCacheImages!,
          checkerboardOffscreenLayers: checkerboardOffscreenLayers!);
    },
    "PersistentHashMap.empty": () {
      return const PersistentHashMap.empty();
    },
    "PersistentHeaderShowOnScreenConfiguration": () {
      final minShowOnScreenExtent =
          getValue(maps["minShowOnScreenExtent"], datas, "double", vars, props);
      final maxShowOnScreenExtent =
          getValue(maps["maxShowOnScreenExtent"], datas, "double", vars, props);
      return PersistentHeaderShowOnScreenConfiguration(
          minShowOnScreenExtent:
              minShowOnScreenExtent ?? double.negativeInfinity,
          maxShowOnScreenExtent: maxShowOnScreenExtent ?? double.infinity);
    },
    "PhysicalModel": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final shape = getValue(maps["shape"], datas, "BoxShape", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      final borderRadius =
          getValue(maps["borderRadius"], datas, "BorderRadius?", vars, props);
      final elevation =
          getValue(maps["elevation"], datas, "double", vars, props);
      final color = getValue(maps["color"], datas, "Color", vars, props);
      final shadowColor =
          getValue(maps["shadowColor"], datas, "Color", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      if (color == null) {
        return null;
      }
      return PhysicalModel(
          key: key,
          shape: shape ?? BoxShape.rectangle,
          clipBehavior: clipBehavior ?? Clip.none,
          borderRadius: borderRadius,
          elevation: elevation ?? 0.0,
          color: color!,
          shadowColor: shadowColor ?? const Color(0xFF000000),
          child: child);
      // "PhysicalModelLayer": () {
      //   final clipPath = getValue(maps["clipPath"], datas, "Path?", vars, props);
      //   final clipBehavior =
      //       getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      //   final elevation =
      //       getValue(maps["elevation"], datas, "double?", vars, props);
      //   final color = getValue(maps["color"], datas, "Color?", vars, props);
      //   final shadowColor =
      //       getValue(maps["shadowColor"], datas, "Color?", vars, props);
      //   return PhysicalModelLayer(
      //       clipPath: clipPath,
      //       clipBehavior: clipBehavior ?? Clip.none,
      //       elevation: elevation,
      //       color: color,
      //       shadowColor: shadowColor);
    },
    "PhysicalShape": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final clipper =
          getValue(maps["clipper"], datas, "CustomClipper<Path>", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      final elevation =
          getValue(maps["elevation"], datas, "double", vars, props);
      final color = getValue(maps["color"], datas, "Color", vars, props);
      final shadowColor =
          getValue(maps["shadowColor"], datas, "Color", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      if (clipper == null || color == null) {
        return null;
      }
      return PhysicalShape(
          key: key,
          clipper: clipper!,
          clipBehavior: clipBehavior ?? Clip.none,
          elevation: elevation ?? 0.0,
          color: color!,
          shadowColor: shadowColor ?? const Color(0xFF000000),
          child: child);
    },
    "PictureRecorder": () {
      return ui.PictureRecorder();
    },
    "PipelineOwner": () {
      final onNeedVisualUpdate = getValue(
          maps["onNeedVisualUpdate"], datas, "VoidCallback?", vars, props);
      final onSemanticsOwnerCreated = getValue(
          maps["onSemanticsOwnerCreated"], datas, "VoidCallback?", vars, props);
      final onSemanticsUpdate = getValue(maps["onSemanticsUpdate"], datas,
          "SemanticsUpdateCallback?", vars, props);
      final onSemanticsOwnerDisposed = getValue(
          maps["onSemanticsOwnerDisposed"],
          datas,
          "VoidCallback?",
          vars,
          props);
      return PipelineOwner(
          onNeedVisualUpdate: onNeedVisualUpdate,
          onSemanticsOwnerCreated: onSemanticsOwnerCreated,
          onSemanticsUpdate: onSemanticsUpdate,
          onSemanticsOwnerDisposed: onSemanticsOwnerDisposed);
    },
    "Placeholder": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final color = getValue(maps["color"], datas, "Color", vars, props);
      final strokeWidth =
          getValue(maps["strokeWidth"], datas, "double", vars, props);
      final fallbackWidth =
          getValue(maps["fallbackWidth"], datas, "double", vars, props);
      final fallbackHeight =
          getValue(maps["fallbackHeight"], datas, "double", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      return Placeholder(
          key: key,
          color: color ?? const Color(0xFF455A64),
          strokeWidth: strokeWidth ?? 2.0,
          fallbackWidth: fallbackWidth ?? 400.0,
          fallbackHeight: fallbackHeight ?? 400.0,
          child: child);
    },
    "PlaceholderDimensions": () {
      final size = getValue(maps["size"], datas, "Size", vars, props);
      final alignment = getValue(
          maps["alignment"], datas, "PlaceholderAlignment", vars, props);
      final baseline =
          getValue(maps["baseline"], datas, "double?", vars, props);
      final baselineOffset =
          getValue(maps["baselineOffset"], datas, "double?", vars, props);
      if (size == null || alignment == null) {
        return null;
      }
      return PlaceholderDimensions(
          size: size!,
          alignment: alignment!,
          baseline: baseline,
          baselineOffset: baselineOffset);
    },
    "PlaceholderSpanIndexSemanticsTag": () {
      final index = getValue(maps["0"], datas, "int", vars, props);
      if (index == null) {
        return null;
      }
      return PlaceholderSpanIndexSemanticsTag(index!);
    },
    "PlatformException": () {
      final code = getValue(maps["code"], datas, "String", vars, props);
      final message = getValue(maps["message"], datas, "String?", vars, props);
      final details = getValue(maps["details"], datas, "dynamic", vars, props);
      final stacktrace =
          getValue(maps["stacktrace"], datas, "String?", vars, props);
      if (code == null) {
        return null;
      }
      return PlatformException(
          code: code!,
          message: message,
          details: details,
          stacktrace: stacktrace);
    },
    "PlatformMenu": () {
      final label = getValue(maps["label"], datas, "", vars, props);
      final onOpen =
          getValue(maps["onOpen"], datas, "VoidCallback?", vars, props);
      final onClose =
          getValue(maps["onClose"], datas, "VoidCallback?", vars, props);
      final menus =
          getValue(maps["menus"], datas, "List<PlatformMenuItem>", vars, props);
      if (label == null || menus == null) {
        return null;
      }
      return PlatformMenu(
          label: label!,
          onOpen: onOpen,
          onClose: onClose,
          menus: List<PlatformMenuItem>.from(menus!));
    },
    "PlatformMenuBar": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final menus = getValue(maps["menus"], datas, "", vars, props);
      final child = getValue(maps["child"], datas, "", vars, props);
      final body = getValue(maps["body"], datas, "", vars, props);
      if (menus == null) {
        return null;
      }
      return PlatformMenuBar(
        key: key, menus: menus!, child: child,
        //body: body
      );
    },
    "PlatformMenuItem": () {
      final label = getValue(maps["label"], datas, "", vars, props);
      final shortcut = getValue(maps["shortcut"], datas, "", vars, props);
      final onSelected = getValue(maps["onSelected"], datas, "", vars, props);
      final onSelectedIntent =
          getValue(maps["onSelectedIntent"], datas, "", vars, props);
      if (label == null) {
        return null;
      }
      return PlatformMenuItem(
          label: label!,
          shortcut: shortcut,
          onSelected: onSelected,
          onSelectedIntent: onSelectedIntent);
    },
    "PlatformMenuItemGroup": () {
      final members = getValue(
          maps["members"], datas, "List<PlatformMenuItem>", vars, props);
      if (members == null) {
        return null;
      }
      return PlatformMenuItemGroup(
          members: List<PlatformMenuItem>.from(members!));
    },
    "PlatformProvidedMenuItem": () {
      final type = getValue(
          maps["type"], datas, "PlatformProvidedMenuItemType", vars, props);
      final enabled = getValue(maps["enabled"], datas, "bool", vars, props);
      if (type == null) {
        return null;
      }
      return PlatformProvidedMenuItem(type: type!, enabled: enabled ?? true);
    },
    "PlatformRouteInformationProvider": () {
      final initialRouteInformation = getValue(maps["initialRouteInformation"],
          datas, "RouteInformation", vars, props);
      if (initialRouteInformation == null) {
        return null;
      }
      return PlatformRouteInformationProvider(
          initialRouteInformation: initialRouteInformation!);
    },
    "PlatformSelectableRegionContextMenu": () {
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      if (child == null) {
        return null;
      }
      return PlatformSelectableRegionContextMenu(child: child!, key: key);
    },
    "PlatformSelectableRegionContextMenu": () {
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      if (child == null) {
        return null;
      }
      return PlatformSelectableRegionContextMenu(child: child!, key: key);
    },
    "PlatformViewLayer": () {
      final rect = getValue(maps["rect"], datas, "Rect", vars, props);
      final viewId = getValue(maps["viewId"], datas, "int", vars, props);
      if (rect == null || viewId == null) {
        return null;
      }
      return PlatformViewLayer(rect: rect!, viewId: viewId!);
    },
    "PlatformViewLink": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final surfaceFactory = getValue(maps["surfaceFactory"], datas,
          "PlatformViewSurfaceFactory", vars, props);
      final onCreatePlatformView = getValue(maps["onCreatePlatformView"], datas,
          "CreatePlatformViewCallback", vars, props);
      final viewType = getValue(maps["viewType"], datas, "String", vars, props);
      if (surfaceFactory == null ||
          onCreatePlatformView == null ||
          viewType == null) {
        return null;
      }
      return PlatformViewLink(
          key: key,
          surfaceFactory: surfaceFactory!,
          onCreatePlatformView: onCreatePlatformView!,
          viewType: viewType!);
    },
    "PlatformViewRenderBox": () {
      final controller = getValue(
          maps["controller"], datas, "PlatformViewController", vars, props);
      final hitTestBehavior = getValue(maps["hitTestBehavior"], datas,
          "PlatformViewHitTestBehavior", vars, props);
      final gestureRecognizers = getValue(maps["gestureRecognizers"], datas,
          "Set<Factory<OneSequenceGestureRecognizer>>", vars, props);
      if (controller == null ||
          hitTestBehavior == null ||
          gestureRecognizers == null) {
        return null;
      }
      return PlatformViewRenderBox(
          controller: controller!,
          hitTestBehavior: hitTestBehavior!,
          gestureRecognizers: Set<Factory<OneSequenceGestureRecognizer>>.from(
              gestureRecognizers!));
    },
    "PlatformViewSurface": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final controller = getValue(
          maps["controller"], datas, "PlatformViewController", vars, props);
      final hitTestBehavior = getValue(maps["hitTestBehavior"], datas,
          "PlatformViewHitTestBehavior", vars, props);
      final gestureRecognizers = getValue(maps["gestureRecognizers"], datas,
          "Set<Factory<OneSequenceGestureRecognizer>>", vars, props);
      if (controller == null ||
          hitTestBehavior == null ||
          gestureRecognizers == null) {
        return null;
      }
      return PlatformViewSurface(
          key: key,
          controller: controller!,
          hitTestBehavior: hitTestBehavior!,
          gestureRecognizers: Set<Factory<OneSequenceGestureRecognizer>>.from(
              gestureRecognizers!));
    },
    "PointerAddedEvent": () {
      final timeStamp =
          getValue(maps["timeStamp"], datas, "Duration", vars, props);
      final pointer = getValue(maps["pointer"], datas, "int", vars, props);
      final kind =
          getValue(maps["kind"], datas, "PointerDeviceKind", vars, props);
      final device = getValue(maps["device"], datas, "int", vars, props);
      final position = getValue(maps["position"], datas, "Offset", vars, props);
      final obscured = getValue(maps["obscured"], datas, "bool", vars, props);
      final pressureMin =
          getValue(maps["pressureMin"], datas, "double", vars, props);
      final pressureMax =
          getValue(maps["pressureMax"], datas, "double", vars, props);
      final distance = getValue(maps["distance"], datas, "double", vars, props);
      final distanceMax =
          getValue(maps["distanceMax"], datas, "double", vars, props);
      final radiusMin =
          getValue(maps["radiusMin"], datas, "double", vars, props);
      final radiusMax =
          getValue(maps["radiusMax"], datas, "double", vars, props);
      final orientation =
          getValue(maps["orientation"], datas, "double", vars, props);
      final tilt = getValue(maps["tilt"], datas, "double", vars, props);
      final embedderId =
          getValue(maps["embedderId"], datas, "int", vars, props);
      return PointerAddedEvent(
          timeStamp: timeStamp ?? Duration.zero,
          pointer: pointer ?? 0,
          kind: kind ?? PointerDeviceKind.touch,
          device: device ?? 0,
          position: position ?? Offset.zero,
          obscured: obscured ?? false,
          pressureMin: pressureMin ?? 1.0,
          pressureMax: pressureMax ?? 1.0,
          distance: distance ?? 0.0,
          distanceMax: distanceMax ?? 0.0,
          radiusMin: radiusMin ?? 0.0,
          radiusMax: radiusMax ?? 0.0,
          orientation: orientation ?? 0.0,
          tilt: tilt ?? 0.0,
          embedderId: embedderId ?? 0);
    },
    "PointerCancelEvent": () {
      final timeStamp =
          getValue(maps["timeStamp"], datas, "Duration", vars, props);
      final pointer = getValue(maps["pointer"], datas, "int", vars, props);
      final kind =
          getValue(maps["kind"], datas, "PointerDeviceKind", vars, props);
      final device = getValue(maps["device"], datas, "int", vars, props);
      final position = getValue(maps["position"], datas, "Offset", vars, props);
      final buttons = getValue(maps["buttons"], datas, "int", vars, props);
      final obscured = getValue(maps["obscured"], datas, "bool", vars, props);
      final pressureMin =
          getValue(maps["pressureMin"], datas, "double", vars, props);
      final pressureMax =
          getValue(maps["pressureMax"], datas, "double", vars, props);
      final distance = getValue(maps["distance"], datas, "double", vars, props);
      final distanceMax =
          getValue(maps["distanceMax"], datas, "double", vars, props);
      final size = getValue(maps["size"], datas, "double", vars, props);
      final radiusMajor =
          getValue(maps["radiusMajor"], datas, "double", vars, props);
      final radiusMinor =
          getValue(maps["radiusMinor"], datas, "double", vars, props);
      final radiusMin =
          getValue(maps["radiusMin"], datas, "double", vars, props);
      final radiusMax =
          getValue(maps["radiusMax"], datas, "double", vars, props);
      final orientation =
          getValue(maps["orientation"], datas, "double", vars, props);
      final tilt = getValue(maps["tilt"], datas, "double", vars, props);
      final embedderId =
          getValue(maps["embedderId"], datas, "int", vars, props);
      return PointerCancelEvent(
          timeStamp: timeStamp ?? Duration.zero,
          pointer: pointer ?? 0,
          kind: kind ?? PointerDeviceKind.touch,
          device: device ?? 0,
          position: position ?? Offset.zero,
          buttons: buttons ?? 0,
          obscured: obscured ?? false,
          pressureMin: pressureMin ?? 1.0,
          pressureMax: pressureMax ?? 1.0,
          distance: distance ?? 0.0,
          distanceMax: distanceMax ?? 0.0,
          size: size ?? 0.0,
          radiusMajor: radiusMajor ?? 0.0,
          radiusMinor: radiusMinor ?? 0.0,
          radiusMin: radiusMin ?? 0.0,
          radiusMax: radiusMax ?? 0.0,
          orientation: orientation ?? 0.0,
          tilt: tilt ?? 0.0,
          embedderId: embedderId ?? 0);
    },
    "PointerData": () {
      final embedderId =
          getValue(maps["embedderId"], datas, "int", vars, props);
      final timeStamp =
          getValue(maps["timeStamp"], datas, "Duration", vars, props);
      final change =
          getValue(maps["change"], datas, "PointerChange", vars, props);
      final kind =
          getValue(maps["kind"], datas, "PointerDeviceKind", vars, props);
      final signalKind = getValue(
          maps["signalKind"], datas, "PointerSignalKind?", vars, props);
      final device = getValue(maps["device"], datas, "int", vars, props);
      final pointerIdentifier =
          getValue(maps["pointerIdentifier"], datas, "int", vars, props);
      final physicalX =
          getValue(maps["physicalX"], datas, "double", vars, props);
      final physicalY =
          getValue(maps["physicalY"], datas, "double", vars, props);
      final physicalDeltaX =
          getValue(maps["physicalDeltaX"], datas, "double", vars, props);
      final physicalDeltaY =
          getValue(maps["physicalDeltaY"], datas, "double", vars, props);
      final buttons = getValue(maps["buttons"], datas, "int", vars, props);
      final obscured = getValue(maps["obscured"], datas, "bool", vars, props);
      final synthesized =
          getValue(maps["synthesized"], datas, "bool", vars, props);
      final pressure = getValue(maps["pressure"], datas, "double", vars, props);
      final pressureMin =
          getValue(maps["pressureMin"], datas, "double", vars, props);
      final pressureMax =
          getValue(maps["pressureMax"], datas, "double", vars, props);
      final distance = getValue(maps["distance"], datas, "double", vars, props);
      final distanceMax =
          getValue(maps["distanceMax"], datas, "double", vars, props);
      final size = getValue(maps["size"], datas, "bool", vars, props);
      final radiusMajor =
          getValue(maps["radiusMajor"], datas, "double", vars, props);
      final radiusMinor =
          getValue(maps["radiusMinor"], datas, "double", vars, props);
      final radiusMin =
          getValue(maps["radiusMin"], datas, "double", vars, props);
      final radiusMax =
          getValue(maps["radiusMax"], datas, "double", vars, props);
      final orientation =
          getValue(maps["orientation"], datas, "double", vars, props);
      final tilt = getValue(maps["tilt"], datas, "double", vars, props);
      final platformData =
          getValue(maps["platformData"], datas, "int", vars, props);
      final scrollDeltaX =
          getValue(maps["scrollDeltaX"], datas, "double", vars, props);
      final scrollDeltaY =
          getValue(maps["scrollDeltaY"], datas, "double", vars, props);
      final panX = getValue(maps["panX"], datas, "double", vars, props);
      final panY = getValue(maps["panY"], datas, "double", vars, props);
      final panDeltaX =
          getValue(maps["panDeltaX"], datas, "double", vars, props);
      final panDeltaY =
          getValue(maps["panDeltaY"], datas, "double", vars, props);
      final scale = getValue(maps["scale"], datas, "double", vars, props);
      final rotation = getValue(maps["rotation"], datas, "double", vars, props);
      final preferredStylusAuxiliaryAction = getValue(
          maps["preferredStylusAuxiliaryAction"],
          datas,
          "PointerPreferredStylusAuxiliaryAction",
          vars,
          props);
      return PointerData(
        embedderId: embedderId ?? 0,
        timeStamp: timeStamp ?? Duration.zero,
        change: change ?? ui.PointerChange.cancel,
        kind: kind ?? PointerDeviceKind.touch,
        signalKind: signalKind,
        device: device ?? 0,
        pointerIdentifier: pointerIdentifier ?? 0,
        physicalX: physicalX ?? 0.0,
        physicalY: physicalY ?? 0.0,
        physicalDeltaX: physicalDeltaX ?? 0.0,
        physicalDeltaY: physicalDeltaY ?? 0.0,
        buttons: buttons ?? 0,
        obscured: obscured ?? false,
        synthesized: synthesized ?? false,
        pressure: pressure ?? 0.0,
        pressureMin: pressureMin ?? 0.0,
        pressureMax: pressureMax ?? 0.0,
        distance: distance ?? 0.0,
        distanceMax: distanceMax ?? 0.0,
        size: size ?? 0.0,
        radiusMajor: radiusMajor ?? 0.0,
        radiusMinor: radiusMinor ?? 0.0,
        radiusMin: radiusMin ?? 0.0,
        radiusMax: radiusMax ?? 0.0,
        orientation: orientation ?? 0.0,
        tilt: tilt ?? 0.0,
        platformData: platformData ?? 0,
        scrollDeltaX: scrollDeltaX ?? 0.0,
        scrollDeltaY: scrollDeltaY ?? 0.0,
        panX: panX ?? 0.0,
        panY: panY ?? 0.0,
        panDeltaX: panDeltaX ?? 0.0,
        panDeltaY: panDeltaY ?? 0.0,
        scale: scale ?? 0.0,
        rotation: rotation ?? 0.0,
        // preferredStylusAuxiliaryAction: preferredStylusAuxiliaryAction ??
        //     ui.PointerPreferredStylusAuxiliaryAction.ignore,
      );
    },
    "PointerDataPacket": () {
      final data =
          getValue(maps["data"], datas, "List<PointerData>", vars, props);
      return ui.PointerDataPacket(
          data: List<PointerData>.from(data ?? const <PointerData>[]));
    },
    "PointerDownEvent": () {
      final timeStamp =
          getValue(maps["timeStamp"], datas, "Duration", vars, props);
      final pointer = getValue(maps["pointer"], datas, "int", vars, props);
      final kind =
          getValue(maps["kind"], datas, "PointerDeviceKind", vars, props);
      final device = getValue(maps["device"], datas, "int", vars, props);
      final position = getValue(maps["position"], datas, "Offset", vars, props);
      final buttons = getValue(maps["buttons"], datas, "int", vars, props);
      final obscured = getValue(maps["obscured"], datas, "bool", vars, props);
      final pressure = getValue(maps["pressure"], datas, "double", vars, props);
      final pressureMin =
          getValue(maps["pressureMin"], datas, "double", vars, props);
      final pressureMax =
          getValue(maps["pressureMax"], datas, "double", vars, props);
      final distanceMax =
          getValue(maps["distanceMax"], datas, "double", vars, props);
      final size = getValue(maps["size"], datas, "double", vars, props);
      final radiusMajor =
          getValue(maps["radiusMajor"], datas, "double", vars, props);
      final radiusMinor =
          getValue(maps["radiusMinor"], datas, "double", vars, props);
      final radiusMin =
          getValue(maps["radiusMin"], datas, "double", vars, props);
      final radiusMax =
          getValue(maps["radiusMax"], datas, "double", vars, props);
      final orientation =
          getValue(maps["orientation"], datas, "double", vars, props);
      final tilt = getValue(maps["tilt"], datas, "double", vars, props);
      final embedderId =
          getValue(maps["embedderId"], datas, "int", vars, props);
      if (buttons != null) {
        return PointerDownEvent(
            timeStamp: timeStamp ?? Duration.zero,
            pointer: pointer ?? 0,
            kind: kind ?? PointerDeviceKind.touch,
            device: device ?? 0,
            position: position ?? Offset.zero,
            obscured: obscured ?? false,
            pressure: pressure ?? 1.0,
            pressureMin: pressureMin ?? 1.0,
            pressureMax: pressureMax ?? 1.0,
            distanceMax: distanceMax ?? 0.0,
            size: size ?? 0.0,
            radiusMajor: radiusMajor ?? 0.0,
            radiusMinor: radiusMinor ?? 0.0,
            radiusMin: radiusMin ?? 0.0,
            radiusMax: radiusMax ?? 0.0,
            orientation: orientation ?? 0.0,
            tilt: tilt ?? 0.0,
            embedderId: embedderId ?? 0,
            buttons: buttons);
      }
      return PointerDownEvent(
          timeStamp: timeStamp ?? Duration.zero,
          pointer: pointer ?? 0,
          kind: kind ?? PointerDeviceKind.touch,
          device: device ?? 0,
          position: position ?? Offset.zero,
          obscured: obscured ?? false,
          pressure: pressure ?? 1.0,
          pressureMin: pressureMin ?? 1.0,
          pressureMax: pressureMax ?? 1.0,
          distanceMax: distanceMax ?? 0.0,
          size: size ?? 0.0,
          radiusMajor: radiusMajor ?? 0.0,
          radiusMinor: radiusMinor ?? 0.0,
          radiusMin: radiusMin ?? 0.0,
          radiusMax: radiusMax ?? 0.0,
          orientation: orientation ?? 0.0,
          tilt: tilt ?? 0.0,
          embedderId: embedderId ?? 0);
    },
    "PointerEnterEvent": () {
      final timeStamp =
          getValue(maps["timeStamp"], datas, "Duration", vars, props);
      final pointer = getValue(maps["pointer"], datas, "int", vars, props);
      final kind =
          getValue(maps["kind"], datas, "PointerDeviceKind", vars, props);
      final device = getValue(maps["device"], datas, "int", vars, props);
      final position = getValue(maps["position"], datas, "Offset", vars, props);
      final delta = getValue(maps["delta"], datas, "Offset", vars, props);
      final buttons = getValue(maps["buttons"], datas, "int", vars, props);
      final obscured = getValue(maps["obscured"], datas, "bool", vars, props);
      final pressureMin =
          getValue(maps["pressureMin"], datas, "double", vars, props);
      final pressureMax =
          getValue(maps["pressureMax"], datas, "double", vars, props);
      final distance = getValue(maps["distance"], datas, "double", vars, props);
      final distanceMax =
          getValue(maps["distanceMax"], datas, "double", vars, props);
      final size = getValue(maps["size"], datas, "double", vars, props);
      final radiusMajor =
          getValue(maps["radiusMajor"], datas, "double", vars, props);
      final radiusMinor =
          getValue(maps["radiusMinor"], datas, "double", vars, props);
      final radiusMin =
          getValue(maps["radiusMin"], datas, "double", vars, props);
      final radiusMax =
          getValue(maps["radiusMax"], datas, "double", vars, props);
      final orientation =
          getValue(maps["orientation"], datas, "double", vars, props);
      final tilt = getValue(maps["tilt"], datas, "double", vars, props);
      final down = getValue(maps["down"], datas, "bool", vars, props);
      final synthesized =
          getValue(maps["synthesized"], datas, "bool", vars, props);
      final embedderId =
          getValue(maps["embedderId"], datas, "int", vars, props);
      return PointerEnterEvent(
          timeStamp: timeStamp ?? Duration.zero,
          pointer: pointer ?? 0,
          kind: kind ?? PointerDeviceKind.touch,
          device: device ?? 0,
          position: position ?? Offset.zero,
          delta: delta ?? Offset.zero,
          buttons: buttons ?? 0,
          obscured: obscured ?? false,
          pressureMin: pressureMin ?? 1.0,
          pressureMax: pressureMax ?? 1.0,
          distance: distance ?? 0.0,
          distanceMax: distanceMax ?? 0.0,
          size: size ?? 0.0,
          radiusMajor: radiusMajor ?? 0.0,
          radiusMinor: radiusMinor ?? 0.0,
          radiusMin: radiusMin ?? 0.0,
          radiusMax: radiusMax ?? 0.0,
          orientation: orientation ?? 0.0,
          tilt: tilt ?? 0.0,
          down: down ?? false,
          synthesized: synthesized ?? false,
          embedderId: embedderId ?? 0);
    },
    "PointerEnterEvent.fromMouseEvent": () {
      final event = getValue(maps["0"], datas, "PointerEvent", vars, props);
      if (event == null) {
        return null;
      }
      return PointerEnterEvent.fromMouseEvent(event!);
    },
    "PointerExitEvent": () {
      final timeStamp =
          getValue(maps["timeStamp"], datas, "Duration", vars, props);
      final kind =
          getValue(maps["kind"], datas, "PointerDeviceKind", vars, props);
      final pointer = getValue(maps["pointer"], datas, "int", vars, props);
      final device = getValue(maps["device"], datas, "int", vars, props);
      final position = getValue(maps["position"], datas, "Offset", vars, props);
      final delta = getValue(maps["delta"], datas, "Offset", vars, props);
      final buttons = getValue(maps["buttons"], datas, "int", vars, props);
      final obscured = getValue(maps["obscured"], datas, "bool", vars, props);
      final pressureMin =
          getValue(maps["pressureMin"], datas, "double", vars, props);
      final pressureMax =
          getValue(maps["pressureMax"], datas, "double", vars, props);
      final distance = getValue(maps["distance"], datas, "double", vars, props);
      final distanceMax =
          getValue(maps["distanceMax"], datas, "double", vars, props);
      final size = getValue(maps["size"], datas, "double", vars, props);
      final radiusMajor =
          getValue(maps["radiusMajor"], datas, "double", vars, props);
      final radiusMinor =
          getValue(maps["radiusMinor"], datas, "double", vars, props);
      final radiusMin =
          getValue(maps["radiusMin"], datas, "double", vars, props);
      final radiusMax =
          getValue(maps["radiusMax"], datas, "double", vars, props);
      final orientation =
          getValue(maps["orientation"], datas, "double", vars, props);
      final tilt = getValue(maps["tilt"], datas, "double", vars, props);
      final down = getValue(maps["down"], datas, "bool", vars, props);
      final synthesized =
          getValue(maps["synthesized"], datas, "bool", vars, props);
      final embedderId =
          getValue(maps["embedderId"], datas, "int", vars, props);
      return PointerExitEvent(
          timeStamp: timeStamp ?? Duration.zero,
          kind: kind ?? PointerDeviceKind.touch,
          pointer: pointer ?? 0,
          device: device ?? 0,
          position: position ?? Offset.zero,
          delta: delta ?? Offset.zero,
          buttons: buttons ?? 0,
          obscured: obscured ?? false,
          pressureMin: pressureMin ?? 1.0,
          pressureMax: pressureMax ?? 1.0,
          distance: distance ?? 0.0,
          distanceMax: distanceMax ?? 0.0,
          size: size ?? 0.0,
          radiusMajor: radiusMajor ?? 0.0,
          radiusMinor: radiusMinor ?? 0.0,
          radiusMin: radiusMin ?? 0.0,
          radiusMax: radiusMax ?? 0.0,
          orientation: orientation ?? 0.0,
          tilt: tilt ?? 0.0,
          down: down ?? false,
          synthesized: synthesized ?? false,
          embedderId: embedderId ?? 0);
    },
    "PointerExitEvent.fromMouseEvent": () {
      final event = getValue(maps["0"], datas, "PointerEvent", vars, props);
      if (event == null) {
        return null;
      }
      return PointerExitEvent.fromMouseEvent(event!);
    },
    "PointerHoverEvent": () {
      final timeStamp =
          getValue(maps["timeStamp"], datas, "Duration", vars, props);
      final kind =
          getValue(maps["kind"], datas, "PointerDeviceKind", vars, props);
      final pointer = getValue(maps["pointer"], datas, "int", vars, props);
      final device = getValue(maps["device"], datas, "int", vars, props);
      final position = getValue(maps["position"], datas, "Offset", vars, props);
      final delta = getValue(maps["delta"], datas, "Offset", vars, props);
      final buttons = getValue(maps["buttons"], datas, "int", vars, props);
      final obscured = getValue(maps["obscured"], datas, "bool", vars, props);
      final pressureMin =
          getValue(maps["pressureMin"], datas, "double", vars, props);
      final pressureMax =
          getValue(maps["pressureMax"], datas, "double", vars, props);
      final distance = getValue(maps["distance"], datas, "double", vars, props);
      final distanceMax =
          getValue(maps["distanceMax"], datas, "double", vars, props);
      final size = getValue(maps["size"], datas, "double", vars, props);
      final radiusMajor =
          getValue(maps["radiusMajor"], datas, "double", vars, props);
      final radiusMinor =
          getValue(maps["radiusMinor"], datas, "double", vars, props);
      final radiusMin =
          getValue(maps["radiusMin"], datas, "double", vars, props);
      final radiusMax =
          getValue(maps["radiusMax"], datas, "double", vars, props);
      final orientation =
          getValue(maps["orientation"], datas, "double", vars, props);
      final tilt = getValue(maps["tilt"], datas, "double", vars, props);
      final synthesized =
          getValue(maps["synthesized"], datas, "bool", vars, props);
      final embedderId =
          getValue(maps["embedderId"], datas, "int", vars, props);
      return PointerHoverEvent(
          timeStamp: timeStamp ?? Duration.zero,
          kind: kind ?? PointerDeviceKind.touch,
          pointer: pointer ?? 0,
          device: device ?? 0,
          position: position ?? Offset.zero,
          delta: delta ?? Offset.zero,
          buttons: buttons ?? 0,
          obscured: obscured ?? false,
          pressureMin: pressureMin ?? 1.0,
          pressureMax: pressureMax ?? 1.0,
          distance: distance ?? 0.0,
          distanceMax: distanceMax ?? 0.0,
          size: size ?? 0.0,
          radiusMajor: radiusMajor ?? 0.0,
          radiusMinor: radiusMinor ?? 0.0,
          radiusMin: radiusMin ?? 0.0,
          radiusMax: radiusMax ?? 0.0,
          orientation: orientation ?? 0.0,
          tilt: tilt ?? 0.0,
          synthesized: synthesized ?? false,
          embedderId: embedderId ?? 0);
    },
    "PointerMoveEvent": () {
      final timeStamp =
          getValue(maps["timeStamp"], datas, "Duration", vars, props);
      final pointer = getValue(maps["pointer"], datas, "int", vars, props);
      final kind =
          getValue(maps["kind"], datas, "PointerDeviceKind", vars, props);
      final device = getValue(maps["device"], datas, "int", vars, props);
      final position = getValue(maps["position"], datas, "Offset", vars, props);
      final delta = getValue(maps["delta"], datas, "Offset", vars, props);
      final buttons = getValue(maps["buttons"], datas, "int", vars, props);
      final obscured = getValue(maps["obscured"], datas, "bool", vars, props);
      final pressure = getValue(maps["pressure"], datas, "double", vars, props);
      final pressureMin =
          getValue(maps["pressureMin"], datas, "double", vars, props);
      final pressureMax =
          getValue(maps["pressureMax"], datas, "double", vars, props);
      final distanceMax =
          getValue(maps["distanceMax"], datas, "double", vars, props);
      final size = getValue(maps["size"], datas, "double", vars, props);
      final radiusMajor =
          getValue(maps["radiusMajor"], datas, "double", vars, props);
      final radiusMinor =
          getValue(maps["radiusMinor"], datas, "double", vars, props);
      final radiusMin =
          getValue(maps["radiusMin"], datas, "double", vars, props);
      final radiusMax =
          getValue(maps["radiusMax"], datas, "double", vars, props);
      final orientation =
          getValue(maps["orientation"], datas, "double", vars, props);
      final tilt = getValue(maps["tilt"], datas, "double", vars, props);
      final platformData =
          getValue(maps["platformData"], datas, "int", vars, props);
      final synthesized =
          getValue(maps["synthesized"], datas, "bool", vars, props);
      final embedderId =
          getValue(maps["embedderId"], datas, "int", vars, props);
      if (buttons != null) {
        return PointerMoveEvent(
            timeStamp: timeStamp ?? Duration.zero,
            pointer: pointer ?? 0,
            kind: kind ?? PointerDeviceKind.touch,
            device: device ?? 0,
            position: position ?? Offset.zero,
            delta: delta ?? Offset.zero,
            obscured: obscured ?? false,
            pressure: pressure ?? 1.0,
            pressureMin: pressureMin ?? 1.0,
            pressureMax: pressureMax ?? 1.0,
            distanceMax: distanceMax ?? 0.0,
            size: size ?? 0.0,
            radiusMajor: radiusMajor ?? 0.0,
            radiusMinor: radiusMinor ?? 0.0,
            radiusMin: radiusMin ?? 0.0,
            radiusMax: radiusMax ?? 0.0,
            orientation: orientation ?? 0.0,
            tilt: tilt ?? 0.0,
            platformData: platformData ?? 0,
            synthesized: synthesized ?? false,
            embedderId: embedderId ?? 0,
            buttons: buttons);
      }
      return PointerMoveEvent(
          timeStamp: timeStamp ?? Duration.zero,
          pointer: pointer ?? 0,
          kind: kind ?? PointerDeviceKind.touch,
          device: device ?? 0,
          position: position ?? Offset.zero,
          delta: delta ?? Offset.zero,
          obscured: obscured ?? false,
          pressure: pressure ?? 1.0,
          pressureMin: pressureMin ?? 1.0,
          pressureMax: pressureMax ?? 1.0,
          distanceMax: distanceMax ?? 0.0,
          size: size ?? 0.0,
          radiusMajor: radiusMajor ?? 0.0,
          radiusMinor: radiusMinor ?? 0.0,
          radiusMin: radiusMin ?? 0.0,
          radiusMax: radiusMax ?? 0.0,
          orientation: orientation ?? 0.0,
          tilt: tilt ?? 0.0,
          platformData: platformData ?? 0,
          synthesized: synthesized ?? false,
          embedderId: embedderId ?? 0);
    },
    "PointerPanZoomEndEvent": () {
      final timeStamp =
          getValue(maps["timeStamp"], datas, "Duration", vars, props);
      final device = getValue(maps["device"], datas, "int", vars, props);
      final pointer = getValue(maps["pointer"], datas, "int", vars, props);
      final position = getValue(maps["position"], datas, "Offset", vars, props);
      final embedderId =
          getValue(maps["embedderId"], datas, "int", vars, props);
      final synthesized =
          getValue(maps["synthesized"], datas, "bool", vars, props);
      return PointerPanZoomEndEvent(
          timeStamp: timeStamp ?? Duration.zero,
          device: device ?? 0,
          pointer: pointer ?? 0,
          position: position ?? Offset.zero,
          embedderId: embedderId ?? 0,
          synthesized: synthesized ?? false);
    },
    "PointerPanZoomStartEvent": () {
      final timeStamp =
          getValue(maps["timeStamp"], datas, "Duration", vars, props);
      final device = getValue(maps["device"], datas, "int", vars, props);
      final pointer = getValue(maps["pointer"], datas, "int", vars, props);
      final position = getValue(maps["position"], datas, "Offset", vars, props);
      final embedderId =
          getValue(maps["embedderId"], datas, "int", vars, props);
      final synthesized =
          getValue(maps["synthesized"], datas, "bool", vars, props);
      return PointerPanZoomStartEvent(
          timeStamp: timeStamp ?? Duration.zero,
          device: device ?? 0,
          pointer: pointer ?? 0,
          position: position ?? Offset.zero,
          embedderId: embedderId ?? 0,
          synthesized: synthesized ?? false);
    },
    "PointerPanZoomUpdateEvent": () {
      final timeStamp =
          getValue(maps["timeStamp"], datas, "Duration", vars, props);
      final device = getValue(maps["device"], datas, "int", vars, props);
      final pointer = getValue(maps["pointer"], datas, "int", vars, props);
      final position = getValue(maps["position"], datas, "Offset", vars, props);
      final embedderId =
          getValue(maps["embedderId"], datas, "int", vars, props);
      final pan = getValue(maps["pan"], datas, "Offset", vars, props);
      final panDelta = getValue(maps["panDelta"], datas, "Offset", vars, props);
      final scale = getValue(maps["scale"], datas, "double", vars, props);
      final rotation = getValue(maps["rotation"], datas, "double", vars, props);
      final synthesized =
          getValue(maps["synthesized"], datas, "bool", vars, props);
      return PointerPanZoomUpdateEvent(
          timeStamp: timeStamp ?? Duration.zero,
          device: device ?? 0,
          pointer: pointer ?? 0,
          position: position ?? Offset.zero,
          embedderId: embedderId ?? 0,
          pan: pan ?? Offset.zero,
          panDelta: panDelta ?? Offset.zero,
          scale: scale ?? 1.0,
          rotation: rotation ?? 0.0,
          synthesized: synthesized ?? false);
    },
    "PointerRemovedEvent": () {
      final timeStamp =
          getValue(maps["timeStamp"], datas, "Duration", vars, props);
      final pointer = getValue(maps["pointer"], datas, "int", vars, props);
      final kind =
          getValue(maps["kind"], datas, "PointerDeviceKind", vars, props);
      final device = getValue(maps["device"], datas, "int", vars, props);
      final position = getValue(maps["position"], datas, "Offset", vars, props);
      final obscured = getValue(maps["obscured"], datas, "bool", vars, props);
      final pressureMin =
          getValue(maps["pressureMin"], datas, "double", vars, props);
      final pressureMax =
          getValue(maps["pressureMax"], datas, "double", vars, props);
      final distanceMax =
          getValue(maps["distanceMax"], datas, "double", vars, props);
      final radiusMin =
          getValue(maps["radiusMin"], datas, "double", vars, props);
      final radiusMax =
          getValue(maps["radiusMax"], datas, "double", vars, props);
      final original = getValue(
          maps["original"], datas, "PointerRemovedEvent?", vars, props);
      final embedderId =
          getValue(maps["embedderId"], datas, "int", vars, props);
      return PointerRemovedEvent(
          timeStamp: timeStamp ?? Duration.zero,
          pointer: pointer ?? 0,
          kind: kind ?? PointerDeviceKind.touch,
          device: device ?? 0,
          position: position ?? Offset.zero,
          obscured: obscured ?? false,
          pressureMin: pressureMin ?? 1.0,
          pressureMax: pressureMax ?? 1.0,
          distanceMax: distanceMax ?? 0.0,
          radiusMin: radiusMin ?? 0.0,
          radiusMax: radiusMax ?? 0.0,
          original: original,
          embedderId: embedderId ?? 0);
    },
    "PointerScaleEvent": () {
      final timeStamp =
          getValue(maps["timeStamp"], datas, "Duration", vars, props);
      final kind =
          getValue(maps["kind"], datas, "PointerDeviceKind", vars, props);
      final device = getValue(maps["device"], datas, "int", vars, props);
      final position = getValue(maps["position"], datas, "Offset", vars, props);
      final embedderId =
          getValue(maps["embedderId"], datas, "int", vars, props);
      final scale = getValue(maps["scale"], datas, "double", vars, props);
      return PointerScaleEvent(
          timeStamp: timeStamp ?? Duration.zero,
          kind: kind ?? PointerDeviceKind.mouse,
          device: device ?? 0,
          position: position ?? Offset.zero,
          embedderId: embedderId ?? 0,
          scale: scale ?? 1.0);
    },
    "PointerScrollEvent": () {
      final timeStamp =
          getValue(maps["timeStamp"], datas, "Duration", vars, props);
      final kind =
          getValue(maps["kind"], datas, "PointerDeviceKind", vars, props);
      final device = getValue(maps["device"], datas, "int", vars, props);
      final position = getValue(maps["position"], datas, "Offset", vars, props);
      final scrollDelta =
          getValue(maps["scrollDelta"], datas, "Offset", vars, props);
      final embedderId =
          getValue(maps["embedderId"], datas, "int", vars, props);
      return PointerScrollEvent(
          timeStamp: timeStamp ?? Duration.zero,
          kind: kind ?? PointerDeviceKind.mouse,
          device: device ?? 0,
          position: position ?? Offset.zero,
          scrollDelta: scrollDelta ?? Offset.zero,
          embedderId: embedderId ?? 0);
    },
    "PointerScrollInertiaCancelEvent": () {
      final timeStamp =
          getValue(maps["timeStamp"], datas, "Duration", vars, props);
      final kind =
          getValue(maps["kind"], datas, "PointerDeviceKind", vars, props);
      final device = getValue(maps["device"], datas, "int", vars, props);
      final position = getValue(maps["position"], datas, "Offset", vars, props);
      final embedderId =
          getValue(maps["embedderId"], datas, "int", vars, props);
      return PointerScrollInertiaCancelEvent(
          timeStamp: timeStamp ?? Duration.zero,
          kind: kind ?? PointerDeviceKind.mouse,
          device: device ?? 0,
          position: position ?? Offset.zero,
          embedderId: embedderId ?? 0);
    },
    "PointerUpEvent": () {
      final timeStamp =
          getValue(maps["timeStamp"], datas, "Duration", vars, props);
      final pointer = getValue(maps["pointer"], datas, "int", vars, props);
      final kind =
          getValue(maps["kind"], datas, "PointerDeviceKind", vars, props);
      final device = getValue(maps["device"], datas, "int", vars, props);
      final position = getValue(maps["position"], datas, "Offset", vars, props);
      final buttons = getValue(maps["buttons"], datas, "int", vars, props);
      final obscured = getValue(maps["obscured"], datas, "bool", vars, props);
      final pressure = getValue(maps["pressure"], datas, "double", vars, props);
      final pressureMin =
          getValue(maps["pressureMin"], datas, "double", vars, props);
      final pressureMax =
          getValue(maps["pressureMax"], datas, "double", vars, props);
      final distance = getValue(maps["distance"], datas, "double", vars, props);
      final distanceMax =
          getValue(maps["distanceMax"], datas, "double", vars, props);
      final size = getValue(maps["size"], datas, "double", vars, props);
      final radiusMajor =
          getValue(maps["radiusMajor"], datas, "double", vars, props);
      final radiusMinor =
          getValue(maps["radiusMinor"], datas, "double", vars, props);
      final radiusMin =
          getValue(maps["radiusMin"], datas, "double", vars, props);
      final radiusMax =
          getValue(maps["radiusMax"], datas, "double", vars, props);
      final orientation =
          getValue(maps["orientation"], datas, "double", vars, props);
      final tilt = getValue(maps["tilt"], datas, "double", vars, props);
      final embedderId =
          getValue(maps["embedderId"], datas, "int", vars, props);
      return PointerUpEvent(
          timeStamp: timeStamp ?? Duration.zero,
          pointer: pointer ?? 0,
          kind: kind ?? PointerDeviceKind.touch,
          device: device ?? 0,
          position: position ?? Offset.zero,
          buttons: buttons ?? 0,
          obscured: obscured ?? false,
          pressure: pressure ?? 0.0,
          pressureMin: pressureMin ?? 1.0,
          pressureMax: pressureMax ?? 1.0,
          distance: distance ?? 0.0,
          distanceMax: distanceMax ?? 0.0,
          size: size ?? 0.0,
          radiusMajor: radiusMajor ?? 0.0,
          radiusMinor: radiusMinor ?? 0.0,
          radiusMin: radiusMin ?? 0.0,
          radiusMax: radiusMax ?? 0.0,
          orientation: orientation ?? 0.0,
          tilt: tilt ?? 0.0,
          embedderId: embedderId ?? 0);
    },
    "PolynomialFit": () {
      final degree = getValue(maps["0"], datas, "int", vars, props);
      if (degree == null) {
        return null;
      }
      return PolynomialFit(degree!);
    },
    "PopupMenuButton": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final itemBuilder = getValue(
          maps["itemBuilder"], datas, "PopupMenuItemBuilder<T>", vars, props);
      final initialValue =
          getValue(maps["initialValue"], datas, "T?", vars, props);
      final onOpened =
          getValue(maps["onOpened"], datas, "VoidCallback?", vars, props);
      final onSelected = getValue(
          maps["onSelected"], datas, "PopupMenuItemSelected<T>?", vars, props);
      final onCanceled = getValue(
          maps["onCanceled"], datas, "PopupMenuCanceled?", vars, props);
      final tooltip = getValue(maps["tooltip"], datas, "String?", vars, props);
      final elevation =
          getValue(maps["elevation"], datas, "double?", vars, props);
      final shadowColor =
          getValue(maps["shadowColor"], datas, "Color?", vars, props);
      final surfaceTintColor =
          getValue(maps["surfaceTintColor"], datas, "Color?", vars, props);
      final padding =
          getValue(maps["padding"], datas, "EdgeInsetsGeometry", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      final splashRadius =
          getValue(maps["splashRadius"], datas, "double?", vars, props);
      final icon = getValue(maps["icon"], datas, "Widget?", vars, props);
      final iconSize =
          getValue(maps["iconSize"], datas, "double?", vars, props);
      final offset = getValue(maps["offset"], datas, "Offset", vars, props);
      final enabled = getValue(maps["enabled"], datas, "bool", vars, props);
      final shape = getValue(maps["shape"], datas, "ShapeBorder?", vars, props);
      final color = getValue(maps["color"], datas, "Color?", vars, props);
      final enableFeedback =
          getValue(maps["enableFeedback"], datas, "bool?", vars, props);
      final constraints =
          getValue(maps["constraints"], datas, "BoxConstraints?", vars, props);
      final position =
          getValue(maps["position"], datas, "PopupMenuPosition?", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      if (itemBuilder == null) {
        return null;
      }
      return PopupMenuButton(
          key: key,
          itemBuilder: itemBuilder!,
          initialValue: initialValue,
          onOpened: onOpened,
          onSelected: onSelected,
          onCanceled: onCanceled,
          tooltip: tooltip,
          elevation: elevation,
          shadowColor: shadowColor,
          surfaceTintColor: surfaceTintColor,
          padding: padding ?? const EdgeInsets.all(8.0),
          child: child,
          splashRadius: splashRadius,
          icon: icon,
          iconSize: iconSize,
          offset: offset ?? Offset.zero,
          enabled: enabled ?? true,
          shape: shape,
          color: color,
          enableFeedback: enableFeedback,
          constraints: constraints,
          position: position,
          clipBehavior: clipBehavior ?? Clip.none);
    },
    "PopupMenuDivider": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final height = getValue(maps["height"], datas, "double", vars, props);
      if (height != null) {
        return PopupMenuDivider(key: key, height: height);
      }
      return PopupMenuDivider(key: key);
    },
    "PopupMenuItem": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final value = getValue(maps["value"], datas, "T?", vars, props);
      final onTap =
          getValue(maps["onTap"], datas, "VoidCallback?", vars, props);
      final enabled = getValue(maps["enabled"], datas, "bool", vars, props);
      final height = getValue(maps["height"], datas, "double", vars, props);
      final padding =
          getValue(maps["padding"], datas, "EdgeInsets?", vars, props);
      final textStyle =
          getValue(maps["textStyle"], datas, "TextStyle?", vars, props);
      final labelTextStyle = getValue(maps["labelTextStyle"], datas,
          "MaterialStateProperty<TextStyle?>?", vars, props);
      final mouseCursor =
          getValue(maps["mouseCursor"], datas, "MouseCursor?", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      if (child == null) {
        return null;
      }
      return PopupMenuItem(
          key: key,
          value: value,
          onTap: onTap,
          enabled: enabled ?? true,
          height: height ?? kMinInteractiveDimension,
          padding: padding,
          textStyle: textStyle,
          labelTextStyle: labelTextStyle,
          mouseCursor: mouseCursor,
          child: child!);
    },
    "PopupMenuTheme": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final data =
          getValue(maps["data"], datas, "PopupMenuThemeData", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (data == null || child == null) {
        return null;
      }
      return PopupMenuTheme(key: key, data: data!, child: child!);
    },
    "PopupMenuThemeData": () {
      final color = getValue(maps["color"], datas, "Color?", vars, props);
      final shape = getValue(maps["shape"], datas, "ShapeBorder?", vars, props);
      final elevation =
          getValue(maps["elevation"], datas, "double?", vars, props);
      final shadowColor =
          getValue(maps["shadowColor"], datas, "Color?", vars, props);
      final surfaceTintColor =
          getValue(maps["surfaceTintColor"], datas, "Color?", vars, props);
      final textStyle =
          getValue(maps["textStyle"], datas, "TextStyle?", vars, props);
      final labelTextStyle = getValue(maps["labelTextStyle"], datas,
          "MaterialStateProperty<TextStyle?>?", vars, props);
      final enableFeedback =
          getValue(maps["enableFeedback"], datas, "bool?", vars, props);
      final mouseCursor = getValue(maps["mouseCursor"], datas,
          "MaterialStateProperty<MouseCursor?>?", vars, props);
      final position =
          getValue(maps["position"], datas, "PopupMenuPosition?", vars, props);
      return PopupMenuThemeData(
          color: color,
          shape: shape,
          elevation: elevation,
          shadowColor: shadowColor,
          surfaceTintColor: surfaceTintColor,
          textStyle: textStyle,
          labelTextStyle: labelTextStyle,
          enableFeedback: enableFeedback,
          mouseCursor: mouseCursor,
          position: position);
    },
    "Positioned": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final left = getValue(maps["left"], datas, "double?", vars, props);
      final top = getValue(maps["top"], datas, "double?", vars, props);
      final right = getValue(maps["right"], datas, "double?", vars, props);
      final bottom = getValue(maps["bottom"], datas, "double?", vars, props);
      final width = getValue(maps["width"], datas, "double?", vars, props);
      final height = getValue(maps["height"], datas, "double?", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (child == null) {
        return null;
      }
      return Positioned(
          key: key,
          left: left,
          top: top,
          right: right,
          bottom: bottom,
          width: width,
          height: height,
          child: child!);
    },
    "Positioned.fromRect": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final rect = getValue(maps["rect"], datas, "Rect", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (rect == null || child == null) {
        return null;
      }
      return Positioned.fromRect(key: key, rect: rect!, child: child!);
    },
    "Positioned.fromRelativeRect": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final rect = getValue(maps["rect"], datas, "RelativeRect", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (rect == null || child == null) {
        return null;
      }
      return Positioned.fromRelativeRect(key: key, rect: rect!, child: child!);
    },
    "Positioned.fill": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final left = getValue(maps["left"], datas, "double?", vars, props);
      final top = getValue(maps["top"], datas, "double?", vars, props);
      final right = getValue(maps["right"], datas, "double?", vars, props);
      final bottom = getValue(maps["bottom"], datas, "double?", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (child == null) {
        return null;
      }
      return Positioned.fill(
          key: key,
          left: left ?? 0.0,
          top: top ?? 0.0,
          right: right ?? 0.0,
          bottom: bottom ?? 0.0,
          child: child!);
    },
    "Positioned.directional": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final textDirection =
          getValue(maps["textDirection"], datas, "TextDirection", vars, props);
      final start = getValue(maps["start"], datas, "double?", vars, props);
      final top = getValue(maps["top"], datas, "double?", vars, props);
      final end = getValue(maps["end"], datas, "double?", vars, props);
      final bottom = getValue(maps["bottom"], datas, "double?", vars, props);
      final width = getValue(maps["width"], datas, "double?", vars, props);
      final height = getValue(maps["height"], datas, "double?", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (textDirection == null || child == null) {
        return null;
      }
      return Positioned.directional(
          key: key,
          textDirection: textDirection!,
          start: start,
          top: top,
          end: end,
          bottom: bottom,
          width: width,
          height: height,
          child: child!);
    },
    "PositionedDirectional": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final start = getValue(maps["start"], datas, "double?", vars, props);
      final top = getValue(maps["top"], datas, "double?", vars, props);
      final end = getValue(maps["end"], datas, "double?", vars, props);
      final bottom = getValue(maps["bottom"], datas, "double?", vars, props);
      final width = getValue(maps["width"], datas, "double?", vars, props);
      final height = getValue(maps["height"], datas, "double?", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (child == null) {
        return null;
      }
      return PositionedDirectional(
          key: key,
          start: start,
          top: top,
          end: end,
          bottom: bottom,
          width: width,
          height: height,
          child: child!);
    },
    "PositionedTransition": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final rect =
          getValue(maps["rect"], datas, "Animation<RelativeRect>", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (rect == null || child == null) {
        return null;
      }
      return PositionedTransition(key: key, rect: rect!, child: child!);
    },
    "PreferredSize": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      final preferredSize =
          getValue(maps["preferredSize"], datas, "Size", vars, props);
      if (child == null || preferredSize == null) {
        return null;
      }
      return PreferredSize(
          key: key, child: child!, preferredSize: preferredSize!);
    },
    "PreviousFocusIntent": () {
      return const PreviousFocusIntent();
    },
    "PrimaryScrollController": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final controller =
          getValue(maps["controller"], datas, "ScrollController", vars, props);
      final automaticallyInheritForPlatforms = getValue(
          maps["automaticallyInheritForPlatforms"],
          datas,
          "Set<TargetPlatform>",
          vars,
          props);
      final scrollDirection =
          getValue(maps["scrollDirection"], datas, "Axis?", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (controller == null || child == null) {
        return null;
      }
      if (automaticallyInheritForPlatforms != null) {
        return PrimaryScrollController(
            key: key,
            controller: controller!,
            scrollDirection: scrollDirection ?? Axis.vertical,
            child: child!,
            automaticallyInheritForPlatforms:
                Set<TargetPlatform>.from(automaticallyInheritForPlatforms));
      }
      return PrimaryScrollController(
          key: key,
          controller: controller!,
          scrollDirection: scrollDirection ?? Axis.vertical,
          child: child!);
    },
    "PrimaryScrollController.none": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (child == null) {
        return null;
      }
      return PrimaryScrollController.none(key: key, child: child!);
    },
    "PrioritizedIntents": () {
      final orderedIntents =
          getValue(maps["orderedIntents"], datas, "List<Intent>", vars, props);
      if (orderedIntents == null) {
        return null;
      }
      return PrioritizedIntents(
          orderedIntents: List<Intent>.from(orderedIntents!));
    },
    "ProgressIndicatorTheme": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final data = getValue(
          maps["data"], datas, "ProgressIndicatorThemeData", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (data == null || child == null) {
        return null;
      }
      return ProgressIndicatorTheme(key: key, data: data!, child: child!);
    },
    "ProgressIndicatorThemeData": () {
      final color = getValue(maps["color"], datas, "Color?", vars, props);
      final linearTrackColor =
          getValue(maps["linearTrackColor"], datas, "Color?", vars, props);
      final linearMinHeight =
          getValue(maps["linearMinHeight"], datas, "double?", vars, props);
      final circularTrackColor =
          getValue(maps["circularTrackColor"], datas, "Color?", vars, props);
      final refreshBackgroundColor = getValue(
          maps["refreshBackgroundColor"], datas, "Color?", vars, props);
      return ProgressIndicatorThemeData(
          color: color,
          linearTrackColor: linearTrackColor,
          linearMinHeight: linearMinHeight,
          circularTrackColor: circularTrackColor,
          refreshBackgroundColor: refreshBackgroundColor);
    },
    "ProxyAnimation": () {
      final animation =
          getValue(maps["0"], datas, "Animation<double>?", vars, props);
      return ProxyAnimation(animation);
    },
    "RRect.fromLTRBXY": () {
      final left = getValue(maps["0"], datas, "double", vars, props);
      final top = getValue(maps["1"], datas, "double", vars, props);
      final right = getValue(maps["2"], datas, "double", vars, props);
      final bottom = getValue(maps["3"], datas, "double", vars, props);
      final radiusX = getValue(maps["4"], datas, "double", vars, props);
      final radiusY = getValue(maps["5"], datas, "double", vars, props);
      if (left == null ||
          top == null ||
          right == null ||
          bottom == null ||
          radiusX == null ||
          radiusY == null) {
        return null;
      }
      return RRect.fromLTRBXY(left!, top!, right!, bottom!, radiusX!, radiusY!);
    },
    "RRect.fromLTRBR": () {
      final left = getValue(maps["0"], datas, "double", vars, props);
      final top = getValue(maps["1"], datas, "double", vars, props);
      final right = getValue(maps["2"], datas, "double", vars, props);
      final bottom = getValue(maps["3"], datas, "double", vars, props);
      final radius = getValue(maps["4"], datas, "Radius", vars, props);
      if (left == null ||
          top == null ||
          right == null ||
          bottom == null ||
          radius == null) {
        return null;
      }
      return RRect.fromLTRBR(left!, top!, right!, bottom!, radius!);
    },
    "RRect.fromRectXY": () {
      final rect = getValue(maps["0"], datas, "Rect", vars, props);
      final radiusX = getValue(maps["1"], datas, "double", vars, props);
      final radiusY = getValue(maps["2"], datas, "double", vars, props);
      if (rect == null || radiusX == null || radiusY == null) {
        return null;
      }
      return RRect.fromRectXY(rect!, radiusX!, radiusY!);
    },
    "RRect.fromRectAndRadius": () {
      final rect = getValue(maps["0"], datas, "Rect", vars, props);
      final radius = getValue(maps["1"], datas, "Radius", vars, props);
      if (rect == null || radius == null) {
        return null;
      }
      return RRect.fromRectAndRadius(rect!, radius!);
    },
    "RRect.fromLTRBAndCorners": () {
      final left = getValue(maps["0"], datas, "double", vars, props);
      final top = getValue(maps["1"], datas, "double", vars, props);
      final right = getValue(maps["2"], datas, "double", vars, props);
      final bottom = getValue(maps["3"], datas, "double", vars, props);
      final topLeft = getValue(maps["topLeft"], datas, "Radius", vars, props);
      final topRight = getValue(maps["topRight"], datas, "Radius", vars, props);
      final bottomRight =
          getValue(maps["bottomRight"], datas, "Radius", vars, props);
      final bottomLeft =
          getValue(maps["bottomLeft"], datas, "Radius", vars, props);
      if (left == null || top == null || right == null || bottom == null) {
        return null;
      }
      return RRect.fromLTRBAndCorners(left!, top!, right!, bottom!,
          topLeft: topLeft ?? Radius.zero,
          topRight: topRight ?? Radius.zero,
          bottomRight: bottomRight ?? Radius.zero,
          bottomLeft: bottomLeft ?? Radius.zero);
    },
    "RRect.fromRectAndCorners": () {
      final rect = getValue(maps["0"], datas, "Rect", vars, props);
      final topLeft = getValue(maps["topLeft"], datas, "Radius", vars, props);
      final topRight = getValue(maps["topRight"], datas, "Radius", vars, props);
      final bottomRight =
          getValue(maps["bottomRight"], datas, "Radius", vars, props);
      final bottomLeft =
          getValue(maps["bottomLeft"], datas, "Radius", vars, props);
      if (rect == null) {
        return null;
      }
      return RRect.fromRectAndCorners(rect!,
          topLeft: topLeft ?? Radius.zero,
          topRight: topRight ?? Radius.zero,
          bottomRight: bottomRight ?? Radius.zero,
          bottomLeft: bottomLeft ?? Radius.zero);
    },
    "RSTransform": () {
      final scos = getValue(maps["0"], datas, "double", vars, props);
      final ssin = getValue(maps["1"], datas, "double", vars, props);
      final tx = getValue(maps["2"], datas, "double", vars, props);
      final ty = getValue(maps["3"], datas, "double", vars, props);
      if (scos == null || ssin == null || tx == null || ty == null) {
        return null;
      }
      return RSTransform(scos!, ssin!, tx!, ty!);
    },
    "RSTransform.fromComponents": () {
      final rotation = getValue(maps["rotation"], datas, "double", vars, props);
      final scale = getValue(maps["scale"], datas, "double", vars, props);
      final anchorX = getValue(maps["anchorX"], datas, "double", vars, props);
      final anchorY = getValue(maps["anchorY"], datas, "double", vars, props);
      final translateX =
          getValue(maps["translateX"], datas, "double", vars, props);
      final translateY =
          getValue(maps["translateY"], datas, "double", vars, props);
      if (rotation == null ||
          scale == null ||
          anchorX == null ||
          anchorY == null ||
          translateX == null ||
          translateY == null) {
        return null;
      }
      return RSTransform.fromComponents(
          rotation: rotation!,
          scale: scale!,
          anchorX: anchorX!,
          anchorY: anchorY!,
          translateX: translateX!,
          translateY: translateY!);
    },
    "RadialGradient": () {
      final center =
          getValue(maps["center"], datas, "AlignmentGeometry", vars, props);
      final radius = getValue(maps["radius"], datas, "double", vars, props);
      final colors = getValue(maps["colors"], datas, "", vars, props);
      final stops = getValue(maps["stops"], datas, "", vars, props);
      final tileMode =
          getValue(maps["tileMode"], datas, "TileMode", vars, props);
      final focal =
          getValue(maps["focal"], datas, "AlignmentGeometry?", vars, props);
      final focalRadius =
          getValue(maps["focalRadius"], datas, "double", vars, props);
      final transform = getValue(maps["transform"], datas, "", vars, props);
      if (colors == null) {
        return null;
      }
      return RadialGradient(
          center: center ?? Alignment.center,
          radius: radius ?? 0.5,
          colors: colors!,
          stops: stops,
          tileMode: tileMode ?? TileMode.clamp,
          focal: focal,
          focalRadius: focalRadius ?? 0.0,
          transform: transform);
    },
    "Radio": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final value = getValue(maps["value"], datas, "T", vars, props);
      final groupValue = getValue(maps["groupValue"], datas, "T?", vars, props);
      final onChanged =
          getValue(maps["onChanged"], datas, "ValueChanged<T?>?", vars, props);
      final mouseCursor =
          getValue(maps["mouseCursor"], datas, "MouseCursor?", vars, props);
      final toggleable =
          getValue(maps["toggleable"], datas, "bool", vars, props);
      final activeColor =
          getValue(maps["activeColor"], datas, "Color?", vars, props);
      final fillColor = getValue(maps["fillColor"], datas,
          "MaterialStateProperty<Color?>?", vars, props);
      final focusColor =
          getValue(maps["focusColor"], datas, "Color?", vars, props);
      final hoverColor =
          getValue(maps["hoverColor"], datas, "Color?", vars, props);
      final overlayColor = getValue(maps["overlayColor"], datas,
          "MaterialStateProperty<Color?>?", vars, props);
      final splashRadius =
          getValue(maps["splashRadius"], datas, "double?", vars, props);
      final materialTapTargetSize = getValue(maps["materialTapTargetSize"],
          datas, "MaterialTapTargetSize?", vars, props);
      final visualDensity =
          getValue(maps["visualDensity"], datas, "VisualDensity?", vars, props);
      final focusNode =
          getValue(maps["focusNode"], datas, "FocusNode?", vars, props);
      final autofocus = getValue(maps["autofocus"], datas, "bool", vars, props);
      if (value == null || groupValue == null || onChanged == null) {
        return null;
      }
      return Radio(
          key: key,
          value: value!,
          groupValue: groupValue!,
          onChanged: onChanged!,
          mouseCursor: mouseCursor,
          toggleable: toggleable ?? false,
          activeColor: activeColor,
          fillColor: fillColor,
          focusColor: focusColor,
          hoverColor: hoverColor,
          overlayColor: overlayColor,
          splashRadius: splashRadius,
          materialTapTargetSize: materialTapTargetSize,
          visualDensity: visualDensity,
          focusNode: focusNode,
          autofocus: autofocus ?? false);
    },
    "Radio.adaptive": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final value = getValue(maps["value"], datas, "T", vars, props);
      final groupValue = getValue(maps["groupValue"], datas, "T?", vars, props);
      final onChanged =
          getValue(maps["onChanged"], datas, "ValueChanged<T?>?", vars, props);
      final mouseCursor =
          getValue(maps["mouseCursor"], datas, "MouseCursor?", vars, props);
      final toggleable =
          getValue(maps["toggleable"], datas, "bool", vars, props);
      final activeColor =
          getValue(maps["activeColor"], datas, "Color?", vars, props);
      final fillColor = getValue(maps["fillColor"], datas,
          "MaterialStateProperty<Color?>?", vars, props);
      final focusColor =
          getValue(maps["focusColor"], datas, "Color?", vars, props);
      final hoverColor =
          getValue(maps["hoverColor"], datas, "Color?", vars, props);
      final overlayColor = getValue(maps["overlayColor"], datas,
          "MaterialStateProperty<Color?>?", vars, props);
      final splashRadius =
          getValue(maps["splashRadius"], datas, "double?", vars, props);
      final materialTapTargetSize = getValue(maps["materialTapTargetSize"],
          datas, "MaterialTapTargetSize?", vars, props);
      final visualDensity =
          getValue(maps["visualDensity"], datas, "VisualDensity?", vars, props);
      final focusNode =
          getValue(maps["focusNode"], datas, "FocusNode?", vars, props);
      final autofocus = getValue(maps["autofocus"], datas, "bool", vars, props);
      if (value == null || groupValue == null || onChanged == null) {
        return null;
      }
      return Radio.adaptive(
          key: key,
          value: value!,
          groupValue: groupValue!,
          onChanged: onChanged!,
          mouseCursor: mouseCursor,
          toggleable: toggleable ?? false,
          activeColor: activeColor,
          fillColor: fillColor,
          focusColor: focusColor,
          hoverColor: hoverColor,
          overlayColor: overlayColor,
          splashRadius: splashRadius,
          materialTapTargetSize: materialTapTargetSize,
          visualDensity: visualDensity,
          focusNode: focusNode,
          autofocus: autofocus ?? false);
    },
    "RadioListTile": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final value = getValue(maps["value"], datas, "T", vars, props);
      final groupValue = getValue(maps["groupValue"], datas, "T?", vars, props);
      final onChanged =
          getValue(maps["onChanged"], datas, "ValueChanged<T?>?", vars, props);
      final mouseCursor =
          getValue(maps["mouseCursor"], datas, "MouseCursor?", vars, props);
      final toggleable =
          getValue(maps["toggleable"], datas, "bool", vars, props);
      final activeColor =
          getValue(maps["activeColor"], datas, "Color?", vars, props);
      final fillColor = getValue(maps["fillColor"], datas,
          "MaterialStateProperty<Color?>?", vars, props);
      final hoverColor =
          getValue(maps["hoverColor"], datas, "Color?", vars, props);
      final overlayColor = getValue(maps["overlayColor"], datas,
          "MaterialStateProperty<Color?>?", vars, props);
      final splashRadius =
          getValue(maps["splashRadius"], datas, "double?", vars, props);
      final materialTapTargetSize = getValue(maps["materialTapTargetSize"],
          datas, "MaterialTapTargetSize?", vars, props);
      final title = getValue(maps["title"], datas, "Widget?", vars, props);
      final subtitle =
          getValue(maps["subtitle"], datas, "Widget?", vars, props);
      final isThreeLine =
          getValue(maps["isThreeLine"], datas, "bool", vars, props);
      final dense = getValue(maps["dense"], datas, "bool?", vars, props);
      final secondary =
          getValue(maps["secondary"], datas, "Widget?", vars, props);
      final selected = getValue(maps["selected"], datas, "bool", vars, props);
      final controlAffinity = getValue(maps["controlAffinity"], datas,
          "ListTileControlAffinity", vars, props);
      final autofocus = getValue(maps["autofocus"], datas, "bool", vars, props);
      final contentPadding = getValue(
          maps["contentPadding"], datas, "EdgeInsetsGeometry?", vars, props);
      final shape = getValue(maps["shape"], datas, "ShapeBorder?", vars, props);
      final tileColor =
          getValue(maps["tileColor"], datas, "Color?", vars, props);
      final selectedTileColor =
          getValue(maps["selectedTileColor"], datas, "Color?", vars, props);
      final visualDensity =
          getValue(maps["visualDensity"], datas, "VisualDensity?", vars, props);
      final focusNode =
          getValue(maps["focusNode"], datas, "FocusNode?", vars, props);
      final onFocusChange = getValue(
          maps["onFocusChange"], datas, "ValueChanged<bool>?", vars, props);
      final enableFeedback =
          getValue(maps["enableFeedback"], datas, "bool?", vars, props);
      if (value == null || groupValue == null || onChanged == null) {
        return null;
      }
      return RadioListTile(
          key: key,
          value: value!,
          groupValue: groupValue!,
          onChanged: onChanged!,
          mouseCursor: mouseCursor,
          toggleable: toggleable ?? false,
          activeColor: activeColor,
          fillColor: fillColor,
          hoverColor: hoverColor,
          overlayColor: overlayColor,
          splashRadius: splashRadius,
          materialTapTargetSize: materialTapTargetSize,
          title: title,
          subtitle: subtitle,
          isThreeLine: isThreeLine ?? false,
          dense: dense,
          secondary: secondary,
          selected: selected ?? false,
          controlAffinity: controlAffinity ?? ListTileControlAffinity.platform,
          autofocus: autofocus ?? false,
          contentPadding: contentPadding,
          shape: shape,
          tileColor: tileColor,
          selectedTileColor: selectedTileColor,
          visualDensity: visualDensity,
          focusNode: focusNode,
          onFocusChange: onFocusChange,
          enableFeedback: enableFeedback);
    },
    "RadioListTile.adaptive": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final value = getValue(maps["value"], datas, "T", vars, props);
      final groupValue = getValue(maps["groupValue"], datas, "T?", vars, props);
      final onChanged =
          getValue(maps["onChanged"], datas, "ValueChanged<T?>?", vars, props);
      final mouseCursor =
          getValue(maps["mouseCursor"], datas, "MouseCursor?", vars, props);
      final toggleable =
          getValue(maps["toggleable"], datas, "bool", vars, props);
      final activeColor =
          getValue(maps["activeColor"], datas, "Color?", vars, props);
      final fillColor = getValue(maps["fillColor"], datas,
          "MaterialStateProperty<Color?>?", vars, props);
      final hoverColor =
          getValue(maps["hoverColor"], datas, "Color?", vars, props);
      final overlayColor = getValue(maps["overlayColor"], datas,
          "MaterialStateProperty<Color?>?", vars, props);
      final splashRadius =
          getValue(maps["splashRadius"], datas, "double?", vars, props);
      final materialTapTargetSize = getValue(maps["materialTapTargetSize"],
          datas, "MaterialTapTargetSize?", vars, props);
      final title = getValue(maps["title"], datas, "Widget?", vars, props);
      final subtitle =
          getValue(maps["subtitle"], datas, "Widget?", vars, props);
      final isThreeLine =
          getValue(maps["isThreeLine"], datas, "bool", vars, props);
      final dense = getValue(maps["dense"], datas, "bool?", vars, props);
      final secondary =
          getValue(maps["secondary"], datas, "Widget?", vars, props);
      final selected = getValue(maps["selected"], datas, "bool", vars, props);
      final controlAffinity = getValue(maps["controlAffinity"], datas,
          "ListTileControlAffinity", vars, props);
      final autofocus = getValue(maps["autofocus"], datas, "bool", vars, props);
      final contentPadding = getValue(
          maps["contentPadding"], datas, "EdgeInsetsGeometry?", vars, props);
      final shape = getValue(maps["shape"], datas, "ShapeBorder?", vars, props);
      final tileColor =
          getValue(maps["tileColor"], datas, "Color?", vars, props);
      final selectedTileColor =
          getValue(maps["selectedTileColor"], datas, "Color?", vars, props);
      final visualDensity =
          getValue(maps["visualDensity"], datas, "VisualDensity?", vars, props);
      final focusNode =
          getValue(maps["focusNode"], datas, "FocusNode?", vars, props);
      final onFocusChange = getValue(
          maps["onFocusChange"], datas, "ValueChanged<bool>?", vars, props);
      final enableFeedback =
          getValue(maps["enableFeedback"], datas, "bool?", vars, props);
      if (value == null || groupValue == null || onChanged == null) {
        return null;
      }
      return RadioListTile.adaptive(
          key: key,
          value: value!,
          groupValue: groupValue!,
          onChanged: onChanged!,
          mouseCursor: mouseCursor,
          toggleable: toggleable ?? false,
          activeColor: activeColor,
          fillColor: fillColor,
          hoverColor: hoverColor,
          overlayColor: overlayColor,
          splashRadius: splashRadius,
          materialTapTargetSize: materialTapTargetSize,
          title: title,
          subtitle: subtitle,
          isThreeLine: isThreeLine ?? false,
          dense: dense,
          secondary: secondary,
          selected: selected ?? false,
          controlAffinity: controlAffinity ?? ListTileControlAffinity.platform,
          autofocus: autofocus ?? false,
          contentPadding: contentPadding,
          shape: shape,
          tileColor: tileColor,
          selectedTileColor: selectedTileColor,
          visualDensity: visualDensity,
          focusNode: focusNode,
          onFocusChange: onFocusChange,
          enableFeedback: enableFeedback);
    },
    "RadioMenuButton": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final value = getValue(maps["value"], datas, "T", vars, props);
      final groupValue = getValue(maps["groupValue"], datas, "T?", vars, props);
      final onChanged =
          getValue(maps["onChanged"], datas, "ValueChanged<T?>?", vars, props);
      final toggleable =
          getValue(maps["toggleable"], datas, "bool", vars, props);
      final onHover =
          getValue(maps["onHover"], datas, "ValueChanged<bool>?", vars, props);
      final onFocusChange = getValue(
          maps["onFocusChange"], datas, "ValueChanged<bool>?", vars, props);
      final focusNode =
          getValue(maps["focusNode"], datas, "FocusNode?", vars, props);
      final shortcut = getValue(
          maps["shortcut"], datas, "MenuSerializableShortcut?", vars, props);
      final style = getValue(maps["style"], datas, "ButtonStyle?", vars, props);
      final statesController = getValue(maps["statesController"], datas,
          "MaterialStatesController?", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      final trailingIcon =
          getValue(maps["trailingIcon"], datas, "Widget?", vars, props);
      final closeOnActivate =
          getValue(maps["closeOnActivate"], datas, "bool", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      if (value == null ||
          groupValue == null ||
          onChanged == null ||
          child == null) {
        return null;
      }
      return RadioMenuButton(
          key: key,
          value: value!,
          groupValue: groupValue!,
          onChanged: onChanged!,
          toggleable: toggleable ?? false,
          onHover: onHover,
          onFocusChange: onFocusChange,
          focusNode: focusNode,
          shortcut: shortcut,
          style: style,
          statesController: statesController,
          clipBehavior: clipBehavior ?? Clip.none,
          trailingIcon: trailingIcon,
          closeOnActivate: closeOnActivate ?? true,
          child: child!);
    },
    "RadioTheme": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final data = getValue(maps["data"], datas, "RadioThemeData", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (data == null || child == null) {
        return null;
      }
      return RadioTheme(key: key, data: data!, child: child!);
    },
    "RadioThemeData": () {
      final mouseCursor = getValue(maps["mouseCursor"], datas,
          "MaterialStateProperty<MouseCursor?>?", vars, props);
      final fillColor = getValue(maps["fillColor"], datas,
          "MaterialStateProperty<Color?>?", vars, props);
      final overlayColor = getValue(maps["overlayColor"], datas,
          "MaterialStateProperty<Color?>?", vars, props);
      final splashRadius =
          getValue(maps["splashRadius"], datas, "double?", vars, props);
      final materialTapTargetSize = getValue(maps["materialTapTargetSize"],
          datas, "MaterialTapTargetSize?", vars, props);
      final visualDensity =
          getValue(maps["visualDensity"], datas, "VisualDensity?", vars, props);
      return RadioThemeData(
          mouseCursor: mouseCursor,
          fillColor: fillColor,
          overlayColor: overlayColor,
          splashRadius: splashRadius,
          materialTapTargetSize: materialTapTargetSize,
          visualDensity: visualDensity);
    },
    "Radius.circular": () {
      final radius = getValue(maps["0"], datas, "double", vars, props);
      if (radius == null) {
        return null;
      }
      return Radius.circular(radius!);
    },
    "Radius.elliptical": () {
      final x = getValue(maps["0"], datas, "double", vars, props);
      final y = getValue(maps["1"], datas, "double", vars, props);
      if (x == null || y == null) {
        return null;
      }
      return Radius.elliptical(x!, y!);
    },
    "RangeError": () {
      final message = getValue(maps["0"], datas, "dynamic", vars, props);
      return RangeError(message);
    },
    "RangeError.value": () {
      final value = getValue(maps["0"], datas, "num", vars, props);
      final name = getValue(maps["1"], datas, "String?", vars, props);
      final message = getValue(maps["2"], datas, "String?", vars, props);
      if (value == null) {
        return null;
      }
      return RangeError.value(value!, name, message);
    },
    "RangeSlider": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final values =
          getValue(maps["values"], datas, "RangeValues", vars, props);
      final onChanged = getValue(
          maps["onChanged"], datas, "ValueChanged<RangeValues>?", vars, props);
      final onChangeStart = getValue(maps["onChangeStart"], datas,
          "ValueChanged<RangeValues>?", vars, props);
      final onChangeEnd = getValue(maps["onChangeEnd"], datas,
          "ValueChanged<RangeValues>?", vars, props);
      final min = getValue(maps["min"], datas, "double", vars, props);
      final max = getValue(maps["max"], datas, "double", vars, props);
      final divisions = getValue(maps["divisions"], datas, "int?", vars, props);
      final labels =
          getValue(maps["labels"], datas, "RangeLabels?", vars, props);
      final activeColor =
          getValue(maps["activeColor"], datas, "Color?", vars, props);
      final inactiveColor =
          getValue(maps["inactiveColor"], datas, "Color?", vars, props);
      final overlayColor = getValue(maps["overlayColor"], datas,
          "MaterialStateProperty<Color?>?", vars, props);
      final mouseCursor = getValue(maps["mouseCursor"], datas,
          "MaterialStateProperty<MouseCursor?>?", vars, props);
      final semanticFormatterCallback = getValue(
          maps["semanticFormatterCallback"],
          datas,
          "SemanticFormatterCallback?",
          vars,
          props);
      if (values == null || onChanged == null) {
        return null;
      }
      return RangeSlider(
          key: key,
          values: values!,
          onChanged: onChanged!,
          onChangeStart: onChangeStart,
          onChangeEnd: onChangeEnd,
          min: min ?? 0.0,
          max: max ?? 1.0,
          divisions: divisions,
          labels: labels,
          activeColor: activeColor,
          inactiveColor: inactiveColor,
          overlayColor: overlayColor,
          mouseCursor: mouseCursor,
          semanticFormatterCallback: semanticFormatterCallback);
    },
    "RangeValues": () {
      final start = getValue(maps["0"], datas, "double", vars, props);
      final end = getValue(maps["1"], datas, "double", vars, props);
      if (start == null || end == null) {
        return null;
      }
      return RangeValues(start!, end!);
    },
    "RawAutocomplete": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final optionsViewBuilder = getValue(maps["optionsViewBuilder"], datas,
          "AutocompleteOptionsViewBuilder<T>", vars, props);
      final optionsBuilder = getValue(maps["optionsBuilder"], datas,
          "AutocompleteOptionsBuilder<T>", vars, props);
      final displayStringForOption = getValue(maps["displayStringForOption"],
          datas, "AutocompleteOptionToString<T>", vars, props);
      final fieldViewBuilder = getValue(maps["fieldViewBuilder"], datas,
          "AutocompleteFieldViewBuilder?", vars, props);
      final focusNode =
          getValue(maps["focusNode"], datas, "FocusNode?", vars, props);
      final onSelected = getValue(
          maps["onSelected"], datas, "AutocompleteOnSelected<T>?", vars, props);
      final textEditingController = getValue(maps["textEditingController"],
          datas, "TextEditingController?", vars, props);
      final initialValue = getValue(
          maps["initialValue"], datas, "TextEditingValue?", vars, props);
      if (optionsViewBuilder == null || optionsBuilder == null) {
        return null;
      }
      if (displayStringForOption != null) {
        return RawAutocomplete(
            key: key,
            optionsViewBuilder: optionsViewBuilder!,
            optionsBuilder: optionsBuilder!,
            fieldViewBuilder: fieldViewBuilder,
            focusNode: focusNode,
            onSelected: onSelected,
            textEditingController: textEditingController,
            initialValue: initialValue,
            displayStringForOption: displayStringForOption);
      }
      return RawAutocomplete(
          key: key,
          optionsViewBuilder: optionsViewBuilder!,
          optionsBuilder: optionsBuilder!,
          fieldViewBuilder: fieldViewBuilder,
          focusNode: focusNode,
          onSelected: onSelected,
          textEditingController: textEditingController,
          initialValue: initialValue);
    },
    "RawChip": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final defaultProperties = getValue(
          maps["defaultProperties"], datas, "ChipThemeData?", vars, props);
      final avatar = getValue(maps["avatar"], datas, "Widget?", vars, props);
      final label = getValue(maps["label"], datas, "Widget", vars, props);
      final labelStyle =
          getValue(maps["labelStyle"], datas, "TextStyle?", vars, props);
      final padding =
          getValue(maps["padding"], datas, "EdgeInsetsGeometry?", vars, props);
      final visualDensity =
          getValue(maps["visualDensity"], datas, "VisualDensity?", vars, props);
      final labelPadding = getValue(
          maps["labelPadding"], datas, "EdgeInsetsGeometry?", vars, props);
      final deleteIcon =
          getValue(maps["deleteIcon"], datas, "Widget?", vars, props);
      final onDeleted =
          getValue(maps["onDeleted"], datas, "VoidCallback?", vars, props);
      final deleteIconColor =
          getValue(maps["deleteIconColor"], datas, "Color?", vars, props);
      final deleteButtonTooltipMessage = getValue(
          maps["deleteButtonTooltipMessage"], datas, "String?", vars, props);
      final onPressed =
          getValue(maps["onPressed"], datas, "VoidCallback?", vars, props);
      final onSelected = getValue(
          maps["onSelected"], datas, "ValueChanged<bool>?", vars, props);
      final pressElevation =
          getValue(maps["pressElevation"], datas, "double?", vars, props);
      final tapEnabled =
          getValue(maps["tapEnabled"], datas, "bool", vars, props);
      final selected = getValue(maps["selected"], datas, "bool", vars, props);
      final isEnabled = getValue(maps["isEnabled"], datas, "bool", vars, props);
      final disabledColor =
          getValue(maps["disabledColor"], datas, "Color?", vars, props);
      final selectedColor =
          getValue(maps["selectedColor"], datas, "Color?", vars, props);
      final tooltip = getValue(maps["tooltip"], datas, "String?", vars, props);
      final side = getValue(maps["side"], datas, "BorderSide?", vars, props);
      final shape =
          getValue(maps["shape"], datas, "OutlinedBorder?", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      final focusNode =
          getValue(maps["focusNode"], datas, "FocusNode?", vars, props);
      final autofocus = getValue(maps["autofocus"], datas, "bool", vars, props);
      final backgroundColor =
          getValue(maps["backgroundColor"], datas, "Color?", vars, props);
      final materialTapTargetSize = getValue(maps["materialTapTargetSize"],
          datas, "MaterialTapTargetSize?", vars, props);
      final elevation =
          getValue(maps["elevation"], datas, "double?", vars, props);
      final shadowColor =
          getValue(maps["shadowColor"], datas, "Color?", vars, props);
      final surfaceTintColor =
          getValue(maps["surfaceTintColor"], datas, "Color?", vars, props);
      final iconTheme =
          getValue(maps["iconTheme"], datas, "IconThemeData?", vars, props);
      final selectedShadowColor =
          getValue(maps["selectedShadowColor"], datas, "Color?", vars, props);
      final showCheckmark =
          getValue(maps["showCheckmark"], datas, "bool?", vars, props);
      final checkmarkColor =
          getValue(maps["checkmarkColor"], datas, "Color?", vars, props);
      final avatarBorder =
          getValue(maps["avatarBorder"], datas, "ShapeBorder", vars, props);
      final useDeleteButtonTooltip =
          getValue(maps["useDeleteButtonTooltip"], datas, "bool", vars, props);
      if (label == null) {
        return null;
      }
      return RawChip(
        key: key,
        defaultProperties: defaultProperties,
        avatar: avatar,
        label: label!,
        labelStyle: labelStyle,
        padding: padding,
        visualDensity: visualDensity,
        labelPadding: labelPadding,
        deleteIcon: deleteIcon,
        onDeleted: onDeleted,
        deleteIconColor: deleteIconColor,
        deleteButtonTooltipMessage: deleteButtonTooltipMessage,
        onPressed: onPressed,
        onSelected: onSelected,
        pressElevation: pressElevation,
        tapEnabled: tapEnabled ?? true,
        selected: selected ?? false,
        isEnabled: isEnabled ?? true,
        disabledColor: disabledColor,
        selectedColor: selectedColor,
        tooltip: tooltip,
        side: side,
        shape: shape,
        clipBehavior: clipBehavior ?? Clip.none,
        focusNode: focusNode,
        autofocus: autofocus ?? false,
        backgroundColor: backgroundColor,
        materialTapTargetSize: materialTapTargetSize,
        elevation: elevation,
        shadowColor: shadowColor,
        surfaceTintColor: surfaceTintColor,
        iconTheme: iconTheme,
        selectedShadowColor: selectedShadowColor,
        showCheckmark: showCheckmark ?? true,
        checkmarkColor: checkmarkColor,
        avatarBorder: avatarBorder ?? const CircleBorder(),
        //useDeleteButtonTooltip: useDeleteButtonTooltip ?? true,
      );
    },
    "RawDialogRoute": () {
      final pageBuilder =
          getValue(maps["pageBuilder"], datas, "RoutePageBuilder", vars, props);
      final barrierDismissible =
          getValue(maps["barrierDismissible"], datas, "bool", vars, props);
      final barrierColor =
          getValue(maps["barrierColor"], datas, "Color?", vars, props);
      final barrierLabel =
          getValue(maps["barrierLabel"], datas, "String?", vars, props);
      final transitionDuration =
          getValue(maps["transitionDuration"], datas, "Duration", vars, props);
      final transitionBuilder = getValue(maps["transitionBuilder"], datas,
          "RouteTransitionsBuilder?", vars, props);
      final settings = getValue(maps["settings"], datas, "", vars, props);
      final anchorPoint =
          getValue(maps["anchorPoint"], datas, "Offset?", vars, props);
      final traversalEdgeBehavior =
          getValue(maps["traversalEdgeBehavior"], datas, "", vars, props);
      if (pageBuilder == null) {
        return null;
      }
      return RawDialogRoute(
          pageBuilder: pageBuilder!,
          barrierDismissible: barrierDismissible ?? true,
          barrierColor: barrierColor ?? const Color(0x80000000),
          barrierLabel: barrierLabel,
          transitionDuration:
              transitionDuration ?? const Duration(milliseconds: 200),
          transitionBuilder: transitionBuilder,
          settings: settings,
          anchorPoint: anchorPoint,
          traversalEdgeBehavior: traversalEdgeBehavior);
    },
    "RawFloatingCursorPoint": () {
      final offset = getValue(maps["offset"], datas, "Offset?", vars, props);
      final state = getValue(
          maps["state"], datas, "FloatingCursorDragState", vars, props);
      if (state == null) {
        return null;
      }
      return RawFloatingCursorPoint(offset: offset, state: state!);
    },
    "RawGestureDetector": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      final gestures = getValue(maps["gestures"], datas,
          "Map<Type, GestureRecognizerFactory>", vars, props);
      final behavior =
          getValue(maps["behavior"], datas, "HitTestBehavior?", vars, props);
      final excludeFromSemantics =
          getValue(maps["excludeFromSemantics"], datas, "bool", vars, props);
      final semantics = getValue(
          maps["semantics"], datas, "SemanticsGestureDelegate?", vars, props);
      return RawGestureDetector(
          key: key,
          child: child,
          gestures: Map<Type, GestureRecognizerFactory>.from(
              gestures ?? const <Type, GestureRecognizerFactory>{}),
          behavior: behavior,
          excludeFromSemantics: excludeFromSemantics ?? false,
          semantics: semantics);
    },
    "RawImage": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final image = getValue(maps["image"], datas, "Image?", vars, props);
      final debugImageLabel =
          getValue(maps["debugImageLabel"], datas, "String?", vars, props);
      final width = getValue(maps["width"], datas, "double?", vars, props);
      final height = getValue(maps["height"], datas, "double?", vars, props);
      final scale = getValue(maps["scale"], datas, "double", vars, props);
      final color = getValue(maps["color"], datas, "Color?", vars, props);
      final opacity =
          getValue(maps["opacity"], datas, "Animation<double>?", vars, props);
      final colorBlendMode =
          getValue(maps["colorBlendMode"], datas, "BlendMode?", vars, props);
      final fit = getValue(maps["fit"], datas, "BoxFit?", vars, props);
      final alignment =
          getValue(maps["alignment"], datas, "AlignmentGeometry", vars, props);
      final repeat =
          getValue(maps["repeat"], datas, "ImageRepeat", vars, props);
      final centerSlice =
          getValue(maps["centerSlice"], datas, "Rect?", vars, props);
      final matchTextDirection =
          getValue(maps["matchTextDirection"], datas, "bool", vars, props);
      final invertColors =
          getValue(maps["invertColors"], datas, "bool", vars, props);
      final filterQuality =
          getValue(maps["filterQuality"], datas, "FilterQuality", vars, props);
      final isAntiAlias =
          getValue(maps["isAntiAlias"], datas, "bool", vars, props);
      return RawImage(
          key: key,
          image: image,
          debugImageLabel: debugImageLabel,
          width: width,
          height: height,
          scale: scale ?? 1.0,
          color: color,
          opacity: opacity,
          colorBlendMode: colorBlendMode,
          fit: fit,
          alignment: alignment ?? Alignment.center,
          repeat: repeat ?? ImageRepeat.noRepeat,
          centerSlice: centerSlice,
          matchTextDirection: matchTextDirection ?? false,
          invertColors: invertColors ?? false,
          filterQuality: filterQuality ?? FilterQuality.low,
          isAntiAlias: isAntiAlias ?? false);
    },
    "RawKeyDownEvent": () {
      final data =
          getValue(maps["data"], datas, "RawKeyEventData", vars, props);
      final character =
          getValue(maps["character"], datas, "String?", vars, props);
      final repeat = getValue(maps["repeat"], datas, "bool", vars, props);
      if (data == null) {
        return null;
      }
      return RawKeyDownEvent(
          data: data!, character: character, repeat: repeat ?? false);
    },
    "RawKeyEvent.fromMessage": () {
      final message =
          getValue(maps["0"], datas, "Map<String,   Object?>", vars, props);
      if (message == null) {
        return null;
      }
      return RawKeyEvent.fromMessage(Map<String, Object?>.from(message!));
    },
    "RawKeyEventDataAndroid": () {
      final flags = getValue(maps["flags"], datas, "int", vars, props);
      final codePoint = getValue(maps["codePoint"], datas, "int", vars, props);
      final plainCodePoint =
          getValue(maps["plainCodePoint"], datas, "int", vars, props);
      final keyCode = getValue(maps["keyCode"], datas, "int", vars, props);
      final scanCode = getValue(maps["scanCode"], datas, "int", vars, props);
      final metaState = getValue(maps["metaState"], datas, "int", vars, props);
      final eventSource =
          getValue(maps["eventSource"], datas, "int", vars, props);
      final vendorId = getValue(maps["vendorId"], datas, "int", vars, props);
      final productId = getValue(maps["productId"], datas, "int", vars, props);
      final deviceId = getValue(maps["deviceId"], datas, "int", vars, props);
      final repeatCount =
          getValue(maps["repeatCount"], datas, "int", vars, props);
      return RawKeyEventDataAndroid(
          flags: flags ?? 0,
          codePoint: codePoint ?? 0,
          plainCodePoint: plainCodePoint ?? 0,
          keyCode: keyCode ?? 0,
          scanCode: scanCode ?? 0,
          metaState: metaState ?? 0,
          eventSource: eventSource ?? 0,
          vendorId: vendorId ?? 0,
          productId: productId ?? 0,
          deviceId: deviceId ?? 0,
          repeatCount: repeatCount ?? 0);
    },
    "RawKeyEventDataFuchsia": () {
      final hidUsage = getValue(maps["hidUsage"], datas, "int", vars, props);
      final codePoint = getValue(maps["codePoint"], datas, "int", vars, props);
      final modifiers = getValue(maps["modifiers"], datas, "int", vars, props);
      return RawKeyEventDataFuchsia(
          hidUsage: hidUsage ?? 0,
          codePoint: codePoint ?? 0,
          modifiers: modifiers ?? 0);
    },
    "RawKeyEventDataIos": () {
      final characters =
          getValue(maps["characters"], datas, "String", vars, props);
      final charactersIgnoringModifiers = getValue(
          maps["charactersIgnoringModifiers"], datas, "String", vars, props);
      final keyCode = getValue(maps["keyCode"], datas, "int", vars, props);
      final modifiers = getValue(maps["modifiers"], datas, "int", vars, props);
      return RawKeyEventDataIos(
          characters: characters ?? '',
          charactersIgnoringModifiers: charactersIgnoringModifiers ?? '',
          keyCode: keyCode ?? 0,
          modifiers: modifiers ?? 0);
    },
    "RawKeyEventDataLinux": () {
      final keyHelper =
          getValue(maps["keyHelper"], datas, "KeyHelper", vars, props);
      final unicodeScalarValues =
          getValue(maps["unicodeScalarValues"], datas, "int", vars, props);
      final scanCode = getValue(maps["scanCode"], datas, "int", vars, props);
      final keyCode = getValue(maps["keyCode"], datas, "int", vars, props);
      final modifiers = getValue(maps["modifiers"], datas, "int", vars, props);
      final isDown = getValue(maps["isDown"], datas, "bool", vars, props);
      final specifiedLogicalKey =
          getValue(maps["specifiedLogicalKey"], datas, "int?", vars, props);
      if (keyHelper == null || isDown == null) {
        return null;
      }
      return RawKeyEventDataLinux(
          keyHelper: keyHelper!,
          unicodeScalarValues: unicodeScalarValues ?? 0,
          scanCode: scanCode ?? 0,
          keyCode: keyCode ?? 0,
          modifiers: modifiers ?? 0,
          isDown: isDown!,
          specifiedLogicalKey: specifiedLogicalKey);
    },
    "RawKeyEventDataMacOs": () {
      final characters =
          getValue(maps["characters"], datas, "String", vars, props);
      final charactersIgnoringModifiers = getValue(
          maps["charactersIgnoringModifiers"], datas, "String", vars, props);
      final keyCode = getValue(maps["keyCode"], datas, "int", vars, props);
      final modifiers = getValue(maps["modifiers"], datas, "int", vars, props);
      final specifiedLogicalKey =
          getValue(maps["specifiedLogicalKey"], datas, "int?", vars, props);
      return RawKeyEventDataMacOs(
          characters: characters ?? '',
          charactersIgnoringModifiers: charactersIgnoringModifiers ?? '',
          keyCode: keyCode ?? 0,
          modifiers: modifiers ?? 0,
          specifiedLogicalKey: specifiedLogicalKey);
    },
    "RawKeyEventDataWeb": () {
      final code = getValue(maps["code"], datas, "String", vars, props);
      final key = getValue(maps["key"], datas, "String", vars, props);
      final location = getValue(maps["location"], datas, "int", vars, props);
      final metaState = getValue(maps["metaState"], datas, "int", vars, props);
      final keyCode = getValue(maps["keyCode"], datas, "int", vars, props);
      if (code == null || key == null) {
        return null;
      }
      if (metaState != null) {
        return RawKeyEventDataWeb(
            code: code!,
            key: key!,
            location: location ?? 0,
            keyCode: keyCode ?? 0,
            metaState: metaState);
      }
      return RawKeyEventDataWeb(
          code: code!,
          key: key!,
          location: location ?? 0,
          keyCode: keyCode ?? 0);
    },
    "RawKeyEventDataWindows": () {
      final keyCode = getValue(maps["keyCode"], datas, "int", vars, props);
      final scanCode = getValue(maps["scanCode"], datas, "int", vars, props);
      final characterCodePoint =
          getValue(maps["characterCodePoint"], datas, "int", vars, props);
      final modifiers = getValue(maps["modifiers"], datas, "int", vars, props);
      return RawKeyEventDataWindows(
          keyCode: keyCode ?? 0,
          scanCode: scanCode ?? 0,
          characterCodePoint: characterCodePoint ?? 0,
          modifiers: modifiers ?? 0);
    },
    "RawKeyUpEvent": () {
      final data =
          getValue(maps["data"], datas, "RawKeyEventData", vars, props);
      final character =
          getValue(maps["character"], datas, "String?", vars, props);
      if (data == null) {
        return null;
      }
      return RawKeyUpEvent(data: data!, character: character);
    },
    "RawKeyboardListener": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final focusNode =
          getValue(maps["focusNode"], datas, "FocusNode", vars, props);
      final autofocus = getValue(maps["autofocus"], datas, "bool", vars, props);
      final includeSemantics =
          getValue(maps["includeSemantics"], datas, "bool", vars, props);
      final onKey = getValue(
          maps["onKey"], datas, "ValueChanged<RawKeyEvent>?", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (focusNode == null || child == null) {
        return null;
      }
      return RawKeyboardListener(
          key: key,
          focusNode: focusNode!,
          autofocus: autofocus ?? false,
          includeSemantics: includeSemantics ?? true,
          onKey: onKey,
          child: child!);
    },
    "RawMagnifier": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final child = getValue(maps["child"], datas, "", vars, props);
      final decoration = getValue(maps["decoration"], datas, "", vars, props);
      final focalPointOffset =
          getValue(maps["focalPointOffset"], datas, "", vars, props);
      final magnificationScale =
          getValue(maps["magnificationScale"], datas, "", vars, props);
      final size = getValue(maps["size"], datas, "", vars, props);
      if (size == null) {
        return null;
      }
      return RawMagnifier(
          key: key,
          child: child,
          decoration: decoration ?? const MagnifierDecoration(),
          focalPointOffset: focalPointOffset ?? Offset.zero,
          magnificationScale: magnificationScale ?? 1,
          size: size!);
    },
    "RawMaterialButton": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final onPressed =
          getValue(maps["onPressed"], datas, "VoidCallback?", vars, props);
      final onLongPress =
          getValue(maps["onLongPress"], datas, "VoidCallback?", vars, props);
      final onHighlightChanged = getValue(maps["onHighlightChanged"], datas,
          "ValueChanged<bool>?", vars, props);
      final mouseCursor =
          getValue(maps["mouseCursor"], datas, "MouseCursor?", vars, props);
      final textStyle =
          getValue(maps["textStyle"], datas, "TextStyle?", vars, props);
      final fillColor =
          getValue(maps["fillColor"], datas, "Color?", vars, props);
      final focusColor =
          getValue(maps["focusColor"], datas, "Color?", vars, props);
      final hoverColor =
          getValue(maps["hoverColor"], datas, "Color?", vars, props);
      final highlightColor =
          getValue(maps["highlightColor"], datas, "Color?", vars, props);
      final splashColor =
          getValue(maps["splashColor"], datas, "Color?", vars, props);
      final elevation =
          getValue(maps["elevation"], datas, "double", vars, props);
      final focusElevation =
          getValue(maps["focusElevation"], datas, "double", vars, props);
      final hoverElevation =
          getValue(maps["hoverElevation"], datas, "double", vars, props);
      final highlightElevation =
          getValue(maps["highlightElevation"], datas, "double", vars, props);
      final disabledElevation =
          getValue(maps["disabledElevation"], datas, "double", vars, props);
      final padding =
          getValue(maps["padding"], datas, "EdgeInsetsGeometry", vars, props);
      final visualDensity =
          getValue(maps["visualDensity"], datas, "VisualDensity", vars, props);
      final constraints =
          getValue(maps["constraints"], datas, "BoxConstraints", vars, props);
      final shape = getValue(maps["shape"], datas, "ShapeBorder", vars, props);
      final animationDuration =
          getValue(maps["animationDuration"], datas, "Duration", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      final focusNode =
          getValue(maps["focusNode"], datas, "FocusNode?", vars, props);
      final autofocus = getValue(maps["autofocus"], datas, "bool", vars, props);
      final materialTapTargetSize = getValue(maps["materialTapTargetSize"],
          datas, "MaterialTapTargetSize?", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      final enableFeedback =
          getValue(maps["enableFeedback"], datas, "bool", vars, props);
      if (onPressed == null) {
        return null;
      }
      return RawMaterialButton(
          key: key,
          onPressed: onPressed!,
          onLongPress: onLongPress,
          onHighlightChanged: onHighlightChanged,
          mouseCursor: mouseCursor,
          textStyle: textStyle,
          fillColor: fillColor,
          focusColor: focusColor,
          hoverColor: hoverColor,
          highlightColor: highlightColor,
          splashColor: splashColor,
          elevation: elevation ?? 2.0,
          focusElevation: focusElevation ?? 4.0,
          hoverElevation: hoverElevation ?? 4.0,
          highlightElevation: highlightElevation ?? 8.0,
          disabledElevation: disabledElevation ?? 0.0,
          padding: padding ?? EdgeInsets.zero,
          visualDensity: visualDensity ?? VisualDensity.standard,
          constraints: constraints ??
              const BoxConstraints(minWidth: 88.0, minHeight: 36.0),
          shape: shape ?? const RoundedRectangleBorder(),
          animationDuration: animationDuration ?? kThemeChangeDuration,
          clipBehavior: clipBehavior ?? Clip.none,
          focusNode: focusNode,
          autofocus: autofocus ?? false,
          materialTapTargetSize: materialTapTargetSize,
          child: child,
          enableFeedback: enableFeedback ?? true);
    },
    "RawScrollbar": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      final controller =
          getValue(maps["controller"], datas, "ScrollController?", vars, props);
      final thumbVisibility =
          getValue(maps["thumbVisibility"], datas, "bool?", vars, props);
      final shape =
          getValue(maps["shape"], datas, "OutlinedBorder?", vars, props);
      final radius = getValue(maps["radius"], datas, "Radius?", vars, props);
      final thickness =
          getValue(maps["thickness"], datas, "double?", vars, props);
      final thumbColor =
          getValue(maps["thumbColor"], datas, "Color?", vars, props);
      final minThumbLength =
          getValue(maps["minThumbLength"], datas, "double", vars, props);
      final minOverscrollLength =
          getValue(maps["minOverscrollLength"], datas, "double?", vars, props);
      final trackVisibility =
          getValue(maps["trackVisibility"], datas, "bool?", vars, props);
      final trackRadius =
          getValue(maps["trackRadius"], datas, "Radius?", vars, props);
      final trackColor =
          getValue(maps["trackColor"], datas, "Color?", vars, props);
      final trackBorderColor =
          getValue(maps["trackBorderColor"], datas, "Color?", vars, props);
      final fadeDuration =
          getValue(maps["fadeDuration"], datas, "Duration", vars, props);
      final timeToFade =
          getValue(maps["timeToFade"], datas, "Duration", vars, props);
      final pressDuration =
          getValue(maps["pressDuration"], datas, "Duration", vars, props);
      final notificationPredicate = getValue(maps["notificationPredicate"],
          datas, "ScrollNotificationPredicate", vars, props);
      final interactive =
          getValue(maps["interactive"], datas, "bool?", vars, props);
      final scrollbarOrientation = getValue(maps["scrollbarOrientation"], datas,
          "ScrollbarOrientation?", vars, props);
      final mainAxisMargin =
          getValue(maps["mainAxisMargin"], datas, "double", vars, props);
      final crossAxisMargin =
          getValue(maps["crossAxisMargin"], datas, "double", vars, props);
      final padding =
          getValue(maps["padding"], datas, "EdgeInsets?", vars, props);
      final isAlwaysShown =
          getValue(maps["isAlwaysShown"], datas, "bool?", vars, props);
      if (child == null) {
        return null;
      }
      if (minThumbLength != null &&
          fadeDuration != null &&
          timeToFade != null) {
        return RawScrollbar(
            key: key,
            child: child!,
            controller: controller,
            thumbVisibility: thumbVisibility,
            shape: shape,
            radius: radius,
            thickness: thickness,
            thumbColor: thumbColor,
            minOverscrollLength: minOverscrollLength,
            trackVisibility: trackVisibility,
            trackRadius: trackRadius,
            trackColor: trackColor,
            trackBorderColor: trackBorderColor,
            pressDuration: pressDuration ?? Duration.zero,
            notificationPredicate:
                notificationPredicate ?? defaultScrollNotificationPredicate,
            interactive: interactive,
            scrollbarOrientation: scrollbarOrientation,
            mainAxisMargin: mainAxisMargin ?? 0.0,
            crossAxisMargin: crossAxisMargin ?? 0.0,
            padding: padding,
            //isAlwaysShown: isAlwaysShown,
            minThumbLength: minThumbLength,
            fadeDuration: fadeDuration,
            timeToFade: timeToFade);
      }
      if (minThumbLength != null && fadeDuration != null) {
        return RawScrollbar(
            key: key,
            child: child!,
            controller: controller,
            thumbVisibility: thumbVisibility,
            shape: shape,
            radius: radius,
            thickness: thickness,
            thumbColor: thumbColor,
            minOverscrollLength: minOverscrollLength,
            trackVisibility: trackVisibility,
            trackRadius: trackRadius,
            trackColor: trackColor,
            trackBorderColor: trackBorderColor,
            pressDuration: pressDuration ?? Duration.zero,
            notificationPredicate:
                notificationPredicate ?? defaultScrollNotificationPredicate,
            interactive: interactive,
            scrollbarOrientation: scrollbarOrientation,
            mainAxisMargin: mainAxisMargin ?? 0.0,
            crossAxisMargin: crossAxisMargin ?? 0.0,
            padding: padding,
            //isAlwaysShown: isAlwaysShown,
            minThumbLength: minThumbLength,
            fadeDuration: fadeDuration);
      }
      if (minThumbLength != null && timeToFade != null) {
        return RawScrollbar(
            key: key,
            child: child!,
            controller: controller,
            thumbVisibility: thumbVisibility,
            shape: shape,
            radius: radius,
            thickness: thickness,
            thumbColor: thumbColor,
            minOverscrollLength: minOverscrollLength,
            trackVisibility: trackVisibility,
            trackRadius: trackRadius,
            trackColor: trackColor,
            trackBorderColor: trackBorderColor,
            pressDuration: pressDuration ?? Duration.zero,
            notificationPredicate:
                notificationPredicate ?? defaultScrollNotificationPredicate,
            interactive: interactive,
            scrollbarOrientation: scrollbarOrientation,
            mainAxisMargin: mainAxisMargin ?? 0.0,
            crossAxisMargin: crossAxisMargin ?? 0.0,
            padding: padding,
            //isAlwaysShown: isAlwaysShown,
            minThumbLength: minThumbLength,
            timeToFade: timeToFade);
      }
      if (fadeDuration != null && timeToFade != null) {
        return RawScrollbar(
            key: key,
            child: child!,
            controller: controller,
            thumbVisibility: thumbVisibility,
            shape: shape,
            radius: radius,
            thickness: thickness,
            thumbColor: thumbColor,
            minOverscrollLength: minOverscrollLength,
            trackVisibility: trackVisibility,
            trackRadius: trackRadius,
            trackColor: trackColor,
            trackBorderColor: trackBorderColor,
            pressDuration: pressDuration ?? Duration.zero,
            notificationPredicate:
                notificationPredicate ?? defaultScrollNotificationPredicate,
            interactive: interactive,
            scrollbarOrientation: scrollbarOrientation,
            mainAxisMargin: mainAxisMargin ?? 0.0,
            crossAxisMargin: crossAxisMargin ?? 0.0,
            padding: padding,
            //isAlwaysShown: isAlwaysShown,
            fadeDuration: fadeDuration,
            timeToFade: timeToFade);
      }
      if (minThumbLength != null) {
        return RawScrollbar(
            key: key,
            child: child!,
            controller: controller,
            thumbVisibility: thumbVisibility,
            shape: shape,
            radius: radius,
            thickness: thickness,
            thumbColor: thumbColor,
            minOverscrollLength: minOverscrollLength,
            trackVisibility: trackVisibility,
            trackRadius: trackRadius,
            trackColor: trackColor,
            trackBorderColor: trackBorderColor,
            pressDuration: pressDuration ?? Duration.zero,
            notificationPredicate:
                notificationPredicate ?? defaultScrollNotificationPredicate,
            interactive: interactive,
            scrollbarOrientation: scrollbarOrientation,
            mainAxisMargin: mainAxisMargin ?? 0.0,
            crossAxisMargin: crossAxisMargin ?? 0.0,
            padding: padding,
            // isAlwaysShown: isAlwaysShown,
            minThumbLength: minThumbLength);
      }
      if (fadeDuration != null) {
        return RawScrollbar(
            key: key,
            child: child!,
            controller: controller,
            thumbVisibility: thumbVisibility,
            shape: shape,
            radius: radius,
            thickness: thickness,
            thumbColor: thumbColor,
            minOverscrollLength: minOverscrollLength,
            trackVisibility: trackVisibility,
            trackRadius: trackRadius,
            trackColor: trackColor,
            trackBorderColor: trackBorderColor,
            pressDuration: pressDuration ?? Duration.zero,
            notificationPredicate:
                notificationPredicate ?? defaultScrollNotificationPredicate,
            interactive: interactive,
            scrollbarOrientation: scrollbarOrientation,
            mainAxisMargin: mainAxisMargin ?? 0.0,
            crossAxisMargin: crossAxisMargin ?? 0.0,
            padding: padding,
            //isAlwaysShown: isAlwaysShown,
            fadeDuration: fadeDuration);
      }
      if (timeToFade != null) {
        return RawScrollbar(
            key: key,
            child: child!,
            controller: controller,
            thumbVisibility: thumbVisibility,
            shape: shape,
            radius: radius,
            thickness: thickness,
            thumbColor: thumbColor,
            minOverscrollLength: minOverscrollLength,
            trackVisibility: trackVisibility,
            trackRadius: trackRadius,
            trackColor: trackColor,
            trackBorderColor: trackBorderColor,
            pressDuration: pressDuration ?? Duration.zero,
            notificationPredicate:
                notificationPredicate ?? defaultScrollNotificationPredicate,
            interactive: interactive,
            scrollbarOrientation: scrollbarOrientation,
            mainAxisMargin: mainAxisMargin ?? 0.0,
            crossAxisMargin: crossAxisMargin ?? 0.0,
            padding: padding,
            //isAlwaysShown: isAlwaysShown,
            timeToFade: timeToFade);
      }
      return RawScrollbar(
        key: key,
        child: child!,
        controller: controller,
        thumbVisibility: thumbVisibility,
        shape: shape,
        radius: radius,
        thickness: thickness,
        thumbColor: thumbColor,
        minOverscrollLength: minOverscrollLength,
        trackVisibility: trackVisibility,
        trackRadius: trackRadius,
        trackColor: trackColor,
        trackBorderColor: trackBorderColor,
        pressDuration: pressDuration ?? Duration.zero,
        notificationPredicate:
            notificationPredicate ?? defaultScrollNotificationPredicate,
        interactive: interactive,
        scrollbarOrientation: scrollbarOrientation,
        mainAxisMargin: mainAxisMargin ?? 0.0,
        crossAxisMargin: crossAxisMargin ?? 0.0,
        padding: padding,
        //isAlwaysShown: isAlwaysShown,
      );
    },
    "ReadBuffer": () {
      final data = getValue(maps["0"], datas, "ByteData", vars, props);
      if (data == null) {
        return null;
      }
      return ReadBuffer(data!);
    },
    "Rect.fromLTRB": () {
      final left = getValue(maps["0"], datas, "double", vars, props);
      final top = getValue(maps["1"], datas, "double", vars, props);
      final right = getValue(maps["2"], datas, "double", vars, props);
      final bottom = getValue(maps["3"], datas, "double", vars, props);
      if (left == null || top == null || right == null || bottom == null) {
        return null;
      }
      return Rect.fromLTRB(left!, top!, right!, bottom!);
    },
    "Rect.fromLTWH": () {
      final left = getValue(maps["0"], datas, "double", vars, props);
      final top = getValue(maps["1"], datas, "double", vars, props);
      final width = getValue(maps["2"], datas, "double", vars, props);
      final height = getValue(maps["3"], datas, "double", vars, props);
      if (left == null || top == null || width == null || height == null) {
        return null;
      }
      return Rect.fromLTWH(left!, top!, width!, height!);
    },
    "Rect.fromCircle": () {
      final center = getValue(maps["center"], datas, "Offset", vars, props);
      final radius = getValue(maps["radius"], datas, "double", vars, props);
      if (center == null || radius == null) {
        return null;
      }
      return Rect.fromCircle(center: center!, radius: radius!);
    },
    "Rect.fromCenter": () {
      final center = getValue(maps["center"], datas, "Offset", vars, props);
      final width = getValue(maps["width"], datas, "double", vars, props);
      final height = getValue(maps["height"], datas, "double", vars, props);
      if (center == null || width == null || height == null) {
        return null;
      }
      return Rect.fromCenter(center: center!, width: width!, height: height!);
    },
    "Rect.fromPoints": () {
      final a = getValue(maps["0"], datas, "Offset", vars, props);
      final b = getValue(maps["1"], datas, "Offset", vars, props);
      if (a == null || b == null) {
        return null;
      }
      return Rect.fromPoints(a!, b!);
    },
    "RectTween": () {
      final begin = getValue(maps["begin"], datas, "T?", vars, props);
      final end = getValue(maps["end"], datas, "T?", vars, props);
      return RectTween(begin: begin, end: end);
    },
    "RectangularRangeSliderTrackShape": () {
      return const RectangularRangeSliderTrackShape();
    },
    "RectangularRangeSliderValueIndicatorShape": () {
      return const RectangularRangeSliderValueIndicatorShape();
    },
    "RectangularSliderTrackShape": () {
      return const RectangularSliderTrackShape();
    },
    "RectangularSliderValueIndicatorShape": () {
      return const RectangularSliderValueIndicatorShape();
    },
    "RedoTextIntent": () {
      final cause =
          getValue(maps["0"], datas, "SelectionChangedCause", vars, props);
      if (cause == null) {
        return null;
      }
      return RedoTextIntent(cause!);
    },
    "RefreshIndicator": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      final displacement =
          getValue(maps["displacement"], datas, "double", vars, props);
      final edgeOffset =
          getValue(maps["edgeOffset"], datas, "double", vars, props);
      final onRefresh =
          getValue(maps["onRefresh"], datas, "RefreshCallback", vars, props);
      final color = getValue(maps["color"], datas, "Color?", vars, props);
      final backgroundColor =
          getValue(maps["backgroundColor"], datas, "Color?", vars, props);
      final notificationPredicate = getValue(maps["notificationPredicate"],
          datas, "ScrollNotificationPredicate", vars, props);
      final semanticsLabel =
          getValue(maps["semanticsLabel"], datas, "String?", vars, props);
      final semanticsValue =
          getValue(maps["semanticsValue"], datas, "String?", vars, props);
      final strokeWidth =
          getValue(maps["strokeWidth"], datas, "double", vars, props);
      final triggerMode = getValue(maps["triggerMode"], datas,
          "RefreshIndicatorTriggerMode", vars, props);
      if (child == null || onRefresh == null) {
        return null;
      }
      return RefreshIndicator(
          key: key,
          child: child!,
          displacement: displacement ?? 40.0,
          edgeOffset: edgeOffset ?? 0.0,
          onRefresh: onRefresh!,
          color: color,
          backgroundColor: backgroundColor,
          notificationPredicate:
              notificationPredicate ?? defaultScrollNotificationPredicate,
          semanticsLabel: semanticsLabel,
          semanticsValue: semanticsValue,
          strokeWidth:
              strokeWidth ?? RefreshProgressIndicator.defaultStrokeWidth,
          triggerMode: triggerMode ?? RefreshIndicatorTriggerMode.onEdge);
    },
    "RefreshIndicator.adaptive": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      final displacement =
          getValue(maps["displacement"], datas, "double", vars, props);
      final edgeOffset =
          getValue(maps["edgeOffset"], datas, "double", vars, props);
      final onRefresh =
          getValue(maps["onRefresh"], datas, "RefreshCallback", vars, props);
      final color = getValue(maps["color"], datas, "Color?", vars, props);
      final backgroundColor =
          getValue(maps["backgroundColor"], datas, "Color?", vars, props);
      final notificationPredicate = getValue(maps["notificationPredicate"],
          datas, "ScrollNotificationPredicate", vars, props);
      final semanticsLabel =
          getValue(maps["semanticsLabel"], datas, "String?", vars, props);
      final semanticsValue =
          getValue(maps["semanticsValue"], datas, "String?", vars, props);
      final strokeWidth =
          getValue(maps["strokeWidth"], datas, "double", vars, props);
      final triggerMode = getValue(maps["triggerMode"], datas,
          "RefreshIndicatorTriggerMode", vars, props);
      if (child == null || onRefresh == null) {
        return null;
      }
      return RefreshIndicator.adaptive(
          key: key,
          child: child!,
          displacement: displacement ?? 40.0,
          edgeOffset: edgeOffset ?? 0.0,
          onRefresh: onRefresh!,
          color: color,
          backgroundColor: backgroundColor,
          notificationPredicate:
              notificationPredicate ?? defaultScrollNotificationPredicate,
          semanticsLabel: semanticsLabel,
          semanticsValue: semanticsValue,
          strokeWidth:
              strokeWidth ?? RefreshProgressIndicator.defaultStrokeWidth,
          triggerMode: triggerMode ?? RefreshIndicatorTriggerMode.onEdge);
    },
    "RefreshProgressIndicator": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final value = getValue(maps["value"], datas, "double?", vars, props);
      final backgroundColor =
          getValue(maps["backgroundColor"], datas, "Color?", vars, props);
      final color = getValue(maps["color"], datas, "Color?", vars, props);
      final valueColor = getValue(
          maps["valueColor"], datas, "Animation<Color?>?", vars, props);
      final strokeWidth =
          getValue(maps["strokeWidth"], datas, "double", vars, props);
      final semanticsLabel =
          getValue(maps["semanticsLabel"], datas, "String?", vars, props);
      final semanticsValue =
          getValue(maps["semanticsValue"], datas, "String?", vars, props);
      if (strokeWidth != null) {
        return RefreshProgressIndicator(
            key: key,
            value: value,
            backgroundColor: backgroundColor,
            color: color,
            valueColor: valueColor,
            semanticsLabel: semanticsLabel,
            semanticsValue: semanticsValue,
            strokeWidth: strokeWidth);
      }
      return RefreshProgressIndicator(
          key: key,
          value: value,
          backgroundColor: backgroundColor,
          color: color,
          valueColor: valueColor,
          semanticsLabel: semanticsLabel,
          semanticsValue: semanticsValue);
    },
    "RelativePositionedTransition": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final rect =
          getValue(maps["rect"], datas, "Animation<Rect?>", vars, props);
      final size = getValue(maps["size"], datas, "Size", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (rect == null || size == null || child == null) {
        return null;
      }
      return RelativePositionedTransition(
          key: key, rect: rect!, size: size!, child: child!);
    },
    "RelativeRect.fromLTRB": () {
      final left = getValue(maps["0"], datas, "double", vars, props);
      final top = getValue(maps["1"], datas, "double", vars, props);
      final right = getValue(maps["2"], datas, "double", vars, props);
      final bottom = getValue(maps["3"], datas, "double", vars, props);
      if (left == null || top == null || right == null || bottom == null) {
        return null;
      }
      return RelativeRect.fromLTRB(left!, top!, right!, bottom!);
    },
    "RelativeRect.fromSize": () {
      final rect = getValue(maps["0"], datas, "Rect", vars, props);
      final container = getValue(maps["1"], datas, "Size", vars, props);
      if (rect == null || container == null) {
        return null;
      }
      return RelativeRect.fromSize(rect!, container!);
    },
    "RelativeRect.fromRect": () {
      final rect = getValue(maps["0"], datas, "Rect", vars, props);
      final container = getValue(maps["1"], datas, "Rect", vars, props);
      if (rect == null || container == null) {
        return null;
      }
      return RelativeRect.fromRect(rect!, container!);
    },
    "RelativeRect.fromDirectional": () {
      final textDirection =
          getValue(maps["textDirection"], datas, "TextDirection", vars, props);
      final start = getValue(maps["start"], datas, "double", vars, props);
      final top = getValue(maps["top"], datas, "double", vars, props);
      final end = getValue(maps["end"], datas, "double", vars, props);
      final bottom = getValue(maps["bottom"], datas, "double", vars, props);
      if (textDirection == null ||
          start == null ||
          top == null ||
          end == null ||
          bottom == null) {
        return null;
      }
      return RelativeRect.fromDirectional(
          textDirection: textDirection!,
          start: start!,
          top: top!,
          end: end!,
          bottom: bottom!);
    },
    "RelativeRectTween": () {
      final begin = getValue(maps["begin"], datas, "T?", vars, props);
      final end = getValue(maps["end"], datas, "T?", vars, props);
      return RelativeRectTween(begin: begin, end: end);
    },
    "RenderAbsorbPointer": () {
      final child = getValue(maps["child"], datas, "RenderBox?", vars, props);
      final absorbing = getValue(maps["absorbing"], datas, "bool", vars, props);
      final ignoringSemantics =
          getValue(maps["ignoringSemantics"], datas, "bool?", vars, props);
      return RenderAbsorbPointer(
          child: child,
          absorbing: absorbing ?? true,
          ignoringSemantics: ignoringSemantics);
    },
    "RenderAndroidView": () {
      final viewController = getValue(
          maps["viewController"], datas, "AndroidViewController", vars, props);
      final hitTestBehavior = getValue(maps["hitTestBehavior"], datas,
          "PlatformViewHitTestBehavior", vars, props);
      final gestureRecognizers = getValue(maps["gestureRecognizers"], datas,
          "Set<Factory<OneSequenceGestureRecognizer>>", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      if (viewController == null ||
          hitTestBehavior == null ||
          gestureRecognizers == null) {
        return null;
      }
      return RenderAndroidView(
          viewController: viewController!,
          hitTestBehavior: hitTestBehavior!,
          gestureRecognizers: Set<Factory<OneSequenceGestureRecognizer>>.from(
              gestureRecognizers!),
          clipBehavior: clipBehavior ?? Clip.hardEdge);
    },
    "RenderAnimatedOpacity": () {
      final opacity =
          getValue(maps["opacity"], datas, "Animation<double>", vars, props);
      final alwaysIncludeSemantics =
          getValue(maps["alwaysIncludeSemantics"], datas, "bool", vars, props);
      final child = getValue(maps["child"], datas, "RenderBox?", vars, props);
      if (opacity == null) {
        return null;
      }
      return RenderAnimatedOpacity(
          opacity: opacity!,
          alwaysIncludeSemantics: alwaysIncludeSemantics ?? false,
          child: child);
    },
    "RenderAnimatedSize": () {
      final vsync =
          getValue(maps["vsync"], datas, "TickerProvider", vars, props);
      final duration =
          getValue(maps["duration"], datas, "Duration", vars, props);
      final reverseDuration =
          getValue(maps["reverseDuration"], datas, "Duration?", vars, props);
      final curve = getValue(maps["curve"], datas, "Curve", vars, props);
      final alignment =
          getValue(maps["alignment"], datas, "AlignmentGeometry", vars, props);
      final textDirection =
          getValue(maps["textDirection"], datas, "TextDirection?", vars, props);
      final child = getValue(maps["child"], datas, "RenderBox?", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      if (vsync == null || duration == null) {
        return null;
      }
      return RenderAnimatedSize(
          vsync: vsync!,
          duration: duration!,
          reverseDuration: reverseDuration,
          curve: curve ?? Curves.linear,
          alignment: alignment ?? Alignment.center,
          textDirection: textDirection,
          child: child,
          clipBehavior: clipBehavior ?? Clip.hardEdge);
    },
    "RenderAnnotatedRegion": () {
      final value = getValue(maps["value"], datas, "T", vars, props);
      final sized = getValue(maps["sized"], datas, "bool", vars, props);
      final child = getValue(maps["child"], datas, "RenderBox?", vars, props);
      if (value == null || sized == null) {
        return null;
      }
      return RenderAnnotatedRegion<T>(
          value: value!, sized: sized!, child: child);
    },
    "RenderAspectRatio": () {
      final child = getValue(maps["child"], datas, "RenderBox?", vars, props);
      final aspectRatio =
          getValue(maps["aspectRatio"], datas, "double", vars, props);
      if (aspectRatio == null) {
        return null;
      }
      return RenderAspectRatio(child: child, aspectRatio: aspectRatio!);
    },
    "RenderBackdropFilter": () {
      final child = getValue(maps["child"], datas, "RenderBox?", vars, props);
      final filter =
          getValue(maps["filter"], datas, "ImageFilter", vars, props);
      final blendMode =
          getValue(maps["blendMode"], datas, "BlendMode", vars, props);
      if (filter == null) {
        return null;
      }
      return RenderBackdropFilter(
          child: child,
          filter: filter!,
          blendMode: blendMode ?? BlendMode.srcOver);
    },
    "RenderBaseline": () {
      final child = getValue(maps["child"], datas, "RenderBox?", vars, props);
      final baseline = getValue(maps["baseline"], datas, "double", vars, props);
      final baselineType =
          getValue(maps["baselineType"], datas, "TextBaseline", vars, props);
      if (baseline == null || baselineType == null) {
        return null;
      }
      return RenderBaseline(
          child: child, baseline: baseline!, baselineType: baselineType!);
    },
    "RenderBlockSemantics": () {
      final child = getValue(maps["child"], datas, "RenderBox?", vars, props);
      final blocking = getValue(maps["blocking"], datas, "bool", vars, props);
      return RenderBlockSemantics(child: child, blocking: blocking ?? true);
    },
    "RenderClipOval": () {
      final child = getValue(maps["child"], datas, "RenderBox?", vars, props);
      final clipper =
          getValue(maps["clipper"], datas, "CustomClipper<T>?", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      return RenderClipOval(
          child: child,
          clipper: clipper,
          clipBehavior: clipBehavior ?? Clip.antiAlias);
    },
    "RenderClipPath": () {
      final child = getValue(maps["child"], datas, "RenderBox?", vars, props);
      final clipper =
          getValue(maps["clipper"], datas, "CustomClipper<T>?", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      return RenderClipPath(
          child: child,
          clipper: clipper,
          clipBehavior: clipBehavior ?? Clip.antiAlias);
    },
    "RenderClipRRect": () {
      final child = getValue(maps["child"], datas, "RenderBox?", vars, props);
      final borderRadius = getValue(
          maps["borderRadius"], datas, "BorderRadiusGeometry", vars, props);
      final clipper =
          getValue(maps["clipper"], datas, "CustomClipper<T>?", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      final textDirection =
          getValue(maps["textDirection"], datas, "TextDirection?", vars, props);
      return RenderClipRRect(
          child: child,
          borderRadius: borderRadius ?? BorderRadius.zero,
          clipper: clipper,
          clipBehavior: clipBehavior ?? Clip.antiAlias,
          textDirection: textDirection);
    },
    "RenderClipRect": () {
      final child = getValue(maps["child"], datas, "RenderBox?", vars, props);
      final clipper =
          getValue(maps["clipper"], datas, "CustomClipper<T>?", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      return RenderClipRect(
          child: child,
          clipper: clipper,
          clipBehavior: clipBehavior ?? Clip.antiAlias);
    },
    "RenderConstrainedBox": () {
      final child = getValue(maps["child"], datas, "RenderBox?", vars, props);
      final additionalConstraints = getValue(
          maps["additionalConstraints"], datas, "BoxConstraints", vars, props);
      if (additionalConstraints == null) {
        return null;
      }
      return RenderConstrainedBox(
          child: child, additionalConstraints: additionalConstraints!);
    },
    "RenderConstrainedOverflowBox": () {
      final child = getValue(maps["child"], datas, "RenderBox?", vars, props);
      final minWidth =
          getValue(maps["minWidth"], datas, "double?", vars, props);
      final maxWidth =
          getValue(maps["maxWidth"], datas, "double?", vars, props);
      final minHeight =
          getValue(maps["minHeight"], datas, "double?", vars, props);
      final maxHeight =
          getValue(maps["maxHeight"], datas, "double?", vars, props);
      final alignment =
          getValue(maps["alignment"], datas, "AlignmentGeometry", vars, props);
      final textDirection =
          getValue(maps["textDirection"], datas, "TextDirection?", vars, props);
      return RenderConstrainedOverflowBox(
          child: child,
          minWidth: minWidth,
          maxWidth: maxWidth,
          minHeight: minHeight,
          maxHeight: maxHeight,
          alignment: alignment ?? Alignment.center,
          textDirection: textDirection);
    },
    "RenderConstraintsTransformBox": () {
      final alignment =
          getValue(maps["alignment"], datas, "AlignmentGeometry", vars, props);
      final textDirection =
          getValue(maps["textDirection"], datas, "TextDirection?", vars, props);
      final constraintsTransform = getValue(maps["constraintsTransform"], datas,
          "BoxConstraintsTransform", vars, props);
      final child = getValue(maps["child"], datas, "RenderBox?", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      if (alignment == null ||
          textDirection == null ||
          constraintsTransform == null) {
        return null;
      }
      return RenderConstraintsTransformBox(
          alignment: alignment ?? Alignment.center,
          textDirection: textDirection!,
          constraintsTransform: constraintsTransform!,
          child: child,
          clipBehavior: clipBehavior ?? Clip.none);
    },
    "RenderCustomPaint": () {
      final painter =
          getValue(maps["painter"], datas, "CustomPainter?", vars, props);
      final foregroundPainter = getValue(
          maps["foregroundPainter"], datas, "CustomPainter?", vars, props);
      final preferredSize =
          getValue(maps["preferredSize"], datas, "Size", vars, props);
      final isComplex = getValue(maps["isComplex"], datas, "bool", vars, props);
      final willChange =
          getValue(maps["willChange"], datas, "bool", vars, props);
      final child = getValue(maps["child"], datas, "RenderBox?", vars, props);
      return RenderCustomPaint(
          painter: painter,
          foregroundPainter: foregroundPainter,
          preferredSize: preferredSize ?? Size.zero,
          isComplex: isComplex ?? false,
          willChange: willChange ?? false,
          child: child);
    },
    "RenderCustomSingleChildLayoutBox": () {
      final child = getValue(maps["child"], datas, "RenderBox?", vars, props);
      final delegate = getValue(
          maps["delegate"], datas, "SingleChildLayoutDelegate", vars, props);
      if (delegate == null) {
        return null;
      }
      return RenderCustomSingleChildLayoutBox(
          child: child, delegate: delegate!);
    },
    "RenderDecoratedBox": () {
      final decoration =
          getValue(maps["decoration"], datas, "Decoration", vars, props);
      final position =
          getValue(maps["position"], datas, "DecorationPosition", vars, props);
      final configuration = getValue(
          maps["configuration"], datas, "ImageConfiguration", vars, props);
      final child = getValue(maps["child"], datas, "RenderBox?", vars, props);
      if (decoration == null) {
        return null;
      }
      return RenderDecoratedBox(
          decoration: decoration!,
          position: position ?? DecorationPosition.background,
          configuration: configuration ?? ImageConfiguration.empty,
          child: child);
    },
    "RenderEditable": () {
      final text = getValue(maps["text"], datas, "InlineSpan?", vars, props);
      final textDirection =
          getValue(maps["textDirection"], datas, "TextDirection", vars, props);
      final textAlign =
          getValue(maps["textAlign"], datas, "TextAlign", vars, props);
      final cursorColor =
          getValue(maps["cursorColor"], datas, "Color?", vars, props);
      final backgroundCursorColor =
          getValue(maps["backgroundCursorColor"], datas, "Color?", vars, props);
      final showCursor = getValue(
          maps["showCursor"], datas, "ValueNotifier<bool>?", vars, props);
      final hasFocus = getValue(maps["hasFocus"], datas, "bool?", vars, props);
      final startHandleLayerLink = getValue(
          maps["startHandleLayerLink"], datas, "LayerLink", vars, props);
      final endHandleLayerLink =
          getValue(maps["endHandleLayerLink"], datas, "LayerLink", vars, props);
      final maxLines = getValue(maps["maxLines"], datas, "int?", vars, props);
      final minLines = getValue(maps["minLines"], datas, "int?", vars, props);
      final expands = getValue(maps["expands"], datas, "bool", vars, props);
      final strutStyle =
          getValue(maps["strutStyle"], datas, "StrutStyle?", vars, props);
      final selectionColor =
          getValue(maps["selectionColor"], datas, "Color?", vars, props);
      final textScaleFactor =
          getValue(maps["textScaleFactor"], datas, "double", vars, props);
      final selection =
          getValue(maps["selection"], datas, "TextSelection?", vars, props);
      final offset =
          getValue(maps["offset"], datas, "ViewportOffset", vars, props);
      final onCaretChanged = getValue(
          maps["onCaretChanged"], datas, "CaretChangedHandler?", vars, props);
      final ignorePointer =
          getValue(maps["ignorePointer"], datas, "bool", vars, props);
      final readOnly = getValue(maps["readOnly"], datas, "bool", vars, props);
      final forceLine = getValue(maps["forceLine"], datas, "bool", vars, props);
      final textHeightBehavior = getValue(maps["textHeightBehavior"], datas,
          "TextHeightBehavior?", vars, props);
      final textWidthBasis = getValue(
          maps["textWidthBasis"], datas, "TextWidthBasis", vars, props);
      final obscuringCharacter =
          getValue(maps["obscuringCharacter"], datas, "String", vars, props);
      final obscureText =
          getValue(maps["obscureText"], datas, "bool", vars, props);
      final locale = getValue(maps["locale"], datas, "Locale?", vars, props);
      final cursorWidth =
          getValue(maps["cursorWidth"], datas, "double", vars, props);
      final cursorHeight =
          getValue(maps["cursorHeight"], datas, "double?", vars, props);
      final cursorRadius =
          getValue(maps["cursorRadius"], datas, "Radius?", vars, props);
      final paintCursorAboveText =
          getValue(maps["paintCursorAboveText"], datas, "bool", vars, props);
      final cursorOffset =
          getValue(maps["cursorOffset"], datas, "Offset", vars, props);
      final devicePixelRatio =
          getValue(maps["devicePixelRatio"], datas, "double", vars, props);
      final selectionHeightStyle = getValue(
          maps["selectionHeightStyle"], datas, "BoxHeightStyle", vars, props);
      final selectionWidthStyle = getValue(
          maps["selectionWidthStyle"], datas, "BoxWidthStyle", vars, props);
      final enableInteractiveSelection = getValue(
          maps["enableInteractiveSelection"], datas, "bool?", vars, props);
      final floatingCursorAddedMargin = getValue(
          maps["floatingCursorAddedMargin"], datas, "EdgeInsets", vars, props);
      final promptRectRange =
          getValue(maps["promptRectRange"], datas, "TextRange?", vars, props);
      final promptRectColor =
          getValue(maps["promptRectColor"], datas, "Color?", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      final textSelectionDelegate = getValue(maps["textSelectionDelegate"],
          datas, "TextSelectionDelegate", vars, props);
      final painter = getValue(
          maps["painter"], datas, "RenderEditablePainter?", vars, props);
      final foregroundPainter = getValue(maps["foregroundPainter"], datas,
          "RenderEditablePainter?", vars, props);
      final children =
          getValue(maps["children"], datas, "List<RenderBox>?", vars, props);
      if (textDirection == null ||
          startHandleLayerLink == null ||
          endHandleLayerLink == null ||
          offset == null ||
          textSelectionDelegate == null) {
        return null;
      }
      return RenderEditable(
          text: text,
          textDirection: textDirection!,
          textAlign: textAlign ?? TextAlign.start,
          cursorColor: cursorColor,
          backgroundCursorColor: backgroundCursorColor,
          showCursor: showCursor,
          hasFocus: hasFocus,
          startHandleLayerLink: startHandleLayerLink!,
          endHandleLayerLink: endHandleLayerLink!,
          maxLines: maxLines ?? 1,
          minLines: minLines,
          expands: expands ?? false,
          strutStyle: strutStyle,
          selectionColor: selectionColor,
          textScaleFactor: textScaleFactor ?? 1.0,
          selection: selection,
          offset: offset!,
          //  onCaretChanged: onCaretChanged,
          ignorePointer: ignorePointer ?? false,
          readOnly: readOnly ?? false,
          forceLine: forceLine ?? true,
          textHeightBehavior: textHeightBehavior,
          textWidthBasis: textWidthBasis ?? TextWidthBasis.parent,
          obscuringCharacter: obscuringCharacter ?? '•',
          obscureText: obscureText ?? false,
          locale: locale,
          cursorWidth: cursorWidth ?? 1.0,
          cursorHeight: cursorHeight,
          cursorRadius: cursorRadius,
          paintCursorAboveText: paintCursorAboveText ?? false,
          cursorOffset: cursorOffset ?? Offset.zero,
          devicePixelRatio: devicePixelRatio ?? 1.0,
          selectionHeightStyle: selectionHeightStyle ?? ui.BoxHeightStyle.tight,
          selectionWidthStyle: selectionWidthStyle ?? ui.BoxWidthStyle.tight,
          enableInteractiveSelection: enableInteractiveSelection,
          floatingCursorAddedMargin: floatingCursorAddedMargin ??
              const EdgeInsets.fromLTRB(4, 4, 4, 5),
          promptRectRange: promptRectRange,
          promptRectColor: promptRectColor,
          clipBehavior: clipBehavior ?? Clip.hardEdge,
          textSelectionDelegate: textSelectionDelegate!,
          painter: painter,
          foregroundPainter: foregroundPainter,
          children: children != null ? List<RenderBox>.from(children) : null);
    },
    "RenderErrorBox": () {
      final message = getValue(maps["0"], datas, "String", vars, props);
      return RenderErrorBox(message ?? '');
    },
    "RenderExcludeSemantics": () {
      final child = getValue(maps["child"], datas, "RenderBox?", vars, props);
      final excluding = getValue(maps["excluding"], datas, "bool", vars, props);
      return RenderExcludeSemantics(child: child, excluding: excluding ?? true);
    },
    "RenderFittedBox": () {
      final fit = getValue(maps["fit"], datas, "BoxFit", vars, props);
      final alignment =
          getValue(maps["alignment"], datas, "AlignmentGeometry", vars, props);
      final textDirection =
          getValue(maps["textDirection"], datas, "TextDirection?", vars, props);
      final child = getValue(maps["child"], datas, "RenderBox?", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      return RenderFittedBox(
          fit: fit ?? BoxFit.contain,
          alignment: alignment ?? Alignment.center,
          textDirection: textDirection,
          child: child,
          clipBehavior: clipBehavior ?? Clip.none);
    },
    "RenderFlex": () {
      final children =
          getValue(maps["children"], datas, "List<RenderBox>?", vars, props);
      final direction = getValue(maps["direction"], datas, "Axis", vars, props);
      final mainAxisSize =
          getValue(maps["mainAxisSize"], datas, "MainAxisSize", vars, props);
      final mainAxisAlignment = getValue(
          maps["mainAxisAlignment"], datas, "MainAxisAlignment", vars, props);
      final crossAxisAlignment = getValue(
          maps["crossAxisAlignment"], datas, "CrossAxisAlignment", vars, props);
      final textDirection =
          getValue(maps["textDirection"], datas, "TextDirection?", vars, props);
      final verticalDirection = getValue(
          maps["verticalDirection"], datas, "VerticalDirection", vars, props);
      final textBaseline =
          getValue(maps["textBaseline"], datas, "TextBaseline?", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      return RenderFlex(
          children: children != null ? List<RenderBox>.from(children) : null,
          direction: direction ?? Axis.horizontal,
          mainAxisSize: mainAxisSize ?? MainAxisSize.max,
          mainAxisAlignment: mainAxisAlignment ?? MainAxisAlignment.start,
          crossAxisAlignment: crossAxisAlignment ?? CrossAxisAlignment.center,
          textDirection: textDirection,
          verticalDirection: verticalDirection ?? VerticalDirection.down,
          textBaseline: textBaseline,
          clipBehavior: clipBehavior ?? Clip.none);
    },
    "RenderFlow": () {
      final children =
          getValue(maps["children"], datas, "List<RenderBox>?", vars, props);
      final delegate =
          getValue(maps["delegate"], datas, "FlowDelegate", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      if (delegate == null) {
        return null;
      }
      return RenderFlow(
          children: children != null ? List<RenderBox>.from(children) : null,
          delegate: delegate!,
          clipBehavior: clipBehavior ?? Clip.hardEdge);
    },
    "RenderFollowerLayer": () {
      final link = getValue(maps["link"], datas, "LayerLink", vars, props);
      final showWhenUnlinked =
          getValue(maps["showWhenUnlinked"], datas, "bool", vars, props);
      final offset = getValue(maps["offset"], datas, "Offset", vars, props);
      final leaderAnchor =
          getValue(maps["leaderAnchor"], datas, "Alignment", vars, props);
      final followerAnchor =
          getValue(maps["followerAnchor"], datas, "Alignment", vars, props);
      final child = getValue(maps["child"], datas, "RenderBox?", vars, props);
      if (link == null) {
        return null;
      }
      return RenderFollowerLayer(
          link: link!,
          showWhenUnlinked: showWhenUnlinked ?? true,
          offset: offset ?? Offset.zero,
          leaderAnchor: leaderAnchor ?? Alignment.topLeft,
          followerAnchor: followerAnchor ?? Alignment.topLeft,
          child: child);
    },
    "RenderFractionalTranslation": () {
      final translation =
          getValue(maps["translation"], datas, "Offset", vars, props);
      final transformHitTests =
          getValue(maps["transformHitTests"], datas, "bool", vars, props);
      final child = getValue(maps["child"], datas, "RenderBox?", vars, props);
      if (translation == null) {
        return null;
      }
      return RenderFractionalTranslation(
          translation: translation!,
          transformHitTests: transformHitTests ?? true,
          child: child);
    },
    "RenderFractionallySizedOverflowBox": () {
      final child = getValue(maps["child"], datas, "RenderBox?", vars, props);
      final widthFactor =
          getValue(maps["widthFactor"], datas, "double?", vars, props);
      final heightFactor =
          getValue(maps["heightFactor"], datas, "double?", vars, props);
      final alignment =
          getValue(maps["alignment"], datas, "AlignmentGeometry", vars, props);
      final textDirection =
          getValue(maps["textDirection"], datas, "TextDirection?", vars, props);
      return RenderFractionallySizedOverflowBox(
          child: child,
          widthFactor: widthFactor,
          heightFactor: heightFactor,
          alignment: alignment ?? Alignment.center,
          textDirection: textDirection);
    },
    "RenderIgnorePointer": () {
      final child = getValue(maps["child"], datas, "RenderBox?", vars, props);
      final ignoring = getValue(maps["ignoring"], datas, "bool", vars, props);
      final ignoringSemantics =
          getValue(maps["ignoringSemantics"], datas, "bool?", vars, props);
      return RenderIgnorePointer(
          child: child,
          ignoring: ignoring ?? true,
          ignoringSemantics: ignoringSemantics);
    },
    "RenderImage": () {
      final image = getValue(maps["image"], datas, "Image?", vars, props);
      final debugImageLabel =
          getValue(maps["debugImageLabel"], datas, "String?", vars, props);
      final width = getValue(maps["width"], datas, "double?", vars, props);
      final height = getValue(maps["height"], datas, "double?", vars, props);
      final scale = getValue(maps["scale"], datas, "double", vars, props);
      final color = getValue(maps["color"], datas, "Color?", vars, props);
      final opacity =
          getValue(maps["opacity"], datas, "Animation<double>?", vars, props);
      final colorBlendMode =
          getValue(maps["colorBlendMode"], datas, "BlendMode?", vars, props);
      final fit = getValue(maps["fit"], datas, "BoxFit?", vars, props);
      final alignment =
          getValue(maps["alignment"], datas, "AlignmentGeometry", vars, props);
      final repeat =
          getValue(maps["repeat"], datas, "ImageRepeat", vars, props);
      final centerSlice =
          getValue(maps["centerSlice"], datas, "Rect?", vars, props);
      final matchTextDirection =
          getValue(maps["matchTextDirection"], datas, "bool", vars, props);
      final textDirection =
          getValue(maps["textDirection"], datas, "TextDirection?", vars, props);
      final invertColors =
          getValue(maps["invertColors"], datas, "bool", vars, props);
      final isAntiAlias =
          getValue(maps["isAntiAlias"], datas, "bool", vars, props);
      final filterQuality =
          getValue(maps["filterQuality"], datas, "FilterQuality", vars, props);
      return RenderImage(
          image: image,
          debugImageLabel: debugImageLabel,
          width: width,
          height: height,
          scale: scale ?? 1.0,
          color: color,
          opacity: opacity,
          colorBlendMode: colorBlendMode,
          fit: fit,
          alignment: alignment ?? Alignment.center,
          repeat: repeat ?? ImageRepeat.noRepeat,
          centerSlice: centerSlice,
          matchTextDirection: matchTextDirection ?? false,
          textDirection: textDirection,
          invertColors: invertColors ?? false,
          isAntiAlias: isAntiAlias ?? false,
          filterQuality: filterQuality ?? FilterQuality.low);
    },
    "RenderIndexedSemantics": () {
      final child = getValue(maps["child"], datas, "RenderBox?", vars, props);
      final index = getValue(maps["index"], datas, "int", vars, props);
      if (index == null) {
        return null;
      }
      return RenderIndexedSemantics(child: child, index: index!);
    },
    "RenderIndexedStack": () {
      final children =
          getValue(maps["children"], datas, "List<RenderBox>?", vars, props);
      final alignment =
          getValue(maps["alignment"], datas, "AlignmentGeometry", vars, props);
      final textDirection =
          getValue(maps["textDirection"], datas, "TextDirection?", vars, props);
      final fit = getValue(maps["fit"], datas, "StackFit", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      final index = getValue(maps["index"], datas, "int?", vars, props);
      return RenderIndexedStack(
          children: children != null ? List<RenderBox>.from(children) : null,
          alignment: alignment ?? AlignmentDirectional.topStart,
          textDirection: textDirection,
          fit: fit ?? StackFit.loose,
          clipBehavior: clipBehavior ?? Clip.hardEdge,
          index: index ?? 0);
    },
    "RenderIntrinsicHeight": () {
      final child = getValue(maps["child"], datas, "RenderBox?", vars, props);
      return RenderIntrinsicHeight(child: child);
    },
    "RenderIntrinsicWidth": () {
      final stepWidth =
          getValue(maps["stepWidth"], datas, "double?", vars, props);
      final stepHeight =
          getValue(maps["stepHeight"], datas, "double?", vars, props);
      final child = getValue(maps["child"], datas, "RenderBox?", vars, props);
      return RenderIntrinsicWidth(
          stepWidth: stepWidth, stepHeight: stepHeight, child: child);
    },
    "RenderLeaderLayer": () {
      final link = getValue(maps["link"], datas, "LayerLink", vars, props);
      final child = getValue(maps["child"], datas, "RenderBox?", vars, props);
      if (link == null) {
        return null;
      }
      return RenderLeaderLayer(link: link!, child: child);
    },
    "RenderLimitedBox": () {
      final child = getValue(maps["child"], datas, "RenderBox?", vars, props);
      final maxWidth = getValue(maps["maxWidth"], datas, "double", vars, props);
      final maxHeight =
          getValue(maps["maxHeight"], datas, "double", vars, props);
      return RenderLimitedBox(
          child: child,
          maxWidth: maxWidth ?? double.infinity,
          maxHeight: maxHeight ?? double.infinity);
    },
    "RenderListBody": () {
      final children =
          getValue(maps["children"], datas, "List<RenderBox>?", vars, props);
      final axisDirection =
          getValue(maps["axisDirection"], datas, "AxisDirection", vars, props);
      return RenderListBody(
          children: children != null ? List<RenderBox>.from(children) : null,
          axisDirection: axisDirection ?? AxisDirection.down);
    },
    "RenderListWheelViewport": () {
      final childManager = getValue(
          maps["childManager"], datas, "ListWheelChildManager", vars, props);
      final offset =
          getValue(maps["offset"], datas, "ViewportOffset", vars, props);
      final diameterRatio =
          getValue(maps["diameterRatio"], datas, "double", vars, props);
      final perspective =
          getValue(maps["perspective"], datas, "double", vars, props);
      final offAxisFraction =
          getValue(maps["offAxisFraction"], datas, "double", vars, props);
      final useMagnifier =
          getValue(maps["useMagnifier"], datas, "bool", vars, props);
      final magnification =
          getValue(maps["magnification"], datas, "double", vars, props);
      final overAndUnderCenterOpacity = getValue(
          maps["overAndUnderCenterOpacity"], datas, "double", vars, props);
      final itemExtent =
          getValue(maps["itemExtent"], datas, "double", vars, props);
      final squeeze = getValue(maps["squeeze"], datas, "double", vars, props);
      final renderChildrenOutsideViewport = getValue(
          maps["renderChildrenOutsideViewport"], datas, "bool", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      final children =
          getValue(maps["children"], datas, "List<RenderBox>?", vars, props);
      if (childManager == null || offset == null || itemExtent == null) {
        return null;
      }
      if (diameterRatio != null && perspective != null) {
        return RenderListWheelViewport(
            childManager: childManager!,
            offset: offset!,
            offAxisFraction: offAxisFraction ?? 0,
            useMagnifier: useMagnifier ?? false,
            magnification: magnification ?? 1,
            overAndUnderCenterOpacity: overAndUnderCenterOpacity ?? 1,
            itemExtent: itemExtent!,
            squeeze: squeeze ?? 1,
            renderChildrenOutsideViewport:
                renderChildrenOutsideViewport ?? false,
            clipBehavior: clipBehavior ?? Clip.none,
            children: children != null ? List<RenderBox>.from(children) : null,
            diameterRatio: diameterRatio,
            perspective: perspective);
      }
      if (diameterRatio != null) {
        return RenderListWheelViewport(
            childManager: childManager!,
            offset: offset!,
            offAxisFraction: offAxisFraction ?? 0,
            useMagnifier: useMagnifier ?? false,
            magnification: magnification ?? 1,
            overAndUnderCenterOpacity: overAndUnderCenterOpacity ?? 1,
            itemExtent: itemExtent!,
            squeeze: squeeze ?? 1,
            renderChildrenOutsideViewport:
                renderChildrenOutsideViewport ?? false,
            clipBehavior: clipBehavior ?? Clip.none,
            children: children != null ? List<RenderBox>.from(children) : null,
            diameterRatio: diameterRatio);
      }
      if (perspective != null) {
        return RenderListWheelViewport(
            childManager: childManager!,
            offset: offset!,
            offAxisFraction: offAxisFraction ?? 0,
            useMagnifier: useMagnifier ?? false,
            magnification: magnification ?? 1,
            overAndUnderCenterOpacity: overAndUnderCenterOpacity ?? 1,
            itemExtent: itemExtent!,
            squeeze: squeeze ?? 1,
            renderChildrenOutsideViewport:
                renderChildrenOutsideViewport ?? false,
            clipBehavior: clipBehavior ?? Clip.none,
            children: children != null ? List<RenderBox>.from(children) : null,
            perspective: perspective);
      }
      return RenderListWheelViewport(
          childManager: childManager!,
          offset: offset!,
          offAxisFraction: offAxisFraction ?? 0,
          useMagnifier: useMagnifier ?? false,
          magnification: magnification ?? 1,
          overAndUnderCenterOpacity: overAndUnderCenterOpacity ?? 1,
          itemExtent: itemExtent!,
          squeeze: squeeze ?? 1,
          renderChildrenOutsideViewport: renderChildrenOutsideViewport ?? false,
          clipBehavior: clipBehavior ?? Clip.none,
          children: children != null ? List<RenderBox>.from(children) : null);
    },
    "RenderMergeSemantics": () {
      final child = getValue(maps["child"], datas, "RenderBox?", vars, props);
      return RenderMergeSemantics(child: child);
    },
    "RenderMetaData": () {
      final metaData =
          getValue(maps["metaData"], datas, "dynamic", vars, props);
      final behavior =
          getValue(maps["behavior"], datas, "HitTestBehavior", vars, props);
      final child = getValue(maps["child"], datas, "RenderBox?", vars, props);
      return RenderMetaData(
          metaData: metaData,
          behavior: behavior ?? HitTestBehavior.deferToChild,
          child: child);
    },
    "RenderMouseRegion": () {
      final onEnter = getValue(
          maps["onEnter"], datas, "PointerEnterEventListener?", vars, props);
      final onHover = getValue(
          maps["onHover"], datas, "PointerHoverEventListener?", vars, props);
      final onExit = getValue(
          maps["onExit"], datas, "PointerExitEventListener?", vars, props);
      final cursor =
          getValue(maps["cursor"], datas, "MouseCursor", vars, props);
      final validForMouseTracker =
          getValue(maps["validForMouseTracker"], datas, "bool", vars, props);
      final opaque = getValue(maps["opaque"], datas, "bool", vars, props);
      final child = getValue(maps["child"], datas, "RenderBox?", vars, props);
      final hitTestBehavior = getValue(
          maps["hitTestBehavior"], datas, "HitTestBehavior?", vars, props);
      return RenderMouseRegion(
          onEnter: onEnter,
          onHover: onHover,
          onExit: onExit,
          cursor: cursor ?? MouseCursor.defer,
          validForMouseTracker: validForMouseTracker ?? true,
          opaque: opaque ?? true,
          child: child,
          hitTestBehavior: hitTestBehavior ?? HitTestBehavior.opaque);
    },
    "RenderNestedScrollViewViewport": () {
      final axisDirection =
          getValue(maps["axisDirection"], datas, "", vars, props);
      final crossAxisDirection =
          getValue(maps["crossAxisDirection"], datas, "", vars, props);
      final offset = getValue(maps["offset"], datas, "", vars, props);
      final anchor = getValue(maps["anchor"], datas, "double", vars, props);
      final children =
          getValue(maps["children"], datas, "List<RenderSliver>?", vars, props);
      final center =
          getValue(maps["center"], datas, "RenderSliver?", vars, props);
      final handle = getValue(
          maps["handle"], datas, "SliverOverlapAbsorberHandle", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "", vars, props);
      if (crossAxisDirection == null || offset == null || handle == null) {
        return null;
      }
      return RenderNestedScrollViewViewport(
          axisDirection: axisDirection,
          crossAxisDirection: crossAxisDirection!,
          offset: offset!,
          anchor: anchor ?? 0.0,
          children: children != null ? List<RenderSliver>.from(children) : null,
          center: center,
          handle: handle!,
          clipBehavior: clipBehavior);
    },
    "RenderObjectToWidgetAdapter": () {
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      final container = getValue(maps["container"], datas,
          "RenderObjectWithChildMixin<T>", vars, props);
      final debugShortDescription = getValue(
          maps["debugShortDescription"], datas, "String?", vars, props);
      if (container == null) {
        return null;
      }
      return RenderObjectToWidgetAdapter(
          child: child,
          container: container!,
          debugShortDescription: debugShortDescription);
    },
    "RenderObjectToWidgetElement": () {
      final widget = getValue(
          maps["0"], datas, "RenderObjectToWidgetAdapter<T>", vars, props);
      if (widget == null) {
        return null;
      }
      return RenderObjectToWidgetElement(widget!);
    },
    "RenderOffstage": () {
      final offstage = getValue(maps["offstage"], datas, "bool", vars, props);
      final child = getValue(maps["child"], datas, "RenderBox?", vars, props);
      return RenderOffstage(offstage: offstage ?? true, child: child);
    },
    "RenderOpacity": () {
      final opacity = getValue(maps["opacity"], datas, "double", vars, props);
      final alwaysIncludeSemantics =
          getValue(maps["alwaysIncludeSemantics"], datas, "bool", vars, props);
      final child = getValue(maps["child"], datas, "RenderBox?", vars, props);
      return RenderOpacity(
          opacity: opacity ?? 1.0,
          alwaysIncludeSemantics: alwaysIncludeSemantics ?? false,
          child: child);
    },
    "RenderPadding": () {
      final padding =
          getValue(maps["padding"], datas, "EdgeInsetsGeometry", vars, props);
      final textDirection =
          getValue(maps["textDirection"], datas, "TextDirection?", vars, props);
      final child = getValue(maps["child"], datas, "RenderBox?", vars, props);
      if (padding == null) {
        return null;
      }
      return RenderPadding(
          padding: padding!, textDirection: textDirection, child: child);
    },
    "RenderParagraph": () {
      final text = getValue(maps["0"], datas, "InlineSpan", vars, props);
      final textAlign =
          getValue(maps["textAlign"], datas, "TextAlign", vars, props);
      final textDirection =
          getValue(maps["textDirection"], datas, "TextDirection", vars, props);
      final softWrap = getValue(maps["softWrap"], datas, "bool", vars, props);
      final overflow =
          getValue(maps["overflow"], datas, "TextOverflow", vars, props);
      final textScaleFactor =
          getValue(maps["textScaleFactor"], datas, "double", vars, props);
      final maxLines = getValue(maps["maxLines"], datas, "int?", vars, props);
      final locale = getValue(maps["locale"], datas, "Locale?", vars, props);
      final strutStyle =
          getValue(maps["strutStyle"], datas, "StrutStyle?", vars, props);
      final textWidthBasis = getValue(
          maps["textWidthBasis"], datas, "TextWidthBasis", vars, props);
      final textHeightBehavior = getValue(maps["textHeightBehavior"], datas,
          "TextHeightBehavior?", vars, props);
      final children =
          getValue(maps["children"], datas, "List<RenderBox>?", vars, props);
      final selectionColor =
          getValue(maps["selectionColor"], datas, "Color?", vars, props);
      final registrar = getValue(
          maps["registrar"], datas, "SelectionRegistrar?", vars, props);
      if (text == null || textDirection == null) {
        return null;
      }
      return RenderParagraph(text!,
          textAlign: textAlign ?? TextAlign.start,
          textDirection: textDirection!,
          softWrap: softWrap ?? true,
          overflow: overflow ?? TextOverflow.clip,
          textScaleFactor: textScaleFactor ?? 1.0,
          maxLines: maxLines,
          locale: locale,
          strutStyle: strutStyle,
          textWidthBasis: textWidthBasis ?? TextWidthBasis.parent,
          textHeightBehavior: textHeightBehavior,
          children: children != null ? List<RenderBox>.from(children) : null,
          selectionColor: selectionColor,
          registrar: registrar);
    },
    "RenderPerformanceOverlay": () {
      final optionsMask =
          getValue(maps["optionsMask"], datas, "int", vars, props);
      final rasterizerThreshold =
          getValue(maps["rasterizerThreshold"], datas, "int", vars, props);
      final checkerboardRasterCacheImages = getValue(
          maps["checkerboardRasterCacheImages"], datas, "bool", vars, props);
      final checkerboardOffscreenLayers = getValue(
          maps["checkerboardOffscreenLayers"], datas, "bool", vars, props);
      return RenderPerformanceOverlay(
          optionsMask: optionsMask ?? 0,
          rasterizerThreshold: rasterizerThreshold ?? 0,
          checkerboardRasterCacheImages: checkerboardRasterCacheImages ?? false,
          checkerboardOffscreenLayers: checkerboardOffscreenLayers ?? false);
    },
    "RenderPhysicalModel": () {
      final child = getValue(maps["child"], datas, "RenderBox?", vars, props);
      final shape = getValue(maps["shape"], datas, "BoxShape", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      final borderRadius =
          getValue(maps["borderRadius"], datas, "BorderRadius?", vars, props);
      final elevation =
          getValue(maps["elevation"], datas, "double", vars, props);
      final color = getValue(maps["color"], datas, "Color", vars, props);
      final shadowColor =
          getValue(maps["shadowColor"], datas, "Color", vars, props);
      if (color == null) {
        return null;
      }
      return RenderPhysicalModel(
          child: child,
          shape: shape ?? BoxShape.rectangle,
          clipBehavior: clipBehavior ?? Clip.none,
          borderRadius: borderRadius,
          elevation: elevation ?? 0.0,
          color: color!,
          shadowColor: shadowColor ?? const Color(0xFF000000));
    },
    "RenderPhysicalShape": () {
      final child = getValue(maps["child"], datas, "RenderBox?", vars, props);
      final clipper =
          getValue(maps["clipper"], datas, "CustomClipper<Path>", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      final elevation =
          getValue(maps["elevation"], datas, "double", vars, props);
      final color = getValue(maps["color"], datas, "Color", vars, props);
      final shadowColor =
          getValue(maps["shadowColor"], datas, "Color", vars, props);
      if (clipper == null || color == null) {
        return null;
      }
      return RenderPhysicalShape(
          child: child,
          clipper: clipper!,
          clipBehavior: clipBehavior ?? Clip.none,
          elevation: elevation ?? 0.0,
          color: color!,
          shadowColor: shadowColor ?? const Color(0xFF000000));
    },
    "RenderPointerListener": () {
      final onPointerDown = getValue(maps["onPointerDown"], datas,
          "PointerDownEventListener?", vars, props);
      final onPointerMove = getValue(maps["onPointerMove"], datas,
          "PointerMoveEventListener?", vars, props);
      final onPointerUp = getValue(
          maps["onPointerUp"], datas, "PointerUpEventListener?", vars, props);
      final onPointerHover = getValue(maps["onPointerHover"], datas,
          "PointerHoverEventListener?", vars, props);
      final onPointerCancel = getValue(maps["onPointerCancel"], datas,
          "PointerCancelEventListener?", vars, props);
      final onPointerPanZoomStart = getValue(maps["onPointerPanZoomStart"],
          datas, "PointerPanZoomStartEventListener?", vars, props);
      final onPointerPanZoomUpdate = getValue(maps["onPointerPanZoomUpdate"],
          datas, "PointerPanZoomUpdateEventListener?", vars, props);
      final onPointerPanZoomEnd = getValue(maps["onPointerPanZoomEnd"], datas,
          "PointerPanZoomEndEventListener?", vars, props);
      final onPointerSignal = getValue(maps["onPointerSignal"], datas,
          "PointerSignalEventListener?", vars, props);
      final behavior =
          getValue(maps["behavior"], datas, "HitTestBehavior", vars, props);
      final child = getValue(maps["child"], datas, "RenderBox?", vars, props);
      return RenderPointerListener(
          onPointerDown: onPointerDown,
          onPointerMove: onPointerMove,
          onPointerUp: onPointerUp,
          onPointerHover: onPointerHover,
          onPointerCancel: onPointerCancel,
          onPointerPanZoomStart: onPointerPanZoomStart,
          onPointerPanZoomUpdate: onPointerPanZoomUpdate,
          onPointerPanZoomEnd: onPointerPanZoomEnd,
          onPointerSignal: onPointerSignal,
          behavior: behavior ?? HitTestBehavior.deferToChild,
          child: child);
    },
    "RenderPositionedBox": () {
      final child = getValue(maps["child"], datas, "RenderBox?", vars, props);
      final widthFactor =
          getValue(maps["widthFactor"], datas, "double?", vars, props);
      final heightFactor =
          getValue(maps["heightFactor"], datas, "double?", vars, props);
      final alignment =
          getValue(maps["alignment"], datas, "AlignmentGeometry", vars, props);
      final textDirection =
          getValue(maps["textDirection"], datas, "TextDirection?", vars, props);
      return RenderPositionedBox(
          child: child,
          widthFactor: widthFactor,
          heightFactor: heightFactor,
          alignment: alignment ?? Alignment.center,
          textDirection: textDirection);
    },
    "RenderProxyBox": () {
      final child = getValue(maps["0"], datas, "RenderBox?", vars, props);
      return RenderProxyBox(child);
    },
    "RenderRepaintBoundary": () {
      final child = getValue(maps["child"], datas, "RenderBox?", vars, props);
      return RenderRepaintBoundary(child: child);
    },
    "RenderRotatedBox": () {
      final quarterTurns =
          getValue(maps["quarterTurns"], datas, "int", vars, props);
      final child = getValue(maps["child"], datas, "RenderBox?", vars, props);
      if (quarterTurns == null) {
        return null;
      }
      return RenderRotatedBox(quarterTurns: quarterTurns!, child: child);
    },
    "RenderSemanticsAnnotations": () {
      final child = getValue(maps["child"], datas, "RenderBox?", vars, props);
      final properties = getValue(
          maps["properties"], datas, "SemanticsProperties", vars, props);
      final container = getValue(maps["container"], datas, "bool", vars, props);
      final explicitChildNodes =
          getValue(maps["explicitChildNodes"], datas, "bool", vars, props);
      final excludeSemantics =
          getValue(maps["excludeSemantics"], datas, "bool", vars, props);
      final textDirection =
          getValue(maps["textDirection"], datas, "TextDirection?", vars, props);
      if (properties == null) {
        return null;
      }
      return RenderSemanticsAnnotations(
          child: child,
          properties: properties!,
          container: container ?? false,
          explicitChildNodes: explicitChildNodes ?? false,
          excludeSemantics: excludeSemantics ?? false,
          textDirection: textDirection);
    },
    "RenderSemanticsGestureHandler": () {
      final child = getValue(maps["child"], datas, "RenderBox?", vars, props);
      final onTap =
          getValue(maps["onTap"], datas, "GestureTapCallback?", vars, props);
      final onLongPress = getValue(
          maps["onLongPress"], datas, "GestureLongPressCallback?", vars, props);
      final onHorizontalDragUpdate = getValue(maps["onHorizontalDragUpdate"],
          datas, "GestureDragUpdateCallback?", vars, props);
      final onVerticalDragUpdate = getValue(maps["onVerticalDragUpdate"], datas,
          "GestureDragUpdateCallback?", vars, props);
      final scrollFactor =
          getValue(maps["scrollFactor"], datas, "double", vars, props);
      final behavior =
          getValue(maps["behavior"], datas, "HitTestBehavior", vars, props);
      return RenderSemanticsGestureHandler(
          child: child,
          onTap: onTap,
          onLongPress: onLongPress,
          onHorizontalDragUpdate: onHorizontalDragUpdate,
          onVerticalDragUpdate: onVerticalDragUpdate,
          scrollFactor: scrollFactor ?? 0.8,
          behavior: behavior ?? HitTestBehavior.deferToChild);
    },
    "RenderShaderMask": () {
      final child = getValue(maps["child"], datas, "RenderBox?", vars, props);
      final shaderCallback = getValue(
          maps["shaderCallback"], datas, "ShaderCallback", vars, props);
      final blendMode =
          getValue(maps["blendMode"], datas, "BlendMode", vars, props);
      if (shaderCallback == null) {
        return null;
      }
      return RenderShaderMask(
          child: child,
          shaderCallback: shaderCallback!,
          blendMode: blendMode ?? BlendMode.modulate);
    },
    "RenderShrinkWrappingViewport": () {
      final axisDirection =
          getValue(maps["axisDirection"], datas, "", vars, props);
      final crossAxisDirection =
          getValue(maps["crossAxisDirection"], datas, "", vars, props);
      final offset = getValue(maps["offset"], datas, "", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "", vars, props);
      final children =
          getValue(maps["children"], datas, "List<RenderSliver>?", vars, props);
      if (crossAxisDirection == null || offset == null) {
        return null;
      }
      return RenderShrinkWrappingViewport(
          axisDirection: axisDirection,
          crossAxisDirection: crossAxisDirection!,
          offset: offset!,
          clipBehavior: clipBehavior,
          children:
              children != null ? List<RenderSliver>.from(children) : null);
    },
    "RenderSizedOverflowBox": () {
      final child = getValue(maps["child"], datas, "RenderBox?", vars, props);
      final requestedSize =
          getValue(maps["requestedSize"], datas, "Size", vars, props);
      final alignment =
          getValue(maps["alignment"], datas, "AlignmentGeometry", vars, props);
      final textDirection =
          getValue(maps["textDirection"], datas, "TextDirection?", vars, props);
      if (requestedSize == null) {
        return null;
      }
      return RenderSizedOverflowBox(
          child: child,
          requestedSize: requestedSize!,
          alignment: alignment ?? Alignment.center,
          textDirection: textDirection);
    },
    "RenderSliverAnimatedOpacity": () {
      final opacity =
          getValue(maps["opacity"], datas, "Animation<double>", vars, props);
      final alwaysIncludeSemantics =
          getValue(maps["alwaysIncludeSemantics"], datas, "bool", vars, props);
      final sliver =
          getValue(maps["sliver"], datas, "RenderSliver?", vars, props);
      if (opacity == null) {
        return null;
      }
      return RenderSliverAnimatedOpacity(
          opacity: opacity!,
          alwaysIncludeSemantics: alwaysIncludeSemantics ?? false,
          sliver: sliver);
    },
    "RenderSliverFillRemaining": () {
      final child = getValue(maps["child"], datas, "RenderBox?", vars, props);
      return RenderSliverFillRemaining(child: child);
    },
    "RenderSliverFillRemainingAndOverscroll": () {
      final child = getValue(maps["child"], datas, "RenderBox?", vars, props);
      return RenderSliverFillRemainingAndOverscroll(child: child);
    },
    "RenderSliverFillRemainingWithScrollable": () {
      final child = getValue(maps["child"], datas, "RenderBox?", vars, props);
      return RenderSliverFillRemainingWithScrollable(child: child);
    },
    "RenderSliverFillViewport": () {
      final childManager = getValue(maps["childManager"], datas,
          "RenderSliverBoxChildManager", vars, props);
      final viewportFraction =
          getValue(maps["viewportFraction"], datas, "double", vars, props);
      if (childManager == null) {
        return null;
      }
      return RenderSliverFillViewport(
          childManager: childManager!,
          viewportFraction: viewportFraction ?? 1.0);
    },
    "RenderSliverFixedExtentList": () {
      final childManager = getValue(maps["childManager"], datas,
          "RenderSliverBoxChildManager", vars, props);
      final itemExtent =
          getValue(maps["itemExtent"], datas, "double", vars, props);
      if (childManager == null || itemExtent == null) {
        return null;
      }
      return RenderSliverFixedExtentList(
          childManager: childManager!, itemExtent: itemExtent!);
    },
    "RenderSliverGrid": () {
      final childManager = getValue(maps["childManager"], datas,
          "RenderSliverBoxChildManager", vars, props);
      final gridDelegate = getValue(
          maps["gridDelegate"], datas, "SliverGridDelegate", vars, props);
      if (childManager == null || gridDelegate == null) {
        return null;
      }
      return RenderSliverGrid(
          childManager: childManager!, gridDelegate: gridDelegate!);
    },
    "RenderSliverIgnorePointer": () {
      final sliver =
          getValue(maps["sliver"], datas, "RenderSliver?", vars, props);
      final ignoring = getValue(maps["ignoring"], datas, "bool", vars, props);
      final ignoringSemantics =
          getValue(maps["ignoringSemantics"], datas, "bool?", vars, props);
      return RenderSliverIgnorePointer(
          sliver: sliver,
          ignoring: ignoring ?? true,
          ignoringSemantics: ignoringSemantics);
    },
    "RenderSliverList": () {
      final childManager = getValue(maps["childManager"], datas,
          "RenderSliverBoxChildManager", vars, props);
      if (childManager == null) {
        return null;
      }
      return RenderSliverList(childManager: childManager!);
    },
    "RenderSliverOffstage": () {
      final offstage = getValue(maps["offstage"], datas, "bool", vars, props);
      final sliver =
          getValue(maps["sliver"], datas, "RenderSliver?", vars, props);
      return RenderSliverOffstage(offstage: offstage ?? true, sliver: sliver);
    },
    "RenderSliverOpacity": () {
      final opacity = getValue(maps["opacity"], datas, "double", vars, props);
      final alwaysIncludeSemantics =
          getValue(maps["alwaysIncludeSemantics"], datas, "bool", vars, props);
      final sliver =
          getValue(maps["sliver"], datas, "RenderSliver?", vars, props);
      return RenderSliverOpacity(
          opacity: opacity ?? 1.0,
          alwaysIncludeSemantics: alwaysIncludeSemantics ?? false,
          sliver: sliver);
    },
    "RenderSliverOverlapAbsorber": () {
      final handle = getValue(
          maps["handle"], datas, "SliverOverlapAbsorberHandle", vars, props);
      final sliver =
          getValue(maps["sliver"], datas, "RenderSliver?", vars, props);
      if (handle == null) {
        return null;
      }
      return RenderSliverOverlapAbsorber(handle: handle!, sliver: sliver);
    },
    "RenderSliverOverlapInjector": () {
      final handle = getValue(
          maps["handle"], datas, "SliverOverlapAbsorberHandle", vars, props);
      if (handle == null) {
        return null;
      }
      return RenderSliverOverlapInjector(handle: handle!);
    },
    "RenderSliverPadding": () {
      final padding =
          getValue(maps["padding"], datas, "EdgeInsetsGeometry", vars, props);
      final textDirection =
          getValue(maps["textDirection"], datas, "TextDirection?", vars, props);
      final child =
          getValue(maps["child"], datas, "RenderSliver?", vars, props);
      if (padding == null) {
        return null;
      }
      return RenderSliverPadding(
          padding: padding!, textDirection: textDirection, child: child);
    },
    "RenderSliverToBoxAdapter": () {
      final child = getValue(maps["child"], datas, "RenderBox?", vars, props);
      return RenderSliverToBoxAdapter(child: child);
    },
    "RenderStack": () {
      final children =
          getValue(maps["children"], datas, "List<RenderBox>?", vars, props);
      final alignment =
          getValue(maps["alignment"], datas, "AlignmentGeometry", vars, props);
      final textDirection =
          getValue(maps["textDirection"], datas, "TextDirection?", vars, props);
      final fit = getValue(maps["fit"], datas, "StackFit", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      return RenderStack(
          children: children != null ? List<RenderBox>.from(children) : null,
          alignment: alignment ?? AlignmentDirectional.topStart,
          textDirection: textDirection,
          fit: fit ?? StackFit.loose,
          clipBehavior: clipBehavior ?? Clip.hardEdge);
    },
    "RenderTable": () {
      final columns = getValue(maps["columns"], datas, "int?", vars, props);
      final rows = getValue(maps["rows"], datas, "int?", vars, props);
      final columnWidths = getValue(maps["columnWidths"], datas,
          "Map<int,   TableColumnWidth>?", vars, props);
      final defaultColumnWidth = getValue(
          maps["defaultColumnWidth"], datas, "TableColumnWidth", vars, props);
      final textDirection =
          getValue(maps["textDirection"], datas, "TextDirection", vars, props);
      final border =
          getValue(maps["border"], datas, "TableBorder?", vars, props);
      final rowDecorations = getValue(
          maps["rowDecorations"], datas, "List<Decoration?>?", vars, props);
      final configuration = getValue(
          maps["configuration"], datas, "ImageConfiguration", vars, props);
      final defaultVerticalAlignment = getValue(
          maps["defaultVerticalAlignment"],
          datas,
          "TableCellVerticalAlignment",
          vars,
          props);
      final textBaseline =
          getValue(maps["textBaseline"], datas, "TextBaseline?", vars, props);
      final children = getValue(
          maps["children"], datas, "List<List<RenderBox>>?", vars, props);
      if (textDirection == null) {
        return null;
      }
      return RenderTable(
          columns: columns,
          rows: rows,
          columnWidths: columnWidths
              ? Map<int, TableColumnWidth>.from(columnWidths)
              : null,
          defaultColumnWidth: defaultColumnWidth ?? const FlexColumnWidth(),
          textDirection: textDirection!,
          border: border,
          rowDecorations: rowDecorations != null
              ? List<Decoration?>.from(rowDecorations)
              : null,
          configuration: configuration ?? ImageConfiguration.empty,
          defaultVerticalAlignment:
              defaultVerticalAlignment ?? TableCellVerticalAlignment.top,
          textBaseline: textBaseline,
          children:
              children != null ? List<List<RenderBox>>.from(children) : null);
    },
    "RenderTapRegion": () {
      final registry =
          getValue(maps["registry"], datas, "TapRegionRegistry?", vars, props);
      final enabled = getValue(maps["enabled"], datas, "bool", vars, props);
      final onTapOutside = getValue(
          maps["onTapOutside"], datas, "TapRegionCallback?", vars, props);
      final onTapInside = getValue(
          maps["onTapInside"], datas, "TapRegionCallback?", vars, props);
      final behavior =
          getValue(maps["behavior"], datas, "HitTestBehavior", vars, props);
      final groupId = getValue(maps["groupId"], datas, "Object?", vars, props);
      final debugLabel =
          getValue(maps["debugLabel"], datas, "String?", vars, props);
      return RenderTapRegion(
          registry: registry,
          enabled: enabled ?? true,
          onTapOutside: onTapOutside,
          onTapInside: onTapInside,
          behavior: behavior ?? HitTestBehavior.deferToChild,
          groupId: groupId,
          debugLabel: debugLabel);
    },
    "RenderTransform": () {
      final transform =
          getValue(maps["transform"], datas, "Matrix4", vars, props);
      final origin = getValue(maps["origin"], datas, "Offset?", vars, props);
      final alignment =
          getValue(maps["alignment"], datas, "AlignmentGeometry?", vars, props);
      final textDirection =
          getValue(maps["textDirection"], datas, "TextDirection?", vars, props);
      final transformHitTests =
          getValue(maps["transformHitTests"], datas, "bool", vars, props);
      final filterQuality =
          getValue(maps["filterQuality"], datas, "FilterQuality?", vars, props);
      final child = getValue(maps["child"], datas, "RenderBox?", vars, props);
      if (transform == null) {
        return null;
      }
      return RenderTransform(
          transform: transform!,
          origin: origin,
          alignment: alignment,
          textDirection: textDirection,
          transformHitTests: transformHitTests ?? true,
          filterQuality: filterQuality,
          child: child);
    },
    "RenderUiKitView": () {
      final viewController = getValue(
          maps["viewController"], datas, "UiKitViewController", vars, props);
      final hitTestBehavior = getValue(maps["hitTestBehavior"], datas,
          "PlatformViewHitTestBehavior", vars, props);
      final gestureRecognizers = getValue(maps["gestureRecognizers"], datas,
          "Set<Factory<OneSequenceGestureRecognizer>>", vars, props);
      if (viewController == null ||
          hitTestBehavior == null ||
          gestureRecognizers == null) {
        return null;
      }
      return RenderUiKitView(
          viewController: viewController!,
          hitTestBehavior: hitTestBehavior!,
          gestureRecognizers: Set<Factory<OneSequenceGestureRecognizer>>.from(
              gestureRecognizers!));
    },
    "RenderView": () {
      final child = getValue(maps["child"], datas, "RenderBox?", vars, props);
      final configuration = getValue(
          maps["configuration"], datas, "ViewConfiguration", vars, props);
      final view = getValue(maps["view"], datas, "FlutterView", vars, props);
      if (configuration == null || view == null) {
        return null;
      }
      return RenderView(
          child: child, configuration: configuration!, view: view!);
    },
    "RenderViewport": () {
      final axisDirection =
          getValue(maps["axisDirection"], datas, "", vars, props);
      final crossAxisDirection =
          getValue(maps["crossAxisDirection"], datas, "", vars, props);
      final offset = getValue(maps["offset"], datas, "", vars, props);
      final anchor = getValue(maps["anchor"], datas, "double", vars, props);
      final children =
          getValue(maps["children"], datas, "List<RenderSliver>?", vars, props);
      final center =
          getValue(maps["center"], datas, "RenderSliver?", vars, props);
      final cacheExtent = getValue(maps["cacheExtent"], datas, "", vars, props);
      final cacheExtentStyle =
          getValue(maps["cacheExtentStyle"], datas, "", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "", vars, props);
      if (crossAxisDirection == null || offset == null) {
        return null;
      }
      return RenderViewport(
          axisDirection: axisDirection,
          crossAxisDirection: crossAxisDirection!,
          offset: offset!,
          anchor: anchor ?? 0.0,
          children: children != null ? List<RenderSliver>.from(children) : null,
          center: center,
          cacheExtent: cacheExtent,
          cacheExtentStyle: cacheExtentStyle,
          clipBehavior: clipBehavior);
    },
    "RenderWrap": () {
      final children =
          getValue(maps["children"], datas, "List<RenderBox>?", vars, props);
      final direction = getValue(maps["direction"], datas, "Axis", vars, props);
      final alignment =
          getValue(maps["alignment"], datas, "WrapAlignment", vars, props);
      final spacing = getValue(maps["spacing"], datas, "double", vars, props);
      final runAlignment =
          getValue(maps["runAlignment"], datas, "WrapAlignment", vars, props);
      final runSpacing =
          getValue(maps["runSpacing"], datas, "double", vars, props);
      final crossAxisAlignment = getValue(
          maps["crossAxisAlignment"], datas, "WrapCrossAlignment", vars, props);
      final textDirection =
          getValue(maps["textDirection"], datas, "TextDirection?", vars, props);
      final verticalDirection = getValue(
          maps["verticalDirection"], datas, "VerticalDirection", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      return RenderWrap(
          children: children != null ? List<RenderBox>.from(children) : null,
          direction: direction ?? Axis.horizontal,
          alignment: alignment ?? WrapAlignment.start,
          spacing: spacing ?? 0.0,
          runAlignment: runAlignment ?? WrapAlignment.start,
          runSpacing: runSpacing ?? 0.0,
          crossAxisAlignment: crossAxisAlignment ?? WrapCrossAlignment.start,
          textDirection: textDirection,
          verticalDirection: verticalDirection ?? VerticalDirection.down,
          clipBehavior: clipBehavior ?? Clip.none);
    },
    "RenderingFlutterBinding": () {
      //final root = getValue(maps["root"], datas, "RenderBox?", vars, props);
      return RenderingFlutterBinding(
          //root: root
          );
    },
    "ReorderableDelayedDragStartListener": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      final index = getValue(maps["index"], datas, "int", vars, props);
      final enabled = getValue(maps["enabled"], datas, "bool", vars, props);
      if (child == null || index == null) {
        return null;
      }
      return ReorderableDelayedDragStartListener(
          key: key, child: child!, index: index!, enabled: enabled ?? true);
    },
    "ReorderableDragStartListener": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      final index = getValue(maps["index"], datas, "int", vars, props);
      final enabled = getValue(maps["enabled"], datas, "bool", vars, props);
      if (child == null || index == null) {
        return null;
      }
      return ReorderableDragStartListener(
          key: key, child: child!, index: index!, enabled: enabled ?? true);
    },
    "ReorderableList": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final itemBuilder = getValue(
          maps["itemBuilder"], datas, "IndexedWidgetBuilder", vars, props);
      final itemCount = getValue(maps["itemCount"], datas, "int", vars, props);
      final onReorder =
          getValue(maps["onReorder"], datas, "ReorderCallback", vars, props);
      final onReorderStart =
          getValue(maps["onReorderStart"], datas, "", vars, props);
      final onReorderEnd =
          getValue(maps["onReorderEnd"], datas, "", vars, props);
      final itemExtent =
          getValue(maps["itemExtent"], datas, "double?", vars, props);
      final prototypeItem =
          getValue(maps["prototypeItem"], datas, "Widget?", vars, props);
      final proxyDecorator = getValue(maps["proxyDecorator"], datas,
          "ReorderItemProxyDecorator?", vars, props);
      final padding =
          getValue(maps["padding"], datas, "EdgeInsetsGeometry?", vars, props);
      final scrollDirection =
          getValue(maps["scrollDirection"], datas, "Axis", vars, props);
      final reverse = getValue(maps["reverse"], datas, "bool", vars, props);
      final controller =
          getValue(maps["controller"], datas, "ScrollController?", vars, props);
      final primary = getValue(maps["primary"], datas, "bool?", vars, props);
      final physics =
          getValue(maps["physics"], datas, "ScrollPhysics?", vars, props);
      final shrinkWrap =
          getValue(maps["shrinkWrap"], datas, "bool", vars, props);
      final anchor = getValue(maps["anchor"], datas, "double", vars, props);
      final cacheExtent =
          getValue(maps["cacheExtent"], datas, "double?", vars, props);
      final dragStartBehavior = getValue(
          maps["dragStartBehavior"], datas, "DragStartBehavior", vars, props);
      final keyboardDismissBehavior = getValue(maps["keyboardDismissBehavior"],
          datas, "ScrollViewKeyboardDismissBehavior", vars, props);
      final restorationId =
          getValue(maps["restorationId"], datas, "String?", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      if (itemBuilder == null || itemCount == null || onReorder == null) {
        return null;
      }
      return ReorderableList(
          key: key,
          itemBuilder: itemBuilder!,
          itemCount: itemCount!,
          onReorder: onReorder!,
          onReorderStart: onReorderStart,
          onReorderEnd: onReorderEnd,
          itemExtent: itemExtent,
          prototypeItem: prototypeItem,
          proxyDecorator: proxyDecorator,
          padding: padding,
          scrollDirection: scrollDirection ?? Axis.vertical,
          reverse: reverse ?? false,
          controller: controller,
          primary: primary,
          physics: physics,
          shrinkWrap: shrinkWrap ?? false,
          anchor: anchor ?? 0.0,
          cacheExtent: cacheExtent,
          dragStartBehavior: dragStartBehavior ?? DragStartBehavior.start,
          keyboardDismissBehavior: keyboardDismissBehavior ??
              ScrollViewKeyboardDismissBehavior.manual,
          restorationId: restorationId,
          clipBehavior: clipBehavior ?? Clip.hardEdge);
    },
    "ReorderableListView": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final children =
          getValue(maps["children"], datas, "List<Widget>", vars, props);
      final onReorder =
          getValue(maps["onReorder"], datas, "ReorderCallback", vars, props);
      final onReorderStart =
          getValue(maps["onReorderStart"], datas, "", vars, props);
      final onReorderEnd =
          getValue(maps["onReorderEnd"], datas, "", vars, props);
      final itemExtent =
          getValue(maps["itemExtent"], datas, "double?", vars, props);
      final prototypeItem =
          getValue(maps["prototypeItem"], datas, "Widget?", vars, props);
      final proxyDecorator = getValue(maps["proxyDecorator"], datas,
          "ReorderItemProxyDecorator?", vars, props);
      final buildDefaultDragHandles =
          getValue(maps["buildDefaultDragHandles"], datas, "bool", vars, props);
      final padding =
          getValue(maps["padding"], datas, "EdgeInsets?", vars, props);
      final header = getValue(maps["header"], datas, "Widget?", vars, props);
      final footer = getValue(maps["footer"], datas, "Widget?", vars, props);
      final scrollDirection =
          getValue(maps["scrollDirection"], datas, "Axis", vars, props);
      final reverse = getValue(maps["reverse"], datas, "bool", vars, props);
      final scrollController = getValue(
          maps["scrollController"], datas, "ScrollController?", vars, props);
      final primary = getValue(maps["primary"], datas, "bool?", vars, props);
      final physics =
          getValue(maps["physics"], datas, "ScrollPhysics?", vars, props);
      final shrinkWrap =
          getValue(maps["shrinkWrap"], datas, "bool", vars, props);
      final anchor = getValue(maps["anchor"], datas, "double", vars, props);
      final cacheExtent =
          getValue(maps["cacheExtent"], datas, "double?", vars, props);
      final dragStartBehavior = getValue(
          maps["dragStartBehavior"], datas, "DragStartBehavior", vars, props);
      final keyboardDismissBehavior = getValue(maps["keyboardDismissBehavior"],
          datas, "ScrollViewKeyboardDismissBehavior", vars, props);
      final restorationId =
          getValue(maps["restorationId"], datas, "String?", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      if (children == null || onReorder == null) {
        return null;
      }
      return ReorderableListView(
          key: key,
          onReorder: onReorder!,
          onReorderStart: onReorderStart,
          onReorderEnd: onReorderEnd,
          itemExtent: itemExtent,
          prototypeItem: prototypeItem,
          proxyDecorator: proxyDecorator,
          buildDefaultDragHandles: buildDefaultDragHandles ?? true,
          padding: padding,
          header: header,
          footer: footer,
          scrollDirection: scrollDirection ?? Axis.vertical,
          reverse: reverse ?? false,
          scrollController: scrollController,
          primary: primary,
          physics: physics,
          shrinkWrap: shrinkWrap ?? false,
          anchor: anchor ?? 0.0,
          cacheExtent: cacheExtent,
          dragStartBehavior: dragStartBehavior ?? DragStartBehavior.start,
          keyboardDismissBehavior: keyboardDismissBehavior ??
              ScrollViewKeyboardDismissBehavior.manual,
          restorationId: restorationId,
          clipBehavior: clipBehavior ?? Clip.hardEdge,
          children: List<Widget>.from(children!));
    },
    "ReorderableListView.builder": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final itemBuilder = getValue(
          maps["itemBuilder"], datas, "IndexedWidgetBuilder", vars, props);
      final itemCount = getValue(maps["itemCount"], datas, "int", vars, props);
      final onReorder =
          getValue(maps["onReorder"], datas, "ReorderCallback", vars, props);
      final onReorderStart =
          getValue(maps["onReorderStart"], datas, "", vars, props);
      final onReorderEnd =
          getValue(maps["onReorderEnd"], datas, "", vars, props);
      final itemExtent =
          getValue(maps["itemExtent"], datas, "double?", vars, props);
      final prototypeItem =
          getValue(maps["prototypeItem"], datas, "Widget?", vars, props);
      final proxyDecorator = getValue(maps["proxyDecorator"], datas,
          "ReorderItemProxyDecorator?", vars, props);
      final buildDefaultDragHandles =
          getValue(maps["buildDefaultDragHandles"], datas, "bool", vars, props);
      final padding =
          getValue(maps["padding"], datas, "EdgeInsets?", vars, props);
      final header = getValue(maps["header"], datas, "Widget?", vars, props);
      final footer = getValue(maps["footer"], datas, "Widget?", vars, props);
      final scrollDirection =
          getValue(maps["scrollDirection"], datas, "Axis", vars, props);
      final reverse = getValue(maps["reverse"], datas, "bool", vars, props);
      final scrollController = getValue(
          maps["scrollController"], datas, "ScrollController?", vars, props);
      final primary = getValue(maps["primary"], datas, "bool?", vars, props);
      final physics =
          getValue(maps["physics"], datas, "ScrollPhysics?", vars, props);
      final shrinkWrap =
          getValue(maps["shrinkWrap"], datas, "bool", vars, props);
      final anchor = getValue(maps["anchor"], datas, "double", vars, props);
      final cacheExtent =
          getValue(maps["cacheExtent"], datas, "double?", vars, props);
      final dragStartBehavior = getValue(
          maps["dragStartBehavior"], datas, "DragStartBehavior", vars, props);
      final keyboardDismissBehavior = getValue(maps["keyboardDismissBehavior"],
          datas, "ScrollViewKeyboardDismissBehavior", vars, props);
      final restorationId =
          getValue(maps["restorationId"], datas, "String?", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      if (itemBuilder == null || itemCount == null || onReorder == null) {
        return null;
      }
      return ReorderableListView.builder(
          key: key,
          itemBuilder: itemBuilder!,
          itemCount: itemCount!,
          onReorder: onReorder!,
          onReorderStart: onReorderStart,
          onReorderEnd: onReorderEnd,
          itemExtent: itemExtent,
          prototypeItem: prototypeItem,
          proxyDecorator: proxyDecorator,
          buildDefaultDragHandles: buildDefaultDragHandles ?? true,
          padding: padding,
          header: header,
          footer: footer,
          scrollDirection: scrollDirection ?? Axis.vertical,
          reverse: reverse ?? false,
          scrollController: scrollController,
          primary: primary,
          physics: physics,
          shrinkWrap: shrinkWrap ?? false,
          anchor: anchor ?? 0.0,
          cacheExtent: cacheExtent,
          dragStartBehavior: dragStartBehavior ?? DragStartBehavior.start,
          keyboardDismissBehavior: keyboardDismissBehavior ??
              ScrollViewKeyboardDismissBehavior.manual,
          restorationId: restorationId,
          clipBehavior: clipBehavior ?? Clip.hardEdge);
    },
    "RepaintBoundary": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      return RepaintBoundary(key: key, child: child);
    },
    "RepaintBoundary.wrap": () {
      final child = getValue(maps["0"], datas, "Widget", vars, props);
      final childIndex = getValue(maps["1"], datas, "int", vars, props);
      if (child == null || childIndex == null) {
        return null;
      }
      return RepaintBoundary.wrap(child!, childIndex!);
    },
    "RepetitiveStackFrameFilter": () {
      final frames = getValue(
          maps["frames"], datas, "List<PartialStackFrame>", vars, props);
      final replacement =
          getValue(maps["replacement"], datas, "String", vars, props);
      if (frames == null || replacement == null) {
        return null;
      }
      return RepetitiveStackFrameFilter(
          frames: List<PartialStackFrame>.from(frames!),
          replacement: replacement!);
    },
    "ReplaceTextIntent": () {
      final currentTextEditingValue =
          getValue(maps["0"], datas, "TextEditingValue", vars, props);
      final replacementText = getValue(maps["1"], datas, "String", vars, props);
      final replacementRange =
          getValue(maps["2"], datas, "TextRange", vars, props);
      final cause =
          getValue(maps["3"], datas, "SelectionChangedCause", vars, props);
      if (currentTextEditingValue == null ||
          replacementText == null ||
          replacementRange == null ||
          cause == null) {
        return null;
      }
      return ReplaceTextIntent(currentTextEditingValue!, replacementText!,
          replacementRange!, cause!);
    },
    "RequestFocusIntent": () {
      final focusNode = getValue(maps["0"], datas, "FocusNode", vars, props);
      if (focusNode == null) {
        return null;
      }
      return RequestFocusIntent(focusNode!);
    },
    "ResizeImage": () {
      final imageProvider =
          getValue(maps["0"], datas, "ImageProvider", vars, props);
      final width = getValue(maps["width"], datas, "int?", vars, props);
      final height = getValue(maps["height"], datas, "int?", vars, props);
      final policy =
          getValue(maps["policy"], datas, "ResizeImagePolicy", vars, props);
      final allowUpscaling =
          getValue(maps["allowUpscaling"], datas, "bool", vars, props);
      if (imageProvider == null) {
        return null;
      }
      return ResizeImage(imageProvider!,
          width: width,
          height: height,
          policy: policy ?? ResizeImagePolicy.exact,
          allowUpscaling: allowUpscaling ?? false);
    },
    "RestorableBool": () {
      final defaultValue = getValue(maps["0"], datas, "T", vars, props);
      if (defaultValue == null) {
        return null;
      }
      return RestorableBool(defaultValue!);
    },
    "RestorableBoolN": () {
      final defaultValue = getValue(maps["0"], datas, "T", vars, props);
      if (defaultValue == null) {
        return null;
      }
      return RestorableBoolN(defaultValue!);
    },
    "RestorableCupertinoTabController": () {
      final initialIndex =
          getValue(maps["initialIndex"], datas, "int", vars, props);
      return RestorableCupertinoTabController(initialIndex: initialIndex ?? 0);
    },
    "RestorableDateTime": () {
      final defaultValue = getValue(maps["0"], datas, "DateTime", vars, props);
      if (defaultValue == null) {
        return null;
      }
      return RestorableDateTime(defaultValue!);
    },
    "RestorableDateTimeN": () {
      final defaultValue = getValue(maps["0"], datas, "DateTime?", vars, props);
      if (defaultValue == null) {
        return null;
      }
      return RestorableDateTimeN(defaultValue!);
    },
    "RestorableDouble": () {
      final defaultValue = getValue(maps["0"], datas, "T", vars, props);
      if (defaultValue == null) {
        return null;
      }
      return RestorableDouble(defaultValue!);
    },
    "RestorableDoubleN": () {
      final defaultValue = getValue(maps["0"], datas, "T", vars, props);
      if (defaultValue == null) {
        return null;
      }
      return RestorableDoubleN(defaultValue!);
    },
    "RestorableEnumN": () {
      final defaultValue = getValue(maps["0"], datas, "T?", vars, props);
      final values =
          getValue(maps["values"], datas, "Iterable<T>", vars, props);
      if (defaultValue == null || values == null) {
        return null;
      }
      return RestorableEnumN<E>(defaultValue!, values: values!);
    },
    "RestorableInt": () {
      final defaultValue = getValue(maps["0"], datas, "T", vars, props);
      if (defaultValue == null) {
        return null;
      }
      return RestorableInt(defaultValue!);
    },
    "RestorableIntN": () {
      final defaultValue = getValue(maps["0"], datas, "T", vars, props);
      if (defaultValue == null) {
        return null;
      }
      return RestorableIntN(defaultValue!);
    },
    "RestorableNum": () {
      final defaultValue = getValue(maps["0"], datas, "T", vars, props);
      if (defaultValue == null) {
        return null;
      }
      return RestorableNum<N>(defaultValue!);
    },
    "RestorableNumN": () {
      final defaultValue = getValue(maps["0"], datas, "T", vars, props);
      if (defaultValue == null) {
        return null;
      }
      return RestorableNumN<N>(defaultValue!);
    },
    "RestorableRouteFuture": () {
      final navigatorFinder = getValue(maps["navigatorFinder"], datas,
          "NavigatorFinderCallback", vars, props);
      final onPresent = getValue(
          maps["onPresent"], datas, "RoutePresentationCallback", vars, props);
      final onComplete = getValue(maps["onComplete"], datas,
          "RouteCompletionCallback<T>?", vars, props);
      if (onPresent == null) {
        return null;
      }
      if (navigatorFinder != null) {
        return RestorableRouteFuture(
            onPresent: onPresent!,
            onComplete: onComplete,
            navigatorFinder: navigatorFinder);
      }
      return RestorableRouteFuture(
          onPresent: onPresent!, onComplete: onComplete);
    },
    "RestorableString": () {
      final defaultValue = getValue(maps["0"], datas, "T", vars, props);
      if (defaultValue == null) {
        return null;
      }
      return RestorableString(defaultValue!);
    },
    "RestorableStringN": () {
      final defaultValue = getValue(maps["0"], datas, "T", vars, props);
      if (defaultValue == null) {
        return null;
      }
      return RestorableStringN(defaultValue!);
    },
    "RestorableTextEditingController": () {
      final text = getValue(maps["text"], datas, "String?", vars, props);
      return RestorableTextEditingController(text: text);
    },
    "RestorableTextEditingController.fromValue": () {
      final value = getValue(maps["0"], datas, "TextEditingValue", vars, props);
      if (value == null) {
        return null;
      }
      return RestorableTextEditingController.fromValue(value!);
    },
    "RestorableTimeOfDay": () {
      final defaultValue = getValue(maps["0"], datas, "TimeOfDay", vars, props);
      if (defaultValue == null) {
        return null;
      }
      return RestorableTimeOfDay(defaultValue!);
    },
    "RestorationBucket.empty": () {
      final restorationId =
          getValue(maps["restorationId"], datas, "String", vars, props);
      final debugOwner =
          getValue(maps["debugOwner"], datas, "Object?", vars, props);
      if (restorationId == null || debugOwner == null) {
        return null;
      }
      return RestorationBucket.empty(
          restorationId: restorationId!, debugOwner: debugOwner!);
    },
    "RestorationBucket.root": () {
      final manager =
          getValue(maps["manager"], datas, "RestorationManager", vars, props);
      final rawData = getValue(
          maps["rawData"], datas, "Map<Object?,   Object?>?", vars, props);
      if (manager == null || rawData == null) {
        return null;
      }
      return RestorationBucket.root(
          manager: manager!, rawData: Map<Object?, Object?>.from(rawData!));
    },
    "RestorationBucket.child": () {
      final restorationId =
          getValue(maps["restorationId"], datas, "String", vars, props);
      final parent =
          getValue(maps["parent"], datas, "RestorationBucket", vars, props);
      final debugOwner =
          getValue(maps["debugOwner"], datas, "Object?", vars, props);
      if (restorationId == null || parent == null || debugOwner == null) {
        return null;
      }
      return RestorationBucket.child(
          restorationId: restorationId!,
          parent: parent!,
          debugOwner: debugOwner!);
    },
    "RestorationManager": () {
      return RestorationManager();
    },
    "RestorationScope": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final restorationId =
          getValue(maps["restorationId"], datas, "String?", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (restorationId == null || child == null) {
        return null;
      }
      return RestorationScope(
          key: key, restorationId: restorationId!, child: child!);
    },
    "RevealedOffset": () {
      final offset = getValue(maps["offset"], datas, "double", vars, props);
      final rect = getValue(maps["rect"], datas, "Rect", vars, props);
      if (offset == null || rect == null) {
        return null;
      }
      return RevealedOffset(offset: offset!, rect: rect!);
    },
    "RichText": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final text = getValue(maps["text"], datas, "InlineSpan", vars, props);
      final textAlign =
          getValue(maps["textAlign"], datas, "TextAlign", vars, props);
      final textDirection =
          getValue(maps["textDirection"], datas, "TextDirection?", vars, props);
      final softWrap = getValue(maps["softWrap"], datas, "bool", vars, props);
      final overflow =
          getValue(maps["overflow"], datas, "TextOverflow", vars, props);
      final textScaleFactor =
          getValue(maps["textScaleFactor"], datas, "double", vars, props);
      final maxLines = getValue(maps["maxLines"], datas, "int?", vars, props);
      final locale = getValue(maps["locale"], datas, "Locale?", vars, props);
      final strutStyle =
          getValue(maps["strutStyle"], datas, "StrutStyle?", vars, props);
      final textWidthBasis = getValue(
          maps["textWidthBasis"], datas, "TextWidthBasis", vars, props);
      final textHeightBehavior = getValue(maps["textHeightBehavior"], datas,
          "TextHeightBehavior?", vars, props);
      final selectionRegistrar = getValue(maps["selectionRegistrar"], datas,
          "SelectionRegistrar?", vars, props);
      final selectionColor =
          getValue(maps["selectionColor"], datas, "Color?", vars, props);
      if (text == null) {
        return null;
      }
      return RichText(
          key: key,
          text: text!,
          textAlign: textAlign ?? TextAlign.start,
          textDirection: textDirection,
          softWrap: softWrap ?? true,
          overflow: overflow ?? TextOverflow.clip,
          textScaleFactor: textScaleFactor ?? 1.0,
          maxLines: maxLines,
          locale: locale,
          strutStyle: strutStyle,
          textWidthBasis: textWidthBasis ?? TextWidthBasis.parent,
          textHeightBehavior: textHeightBehavior,
          selectionRegistrar: selectionRegistrar,
          selectionColor: selectionColor);
    },
    "RootBackButtonDispatcher": () {
      return RootBackButtonDispatcher();
    },
    "RootRestorationScope": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final restorationId =
          getValue(maps["restorationId"], datas, "String?", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (restorationId == null || child == null) {
        return null;
      }
      return RootRestorationScope(
          key: key, restorationId: restorationId!, child: child!);
    },
    "RotatedBox": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final quarterTurns =
          getValue(maps["quarterTurns"], datas, "int", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      if (quarterTurns == null) {
        return null;
      }
      return RotatedBox(key: key, quarterTurns: quarterTurns!, child: child);
    },
    "RotationTransition": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final turns =
          getValue(maps["turns"], datas, "Animation<double>", vars, props);
      final alignment =
          getValue(maps["alignment"], datas, "Alignment", vars, props);
      final filterQuality =
          getValue(maps["filterQuality"], datas, "FilterQuality?", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      if (turns == null) {
        return null;
      }
      return RotationTransition(
          key: key,
          turns: turns!,
          alignment: alignment ?? Alignment.center,
          filterQuality: filterQuality,
          child: child);
    },
    "RoundRangeSliderThumbShape": () {
      final enabledThumbRadius =
          getValue(maps["enabledThumbRadius"], datas, "double", vars, props);
      final disabledThumbRadius =
          getValue(maps["disabledThumbRadius"], datas, "double?", vars, props);
      final elevation =
          getValue(maps["elevation"], datas, "double", vars, props);
      final pressedElevation =
          getValue(maps["pressedElevation"], datas, "double", vars, props);
      return RoundRangeSliderThumbShape(
          enabledThumbRadius: enabledThumbRadius ?? 10.0,
          disabledThumbRadius: disabledThumbRadius,
          elevation: elevation ?? 1.0,
          pressedElevation: pressedElevation ?? 6.0);
    },
    "RoundRangeSliderTickMarkShape": () {
      final tickMarkRadius =
          getValue(maps["tickMarkRadius"], datas, "double?", vars, props);
      return RoundRangeSliderTickMarkShape(tickMarkRadius: tickMarkRadius);
    },
    "RoundSliderOverlayShape": () {
      final overlayRadius =
          getValue(maps["overlayRadius"], datas, "double", vars, props);
      return RoundSliderOverlayShape(overlayRadius: overlayRadius ?? 24.0);
    },
    "RoundSliderThumbShape": () {
      final enabledThumbRadius =
          getValue(maps["enabledThumbRadius"], datas, "double", vars, props);
      final disabledThumbRadius =
          getValue(maps["disabledThumbRadius"], datas, "double?", vars, props);
      final elevation =
          getValue(maps["elevation"], datas, "double", vars, props);
      final pressedElevation =
          getValue(maps["pressedElevation"], datas, "double", vars, props);
      return RoundSliderThumbShape(
          enabledThumbRadius: enabledThumbRadius ?? 10.0,
          disabledThumbRadius: disabledThumbRadius,
          elevation: elevation ?? 1.0,
          pressedElevation: pressedElevation ?? 6.0);
    },
    "RoundSliderTickMarkShape": () {
      final tickMarkRadius =
          getValue(maps["tickMarkRadius"], datas, "double?", vars, props);
      return RoundSliderTickMarkShape(tickMarkRadius: tickMarkRadius);
    },
    "RoundedRectRangeSliderTrackShape": () {
      return const RoundedRectRangeSliderTrackShape();
    },
    "RoundedRectSliderTrackShape": () {
      return const RoundedRectSliderTrackShape();
    },
    "RoundedRectangleBorder": () {
      final side = getValue(maps["side"], datas, "", vars, props);
      final borderRadius = getValue(
          maps["borderRadius"], datas, "BorderRadiusGeometry", vars, props);
      return RoundedRectangleBorder(
          side: side ?? BorderSide.none,
          borderRadius: borderRadius ?? BorderRadius.zero);
    },
    "RouteInformation": () {
      final location =
          getValue(maps["location"], datas, "String?", vars, props);
      final state = getValue(maps["state"], datas, "Object?", vars, props);
      return RouteInformation(location: location, state: state);
    },
    "RouteSettings": () {
      final name = getValue(maps["name"], datas, "String?", vars, props);
      final arguments =
          getValue(maps["arguments"], datas, "Object?", vars, props);
      return RouteSettings(name: name, arguments: arguments);
    },
    "Router": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final routeInformationProvider = getValue(
          maps["routeInformationProvider"],
          datas,
          "RouteInformationProvider?",
          vars,
          props);
      final routeInformationParser = getValue(maps["routeInformationParser"],
          datas, "RouteInformationParser<T>?", vars, props);
      final routerDelegate = getValue(
          maps["routerDelegate"], datas, "RouterDelegate<T>", vars, props);
      final backButtonDispatcher = getValue(maps["backButtonDispatcher"], datas,
          "BackButtonDispatcher?", vars, props);
      final restorationScopeId =
          getValue(maps["restorationScopeId"], datas, "String?", vars, props);
      if (routerDelegate == null) {
        return null;
      }
      return Router(
          key: key,
          routeInformationProvider: routeInformationProvider,
          routeInformationParser: routeInformationParser,
          routerDelegate: routerDelegate!,
          backButtonDispatcher: backButtonDispatcher,
          restorationScopeId: restorationScopeId);
    },
    "Router.withConfig": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final config =
          getValue(maps["config"], datas, "RouterConfig<T>", vars, props);
      final restorationScopeId =
          getValue(maps["restorationScopeId"], datas, "String?", vars, props);
      if (config == null) {
        return null;
      }
      return Router.withConfig(
          key: key, config: config!, restorationScopeId: restorationScopeId);
    },
    "RouterConfig": () {
      final routeInformationProvider = getValue(
          maps["routeInformationProvider"],
          datas,
          "RouteInformationProvider?",
          vars,
          props);
      final routeInformationParser = getValue(maps["routeInformationParser"],
          datas, "RouteInformationParser<T>?", vars, props);
      final routerDelegate = getValue(
          maps["routerDelegate"], datas, "RouterDelegate<T>", vars, props);
      final backButtonDispatcher = getValue(maps["backButtonDispatcher"], datas,
          "BackButtonDispatcher?", vars, props);
      if (routerDelegate == null) {
        return null;
      }
      return RouterConfig(
          routeInformationProvider: routeInformationProvider,
          routeInformationParser: routeInformationParser,
          routerDelegate: routerDelegate!,
          backButtonDispatcher: backButtonDispatcher);
    },
    "Row": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final mainAxisAlignment =
          getValue(maps["mainAxisAlignment"], datas, "", vars, props);
      final mainAxisSize =
          getValue(maps["mainAxisSize"], datas, "", vars, props);
      final crossAxisAlignment =
          getValue(maps["crossAxisAlignment"], datas, "", vars, props);
      final textDirection =
          getValue(maps["textDirection"], datas, "", vars, props);
      final verticalDirection =
          getValue(maps["verticalDirection"], datas, "", vars, props);
      final textBaseline =
          getValue(maps["textBaseline"], datas, "", vars, props);
      final children =
          getValue(maps["children"], datas, "List<Widget>", vars, props);
      return Row(
          key: key,
          mainAxisAlignment: mainAxisAlignment ?? MainAxisAlignment.start,
          mainAxisSize: mainAxisSize ?? MainAxisSize.max,
          crossAxisAlignment: crossAxisAlignment ?? CrossAxisAlignment.center,
          textDirection: textDirection,
          verticalDirection: verticalDirection ?? VerticalDirection.down,
          textBaseline: textBaseline,
          children: List<Widget>.from(children ?? const <Widget>[]));
    },
    "RuneIterator": () {
      final string = getValue(maps["0"], datas, "String", vars, props);
      if (string == null) {
        return null;
      }
      return RuneIterator(string!);
    },
    "RuneIterator.at": () {
      final string = getValue(maps["0"], datas, "String", vars, props);
      final index = getValue(maps["1"], datas, "int", vars, props);
      if (string == null || index == null) {
        return null;
      }
      return RuneIterator.at(string!, index!);
    },
    "Runes": () {
      final string = getValue(maps["0"], datas, "String", vars, props);
      if (string == null) {
        return null;
      }
      return Runes(string!);
    },
    "SafeArea": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final left = getValue(maps["left"], datas, "bool", vars, props);
      final top = getValue(maps["top"], datas, "bool", vars, props);
      final right = getValue(maps["right"], datas, "bool", vars, props);
      final bottom = getValue(maps["bottom"], datas, "bool", vars, props);
      final minimum =
          getValue(maps["minimum"], datas, "EdgeInsets", vars, props);
      final maintainBottomViewPadding = getValue(
          maps["maintainBottomViewPadding"], datas, "bool", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (child == null) {
        return null;
      }
      return SafeArea(
          key: key,
          left: left ?? true,
          top: top ?? true,
          right: right ?? true,
          bottom: bottom ?? true,
          minimum: minimum ?? EdgeInsets.zero,
          maintainBottomViewPadding: maintainBottomViewPadding ?? false,
          child: child!);
    },
    "SawTooth": () {
      final count = getValue(maps["0"], datas, "int", vars, props);
      if (count == null) {
        return null;
      }
      return SawTooth(count!);
    },
    "Scaffold": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final appBar =
          getValue(maps["appBar"], datas, "PreferredSizeWidget?", vars, props);
      final body = getValue(maps["body"], datas, "Widget?", vars, props);
      final floatingActionButton =
          getValue(maps["floatingActionButton"], datas, "Widget?", vars, props);
      final floatingActionButtonLocation = getValue(
          maps["floatingActionButtonLocation"],
          datas,
          "FloatingActionButtonLocation?",
          vars,
          props);
      final floatingActionButtonAnimator = getValue(
          maps["floatingActionButtonAnimator"],
          datas,
          "FloatingActionButtonAnimator?",
          vars,
          props);
      final persistentFooterButtons = getValue(
          maps["persistentFooterButtons"], datas, "List<Widget>?", vars, props);
      final persistentFooterAlignment = getValue(
          maps["persistentFooterAlignment"],
          datas,
          "AlignmentDirectional",
          vars,
          props);
      final drawer = getValue(maps["drawer"], datas, "Widget?", vars, props);
      final onDrawerChanged = getValue(
          maps["onDrawerChanged"], datas, "DrawerCallback?", vars, props);
      final endDrawer =
          getValue(maps["endDrawer"], datas, "Widget?", vars, props);
      final onEndDrawerChanged = getValue(
          maps["onEndDrawerChanged"], datas, "DrawerCallback?", vars, props);
      final bottomNavigationBar =
          getValue(maps["bottomNavigationBar"], datas, "Widget?", vars, props);
      final bottomSheet =
          getValue(maps["bottomSheet"], datas, "Widget?", vars, props);
      final backgroundColor =
          getValue(maps["backgroundColor"], datas, "Color?", vars, props);
      final resizeToAvoidBottomInset = getValue(
          maps["resizeToAvoidBottomInset"], datas, "bool?", vars, props);
      final primary = getValue(maps["primary"], datas, "bool", vars, props);
      final drawerDragStartBehavior = getValue(maps["drawerDragStartBehavior"],
          datas, "DragStartBehavior", vars, props);
      final extendBody =
          getValue(maps["extendBody"], datas, "bool", vars, props);
      final extendBodyBehindAppBar =
          getValue(maps["extendBodyBehindAppBar"], datas, "bool", vars, props);
      final drawerScrimColor =
          getValue(maps["drawerScrimColor"], datas, "Color?", vars, props);
      final drawerEdgeDragWidth =
          getValue(maps["drawerEdgeDragWidth"], datas, "double?", vars, props);
      final drawerEnableOpenDragGesture = getValue(
          maps["drawerEnableOpenDragGesture"], datas, "bool", vars, props);
      final endDrawerEnableOpenDragGesture = getValue(
          maps["endDrawerEnableOpenDragGesture"], datas, "bool", vars, props);
      final restorationId =
          getValue(maps["restorationId"], datas, "String?", vars, props);
      return Scaffold(
          key: key,
          appBar: appBar,
          body: body,
          floatingActionButton: floatingActionButton,
          floatingActionButtonLocation: floatingActionButtonLocation,
          floatingActionButtonAnimator: floatingActionButtonAnimator,
          persistentFooterButtons: persistentFooterButtons != null
              ? List<Widget>.from(persistentFooterButtons)
              : null,
          persistentFooterAlignment:
              persistentFooterAlignment ?? AlignmentDirectional.centerEnd,
          drawer: drawer,
          onDrawerChanged: onDrawerChanged,
          endDrawer: endDrawer,
          onEndDrawerChanged: onEndDrawerChanged,
          bottomNavigationBar: bottomNavigationBar,
          bottomSheet: bottomSheet,
          backgroundColor: backgroundColor,
          resizeToAvoidBottomInset: resizeToAvoidBottomInset,
          primary: primary ?? true,
          drawerDragStartBehavior:
              drawerDragStartBehavior ?? DragStartBehavior.start,
          extendBody: extendBody ?? false,
          extendBodyBehindAppBar: extendBodyBehindAppBar ?? false,
          drawerScrimColor: drawerScrimColor,
          drawerEdgeDragWidth: drawerEdgeDragWidth,
          drawerEnableOpenDragGesture: drawerEnableOpenDragGesture ?? true,
          endDrawerEnableOpenDragGesture:
              endDrawerEnableOpenDragGesture ?? true,
          restorationId: restorationId);
    },
    "ScaffoldMessenger": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (child == null) {
        return null;
      }
      return ScaffoldMessenger(key: key, child: child!);
    },
    "ScaffoldPrelayoutGeometry": () {
      final bottomSheetSize =
          getValue(maps["bottomSheetSize"], datas, "Size", vars, props);
      final contentBottom =
          getValue(maps["contentBottom"], datas, "double", vars, props);
      final contentTop =
          getValue(maps["contentTop"], datas, "double", vars, props);
      final floatingActionButtonSize = getValue(
          maps["floatingActionButtonSize"], datas, "Size", vars, props);
      final minInsets =
          getValue(maps["minInsets"], datas, "EdgeInsets", vars, props);
      final minViewPadding =
          getValue(maps["minViewPadding"], datas, "EdgeInsets", vars, props);
      final scaffoldSize =
          getValue(maps["scaffoldSize"], datas, "Size", vars, props);
      final snackBarSize =
          getValue(maps["snackBarSize"], datas, "Size", vars, props);
      final materialBannerSize =
          getValue(maps["materialBannerSize"], datas, "Size", vars, props);
      final textDirection =
          getValue(maps["textDirection"], datas, "TextDirection", vars, props);
      if (bottomSheetSize == null ||
          contentBottom == null ||
          contentTop == null ||
          floatingActionButtonSize == null ||
          minInsets == null ||
          minViewPadding == null ||
          scaffoldSize == null ||
          snackBarSize == null ||
          materialBannerSize == null ||
          textDirection == null) {
        return null;
      }
      return ScaffoldPrelayoutGeometry(
          bottomSheetSize: bottomSheetSize!,
          contentBottom: contentBottom!,
          contentTop: contentTop!,
          floatingActionButtonSize: floatingActionButtonSize!,
          minInsets: minInsets!,
          minViewPadding: minViewPadding!,
          scaffoldSize: scaffoldSize!,
          snackBarSize: snackBarSize!,
          materialBannerSize: materialBannerSize!,
          textDirection: textDirection!);
    },
    "ScaleEndDetails": () {
      final velocity =
          getValue(maps["velocity"], datas, "Velocity", vars, props);
      final scaleVelocity =
          getValue(maps["scaleVelocity"], datas, "double", vars, props);
      final pointerCount =
          getValue(maps["pointerCount"], datas, "int", vars, props);
      return ScaleEndDetails(
          velocity: velocity ?? Velocity.zero,
          scaleVelocity: scaleVelocity ?? 0,
          pointerCount: pointerCount ?? 0);
    },
    "ScaleGestureRecognizer": () {
      final debugOwner = getValue(maps["debugOwner"], datas, "", vars, props);
      final supportedDevices =
          getValue(maps["supportedDevices"], datas, "", vars, props);
      final allowedButtonsFilter =
          getValue(maps["allowedButtonsFilter"], datas, "", vars, props);
      final dragStartBehavior = getValue(
          maps["dragStartBehavior"], datas, "DragStartBehavior", vars, props);
      final trackpadScrollCausesScale = getValue(
          maps["trackpadScrollCausesScale"], datas, "bool", vars, props);
      final trackpadScrollToScaleFactor = getValue(
          maps["trackpadScrollToScaleFactor"], datas, "Offset", vars, props);
      if (trackpadScrollToScaleFactor != null) {
        return ScaleGestureRecognizer(
            debugOwner: debugOwner,
            supportedDevices: supportedDevices,
            allowedButtonsFilter: allowedButtonsFilter,
            dragStartBehavior: dragStartBehavior ?? DragStartBehavior.down,
            trackpadScrollCausesScale: trackpadScrollCausesScale ?? false,
            trackpadScrollToScaleFactor: trackpadScrollToScaleFactor);
      }
      return ScaleGestureRecognizer(
          debugOwner: debugOwner,
          supportedDevices: supportedDevices,
          allowedButtonsFilter: allowedButtonsFilter,
          dragStartBehavior: dragStartBehavior ?? DragStartBehavior.down,
          trackpadScrollCausesScale: trackpadScrollCausesScale ?? false);
    },
    "ScaleStartDetails": () {
      final focalPoint =
          getValue(maps["focalPoint"], datas, "Offset", vars, props);
      final localFocalPoint =
          getValue(maps["localFocalPoint"], datas, "Offset?", vars, props);
      final pointerCount =
          getValue(maps["pointerCount"], datas, "int", vars, props);
      return ScaleStartDetails(
          focalPoint: focalPoint ?? Offset.zero,
          localFocalPoint: localFocalPoint,
          pointerCount: pointerCount ?? 0);
    },
    "ScaleTransition": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final scale =
          getValue(maps["scale"], datas, "Animation<double>", vars, props);
      final alignment =
          getValue(maps["alignment"], datas, "Alignment", vars, props);
      final filterQuality =
          getValue(maps["filterQuality"], datas, "FilterQuality?", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      if (scale == null) {
        return null;
      }
      return ScaleTransition(
          key: key,
          scale: scale!,
          alignment: alignment ?? Alignment.center,
          filterQuality: filterQuality,
          child: child);
    },
    "ScaleUpdateDetails": () {
      final focalPoint =
          getValue(maps["focalPoint"], datas, "Offset", vars, props);
      final localFocalPoint =
          getValue(maps["localFocalPoint"], datas, "Offset?", vars, props);
      final scale = getValue(maps["scale"], datas, "double", vars, props);
      final horizontalScale =
          getValue(maps["horizontalScale"], datas, "double", vars, props);
      final verticalScale =
          getValue(maps["verticalScale"], datas, "double", vars, props);
      final rotation = getValue(maps["rotation"], datas, "double", vars, props);
      final pointerCount =
          getValue(maps["pointerCount"], datas, "int", vars, props);
      final focalPointDelta =
          getValue(maps["focalPointDelta"], datas, "Offset", vars, props);
      return ScaleUpdateDetails(
          focalPoint: focalPoint ?? Offset.zero,
          localFocalPoint: localFocalPoint,
          scale: scale ?? 1.0,
          horizontalScale: horizontalScale ?? 1.0,
          verticalScale: verticalScale ?? 1.0,
          rotation: rotation ?? 0.0,
          pointerCount: pointerCount ?? 0,
          focalPointDelta: focalPointDelta ?? Offset.zero);
    },
    "SceneBuilder": () {
      return ui.SceneBuilder();
    },
    "ScrollAwareImageProvider": () {
      final context = getValue(
          maps["context"], datas, "DisposableBuildContext", vars, props);
      final imageProvider = getValue(
          maps["imageProvider"], datas, "ImageProvider<T>", vars, props);
      if (context == null || imageProvider == null) {
        return null;
      }
      return ScrollAwareImageProvider(
          context: context!, imageProvider: imageProvider!);
    },
    "ScrollBehavior": () {
      // final androidOverscrollIndicator = getValue(
      //     maps["androidOverscrollIndicator"],
      //     datas,
      //     },"AndroidOverscrollIndicator?",
      //     vars,
      //     props);
      return const ScrollBehavior(
          //androidOverscrollIndicator: androidOverscrollIndicator
          );
    },
    "ScrollConfiguration": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final behavior =
          getValue(maps["behavior"], datas, "ScrollBehavior", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (behavior == null || child == null) {
        return null;
      }
      return ScrollConfiguration(key: key, behavior: behavior!, child: child!);
    },
    "ScrollController": () {
      final initialScrollOffset =
          getValue(maps["initialScrollOffset"], datas, "double", vars, props);
      final keepScrollOffset =
          getValue(maps["keepScrollOffset"], datas, "bool", vars, props);
      final debugLabel =
          getValue(maps["debugLabel"], datas, "String?", vars, props);
      return ScrollController(
          initialScrollOffset: initialScrollOffset ?? 0.0,
          keepScrollOffset: keepScrollOffset ?? true,
          debugLabel: debugLabel);
    },
    "ScrollDragController": () {
      final delegate = getValue(
          maps["delegate"], datas, "ScrollActivityDelegate", vars, props);
      final details =
          getValue(maps["details"], datas, "DragStartDetails", vars, props);
      final onDragCanceled =
          getValue(maps["onDragCanceled"], datas, "VoidCallback?", vars, props);
      final carriedVelocity =
          getValue(maps["carriedVelocity"], datas, "double?", vars, props);
      final motionStartDistanceThreshold = getValue(
          maps["motionStartDistanceThreshold"], datas, "double?", vars, props);
      if (delegate == null || details == null) {
        return null;
      }
      return ScrollDragController(
          delegate: delegate!,
          details: details!,
          onDragCanceled: onDragCanceled,
          carriedVelocity: carriedVelocity,
          motionStartDistanceThreshold: motionStartDistanceThreshold);
    },
    "ScrollEndNotification": () {
      final metrics =
          getValue(maps["metrics"], datas, "ScrollMetrics", vars, props);
      final context =
          getValue(maps["context"], datas, "BuildContext", vars, props);
      final dragDetails =
          getValue(maps["dragDetails"], datas, "DragEndDetails?", vars, props);
      if (metrics == null || context == null) {
        return null;
      }
      return ScrollEndNotification(
          metrics: metrics!, context: context!, dragDetails: dragDetails);
    },
    "ScrollIncrementDetails": () {
      final type =
          getValue(maps["type"], datas, "ScrollIncrementType", vars, props);
      final metrics =
          getValue(maps["metrics"], datas, "ScrollMetrics", vars, props);
      if (type == null || metrics == null) {
        return null;
      }
      return ScrollIncrementDetails(type: type!, metrics: metrics!);
    },
    "ScrollIntent": () {
      final direction =
          getValue(maps["direction"], datas, "AxisDirection", vars, props);
      final type =
          getValue(maps["type"], datas, "ScrollIncrementType", vars, props);
      if (direction == null) {
        return null;
      }
      return ScrollIntent(
          direction: direction!, type: type ?? ScrollIncrementType.line);
    },
    "ScrollMetricsNotification": () {
      final metrics =
          getValue(maps["metrics"], datas, "ScrollMetrics", vars, props);
      final context =
          getValue(maps["context"], datas, "BuildContext", vars, props);
      if (metrics == null || context == null) {
        return null;
      }
      return ScrollMetricsNotification(metrics: metrics!, context: context!);
    },
    "ScrollNotificationObserver": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (child == null) {
        return null;
      }
      return ScrollNotificationObserver(key: key, child: child!);
    },
    "ScrollPhysics": () {
      final parent =
          getValue(maps["parent"], datas, "ScrollPhysics?", vars, props);
      return ScrollPhysics(parent: parent);
    },
    "ScrollPositionWithSingleContext": () {
      final physics =
          getValue(maps["physics"], datas, "ScrollPhysics", vars, props);
      final context =
          getValue(maps["context"], datas, "ScrollContext", vars, props);
      final initialPixels =
          getValue(maps["initialPixels"], datas, "double?", vars, props);
      final keepScrollOffset =
          getValue(maps["keepScrollOffset"], datas, "bool", vars, props);
      final oldPosition =
          getValue(maps["oldPosition"], datas, "ScrollPosition?", vars, props);
      final debugLabel =
          getValue(maps["debugLabel"], datas, "String?", vars, props);
      if (physics == null || context == null) {
        return null;
      }
      return ScrollPositionWithSingleContext(
          physics: physics!,
          context: context!,
          initialPixels: initialPixels ?? 0.0,
          keepScrollOffset: keepScrollOffset ?? true,
          oldPosition: oldPosition,
          debugLabel: debugLabel);
    },
    "ScrollStartNotification": () {
      final metrics =
          getValue(maps["metrics"], datas, "ScrollMetrics", vars, props);
      final context =
          getValue(maps["context"], datas, "BuildContext?", vars, props);
      final dragDetails = getValue(
          maps["dragDetails"], datas, "DragStartDetails?", vars, props);
      if (metrics == null || context == null) {
        return null;
      }
      return ScrollStartNotification(
          metrics: metrics!, context: context!, dragDetails: dragDetails);
    },
    "ScrollToDocumentBoundaryIntent": () {
      final forward = getValue(maps["forward"], datas, "bool", vars, props);
      if (forward == null) {
        return null;
      }
      return ScrollToDocumentBoundaryIntent(forward: forward!);
    },
    "ScrollUpdateNotification": () {
      final metrics =
          getValue(maps["metrics"], datas, "ScrollMetrics", vars, props);
      final context =
          getValue(maps["context"], datas, "BuildContext", vars, props);
      final dragDetails = getValue(
          maps["dragDetails"], datas, "DragUpdateDetails?", vars, props);
      final scrollDelta =
          getValue(maps["scrollDelta"], datas, "double?", vars, props);
      final depth = getValue(maps["depth"], datas, "int?", vars, props);
      if (metrics == null || context == null) {
        return null;
      }
      return ScrollUpdateNotification(
          metrics: metrics!,
          context: context!,
          dragDetails: dragDetails,
          scrollDelta: scrollDelta,
          depth: depth);
    },
    "Scrollable": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final axisDirection =
          getValue(maps["axisDirection"], datas, "AxisDirection", vars, props);
      final controller =
          getValue(maps["controller"], datas, "ScrollController?", vars, props);
      final physics =
          getValue(maps["physics"], datas, "ScrollPhysics?", vars, props);
      final viewportBuilder = getValue(
          maps["viewportBuilder"], datas, "ViewportBuilder", vars, props);
      final incrementCalculator = getValue(maps["incrementCalculator"], datas,
          "ScrollIncrementCalculator?", vars, props);
      final excludeFromSemantics =
          getValue(maps["excludeFromSemantics"], datas, "bool", vars, props);
      final semanticChildCount =
          getValue(maps["semanticChildCount"], datas, "int?", vars, props);
      final dragStartBehavior = getValue(
          maps["dragStartBehavior"], datas, "DragStartBehavior", vars, props);
      final restorationId =
          getValue(maps["restorationId"], datas, "String?", vars, props);
      final scrollBehavior = getValue(
          maps["scrollBehavior"], datas, "ScrollBehavior?", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      if (viewportBuilder == null) {
        return null;
      }
      return Scrollable(
          key: key,
          axisDirection: axisDirection ?? AxisDirection.down,
          controller: controller,
          physics: physics,
          viewportBuilder: viewportBuilder!,
          incrementCalculator: incrementCalculator,
          excludeFromSemantics: excludeFromSemantics ?? false,
          semanticChildCount: semanticChildCount,
          dragStartBehavior: dragStartBehavior ?? DragStartBehavior.start,
          restorationId: restorationId,
          scrollBehavior: scrollBehavior,
          clipBehavior: clipBehavior ?? Clip.hardEdge);
    },
    "ScrollableDetails": () {
      final direction =
          getValue(maps["direction"], datas, "AxisDirection", vars, props);
      final controller =
          getValue(maps["controller"], datas, "ScrollController?", vars, props);
      final physics =
          getValue(maps["physics"], datas, "ScrollPhysics?", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip?", vars, props);
      final decorationClipBehavior =
          getValue(maps["decorationClipBehavior"], datas, "Clip?", vars, props);
      if (direction == null) {
        return null;
      }
      return ScrollableDetails(
          direction: direction!,
          controller: controller,
          physics: physics,
          clipBehavior: clipBehavior,
          decorationClipBehavior: decorationClipBehavior);
    },
    "ScrollableDetails.vertical": () {
      final reverse = getValue(maps["reverse"], datas, "bool", vars, props);
      final controller =
          getValue(maps["controller"], datas, "ScrollController?", vars, props);
      final physics =
          getValue(maps["physics"], datas, "ScrollPhysics?", vars, props);
      final decorationClipBehavior =
          getValue(maps["decorationClipBehavior"], datas, "Clip?", vars, props);
      return ScrollableDetails.vertical(
          reverse: reverse ?? false,
          controller: controller,
          physics: physics,
          decorationClipBehavior: decorationClipBehavior);
    },
    "ScrollableDetails.horizontal": () {
      final reverse = getValue(maps["reverse"], datas, "bool", vars, props);
      final controller =
          getValue(maps["controller"], datas, "ScrollController?", vars, props);
      final physics =
          getValue(maps["physics"], datas, "ScrollPhysics?", vars, props);
      final decorationClipBehavior =
          getValue(maps["decorationClipBehavior"], datas, "Clip?", vars, props);
      return ScrollableDetails.horizontal(
          reverse: reverse ?? false,
          controller: controller,
          physics: physics,
          decorationClipBehavior: decorationClipBehavior);
    },
    "Scrollbar": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      final controller =
          getValue(maps["controller"], datas, "ScrollController?", vars, props);
      final thumbVisibility =
          getValue(maps["thumbVisibility"], datas, "bool?", vars, props);
      final trackVisibility =
          getValue(maps["trackVisibility"], datas, "bool?", vars, props);
      final thickness =
          getValue(maps["thickness"], datas, "double?", vars, props);
      final radius = getValue(maps["radius"], datas, "Radius?", vars, props);
      final notificationPredicate = getValue(maps["notificationPredicate"],
          datas, "ScrollNotificationPredicate?", vars, props);
      final interactive =
          getValue(maps["interactive"], datas, "bool?", vars, props);
      final scrollbarOrientation = getValue(maps["scrollbarOrientation"], datas,
          "ScrollbarOrientation?", vars, props);
      final isAlwaysShown =
          getValue(maps["isAlwaysShown"], datas, "bool?", vars, props);
      final showTrackOnHover =
          getValue(maps["showTrackOnHover"], datas, "bool?", vars, props);
      final hoverThickness =
          getValue(maps["hoverThickness"], datas, "double?", vars, props);
      if (child == null) {
        return null;
      }
      return Scrollbar(
        key: key,
        child: child!,
        controller: controller,
        thumbVisibility: thumbVisibility,
        trackVisibility: trackVisibility,
        thickness: thickness,
        radius: radius,
        notificationPredicate: notificationPredicate,
        interactive: interactive,
        scrollbarOrientation: scrollbarOrientation,
        // isAlwaysShown: isAlwaysShown,
        // showTrackOnHover: showTrackOnHover,
        // hoverThickness: hoverThickness,
      );
    },
    "ScrollbarPainter": () {
      final color = getValue(maps["color"], datas, "Color", vars, props);
      final fadeoutOpacityAnimation = getValue(maps["fadeoutOpacityAnimation"],
          datas, "Animation<double>", vars, props);
      final trackColor =
          getValue(maps["trackColor"], datas, "Color", vars, props);
      final trackBorderColor =
          getValue(maps["trackBorderColor"], datas, "Color", vars, props);
      final textDirection =
          getValue(maps["textDirection"], datas, "TextDirection?", vars, props);
      final thickness =
          getValue(maps["thickness"], datas, "double", vars, props);
      final padding =
          getValue(maps["padding"], datas, "EdgeInsets", vars, props);
      final mainAxisMargin =
          getValue(maps["mainAxisMargin"], datas, "double", vars, props);
      final crossAxisMargin =
          getValue(maps["crossAxisMargin"], datas, "double", vars, props);
      final radius = getValue(maps["radius"], datas, "Radius?", vars, props);
      final trackRadius =
          getValue(maps["trackRadius"], datas, "Radius?", vars, props);
      final shape =
          getValue(maps["shape"], datas, "OutlinedBorder?", vars, props);
      final minLength =
          getValue(maps["minLength"], datas, "double", vars, props);
      final minOverscrollLength =
          getValue(maps["minOverscrollLength"], datas, "double?", vars, props);
      final scrollbarOrientation = getValue(maps["scrollbarOrientation"], datas,
          "ScrollbarOrientation?", vars, props);
      final ignorePointer =
          getValue(maps["ignorePointer"], datas, "bool", vars, props);
      if (color == null || fadeoutOpacityAnimation == null) {
        return null;
      }
      if (thickness != null && minLength != null) {
        return ScrollbarPainter(
            color: color!,
            fadeoutOpacityAnimation: fadeoutOpacityAnimation!,
            trackColor: trackColor ?? const Color(0x00000000),
            trackBorderColor: trackBorderColor ?? const Color(0x00000000),
            textDirection: textDirection,
            padding: padding ?? EdgeInsets.zero,
            mainAxisMargin: mainAxisMargin ?? 0.0,
            crossAxisMargin: crossAxisMargin ?? 0.0,
            radius: radius,
            trackRadius: trackRadius,
            shape: shape,
            minOverscrollLength: minOverscrollLength,
            scrollbarOrientation: scrollbarOrientation,
            ignorePointer: ignorePointer ?? false,
            thickness: thickness,
            minLength: minLength);
      }
      if (thickness != null) {
        return ScrollbarPainter(
            color: color!,
            fadeoutOpacityAnimation: fadeoutOpacityAnimation!,
            trackColor: trackColor ?? const Color(0x00000000),
            trackBorderColor: trackBorderColor ?? const Color(0x00000000),
            textDirection: textDirection,
            padding: padding ?? EdgeInsets.zero,
            mainAxisMargin: mainAxisMargin ?? 0.0,
            crossAxisMargin: crossAxisMargin ?? 0.0,
            radius: radius,
            trackRadius: trackRadius,
            shape: shape,
            minOverscrollLength: minOverscrollLength,
            scrollbarOrientation: scrollbarOrientation,
            ignorePointer: ignorePointer ?? false,
            thickness: thickness);
      }
      if (minLength != null) {
        return ScrollbarPainter(
            color: color!,
            fadeoutOpacityAnimation: fadeoutOpacityAnimation!,
            trackColor: trackColor ?? const Color(0x00000000),
            trackBorderColor: trackBorderColor ?? const Color(0x00000000),
            textDirection: textDirection,
            padding: padding ?? EdgeInsets.zero,
            mainAxisMargin: mainAxisMargin ?? 0.0,
            crossAxisMargin: crossAxisMargin ?? 0.0,
            radius: radius,
            trackRadius: trackRadius,
            shape: shape,
            minOverscrollLength: minOverscrollLength,
            scrollbarOrientation: scrollbarOrientation,
            ignorePointer: ignorePointer ?? false,
            minLength: minLength);
      }
      return ScrollbarPainter(
          color: color!,
          fadeoutOpacityAnimation: fadeoutOpacityAnimation!,
          trackColor: trackColor ?? const Color(0x00000000),
          trackBorderColor: trackBorderColor ?? const Color(0x00000000),
          textDirection: textDirection,
          padding: padding ?? EdgeInsets.zero,
          mainAxisMargin: mainAxisMargin ?? 0.0,
          crossAxisMargin: crossAxisMargin ?? 0.0,
          radius: radius,
          trackRadius: trackRadius,
          shape: shape,
          minOverscrollLength: minOverscrollLength,
          scrollbarOrientation: scrollbarOrientation,
          ignorePointer: ignorePointer ?? false);
    },
    "ScrollbarTheme": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final data =
          getValue(maps["data"], datas, "ScrollbarThemeData", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (data == null || child == null) {
        return null;
      }
      return ScrollbarTheme(key: key, data: data!, child: child!);
    },
    "ScrollbarThemeData": () {
      final thumbVisibility = getValue(maps["thumbVisibility"], datas,
          "MaterialStateProperty<bool?>?", vars, props);
      final thickness = getValue(maps["thickness"], datas,
          "MaterialStateProperty<double?>?", vars, props);
      final trackVisibility = getValue(maps["trackVisibility"], datas,
          "MaterialStateProperty<bool?>?", vars, props);
      final radius = getValue(maps["radius"], datas, "Radius?", vars, props);
      final thumbColor = getValue(maps["thumbColor"], datas,
          "MaterialStateProperty<Color?>?", vars, props);
      final trackColor = getValue(maps["trackColor"], datas,
          "MaterialStateProperty<Color?>?", vars, props);
      final trackBorderColor = getValue(maps["trackBorderColor"], datas,
          "MaterialStateProperty<Color?>?", vars, props);
      final crossAxisMargin =
          getValue(maps["crossAxisMargin"], datas, "double?", vars, props);
      final mainAxisMargin =
          getValue(maps["mainAxisMargin"], datas, "double?", vars, props);
      final minThumbLength =
          getValue(maps["minThumbLength"], datas, "double?", vars, props);
      final interactive =
          getValue(maps["interactive"], datas, "bool?", vars, props);
      final isAlwaysShown =
          getValue(maps["isAlwaysShown"], datas, "bool?", vars, props);
      final showTrackOnHover =
          getValue(maps["showTrackOnHover"], datas, "bool?", vars, props);
      return ScrollbarThemeData(
        thumbVisibility: thumbVisibility,
        thickness: thickness,
        trackVisibility: trackVisibility,
        radius: radius,
        thumbColor: thumbColor,
        trackColor: trackColor,
        trackBorderColor: trackBorderColor,
        crossAxisMargin: crossAxisMargin,
        mainAxisMargin: mainAxisMargin,
        minThumbLength: minThumbLength,
        interactive: interactive,
        // isAlwaysShown: isAlwaysShown,
        // showTrackOnHover: showTrackOnHover,
      );
    },
    "SearchAnchor": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final isFullScreen =
          getValue(maps["isFullScreen"], datas, "bool?", vars, props);
      final searchController = getValue(
          maps["searchController"], datas, "SearchController?", vars, props);
      final viewBuilder =
          getValue(maps["viewBuilder"], datas, "ViewBuilder?", vars, props);
      final viewLeading =
          getValue(maps["viewLeading"], datas, "Widget?", vars, props);
      final viewTrailing = getValue(
          maps["viewTrailing"], datas, "Iterable<Widget>?", vars, props);
      final viewHintText =
          getValue(maps["viewHintText"], datas, "String?", vars, props);
      final viewBackgroundColor =
          getValue(maps["viewBackgroundColor"], datas, "Color?", vars, props);
      final viewElevation =
          getValue(maps["viewElevation"], datas, "double?", vars, props);
      final viewSurfaceTintColor =
          getValue(maps["viewSurfaceTintColor"], datas, "Color?", vars, props);
      final viewSide =
          getValue(maps["viewSide"], datas, "BorderSide?", vars, props);
      final viewShape =
          getValue(maps["viewShape"], datas, "OutlinedBorder?", vars, props);
      final headerTextStyle =
          getValue(maps["headerTextStyle"], datas, "TextStyle?", vars, props);
      final headerHintStyle =
          getValue(maps["headerHintStyle"], datas, "TextStyle?", vars, props);
      final dividerColor =
          getValue(maps["dividerColor"], datas, "Color?", vars, props);
      final viewConstraints = getValue(
          maps["viewConstraints"], datas, "BoxConstraints?", vars, props);
      final builder = getValue(
          maps["builder"], datas, "SearchAnchorChildBuilder", vars, props);
      final suggestionsBuilder = getValue(
          maps["suggestionsBuilder"], datas, "SuggestionsBuilder", vars, props);
      if (builder == null || suggestionsBuilder == null) {
        return null;
      }
      return SearchAnchor(
          key: key,
          isFullScreen: isFullScreen,
          searchController: searchController,
          viewBuilder: viewBuilder,
          viewLeading: viewLeading,
          viewTrailing: viewTrailing,
          viewHintText: viewHintText,
          viewBackgroundColor: viewBackgroundColor,
          viewElevation: viewElevation,
          viewSurfaceTintColor: viewSurfaceTintColor,
          viewSide: viewSide,
          viewShape: viewShape,
          headerTextStyle: headerTextStyle,
          headerHintStyle: headerHintStyle,
          dividerColor: dividerColor,
          viewConstraints: viewConstraints,
          builder: builder!,
          suggestionsBuilder: suggestionsBuilder!);
    },
    "SearchAnchor.bar": () {
      final barLeading =
          getValue(maps["barLeading"], datas, "Widget?", vars, props);
      final barTrailing = getValue(
          maps["barTrailing"], datas, "Iterable<Widget>?", vars, props);
      final barHintText =
          getValue(maps["barHintText"], datas, "String?", vars, props);
      final onTap =
          getValue(maps["onTap"], datas, "GestureTapCallback?", vars, props);
      final barElevation = getValue(maps["barElevation"], datas,
          "MaterialStateProperty<double?>?", vars, props);
      final barBackgroundColor = getValue(maps["barBackgroundColor"], datas,
          "MaterialStateProperty<Color?>?", vars, props);
      final barOverlayColor = getValue(maps["barOverlayColor"], datas,
          "MaterialStateProperty<Color?>?", vars, props);
      final barSide = getValue(maps["barSide"], datas,
          "MaterialStateProperty<BorderSide?>?", vars, props);
      final barShape = getValue(maps["barShape"], datas,
          "MaterialStateProperty<OutlinedBorder?>?", vars, props);
      final barPadding = getValue(maps["barPadding"], datas,
          "MaterialStateProperty<EdgeInsetsGeometry?>?", vars, props);
      final barTextStyle = getValue(maps["barTextStyle"], datas,
          "MaterialStateProperty<TextStyle?>?", vars, props);
      final barHintStyle = getValue(maps["barHintStyle"], datas,
          "MaterialStateProperty<TextStyle?>?", vars, props);
      final viewLeading =
          getValue(maps["viewLeading"], datas, "Widget?", vars, props);
      final viewTrailing = getValue(
          maps["viewTrailing"], datas, "Iterable<Widget>?", vars, props);
      final viewHintText =
          getValue(maps["viewHintText"], datas, "String?", vars, props);
      final viewBackgroundColor =
          getValue(maps["viewBackgroundColor"], datas, "Color?", vars, props);
      final viewElevation =
          getValue(maps["viewElevation"], datas, "double?", vars, props);
      final viewSide =
          getValue(maps["viewSide"], datas, "BorderSide?", vars, props);
      final viewShape =
          getValue(maps["viewShape"], datas, "OutlinedBorder?", vars, props);
      final viewHeaderTextStyle = getValue(
          maps["viewHeaderTextStyle"], datas, "TextStyle?", vars, props);
      final viewHeaderHintStyle = getValue(
          maps["viewHeaderHintStyle"], datas, "TextStyle?", vars, props);
      final dividerColor =
          getValue(maps["dividerColor"], datas, "Color?", vars, props);
      final constraints =
          getValue(maps["constraints"], datas, "BoxConstraints?", vars, props);
      final viewConstraints = getValue(
          maps["viewConstraints"], datas, "BoxConstraints?", vars, props);
      final isFullScreen =
          getValue(maps["isFullScreen"], datas, "bool?", vars, props);
      final searchController = getValue(
          maps["searchController"], datas, "SearchController", vars, props);
      final suggestionsBuilder = getValue(
          maps["suggestionsBuilder"], datas, "SuggestionsBuilder", vars, props);
      if (suggestionsBuilder == null) {
        return null;
      }
      return SearchAnchor.bar(
          barLeading: barLeading,
          barTrailing: barTrailing,
          barHintText: barHintText,
          onTap: onTap,
          barElevation: barElevation,
          barBackgroundColor: barBackgroundColor,
          barOverlayColor: barOverlayColor,
          barSide: barSide,
          barShape: barShape,
          barPadding: barPadding,
          barTextStyle: barTextStyle,
          barHintStyle: barHintStyle,
          viewLeading: viewLeading,
          viewTrailing: viewTrailing,
          viewHintText: viewHintText,
          viewBackgroundColor: viewBackgroundColor,
          viewElevation: viewElevation,
          viewSide: viewSide,
          viewShape: viewShape,
          viewHeaderTextStyle: viewHeaderTextStyle,
          viewHeaderHintStyle: viewHeaderHintStyle,
          dividerColor: dividerColor,
          constraints: constraints,
          viewConstraints: viewConstraints,
          isFullScreen: isFullScreen,
          searchController: searchController,
          suggestionsBuilder: suggestionsBuilder!);
    },
    "SearchBar": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final controller = getValue(
          maps["controller"], datas, "TextEditingController?", vars, props);
      final focusNode =
          getValue(maps["focusNode"], datas, "FocusNode?", vars, props);
      final hintText =
          getValue(maps["hintText"], datas, "String?", vars, props);
      final leading = getValue(maps["leading"], datas, "Widget?", vars, props);
      final trailing =
          getValue(maps["trailing"], datas, "Iterable<Widget>?", vars, props);
      final onTap =
          getValue(maps["onTap"], datas, "GestureTapCallback?", vars, props);
      final onChanged = getValue(
          maps["onChanged"], datas, "ValueChanged<String>?", vars, props);
      final constraints =
          getValue(maps["constraints"], datas, "BoxConstraints?", vars, props);
      final elevation = getValue(maps["elevation"], datas,
          "MaterialStateProperty<double?>?", vars, props);
      final backgroundColor = getValue(maps["backgroundColor"], datas,
          "MaterialStateProperty<Color?>?", vars, props);
      final shadowColor = getValue(maps["shadowColor"], datas,
          "MaterialStateProperty<Color?>?", vars, props);
      final surfaceTintColor = getValue(maps["surfaceTintColor"], datas,
          "MaterialStateProperty<Color?>?", vars, props);
      final overlayColor = getValue(maps["overlayColor"], datas,
          "MaterialStateProperty<Color?>?", vars, props);
      final side = getValue(maps["side"], datas,
          "MaterialStateProperty<BorderSide?>?", vars, props);
      final shape = getValue(maps["shape"], datas,
          "MaterialStateProperty<OutlinedBorder?>?", vars, props);
      final padding = getValue(maps["padding"], datas,
          "MaterialStateProperty<EdgeInsetsGeometry?>?", vars, props);
      final textStyle = getValue(maps["textStyle"], datas,
          "MaterialStateProperty<TextStyle?>?", vars, props);
      final hintStyle = getValue(maps["hintStyle"], datas,
          "MaterialStateProperty<TextStyle?>?", vars, props);
      return SearchBar(
          key: key,
          controller: controller,
          focusNode: focusNode,
          hintText: hintText,
          leading: leading,
          trailing: trailing,
          onTap: onTap,
          onChanged: onChanged,
          constraints: constraints,
          elevation: elevation,
          backgroundColor: backgroundColor,
          shadowColor: shadowColor,
          surfaceTintColor: surfaceTintColor,
          overlayColor: overlayColor,
          side: side,
          shape: shape,
          padding: padding,
          textStyle: textStyle,
          hintStyle: hintStyle);
    },
    "SearchBarTheme": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final data =
          getValue(maps["data"], datas, "SearchBarThemeData", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (data == null || child == null) {
        return null;
      }
      return SearchBarTheme(key: key, data: data!, child: child!);
    },
    "SearchBarThemeData": () {
      final elevation = getValue(maps["elevation"], datas,
          "MaterialStateProperty<double?>?", vars, props);
      final backgroundColor = getValue(maps["backgroundColor"], datas,
          "MaterialStateProperty<Color?>?", vars, props);
      final shadowColor = getValue(maps["shadowColor"], datas,
          "MaterialStateProperty<Color?>?", vars, props);
      final surfaceTintColor = getValue(maps["surfaceTintColor"], datas,
          "MaterialStateProperty<Color?>?", vars, props);
      final overlayColor = getValue(maps["overlayColor"], datas,
          "MaterialStateProperty<Color?>?", vars, props);
      final side = getValue(maps["side"], datas,
          "MaterialStateProperty<BorderSide?>?", vars, props);
      final shape = getValue(maps["shape"], datas,
          "MaterialStateProperty<OutlinedBorder?>?", vars, props);
      final padding = getValue(maps["padding"], datas,
          "MaterialStateProperty<EdgeInsetsGeometry?>?", vars, props);
      final textStyle = getValue(maps["textStyle"], datas,
          "MaterialStateProperty<TextStyle?>?", vars, props);
      final hintStyle = getValue(maps["hintStyle"], datas,
          "MaterialStateProperty<TextStyle?>?", vars, props);
      final constraints =
          getValue(maps["constraints"], datas, "BoxConstraints?", vars, props);
      return SearchBarThemeData(
          elevation: elevation,
          backgroundColor: backgroundColor,
          shadowColor: shadowColor,
          surfaceTintColor: surfaceTintColor,
          overlayColor: overlayColor,
          side: side,
          shape: shape,
          padding: padding,
          textStyle: textStyle,
          hintStyle: hintStyle,
          constraints: constraints);
    },
    "SearchViewTheme": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final data =
          getValue(maps["data"], datas, "SearchViewThemeData", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (data == null || child == null) {
        return null;
      }
      return SearchViewTheme(key: key, data: data!, child: child!);
    },
    "SearchViewThemeData": () {
      final backgroundColor =
          getValue(maps["backgroundColor"], datas, "Color?", vars, props);
      final elevation =
          getValue(maps["elevation"], datas, "double?", vars, props);
      final surfaceTintColor =
          getValue(maps["surfaceTintColor"], datas, "Color?", vars, props);
      final constraints =
          getValue(maps["constraints"], datas, "BoxConstraints?", vars, props);
      final side = getValue(maps["side"], datas, "BorderSide?", vars, props);
      final shape =
          getValue(maps["shape"], datas, "OutlinedBorder?", vars, props);
      final headerTextStyle =
          getValue(maps["headerTextStyle"], datas, "TextStyle?", vars, props);
      final headerHintStyle =
          getValue(maps["headerHintStyle"], datas, "TextStyle?", vars, props);
      final dividerColor =
          getValue(maps["dividerColor"], datas, "Color?", vars, props);
      return SearchViewThemeData(
          backgroundColor: backgroundColor,
          elevation: elevation,
          surfaceTintColor: surfaceTintColor,
          constraints: constraints,
          side: side,
          shape: shape,
          headerTextStyle: headerTextStyle,
          headerHintStyle: headerHintStyle,
          dividerColor: dividerColor);
    },
    "SegmentedButton": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final segments = getValue(
          maps["segments"], datas, "List<ButtonSegment<T>>", vars, props);
      final selected = getValue(maps["selected"], datas, "Set<T>", vars, props);
      final onSelectionChanged =
          getValue(maps["onSelectionChanged"], datas, "", vars, props);
      final multiSelectionEnabled =
          getValue(maps["multiSelectionEnabled"], datas, "bool", vars, props);
      final emptySelectionAllowed =
          getValue(maps["emptySelectionAllowed"], datas, "bool", vars, props);
      final style = getValue(maps["style"], datas, "ButtonStyle?", vars, props);
      final showSelectedIcon =
          getValue(maps["showSelectedIcon"], datas, "bool", vars, props);
      final selectedIcon =
          getValue(maps["selectedIcon"], datas, "Widget?", vars, props);
      if (segments == null || selected == null) {
        return null;
      }
      return SegmentedButton(
          key: key,
          segments: List<ButtonSegment<T>>.from(segments!),
          selected: Set<T>.from(selected!),
          onSelectionChanged: onSelectionChanged,
          multiSelectionEnabled: multiSelectionEnabled ?? false,
          emptySelectionAllowed: emptySelectionAllowed ?? false,
          style: style,
          showSelectedIcon: showSelectedIcon ?? true,
          selectedIcon: selectedIcon);
    },
    "SegmentedButtonTheme": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final data = getValue(
          maps["data"], datas, "SegmentedButtonThemeData", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (data == null || child == null) {
        return null;
      }
      return SegmentedButtonTheme(key: key, data: data!, child: child!);
    },
    "SegmentedButtonThemeData": () {
      final style = getValue(maps["style"], datas, "ButtonStyle?", vars, props);
      final selectedIcon =
          getValue(maps["selectedIcon"], datas, "Widget?", vars, props);
      return SegmentedButtonThemeData(style: style, selectedIcon: selectedIcon);
    },
    "SelectAllSelectionEvent": () {
      return const SelectAllSelectionEvent();
    },
    "SelectAllTextIntent": () {
      final cause =
          getValue(maps["0"], datas, "SelectionChangedCause", vars, props);
      if (cause == null) {
        return null;
      }
      return SelectAllTextIntent(cause!);
    },
    "SelectIntent": () {
      return const SelectIntent();
    },
    "SelectWordSelectionEvent": () {
      final globalPosition =
          getValue(maps["globalPosition"], datas, "Offset", vars, props);
      if (globalPosition == null) {
        return null;
      }
      return SelectWordSelectionEvent(globalPosition: globalPosition!);
    },
    "SelectableRegion": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final contextMenuBuilder = getValue(maps["contextMenuBuilder"], datas,
          "SelectableRegionContextMenuBuilder?", vars, props);
      final focusNode =
          getValue(maps["focusNode"], datas, "FocusNode", vars, props);
      final selectionControls = getValue(maps["selectionControls"], datas,
          "TextSelectionControls", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      final magnifierConfiguration = getValue(maps["magnifierConfiguration"],
          datas, "TextMagnifierConfiguration", vars, props);
      final onSelectionChanged = getValue(maps["onSelectionChanged"], datas,
          "ValueChanged<SelectedContent?>?", vars, props);
      if (focusNode == null || selectionControls == null || child == null) {
        return null;
      }
      return SelectableRegion(
          key: key,
          contextMenuBuilder: contextMenuBuilder,
          focusNode: focusNode!,
          selectionControls: selectionControls!,
          child: child!,
          magnifierConfiguration:
              magnifierConfiguration ?? TextMagnifierConfiguration.disabled,
          onSelectionChanged: onSelectionChanged);
    },
    "SelectableText": () {
      final data = getValue(maps["0"], datas, "String", vars, props);
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final focusNode =
          getValue(maps["focusNode"], datas, "FocusNode?", vars, props);
      final style = getValue(maps["style"], datas, "TextStyle?", vars, props);
      final strutStyle =
          getValue(maps["strutStyle"], datas, "StrutStyle?", vars, props);
      final textAlign =
          getValue(maps["textAlign"], datas, "TextAlign?", vars, props);
      final textDirection =
          getValue(maps["textDirection"], datas, "TextDirection?", vars, props);
      final textScaleFactor =
          getValue(maps["textScaleFactor"], datas, "double?", vars, props);
      final showCursor =
          getValue(maps["showCursor"], datas, "bool", vars, props);
      final autofocus = getValue(maps["autofocus"], datas, "bool", vars, props);
      final toolbarOptions = getValue(
          maps["toolbarOptions"], datas, "ToolbarOptions?", vars, props);
      final minLines = getValue(maps["minLines"], datas, "int?", vars, props);
      final maxLines = getValue(maps["maxLines"], datas, "int?", vars, props);
      final cursorWidth =
          getValue(maps["cursorWidth"], datas, "double", vars, props);
      final cursorHeight =
          getValue(maps["cursorHeight"], datas, "double?", vars, props);
      final cursorRadius =
          getValue(maps["cursorRadius"], datas, "Radius?", vars, props);
      final cursorColor =
          getValue(maps["cursorColor"], datas, "Color?", vars, props);
      final selectionHeightStyle = getValue(
          maps["selectionHeightStyle"], datas, "BoxHeightStyle", vars, props);
      final selectionWidthStyle = getValue(
          maps["selectionWidthStyle"], datas, "BoxWidthStyle", vars, props);
      final dragStartBehavior = getValue(
          maps["dragStartBehavior"], datas, "DragStartBehavior", vars, props);
      final enableInteractiveSelection = getValue(
          maps["enableInteractiveSelection"], datas, "bool", vars, props);
      final selectionControls = getValue(maps["selectionControls"], datas,
          "TextSelectionControls?", vars, props);
      final onTap =
          getValue(maps["onTap"], datas, "GestureTapCallback?", vars, props);
      final scrollPhysics =
          getValue(maps["scrollPhysics"], datas, "ScrollPhysics?", vars, props);
      final semanticsLabel =
          getValue(maps["semanticsLabel"], datas, "String?", vars, props);
      final textHeightBehavior = getValue(maps["textHeightBehavior"], datas,
          "TextHeightBehavior?", vars, props);
      final textWidthBasis = getValue(
          maps["textWidthBasis"], datas, "TextWidthBasis?", vars, props);
      final onSelectionChanged = getValue(maps["onSelectionChanged"], datas,
          "SelectionChangedCallback?", vars, props);
      final contextMenuBuilder = getValue(maps["contextMenuBuilder"], datas,
          "EditableTextContextMenuBuilder?", vars, props);
      final magnifierConfiguration = getValue(maps["magnifierConfiguration"],
          datas, "TextMagnifierConfiguration?", vars, props);
      if (data == null) {
        return null;
      }
      if (contextMenuBuilder != null) {
        return SelectableText(data!,
            key: key,
            focusNode: focusNode,
            style: style,
            strutStyle: strutStyle,
            textAlign: textAlign,
            textDirection: textDirection,
            textScaleFactor: textScaleFactor,
            showCursor: showCursor ?? false,
            autofocus: autofocus ?? false,
            toolbarOptions: toolbarOptions,
            minLines: minLines,
            maxLines: maxLines,
            cursorWidth: cursorWidth ?? 2.0,
            cursorHeight: cursorHeight,
            cursorRadius: cursorRadius,
            cursorColor: cursorColor,
            selectionHeightStyle:
                selectionHeightStyle ?? ui.BoxHeightStyle.tight,
            selectionWidthStyle: selectionWidthStyle ?? ui.BoxWidthStyle.tight,
            dragStartBehavior: dragStartBehavior ?? DragStartBehavior.start,
            enableInteractiveSelection: enableInteractiveSelection ?? true,
            selectionControls: selectionControls,
            onTap: onTap,
            scrollPhysics: scrollPhysics,
            semanticsLabel: semanticsLabel,
            textHeightBehavior: textHeightBehavior,
            textWidthBasis: textWidthBasis,
            onSelectionChanged: onSelectionChanged,
            magnifierConfiguration: magnifierConfiguration,
            contextMenuBuilder: contextMenuBuilder);
      }
      return SelectableText(data!,
          key: key,
          focusNode: focusNode,
          style: style,
          strutStyle: strutStyle,
          textAlign: textAlign,
          textDirection: textDirection,
          textScaleFactor: textScaleFactor,
          showCursor: showCursor ?? false,
          autofocus: autofocus ?? false,
          toolbarOptions: toolbarOptions,
          minLines: minLines,
          maxLines: maxLines,
          cursorWidth: cursorWidth ?? 2.0,
          cursorHeight: cursorHeight,
          cursorRadius: cursorRadius,
          cursorColor: cursorColor,
          selectionHeightStyle: selectionHeightStyle ?? ui.BoxHeightStyle.tight,
          selectionWidthStyle: selectionWidthStyle ?? ui.BoxWidthStyle.tight,
          dragStartBehavior: dragStartBehavior ?? DragStartBehavior.start,
          enableInteractiveSelection: enableInteractiveSelection ?? true,
          selectionControls: selectionControls,
          onTap: onTap,
          scrollPhysics: scrollPhysics,
          semanticsLabel: semanticsLabel,
          textHeightBehavior: textHeightBehavior,
          textWidthBasis: textWidthBasis,
          onSelectionChanged: onSelectionChanged,
          magnifierConfiguration: magnifierConfiguration);
    },
    "SelectableText.rich": () {
      final textSpan = getValue(maps["0"], datas, "TextSpan", vars, props);
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final focusNode =
          getValue(maps["focusNode"], datas, "FocusNode?", vars, props);
      final style = getValue(maps["style"], datas, "TextStyle?", vars, props);
      final strutStyle =
          getValue(maps["strutStyle"], datas, "StrutStyle?", vars, props);
      final textAlign =
          getValue(maps["textAlign"], datas, "TextAlign?", vars, props);
      final textDirection =
          getValue(maps["textDirection"], datas, "TextDirection?", vars, props);
      final textScaleFactor =
          getValue(maps["textScaleFactor"], datas, "double?", vars, props);
      final showCursor =
          getValue(maps["showCursor"], datas, "bool", vars, props);
      final autofocus = getValue(maps["autofocus"], datas, "bool", vars, props);
      final toolbarOptions = getValue(
          maps["toolbarOptions"], datas, "ToolbarOptions?", vars, props);
      final minLines = getValue(maps["minLines"], datas, "int?", vars, props);
      final maxLines = getValue(maps["maxLines"], datas, "int?", vars, props);
      final cursorWidth =
          getValue(maps["cursorWidth"], datas, "double", vars, props);
      final cursorHeight =
          getValue(maps["cursorHeight"], datas, "double?", vars, props);
      final cursorRadius =
          getValue(maps["cursorRadius"], datas, "Radius?", vars, props);
      final cursorColor =
          getValue(maps["cursorColor"], datas, "Color?", vars, props);
      final selectionHeightStyle = getValue(
          maps["selectionHeightStyle"], datas, "BoxHeightStyle", vars, props);
      final selectionWidthStyle = getValue(
          maps["selectionWidthStyle"], datas, "BoxWidthStyle", vars, props);
      final dragStartBehavior = getValue(
          maps["dragStartBehavior"], datas, "DragStartBehavior", vars, props);
      final enableInteractiveSelection = getValue(
          maps["enableInteractiveSelection"], datas, "bool", vars, props);
      final selectionControls = getValue(maps["selectionControls"], datas,
          "TextSelectionControls?", vars, props);
      final onTap =
          getValue(maps["onTap"], datas, "GestureTapCallback?", vars, props);
      final scrollPhysics =
          getValue(maps["scrollPhysics"], datas, "ScrollPhysics?", vars, props);
      final semanticsLabel =
          getValue(maps["semanticsLabel"], datas, "String?", vars, props);
      final textHeightBehavior = getValue(maps["textHeightBehavior"], datas,
          "TextHeightBehavior?", vars, props);
      final textWidthBasis = getValue(
          maps["textWidthBasis"], datas, "TextWidthBasis?", vars, props);
      final onSelectionChanged = getValue(maps["onSelectionChanged"], datas,
          "SelectionChangedCallback?", vars, props);
      final contextMenuBuilder = getValue(maps["contextMenuBuilder"], datas,
          "EditableTextContextMenuBuilder?", vars, props);
      final magnifierConfiguration = getValue(maps["magnifierConfiguration"],
          datas, "TextMagnifierConfiguration?", vars, props);
      if (textSpan == null) {
        return null;
      }
      if (contextMenuBuilder != null) {
        return SelectableText.rich(textSpan!,
            key: key,
            focusNode: focusNode,
            style: style,
            strutStyle: strutStyle,
            textAlign: textAlign,
            textDirection: textDirection,
            textScaleFactor: textScaleFactor,
            showCursor: showCursor ?? false,
            autofocus: autofocus ?? false,
            toolbarOptions: toolbarOptions,
            minLines: minLines,
            maxLines: maxLines,
            cursorWidth: cursorWidth ?? 2.0,
            cursorHeight: cursorHeight,
            cursorRadius: cursorRadius,
            cursorColor: cursorColor,
            selectionHeightStyle:
                selectionHeightStyle ?? ui.BoxHeightStyle.tight,
            selectionWidthStyle: selectionWidthStyle ?? ui.BoxWidthStyle.tight,
            dragStartBehavior: dragStartBehavior ?? DragStartBehavior.start,
            enableInteractiveSelection: enableInteractiveSelection ?? true,
            selectionControls: selectionControls,
            onTap: onTap,
            scrollPhysics: scrollPhysics,
            semanticsLabel: semanticsLabel,
            textHeightBehavior: textHeightBehavior,
            textWidthBasis: textWidthBasis,
            onSelectionChanged: onSelectionChanged,
            magnifierConfiguration: magnifierConfiguration,
            contextMenuBuilder: contextMenuBuilder);
      }
      return SelectableText.rich(textSpan!,
          key: key,
          focusNode: focusNode,
          style: style,
          strutStyle: strutStyle,
          textAlign: textAlign,
          textDirection: textDirection,
          textScaleFactor: textScaleFactor,
          showCursor: showCursor ?? false,
          autofocus: autofocus ?? false,
          toolbarOptions: toolbarOptions,
          minLines: minLines,
          maxLines: maxLines,
          cursorWidth: cursorWidth ?? 2.0,
          cursorHeight: cursorHeight,
          cursorRadius: cursorRadius,
          cursorColor: cursorColor,
          selectionHeightStyle: selectionHeightStyle ?? ui.BoxHeightStyle.tight,
          selectionWidthStyle: selectionWidthStyle ?? ui.BoxWidthStyle.tight,
          dragStartBehavior: dragStartBehavior ?? DragStartBehavior.start,
          enableInteractiveSelection: enableInteractiveSelection ?? true,
          selectionControls: selectionControls,
          onTap: onTap,
          scrollPhysics: scrollPhysics,
          semanticsLabel: semanticsLabel,
          textHeightBehavior: textHeightBehavior,
          textWidthBasis: textWidthBasis,
          onSelectionChanged: onSelectionChanged,
          magnifierConfiguration: magnifierConfiguration);
    },
    "SelectedContent": () {
      final plainText =
          getValue(maps["plainText"], datas, "String", vars, props);
      if (plainText == null) {
        return null;
      }
      return SelectedContent(plainText: plainText!);
    },
    "SelectionArea": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final focusNode =
          getValue(maps["focusNode"], datas, "FocusNode?", vars, props);
      final selectionControls = getValue(maps["selectionControls"], datas,
          "TextSelectionControls?", vars, props);
      final contextMenuBuilder = getValue(maps["contextMenuBuilder"], datas,
          "SelectableRegionContextMenuBuilder?", vars, props);
      final magnifierConfiguration = getValue(maps["magnifierConfiguration"],
          datas, "TextMagnifierConfiguration?", vars, props);
      final onSelectionChanged = getValue(maps["onSelectionChanged"], datas,
          "ValueChanged<SelectedContent?>?", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (child == null) {
        return null;
      }
      if (contextMenuBuilder != null) {
        return SelectionArea(
            key: key,
            focusNode: focusNode,
            selectionControls: selectionControls,
            magnifierConfiguration: magnifierConfiguration,
            onSelectionChanged: onSelectionChanged,
            child: child!,
            contextMenuBuilder: contextMenuBuilder);
      }
      return SelectionArea(
          key: key,
          focusNode: focusNode,
          selectionControls: selectionControls,
          magnifierConfiguration: magnifierConfiguration,
          onSelectionChanged: onSelectionChanged,
          child: child!);
    },
    "SelectionContainer": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final registrar = getValue(
          maps["registrar"], datas, "SelectionRegistrar?", vars, props);
      final delegate = getValue(
          maps["delegate"], datas, "SelectionContainerDelegate", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (delegate == null || child == null) {
        return null;
      }
      return SelectionContainer(
          key: key, registrar: registrar, delegate: delegate!, child: child!);
    },
    "SelectionContainer.disabled": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (child == null) {
        return null;
      }
      return SelectionContainer.disabled(key: key, child: child!);
    },
    "SelectionEdgeUpdateEvent.forStart": () {
      final globalPosition =
          getValue(maps["globalPosition"], datas, "Offset", vars, props);
      if (globalPosition == null) {
        return null;
      }
      return SelectionEdgeUpdateEvent.forStart(globalPosition: globalPosition!);
    },
    "SelectionEdgeUpdateEvent.forEnd": () {
      final globalPosition =
          getValue(maps["globalPosition"], datas, "Offset", vars, props);
      if (globalPosition == null) {
        return null;
      }
      return SelectionEdgeUpdateEvent.forEnd(globalPosition: globalPosition!);
    },
    "SelectionGeometry": () {
      final startSelectionPoint = getValue(
          maps["startSelectionPoint"], datas, "SelectionPoint?", vars, props);
      final endSelectionPoint = getValue(
          maps["endSelectionPoint"], datas, "SelectionPoint?", vars, props);
      final status =
          getValue(maps["status"], datas, "SelectionStatus", vars, props);
      final hasContent =
          getValue(maps["hasContent"], datas, "bool", vars, props);
      if (status == null || hasContent == null) {
        return null;
      }
      return SelectionGeometry(
          startSelectionPoint: startSelectionPoint,
          endSelectionPoint: endSelectionPoint,
          status: status!,
          hasContent: hasContent!);
    },
    "SelectionOverlay": () {
      final context =
          getValue(maps["context"], datas, "BuildContext", vars, props);
      final debugRequiredFor =
          getValue(maps["debugRequiredFor"], datas, "Widget?", vars, props);
      final startHandleType = getValue(maps["startHandleType"], datas,
          "TextSelectionHandleType", vars, props);
      final lineHeightAtStart =
          getValue(maps["lineHeightAtStart"], datas, "double", vars, props);
      final startHandlesVisible = getValue(maps["startHandlesVisible"], datas,
          "ValueListenable<bool>?", vars, props);
      final onStartHandleDragStart = getValue(maps["onStartHandleDragStart"],
          datas, "ValueChanged<DragStartDetails>?", vars, props);
      final onStartHandleDragUpdate = getValue(maps["onStartHandleDragUpdate"],
          datas, "ValueChanged<DragUpdateDetails>?", vars, props);
      final onStartHandleDragEnd = getValue(maps["onStartHandleDragEnd"], datas,
          "ValueChanged<DragEndDetails>?", vars, props);
      final endHandleType = getValue(
          maps["endHandleType"], datas, "TextSelectionHandleType", vars, props);
      final lineHeightAtEnd =
          getValue(maps["lineHeightAtEnd"], datas, "double", vars, props);
      final endHandlesVisible = getValue(maps["endHandlesVisible"], datas,
          "ValueListenable<bool>?", vars, props);
      final onEndHandleDragStart = getValue(maps["onEndHandleDragStart"], datas,
          "ValueChanged<DragStartDetails>?", vars, props);
      final onEndHandleDragUpdate = getValue(maps["onEndHandleDragUpdate"],
          datas, "ValueChanged<DragUpdateDetails>?", vars, props);
      final onEndHandleDragEnd = getValue(maps["onEndHandleDragEnd"], datas,
          "ValueChanged<DragEndDetails>?", vars, props);
      final toolbarVisible = getValue(
          maps["toolbarVisible"], datas, "ValueListenable<bool>?", vars, props);
      final selectionEndpoints = getValue(maps["selectionEndpoints"], datas,
          "List<TextSelectionPoint>", vars, props);
      final selectionControls = getValue(maps["selectionControls"], datas,
          "TextSelectionControls?", vars, props);
      final selectionDelegate = getValue(maps["selectionDelegate"], datas,
          "TextSelectionDelegate?", vars, props);
      final clipboardStatus = getValue(maps["clipboardStatus"], datas,
          "ClipboardStatusNotifier?", vars, props);
      final startHandleLayerLink = getValue(
          maps["startHandleLayerLink"], datas, "LayerLink", vars, props);
      final endHandleLayerLink =
          getValue(maps["endHandleLayerLink"], datas, "LayerLink", vars, props);
      final toolbarLayerLink =
          getValue(maps["toolbarLayerLink"], datas, "LayerLink", vars, props);
      final dragStartBehavior = getValue(
          maps["dragStartBehavior"], datas, "DragStartBehavior", vars, props);
      final onSelectionHandleTapped = getValue(
          maps["onSelectionHandleTapped"], datas, "VoidCallback?", vars, props);
      final toolbarLocation =
          getValue(maps["toolbarLocation"], datas, "Offset?", vars, props);
      final magnifierConfiguration = getValue(maps["magnifierConfiguration"],
          datas, "TextMagnifierConfiguration", vars, props);
      if (context == null ||
          startHandleType == null ||
          lineHeightAtStart == null ||
          endHandleType == null ||
          lineHeightAtEnd == null ||
          selectionEndpoints == null ||
          selectionControls == null ||
          selectionDelegate == null ||
          clipboardStatus == null ||
          startHandleLayerLink == null ||
          endHandleLayerLink == null ||
          toolbarLayerLink == null) {
        return null;
      }
      return SelectionOverlay(
          context: context!,
          debugRequiredFor: debugRequiredFor,
          startHandleType: startHandleType!,
          lineHeightAtStart: lineHeightAtStart!,
          startHandlesVisible: startHandlesVisible,
          onStartHandleDragStart: onStartHandleDragStart,
          onStartHandleDragUpdate: onStartHandleDragUpdate,
          onStartHandleDragEnd: onStartHandleDragEnd,
          endHandleType: endHandleType!,
          lineHeightAtEnd: lineHeightAtEnd!,
          endHandlesVisible: endHandlesVisible,
          onEndHandleDragStart: onEndHandleDragStart,
          onEndHandleDragUpdate: onEndHandleDragUpdate,
          onEndHandleDragEnd: onEndHandleDragEnd,
          toolbarVisible: toolbarVisible,
          selectionEndpoints:
              List<TextSelectionPoint>.from(selectionEndpoints!),
          selectionControls: selectionControls!,
          selectionDelegate: selectionDelegate!,
          clipboardStatus: clipboardStatus!,
          startHandleLayerLink: startHandleLayerLink!,
          endHandleLayerLink: endHandleLayerLink!,
          toolbarLayerLink: toolbarLayerLink!,
          dragStartBehavior: dragStartBehavior ?? DragStartBehavior.start,
          onSelectionHandleTapped: onSelectionHandleTapped,
          toolbarLocation: toolbarLocation,
          magnifierConfiguration:
              magnifierConfiguration ?? TextMagnifierConfiguration.disabled);
    },
    "SelectionPoint": () {
      final localPosition =
          getValue(maps["localPosition"], datas, "Offset", vars, props);
      final lineHeight =
          getValue(maps["lineHeight"], datas, "double", vars, props);
      final handleType = getValue(
          maps["handleType"], datas, "TextSelectionHandleType", vars, props);
      if (localPosition == null || lineHeight == null || handleType == null) {
        return null;
      }
      return SelectionPoint(
          localPosition: localPosition!,
          lineHeight: lineHeight!,
          handleType: handleType!);
    },
    "SelectionRect": () {
      final position = getValue(maps["position"], datas, "int", vars, props);
      final bounds = getValue(maps["bounds"], datas, "Rect", vars, props);
      final direction =
          getValue(maps["direction"], datas, "TextDirection", vars, props);
      if (position == null || bounds == null) {
        return null;
      }
      return SelectionRect(
          position: position!,
          bounds: bounds!,
          direction: direction ?? TextDirection.ltr);
    },
    "SelectionRegistrarScope": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final registrar =
          getValue(maps["registrar"], datas, "SelectionRegistrar", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (registrar == null || child == null) {
        return null;
      }
      return SelectionRegistrarScope(
          key: key, registrar: registrar!, child: child!);
    },
    "Semantics": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      final container = getValue(maps["container"], datas, "bool", vars, props);
      final explicitChildNodes =
          getValue(maps["explicitChildNodes"], datas, "bool", vars, props);
      final excludeSemantics =
          getValue(maps["excludeSemantics"], datas, "bool", vars, props);
      final enabled = getValue(maps["enabled"], datas, "bool?", vars, props);
      final checked = getValue(maps["checked"], datas, "bool?", vars, props);
      final mixed = getValue(maps["mixed"], datas, "bool?", vars, props);
      final selected = getValue(maps["selected"], datas, "bool?", vars, props);
      final toggled = getValue(maps["toggled"], datas, "bool?", vars, props);
      final button = getValue(maps["button"], datas, "bool?", vars, props);
      final slider = getValue(maps["slider"], datas, "bool?", vars, props);
      final keyboardKey =
          getValue(maps["keyboardKey"], datas, "bool?", vars, props);
      final link = getValue(maps["link"], datas, "bool?", vars, props);
      final header = getValue(maps["header"], datas, "bool?", vars, props);
      final textField =
          getValue(maps["textField"], datas, "bool?", vars, props);
      final readOnly = getValue(maps["readOnly"], datas, "bool?", vars, props);
      final focusable =
          getValue(maps["focusable"], datas, "bool?", vars, props);
      final focused = getValue(maps["focused"], datas, "bool?", vars, props);
      final inMutuallyExclusiveGroup = getValue(
          maps["inMutuallyExclusiveGroup"], datas, "bool?", vars, props);
      final obscured = getValue(maps["obscured"], datas, "bool?", vars, props);
      final multiline =
          getValue(maps["multiline"], datas, "bool?", vars, props);
      final scopesRoute =
          getValue(maps["scopesRoute"], datas, "bool?", vars, props);
      final namesRoute =
          getValue(maps["namesRoute"], datas, "bool?", vars, props);
      final hidden = getValue(maps["hidden"], datas, "bool?", vars, props);
      final image = getValue(maps["image"], datas, "bool?", vars, props);
      final liveRegion =
          getValue(maps["liveRegion"], datas, "bool?", vars, props);
      final maxValueLength =
          getValue(maps["maxValueLength"], datas, "int?", vars, props);
      final currentValueLength =
          getValue(maps["currentValueLength"], datas, "int?", vars, props);
      final label = getValue(maps["label"], datas, "String?", vars, props);
      final attributedLabel = getValue(
          maps["attributedLabel"], datas, "AttributedString?", vars, props);
      final value = getValue(maps["value"], datas, "String?", vars, props);
      final attributedValue = getValue(
          maps["attributedValue"], datas, "AttributedString?", vars, props);
      final increasedValue =
          getValue(maps["increasedValue"], datas, "String?", vars, props);
      final attributedIncreasedValue = getValue(
          maps["attributedIncreasedValue"],
          datas,
          "AttributedString?",
          vars,
          props);
      final decreasedValue =
          getValue(maps["decreasedValue"], datas, "String?", vars, props);
      final attributedDecreasedValue = getValue(
          maps["attributedDecreasedValue"],
          datas,
          "AttributedString?",
          vars,
          props);
      final hint = getValue(maps["hint"], datas, "String?", vars, props);
      final attributedHint = getValue(
          maps["attributedHint"], datas, "AttributedString?", vars, props);
      final tooltip = getValue(maps["tooltip"], datas, "String?", vars, props);
      final onTapHint =
          getValue(maps["onTapHint"], datas, "String?", vars, props);
      final onLongPressHint =
          getValue(maps["onLongPressHint"], datas, "String?", vars, props);
      final textDirection =
          getValue(maps["textDirection"], datas, "TextDirection?", vars, props);
      final sortKey =
          getValue(maps["sortKey"], datas, "SemanticsSortKey?", vars, props);
      final tagForChildren =
          getValue(maps["tagForChildren"], datas, "SemanticsTag?", vars, props);
      final onTap =
          getValue(maps["onTap"], datas, "VoidCallback?", vars, props);
      final onLongPress =
          getValue(maps["onLongPress"], datas, "VoidCallback?", vars, props);
      final onScrollLeft =
          getValue(maps["onScrollLeft"], datas, "VoidCallback?", vars, props);
      final onScrollRight =
          getValue(maps["onScrollRight"], datas, "VoidCallback?", vars, props);
      final onScrollUp =
          getValue(maps["onScrollUp"], datas, "VoidCallback?", vars, props);
      final onScrollDown =
          getValue(maps["onScrollDown"], datas, "VoidCallback?", vars, props);
      final onIncrease =
          getValue(maps["onIncrease"], datas, "VoidCallback?", vars, props);
      final onDecrease =
          getValue(maps["onDecrease"], datas, "VoidCallback?", vars, props);
      final onCopy =
          getValue(maps["onCopy"], datas, "VoidCallback?", vars, props);
      final onCut =
          getValue(maps["onCut"], datas, "VoidCallback?", vars, props);
      final onPaste =
          getValue(maps["onPaste"], datas, "VoidCallback?", vars, props);
      final onDismiss =
          getValue(maps["onDismiss"], datas, "VoidCallback?", vars, props);
      final onMoveCursorForwardByCharacter = getValue(
          maps["onMoveCursorForwardByCharacter"],
          datas,
          "MoveCursorHandler?",
          vars,
          props);
      final onMoveCursorBackwardByCharacter = getValue(
          maps["onMoveCursorBackwardByCharacter"],
          datas,
          "MoveCursorHandler?",
          vars,
          props);
      final onSetSelection = getValue(
          maps["onSetSelection"], datas, "SetSelectionHandler?", vars, props);
      final onSetText =
          getValue(maps["onSetText"], datas, "SetTextHandler?", vars, props);
      final onDidGainAccessibilityFocus = getValue(
          maps["onDidGainAccessibilityFocus"],
          datas,
          "VoidCallback?",
          vars,
          props);
      final onDidLoseAccessibilityFocus = getValue(
          maps["onDidLoseAccessibilityFocus"],
          datas,
          "VoidCallback?",
          vars,
          props);
      final customSemanticsActions = getValue(maps["customSemanticsActions"],
          datas, "Map<CustomSemanticsAction,   VoidCallback>?", vars, props);
      return Semantics(
          key: key,
          child: child,
          container: container ?? false,
          explicitChildNodes: explicitChildNodes ?? false,
          excludeSemantics: excludeSemantics ?? false,
          enabled: enabled,
          checked: checked,
          mixed: mixed,
          selected: selected,
          toggled: toggled,
          button: button,
          slider: slider,
          keyboardKey: keyboardKey,
          link: link,
          header: header,
          textField: textField,
          readOnly: readOnly,
          focusable: focusable,
          focused: focused,
          inMutuallyExclusiveGroup: inMutuallyExclusiveGroup,
          obscured: obscured,
          multiline: multiline,
          scopesRoute: scopesRoute,
          namesRoute: namesRoute,
          hidden: hidden,
          image: image,
          liveRegion: liveRegion,
          maxValueLength: maxValueLength,
          currentValueLength: currentValueLength,
          label: label,
          attributedLabel: attributedLabel,
          value: value,
          attributedValue: attributedValue,
          increasedValue: increasedValue,
          attributedIncreasedValue: attributedIncreasedValue,
          decreasedValue: decreasedValue,
          attributedDecreasedValue: attributedDecreasedValue,
          hint: hint,
          attributedHint: attributedHint,
          tooltip: tooltip,
          onTapHint: onTapHint,
          onLongPressHint: onLongPressHint,
          textDirection: textDirection,
          sortKey: sortKey,
          tagForChildren: tagForChildren,
          onTap: onTap,
          onLongPress: onLongPress,
          onScrollLeft: onScrollLeft,
          onScrollRight: onScrollRight,
          onScrollUp: onScrollUp,
          onScrollDown: onScrollDown,
          onIncrease: onIncrease,
          onDecrease: onDecrease,
          onCopy: onCopy,
          onCut: onCut,
          onPaste: onPaste,
          onDismiss: onDismiss,
          onMoveCursorForwardByCharacter: onMoveCursorForwardByCharacter,
          onMoveCursorBackwardByCharacter: onMoveCursorBackwardByCharacter,
          onSetSelection: onSetSelection,
          onSetText: onSetText,
          onDidGainAccessibilityFocus: onDidGainAccessibilityFocus,
          onDidLoseAccessibilityFocus: onDidLoseAccessibilityFocus,
          customSemanticsActions: customSemanticsActions
              ? Map<CustomSemanticsAction, VoidCallback>.from(
                  customSemanticsActions)
              : null);
    },
    "Semantics.fromProperties": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      final container = getValue(maps["container"], datas, "bool", vars, props);
      final explicitChildNodes =
          getValue(maps["explicitChildNodes"], datas, "bool", vars, props);
      final excludeSemantics =
          getValue(maps["excludeSemantics"], datas, "bool", vars, props);
      final properties = getValue(
          maps["properties"], datas, "SemanticsProperties", vars, props);
      if (properties == null) {
        return null;
      }
      return Semantics.fromProperties(
          key: key,
          child: child,
          container: container ?? false,
          explicitChildNodes: explicitChildNodes ?? false,
          excludeSemantics: excludeSemantics ?? false,
          properties: properties!);
    },
    "SemanticsActionEvent": () {
      final type =
          getValue(maps["type"], datas, "SemanticsAction", vars, props);
      final nodeId = getValue(maps["nodeId"], datas, "int", vars, props);
      final arguments =
          getValue(maps["arguments"], datas, "Object?", vars, props);
      final viewId =
          getValue(maps["viewId"], datas, "SemanticsAction", vars, props);
      if (type == null || nodeId == null) {
        return null;
      }
      return SemanticsActionEvent(
          type: type!, nodeId: nodeId!, arguments: arguments, viewId: viewId);
    },
    "SemanticsData": () {
      final flags = getValue(maps["flags"], datas, "", vars, props);
      final actions = getValue(maps["actions"], datas, "", vars, props);
      final attributedLabel =
          getValue(maps["attributedLabel"], datas, "", vars, props);
      final attributedValue =
          getValue(maps["attributedValue"], datas, "", vars, props);
      final attributedIncreasedValue =
          getValue(maps["attributedIncreasedValue"], datas, "", vars, props);
      final attributedDecreasedValue =
          getValue(maps["attributedDecreasedValue"], datas, "", vars, props);
      final attributedHint =
          getValue(maps["attributedHint"], datas, "", vars, props);
      final tooltip = getValue(maps["tooltip"], datas, "", vars, props);
      final textDirection =
          getValue(maps["textDirection"], datas, "", vars, props);
      final rect = getValue(maps["rect"], datas, "", vars, props);
      final elevation = getValue(maps["elevation"], datas, "", vars, props);
      final thickness = getValue(maps["thickness"], datas, "", vars, props);
      final textSelection =
          getValue(maps["textSelection"], datas, "", vars, props);
      final scrollIndex = getValue(maps["scrollIndex"], datas, "", vars, props);
      final scrollChildCount =
          getValue(maps["scrollChildCount"], datas, "", vars, props);
      final scrollPosition =
          getValue(maps["scrollPosition"], datas, "", vars, props);
      final scrollExtentMax =
          getValue(maps["scrollExtentMax"], datas, "", vars, props);
      final scrollExtentMin =
          getValue(maps["scrollExtentMin"], datas, "", vars, props);
      final platformViewId =
          getValue(maps["platformViewId"], datas, "", vars, props);
      final maxValueLength =
          getValue(maps["maxValueLength"], datas, "", vars, props);
      final currentValueLength =
          getValue(maps["currentValueLength"], datas, "", vars, props);
      final tags = getValue(maps["tags"], datas, "", vars, props);
      final transform = getValue(maps["transform"], datas, "", vars, props);
      final customSemanticsActionIds =
          getValue(maps["customSemanticsActionIds"], datas, "", vars, props);
      final identifier = getValue(maps["identifier"], datas, "", vars, props);
      if (flags == null ||
          actions == null ||
          attributedLabel == null ||
          attributedValue == null ||
          attributedIncreasedValue == null ||
          attributedDecreasedValue == null ||
          attributedHint == null ||
          tooltip == null ||
          textDirection == null ||
          rect == null ||
          elevation == null ||
          thickness == null ||
          textSelection == null ||
          scrollIndex == null ||
          scrollChildCount == null ||
          scrollPosition == null ||
          scrollExtentMax == null ||
          scrollExtentMin == null ||
          platformViewId == null ||
          maxValueLength == null ||
          currentValueLength == null ||
          identifier == null) {
        return null;
      }
      return SemanticsData(
          identifier: identifier,
          flags: flags!,
          actions: actions!,
          attributedLabel: attributedLabel!,
          attributedValue: attributedValue!,
          attributedIncreasedValue: attributedIncreasedValue!,
          attributedDecreasedValue: attributedDecreasedValue!,
          attributedHint: attributedHint!,
          tooltip: tooltip!,
          textDirection: textDirection!,
          rect: rect!,
          elevation: elevation!,
          thickness: thickness!,
          textSelection: textSelection!,
          scrollIndex: scrollIndex!,
          scrollChildCount: scrollChildCount!,
          scrollPosition: scrollPosition!,
          scrollExtentMax: scrollExtentMax!,
          scrollExtentMin: scrollExtentMin!,
          platformViewId: platformViewId!,
          maxValueLength: maxValueLength!,
          currentValueLength: currentValueLength!,
          tags: tags,
          transform: transform,
          customSemanticsActionIds: customSemanticsActionIds);
    },
    "SemanticsDebugger": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      final labelStyle =
          getValue(maps["labelStyle"], datas, "TextStyle", vars, props);
      if (child == null) {
        return null;
      }
      return SemanticsDebugger(
          key: key,
          child: child!,
          labelStyle: labelStyle ??
              const TextStyle(
                color: Color(0xFF000000),
                fontSize: 10.0,
                height: 0.8,
              ));
    },
    "SemanticsHintOverrides": () {
      final onTapHint =
          getValue(maps["onTapHint"], datas, "String?", vars, props);
      final onLongPressHint =
          getValue(maps["onLongPressHint"], datas, "String?", vars, props);
      return SemanticsHintOverrides(
          onTapHint: onTapHint, onLongPressHint: onLongPressHint);
    },
    "SemanticsNode": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final showOnScreen =
          getValue(maps["showOnScreen"], datas, "VoidCallback?", vars, props);
      return SemanticsNode(key: key, showOnScreen: showOnScreen);
    },
    "SemanticsNode.root": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final showOnScreen =
          getValue(maps["showOnScreen"], datas, "VoidCallback?", vars, props);
      final owner =
          getValue(maps["owner"], datas, "SemanticsOwner", vars, props);
      if (owner == null) {
        return null;
      }
      return SemanticsNode.root(
          key: key, showOnScreen: showOnScreen, owner: owner!);
    },
    "SemanticsOwner": () {
      final onSemanticsUpdate = getValue(maps["onSemanticsUpdate"], datas,
          "SemanticsUpdateCallback", vars, props);
      if (onSemanticsUpdate == null) {
        return null;
      }
      return SemanticsOwner(onSemanticsUpdate: onSemanticsUpdate!);
    },
    "SemanticsProperties": () {
      final enabled = getValue(maps["enabled"], datas, "", vars, props);
      final checked = getValue(maps["checked"], datas, "", vars, props);
      final mixed = getValue(maps["mixed"], datas, "", vars, props);
      final selected = getValue(maps["selected"], datas, "", vars, props);
      final toggled = getValue(maps["toggled"], datas, "", vars, props);
      final button = getValue(maps["button"], datas, "", vars, props);
      final link = getValue(maps["link"], datas, "", vars, props);
      final header = getValue(maps["header"], datas, "", vars, props);
      final textField = getValue(maps["textField"], datas, "", vars, props);
      final slider = getValue(maps["slider"], datas, "", vars, props);
      final keyboardKey = getValue(maps["keyboardKey"], datas, "", vars, props);
      final readOnly = getValue(maps["readOnly"], datas, "", vars, props);
      final focusable = getValue(maps["focusable"], datas, "", vars, props);
      final focused = getValue(maps["focused"], datas, "", vars, props);
      final inMutuallyExclusiveGroup =
          getValue(maps["inMutuallyExclusiveGroup"], datas, "", vars, props);
      final hidden = getValue(maps["hidden"], datas, "", vars, props);
      final obscured = getValue(maps["obscured"], datas, "", vars, props);
      final multiline = getValue(maps["multiline"], datas, "", vars, props);
      final scopesRoute = getValue(maps["scopesRoute"], datas, "", vars, props);
      final namesRoute = getValue(maps["namesRoute"], datas, "", vars, props);
      final image = getValue(maps["image"], datas, "", vars, props);
      final liveRegion = getValue(maps["liveRegion"], datas, "", vars, props);
      final maxValueLength =
          getValue(maps["maxValueLength"], datas, "", vars, props);
      final currentValueLength =
          getValue(maps["currentValueLength"], datas, "", vars, props);
      final label = getValue(maps["label"], datas, "", vars, props);
      final attributedLabel =
          getValue(maps["attributedLabel"], datas, "", vars, props);
      final value = getValue(maps["value"], datas, "", vars, props);
      final attributedValue =
          getValue(maps["attributedValue"], datas, "", vars, props);
      final increasedValue =
          getValue(maps["increasedValue"], datas, "", vars, props);
      final attributedIncreasedValue =
          getValue(maps["attributedIncreasedValue"], datas, "", vars, props);
      final decreasedValue =
          getValue(maps["decreasedValue"], datas, "", vars, props);
      final attributedDecreasedValue =
          getValue(maps["attributedDecreasedValue"], datas, "", vars, props);
      final hint = getValue(maps["hint"], datas, "", vars, props);
      final tooltip = getValue(maps["tooltip"], datas, "", vars, props);
      final attributedHint =
          getValue(maps["attributedHint"], datas, "", vars, props);
      final hintOverrides =
          getValue(maps["hintOverrides"], datas, "", vars, props);
      final textDirection =
          getValue(maps["textDirection"], datas, "", vars, props);
      final sortKey = getValue(maps["sortKey"], datas, "", vars, props);
      final tagForChildren =
          getValue(maps["tagForChildren"], datas, "", vars, props);
      final onTap = getValue(maps["onTap"], datas, "", vars, props);
      final onLongPress = getValue(maps["onLongPress"], datas, "", vars, props);
      final onScrollLeft =
          getValue(maps["onScrollLeft"], datas, "", vars, props);
      final onScrollRight =
          getValue(maps["onScrollRight"], datas, "", vars, props);
      final onScrollUp = getValue(maps["onScrollUp"], datas, "", vars, props);
      final onScrollDown =
          getValue(maps["onScrollDown"], datas, "", vars, props);
      final onIncrease = getValue(maps["onIncrease"], datas, "", vars, props);
      final onDecrease = getValue(maps["onDecrease"], datas, "", vars, props);
      final onCopy = getValue(maps["onCopy"], datas, "", vars, props);
      final onCut = getValue(maps["onCut"], datas, "", vars, props);
      final onPaste = getValue(maps["onPaste"], datas, "", vars, props);
      final onMoveCursorForwardByCharacter = getValue(
          maps["onMoveCursorForwardByCharacter"], datas, "", vars, props);
      final onMoveCursorBackwardByCharacter = getValue(
          maps["onMoveCursorBackwardByCharacter"], datas, "", vars, props);
      final onMoveCursorForwardByWord =
          getValue(maps["onMoveCursorForwardByWord"], datas, "", vars, props);
      final onMoveCursorBackwardByWord =
          getValue(maps["onMoveCursorBackwardByWord"], datas, "", vars, props);
      final onSetSelection =
          getValue(maps["onSetSelection"], datas, "", vars, props);
      final onSetText = getValue(maps["onSetText"], datas, "", vars, props);
      final onDidGainAccessibilityFocus =
          getValue(maps["onDidGainAccessibilityFocus"], datas, "", vars, props);
      final onDidLoseAccessibilityFocus =
          getValue(maps["onDidLoseAccessibilityFocus"], datas, "", vars, props);
      final onDismiss = getValue(maps["onDismiss"], datas, "", vars, props);
      final customSemanticsActions =
          getValue(maps["customSemanticsActions"], datas, "", vars, props);
      return SemanticsProperties(
          enabled: enabled,
          checked: checked,
          mixed: mixed,
          selected: selected,
          toggled: toggled,
          button: button,
          link: link,
          header: header,
          textField: textField,
          slider: slider,
          keyboardKey: keyboardKey,
          readOnly: readOnly,
          focusable: focusable,
          focused: focused,
          inMutuallyExclusiveGroup: inMutuallyExclusiveGroup,
          hidden: hidden,
          obscured: obscured,
          multiline: multiline,
          scopesRoute: scopesRoute,
          namesRoute: namesRoute,
          image: image,
          liveRegion: liveRegion,
          maxValueLength: maxValueLength,
          currentValueLength: currentValueLength,
          label: label,
          attributedLabel: attributedLabel,
          value: value,
          attributedValue: attributedValue,
          increasedValue: increasedValue,
          attributedIncreasedValue: attributedIncreasedValue,
          decreasedValue: decreasedValue,
          attributedDecreasedValue: attributedDecreasedValue,
          hint: hint,
          tooltip: tooltip,
          attributedHint: attributedHint,
          hintOverrides: hintOverrides,
          textDirection: textDirection,
          sortKey: sortKey,
          tagForChildren: tagForChildren,
          onTap: onTap,
          onLongPress: onLongPress,
          onScrollLeft: onScrollLeft,
          onScrollRight: onScrollRight,
          onScrollUp: onScrollUp,
          onScrollDown: onScrollDown,
          onIncrease: onIncrease,
          onDecrease: onDecrease,
          onCopy: onCopy,
          onCut: onCut,
          onPaste: onPaste,
          onMoveCursorForwardByCharacter: onMoveCursorForwardByCharacter,
          onMoveCursorBackwardByCharacter: onMoveCursorBackwardByCharacter,
          onMoveCursorForwardByWord: onMoveCursorForwardByWord,
          onMoveCursorBackwardByWord: onMoveCursorBackwardByWord,
          onSetSelection: onSetSelection,
          onSetText: onSetText,
          onDidGainAccessibilityFocus: onDidGainAccessibilityFocus,
          onDidLoseAccessibilityFocus: onDidLoseAccessibilityFocus,
          onDismiss: onDismiss,
          customSemanticsActions: customSemanticsActions);
    },
    "SemanticsTag": () {
      final name = getValue(maps["0"], datas, "String", vars, props);
      if (name == null) {
        return null;
      }
      return SemanticsTag(name!);
    },
    "SemanticsUpdateBuilder": () {
      return SemanticsUpdateBuilder();
    },
    "SerialTapCancelDetails": () {
      final count = getValue(maps["count"], datas, "int", vars, props);
      return SerialTapCancelDetails(count: count ?? 1);
    },
    "SerialTapDownDetails": () {
      final globalPosition =
          getValue(maps["globalPosition"], datas, "Offset", vars, props);
      final localPosition =
          getValue(maps["localPosition"], datas, "Offset?", vars, props);
      final kind =
          getValue(maps["kind"], datas, "PointerDeviceKind", vars, props);
      final buttons = getValue(maps["buttons"], datas, "int", vars, props);
      final count = getValue(maps["count"], datas, "int", vars, props);
      if (kind == null) {
        return null;
      }
      return SerialTapDownDetails(
          globalPosition: globalPosition ?? Offset.zero,
          localPosition: localPosition,
          kind: kind!,
          buttons: buttons ?? 0,
          count: count ?? 1);
    },
    "SerialTapGestureRecognizer": () {
      final debugOwner =
          getValue(maps["debugOwner"], datas, "Object?", vars, props);
      final supportedDevices = getValue(maps["supportedDevices"], datas,
          "Set<PointerDeviceKind>?", vars, props);
      final allowedButtonsFilter = getValue(maps["allowedButtonsFilter"], datas,
          "AllowedButtonsFilter?", vars, props);
      return SerialTapGestureRecognizer(
          debugOwner: debugOwner,
          supportedDevices: supportedDevices
              ? Set<PointerDeviceKind>.from(supportedDevices)
              : null,
          allowedButtonsFilter: allowedButtonsFilter);
    },
    "SerialTapUpDetails": () {
      final globalPosition =
          getValue(maps["globalPosition"], datas, "Offset", vars, props);
      final localPosition =
          getValue(maps["localPosition"], datas, "Offset?", vars, props);
      final kind =
          getValue(maps["kind"], datas, "PointerDeviceKind?", vars, props);
      final count = getValue(maps["count"], datas, "int", vars, props);
      return SerialTapUpDetails(
          globalPosition: globalPosition ?? Offset.zero,
          localPosition: localPosition,
          kind: kind,
          count: count ?? 1);
    },
    "Set.identity": () {
      return Set.identity();
    },
    "Set.from": () {
      final elements = getValue(maps["0"], datas, "Iterable", vars, props);
      if (elements == null) {
        return null;
      }
      return Set.from(elements!);
    },
    "Set.of": () {
      final elements = getValue(maps["0"], datas, "Iterable<E>", vars, props);
      if (elements == null) {
        return null;
      }
      return Set.of(elements!);
    },
    "Set.unmodifiable": () {
      final elements = getValue(maps["0"], datas, "Iterable", vars, props);
      return Set.unmodifiable(elements);
    },
    "ShaderMask": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final shaderCallback = getValue(
          maps["shaderCallback"], datas, "ShaderCallback", vars, props);
      final blendMode =
          getValue(maps["blendMode"], datas, "BlendMode", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      if (shaderCallback == null) {
        return null;
      }
      return ShaderMask(
          key: key,
          shaderCallback: shaderCallback!,
          blendMode: blendMode ?? BlendMode.modulate,
          child: child);
    },
    "ShaderMaskLayer": () {
      final shader = getValue(maps["shader"], datas, "Shader?", vars, props);
      final maskRect = getValue(maps["maskRect"], datas, "Rect?", vars, props);
      final blendMode =
          getValue(maps["blendMode"], datas, "BlendMode?", vars, props);
      return ShaderMaskLayer(
          shader: shader, maskRect: maskRect, blendMode: blendMode);
    },
    "Shadow": () {
      final color = getValue(maps["color"], datas, "", vars, props);
      final offset = getValue(maps["offset"], datas, "", vars, props);
      final blurRadius = getValue(maps["blurRadius"], datas, "", vars, props);
      return Shadow(
          color: color ?? const Color(0xFF000000),
          offset: offset ?? Offset.zero,
          blurRadius: blurRadius ?? 0.0);
    },
    "ShapeBorderClipper": () {
      final shape = getValue(maps["shape"], datas, "ShapeBorder", vars, props);
      final textDirection =
          getValue(maps["textDirection"], datas, "TextDirection?", vars, props);
      if (shape == null) {
        return null;
      }
      return ShapeBorderClipper(shape: shape!, textDirection: textDirection);
    },
    "ShapeBorderTween": () {
      final begin = getValue(maps["begin"], datas, "T?", vars, props);
      final end = getValue(maps["end"], datas, "T?", vars, props);
      return ShapeBorderTween(begin: begin, end: end);
    },
    "ShapeDecoration": () {
      final color = getValue(maps["color"], datas, "Color?", vars, props);
      final image =
          getValue(maps["image"], datas, "DecorationImage?", vars, props);
      final gradient =
          getValue(maps["gradient"], datas, "Gradient?", vars, props);
      final shadows =
          getValue(maps["shadows"], datas, "List<BoxShadow>?", vars, props);
      final shape = getValue(maps["shape"], datas, "ShapeBorder", vars, props);
      if (shape == null) {
        return null;
      }
      return ShapeDecoration(
          color: color,
          image: image,
          gradient: gradient,
          shadows: shadows != null ? List<BoxShadow>.from(shadows) : null,
          shape: shape!);
    },
    "ShapeDecoration.fromBoxDecoration": () {
      final source = getValue(maps["0"], datas, "BoxDecoration", vars, props);
      if (source == null) {
        return null;
      }
      return ShapeDecoration.fromBoxDecoration(source!);
    },
    "SharedAppData": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (child == null) {
        return null;
      }
      return SharedAppData(key: key, child: child!);
    },
    "ShortcutManager": () {
      final shortcuts = getValue(maps["shortcuts"], datas,
          "Map<ShortcutActivator,   Intent>", vars, props);
      final modal = getValue(maps["modal"], datas, "bool", vars, props);
      return ShortcutManager(
          shortcuts: Map<ShortcutActivator, Intent>.from(
              shortcuts ?? const <ShortcutActivator, Intent>{}),
          modal: modal ?? false);
    },
    "ShortcutMapProperty": () {
      final name = getValue(maps["0"], datas, "String", vars, props);
      final value = getValue(
          maps["1"], datas, "Map<ShortcutActivator,   Intent>", vars, props);
      final showName = getValue(maps["showName"], datas, "", vars, props);
      final defaultValue =
          getValue(maps["defaultValue"], datas, "Object", vars, props);
      final level =
          getValue(maps["level"], datas, "DiagnosticLevel", vars, props);
      final description =
          getValue(maps["description"], datas, "String?", vars, props);
      if (name == null || value == null) {
        return null;
      }
      return ShortcutMapProperty(
          name!, Map<ShortcutActivator, Intent>.from(value!),
          showName: showName,
          defaultValue: defaultValue ?? kNoDefaultValue,
          level: level ?? DiagnosticLevel.info,
          description: description);
    },
    "ShortcutRegistrar": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (child == null) {
        return null;
      }
      return ShortcutRegistrar(key: key, child: child!);
    },
    "ShortcutSerialization.character": () {
      final character = getValue(maps["0"], datas, "String", vars, props);
      final alt = getValue(maps["alt"], datas, "bool", vars, props);
      final control = getValue(maps["control"], datas, "bool", vars, props);
      final meta = getValue(maps["meta"], datas, "bool", vars, props);
      if (character == null) {
        return null;
      }
      return ShortcutSerialization.character(character!,
          alt: alt ?? false, control: control ?? false, meta: meta ?? false);
    },
    "ShortcutSerialization.modifier": () {
      final trigger =
          getValue(maps["0"], datas, "LogicalKeyboardKey", vars, props);
      final alt = getValue(maps["alt"], datas, "bool", vars, props);
      final control = getValue(maps["control"], datas, "bool", vars, props);
      final meta = getValue(maps["meta"], datas, "bool", vars, props);
      final shift = getValue(maps["shift"], datas, "bool", vars, props);
      if (trigger == null) {
        return null;
      }
      return ShortcutSerialization.modifier(trigger!,
          alt: alt ?? false,
          control: control ?? false,
          meta: meta ?? false,
          shift: shift ?? false);
    },
    "Shortcuts": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final shortcuts = getValue(maps["shortcuts"], datas,
          "Map<ShortcutActivator,   Intent>", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      final debugLabel =
          getValue(maps["debugLabel"], datas, "String?", vars, props);
      if (shortcuts == null || child == null) {
        return null;
      }
      return Shortcuts(
          key: key,
          shortcuts: Map<ShortcutActivator, Intent>.from(shortcuts!),
          child: child!,
          debugLabel: debugLabel);
    },
    "Shortcuts.manager": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final manager =
          getValue(maps["manager"], datas, "ShortcutManager", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      final debugLabel =
          getValue(maps["debugLabel"], datas, "String?", vars, props);
      if (manager == null || child == null) {
        return null;
      }
      return Shortcuts.manager(
          key: key, manager: manager!, child: child!, debugLabel: debugLabel);
    },
    "ShrinkWrappingViewport": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final axisDirection =
          getValue(maps["axisDirection"], datas, "AxisDirection", vars, props);
      final crossAxisDirection = getValue(
          maps["crossAxisDirection"], datas, "AxisDirection?", vars, props);
      final offset =
          getValue(maps["offset"], datas, "ViewportOffset", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      final slivers =
          getValue(maps["slivers"], datas, "List<Widget>", vars, props);
      if (offset == null) {
        return null;
      }
      return ShrinkWrappingViewport(
          key: key,
          axisDirection: axisDirection ?? AxisDirection.down,
          crossAxisDirection: crossAxisDirection,
          offset: offset!,
          clipBehavior: clipBehavior ?? Clip.hardEdge,
          slivers: List<Widget>.from(slivers ?? const <Widget>[]));
    },
    "SimpleDialog": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final title = getValue(maps["title"], datas, "Widget?", vars, props);
      final titlePadding = getValue(
          maps["titlePadding"], datas, "EdgeInsetsGeometry", vars, props);
      final titleTextStyle =
          getValue(maps["titleTextStyle"], datas, "TextStyle?", vars, props);
      final children =
          getValue(maps["children"], datas, "List<Widget>?", vars, props);
      final contentPadding = getValue(
          maps["contentPadding"], datas, "EdgeInsetsGeometry", vars, props);
      final backgroundColor =
          getValue(maps["backgroundColor"], datas, "Color?", vars, props);
      final elevation =
          getValue(maps["elevation"], datas, "double?", vars, props);
      final shadowColor =
          getValue(maps["shadowColor"], datas, "Color?", vars, props);
      final surfaceTintColor =
          getValue(maps["surfaceTintColor"], datas, "Color?", vars, props);
      final semanticLabel =
          getValue(maps["semanticLabel"], datas, "String?", vars, props);
      final insetPadding =
          getValue(maps["insetPadding"], datas, "EdgeInsets", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      final shape = getValue(maps["shape"], datas, "ShapeBorder?", vars, props);
      final alignment =
          getValue(maps["alignment"], datas, "AlignmentGeometry?", vars, props);
      if (insetPadding != null) {
        return SimpleDialog(
            key: key,
            title: title,
            titlePadding: titlePadding ??
                const EdgeInsets.fromLTRB(24.0, 24.0, 24.0, 0.0),
            titleTextStyle: titleTextStyle,
            contentPadding: contentPadding ??
                const EdgeInsets.fromLTRB(0.0, 12.0, 0.0, 16.0),
            backgroundColor: backgroundColor,
            elevation: elevation,
            shadowColor: shadowColor,
            surfaceTintColor: surfaceTintColor,
            semanticLabel: semanticLabel,
            clipBehavior: clipBehavior ?? Clip.none,
            shape: shape,
            alignment: alignment,
            insetPadding: insetPadding,
            children: children != null ? List<Widget>.from(children) : null);
      }
      return SimpleDialog(
          key: key,
          title: title,
          titlePadding:
              titlePadding ?? const EdgeInsets.fromLTRB(24.0, 24.0, 24.0, 0.0),
          titleTextStyle: titleTextStyle,
          contentPadding:
              contentPadding ?? const EdgeInsets.fromLTRB(0.0, 12.0, 0.0, 16.0),
          backgroundColor: backgroundColor,
          elevation: elevation,
          shadowColor: shadowColor,
          surfaceTintColor: surfaceTintColor,
          semanticLabel: semanticLabel,
          clipBehavior: clipBehavior ?? Clip.none,
          shape: shape,
          alignment: alignment,
          children: children != null ? List<Widget>.from(children) : null);
    },
    "SimpleDialogOption": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final onPressed =
          getValue(maps["onPressed"], datas, "VoidCallback?", vars, props);
      final padding =
          getValue(maps["padding"], datas, "EdgeInsets?", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      return SimpleDialogOption(
          key: key, onPressed: onPressed, padding: padding, child: child);
    },
    "SingleActivator": () {
      final trigger =
          getValue(maps["0"], datas, "LogicalKeyboardKey", vars, props);
      final control = getValue(maps["control"], datas, "bool", vars, props);
      final shift = getValue(maps["shift"], datas, "bool", vars, props);
      final alt = getValue(maps["alt"], datas, "bool", vars, props);
      final meta = getValue(maps["meta"], datas, "bool", vars, props);
      final includeRepeats =
          getValue(maps["includeRepeats"], datas, "bool", vars, props);
      if (trigger == null) {
        return null;
      }
      return SingleActivator(trigger!,
          control: control ?? false,
          shift: shift ?? false,
          alt: alt ?? false,
          meta: meta ?? false,
          includeRepeats: includeRepeats ?? true);
    },
    "SingleChildScrollView": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final scrollDirection =
          getValue(maps["scrollDirection"], datas, "Axis", vars, props);
      final reverse = getValue(maps["reverse"], datas, "bool", vars, props);
      final padding =
          getValue(maps["padding"], datas, "EdgeInsetsGeometry?", vars, props);
      final primary = getValue(maps["primary"], datas, "bool?", vars, props);
      final physics =
          getValue(maps["physics"], datas, "ScrollPhysics?", vars, props);
      final controller =
          getValue(maps["controller"], datas, "ScrollController?", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      final dragStartBehavior = getValue(
          maps["dragStartBehavior"], datas, "DragStartBehavior", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      final restorationId =
          getValue(maps["restorationId"], datas, "String?", vars, props);
      final keyboardDismissBehavior = getValue(maps["keyboardDismissBehavior"],
          datas, "ScrollViewKeyboardDismissBehavior", vars, props);
      return SingleChildScrollView(
          key: key,
          scrollDirection: scrollDirection ?? Axis.vertical,
          reverse: reverse ?? false,
          padding: padding,
          primary: primary,
          physics: physics,
          controller: controller,
          child: child,
          dragStartBehavior: dragStartBehavior ?? DragStartBehavior.start,
          clipBehavior: clipBehavior ?? Clip.hardEdge,
          restorationId: restorationId,
          keyboardDismissBehavior: keyboardDismissBehavior ??
              ScrollViewKeyboardDismissBehavior.manual);
    },
    "Size": () {
      final width = getValue(maps["0"], datas, "", vars, props);
      final height = getValue(maps["1"], datas, "", vars, props);
      if (width == null || height == null) {
        return null;
      }
      return Size(width!, height!);
    },
    "Size.copy": () {
      final source = getValue(maps["0"], datas, "Size", vars, props);
      if (source == null) {
        return null;
      }
      return Size.copy(source!);
    },
    "Size.square": () {
      final dimension = getValue(maps["0"], datas, "double", vars, props);
      if (dimension == null) {
        return null;
      }
      return Size.square(dimension!);
    },
    "Size.fromWidth": () {
      final width = getValue(maps["0"], datas, "double", vars, props);
      if (width == null) {
        return null;
      }
      return Size.fromWidth(width!);
    },
    "Size.fromHeight": () {
      final height = getValue(maps["0"], datas, "double", vars, props);
      if (height == null) {
        return null;
      }
      return Size.fromHeight(height!);
    },
    "Size.fromRadius": () {
      final radius = getValue(maps["0"], datas, "double", vars, props);
      if (radius == null) {
        return null;
      }
      return Size.fromRadius(radius!);
    },
    "SizeChangedLayoutNotification": () {
      return const SizeChangedLayoutNotification();
    },
    "SizeChangedLayoutNotifier": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      return SizeChangedLayoutNotifier(key: key, child: child);
    },
    "SizeTransition": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final axis = getValue(maps["axis"], datas, "Axis", vars, props);
      final sizeFactor =
          getValue(maps["sizeFactor"], datas, "Animation<double>", vars, props);
      final axisAlignment =
          getValue(maps["axisAlignment"], datas, "double", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      if (sizeFactor == null) {
        return null;
      }
      return SizeTransition(
          key: key,
          axis: axis ?? Axis.vertical,
          sizeFactor: sizeFactor!,
          axisAlignment: axisAlignment ?? 0.0,
          child: child);
    },
    "SizeTween": () {
      final begin = getValue(maps["begin"], datas, "T?", vars, props);
      final end = getValue(maps["end"], datas, "T?", vars, props);
      return SizeTween(begin: begin, end: end);
    },
    "SizedBox": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final width = getValue(maps["width"], datas, "double?", vars, props);
      final height = getValue(maps["height"], datas, "double?", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      return SizedBox(key: key, width: width, height: height, child: child);
    },
    "SizedBox.expand": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      return SizedBox.expand(key: key, child: child);
    },
    "SizedBox.shrink": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      return SizedBox.shrink(key: key, child: child);
    },
    "SizedBox.fromSize": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      final size = getValue(maps["size"], datas, "Size?", vars, props);
      return SizedBox.fromSize(key: key, child: child, size: size);
    },
    "SizedBox.square": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      final dimension =
          getValue(maps["dimension"], datas, "double?", vars, props);
      return SizedBox.square(key: key, child: child, dimension: dimension);
    },
    "SizedOverflowBox": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final size = getValue(maps["size"], datas, "Size", vars, props);
      final alignment =
          getValue(maps["alignment"], datas, "AlignmentGeometry", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      if (size == null) {
        return null;
      }
      return SizedOverflowBox(
          key: key,
          size: size!,
          alignment: alignment ?? Alignment.center,
          child: child);
    },
    "SlideTransition": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final position =
          getValue(maps["position"], datas, "Animation<Offset>", vars, props);
      final transformHitTests =
          getValue(maps["transformHitTests"], datas, "bool", vars, props);
      final textDirection =
          getValue(maps["textDirection"], datas, "TextDirection?", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      if (position == null) {
        return null;
      }
      return SlideTransition(
          key: key,
          position: position!,
          transformHitTests: transformHitTests ?? true,
          textDirection: textDirection,
          child: child);
    },
    "Slider": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final value = getValue(maps["value"], datas, "", vars, props);
      final secondaryTrackValue =
          getValue(maps["secondaryTrackValue"], datas, "", vars, props);
      final onChanged = getValue(maps["onChanged"], datas, "", vars, props);
      final onChangeStart =
          getValue(maps["onChangeStart"], datas, "", vars, props);
      final onChangeEnd = getValue(maps["onChangeEnd"], datas, "", vars, props);
      final min = getValue(maps["min"], datas, "", vars, props);
      final max = getValue(maps["max"], datas, "", vars, props);
      final divisions = getValue(maps["divisions"], datas, "", vars, props);
      final label = getValue(maps["label"], datas, "", vars, props);
      final activeColor = getValue(maps["activeColor"], datas, "", vars, props);
      final inactiveColor =
          getValue(maps["inactiveColor"], datas, "", vars, props);
      final secondaryActiveColor =
          getValue(maps["secondaryActiveColor"], datas, "", vars, props);
      final thumbColor = getValue(maps["thumbColor"], datas, "", vars, props);
      final overlayColor =
          getValue(maps["overlayColor"], datas, "", vars, props);
      final mouseCursor = getValue(maps["mouseCursor"], datas, "", vars, props);
      final semanticFormatterCallback =
          getValue(maps["semanticFormatterCallback"], datas, "", vars, props);
      final focusNode = getValue(maps["focusNode"], datas, "", vars, props);
      final autofocus = getValue(maps["autofocus"], datas, "", vars, props);
      if (value == null || onChanged == null) {
        return null;
      }
      return Slider(
          key: key,
          value: value!,
          secondaryTrackValue: secondaryTrackValue,
          onChanged: onChanged!,
          onChangeStart: onChangeStart,
          onChangeEnd: onChangeEnd,
          min: min ?? 0.0,
          max: max ?? 1.0,
          divisions: divisions,
          label: label,
          activeColor: activeColor,
          inactiveColor: inactiveColor,
          secondaryActiveColor: secondaryActiveColor,
          thumbColor: thumbColor,
          overlayColor: overlayColor,
          mouseCursor: mouseCursor,
          semanticFormatterCallback: semanticFormatterCallback,
          focusNode: focusNode,
          autofocus: autofocus ?? false);
    },
    "SliderTheme": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final data =
          getValue(maps["data"], datas, "SliderThemeData", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (data == null || child == null) {
        return null;
      }
      return SliderTheme(key: key, data: data!, child: child!);
    },
    "SliderThemeData": () {
      final trackHeight =
          getValue(maps["trackHeight"], datas, "double?", vars, props);
      final activeTrackColor =
          getValue(maps["activeTrackColor"], datas, "Color?", vars, props);
      final inactiveTrackColor =
          getValue(maps["inactiveTrackColor"], datas, "Color?", vars, props);
      final secondaryActiveTrackColor = getValue(
          maps["secondaryActiveTrackColor"], datas, "Color?", vars, props);
      final disabledActiveTrackColor = getValue(
          maps["disabledActiveTrackColor"], datas, "Color?", vars, props);
      final disabledInactiveTrackColor = getValue(
          maps["disabledInactiveTrackColor"], datas, "Color?", vars, props);
      final disabledSecondaryActiveTrackColor = getValue(
          maps["disabledSecondaryActiveTrackColor"],
          datas,
          "Color?",
          vars,
          props);
      final activeTickMarkColor =
          getValue(maps["activeTickMarkColor"], datas, "Color?", vars, props);
      final inactiveTickMarkColor =
          getValue(maps["inactiveTickMarkColor"], datas, "Color?", vars, props);
      final disabledActiveTickMarkColor = getValue(
          maps["disabledActiveTickMarkColor"], datas, "Color?", vars, props);
      final disabledInactiveTickMarkColor = getValue(
          maps["disabledInactiveTickMarkColor"], datas, "Color?", vars, props);
      final thumbColor =
          getValue(maps["thumbColor"], datas, "Color?", vars, props);
      final overlappingShapeStrokeColor = getValue(
          maps["overlappingShapeStrokeColor"], datas, "Color?", vars, props);
      final disabledThumbColor =
          getValue(maps["disabledThumbColor"], datas, "Color?", vars, props);
      final overlayColor =
          getValue(maps["overlayColor"], datas, "Color?", vars, props);
      final valueIndicatorColor =
          getValue(maps["valueIndicatorColor"], datas, "Color?", vars, props);
      final overlayShape = getValue(
          maps["overlayShape"], datas, "SliderComponentShape?", vars, props);
      final tickMarkShape = getValue(
          maps["tickMarkShape"], datas, "SliderTickMarkShape?", vars, props);
      final thumbShape = getValue(
          maps["thumbShape"], datas, "SliderComponentShape?", vars, props);
      final trackShape =
          getValue(maps["trackShape"], datas, "SliderTrackShape?", vars, props);
      final valueIndicatorShape = getValue(maps["valueIndicatorShape"], datas,
          "SliderComponentShape?", vars, props);
      final rangeTickMarkShape = getValue(maps["rangeTickMarkShape"], datas,
          "RangeSliderTickMarkShape?", vars, props);
      final rangeThumbShape = getValue(maps["rangeThumbShape"], datas,
          "RangeSliderThumbShape?", vars, props);
      final rangeTrackShape = getValue(maps["rangeTrackShape"], datas,
          "RangeSliderTrackShape?", vars, props);
      final rangeValueIndicatorShape = getValue(
          maps["rangeValueIndicatorShape"],
          datas,
          "RangeSliderValueIndicatorShape?",
          vars,
          props);
      final showValueIndicator = getValue(maps["showValueIndicator"], datas,
          "ShowValueIndicator?", vars, props);
      final valueIndicatorTextStyle = getValue(
          maps["valueIndicatorTextStyle"], datas, "TextStyle?", vars, props);
      final minThumbSeparation =
          getValue(maps["minThumbSeparation"], datas, "double?", vars, props);
      final thumbSelector = getValue(
          maps["thumbSelector"], datas, "RangeThumbSelector?", vars, props);
      final mouseCursor = getValue(maps["mouseCursor"], datas,
          "MaterialStateProperty<MouseCursor?>?", vars, props);
      return SliderThemeData(
          trackHeight: trackHeight,
          activeTrackColor: activeTrackColor,
          inactiveTrackColor: inactiveTrackColor,
          secondaryActiveTrackColor: secondaryActiveTrackColor,
          disabledActiveTrackColor: disabledActiveTrackColor,
          disabledInactiveTrackColor: disabledInactiveTrackColor,
          disabledSecondaryActiveTrackColor: disabledSecondaryActiveTrackColor,
          activeTickMarkColor: activeTickMarkColor,
          inactiveTickMarkColor: inactiveTickMarkColor,
          disabledActiveTickMarkColor: disabledActiveTickMarkColor,
          disabledInactiveTickMarkColor: disabledInactiveTickMarkColor,
          thumbColor: thumbColor,
          overlappingShapeStrokeColor: overlappingShapeStrokeColor,
          disabledThumbColor: disabledThumbColor,
          overlayColor: overlayColor,
          valueIndicatorColor: valueIndicatorColor,
          overlayShape: overlayShape,
          tickMarkShape: tickMarkShape,
          thumbShape: thumbShape,
          trackShape: trackShape,
          valueIndicatorShape: valueIndicatorShape,
          rangeTickMarkShape: rangeTickMarkShape,
          rangeThumbShape: rangeThumbShape,
          rangeTrackShape: rangeTrackShape,
          rangeValueIndicatorShape: rangeValueIndicatorShape,
          showValueIndicator: showValueIndicator,
          valueIndicatorTextStyle: valueIndicatorTextStyle,
          minThumbSeparation: minThumbSeparation,
          thumbSelector: thumbSelector,
          mouseCursor: mouseCursor);
    },
    "SliderThemeData.fromPrimaryColors": () {
      final primaryColor =
          getValue(maps["primaryColor"], datas, "Color", vars, props);
      final primaryColorDark =
          getValue(maps["primaryColorDark"], datas, "Color", vars, props);
      final primaryColorLight =
          getValue(maps["primaryColorLight"], datas, "Color", vars, props);
      final valueIndicatorTextStyle = getValue(
          maps["valueIndicatorTextStyle"], datas, "TextStyle", vars, props);
      if (primaryColor == null ||
          primaryColorDark == null ||
          primaryColorLight == null ||
          valueIndicatorTextStyle == null) {
        return null;
      }
      return SliderThemeData.fromPrimaryColors(
          primaryColor: primaryColor!,
          primaryColorDark: primaryColorDark!,
          primaryColorLight: primaryColorLight!,
          valueIndicatorTextStyle: valueIndicatorTextStyle!);
    },
    "SliverAnimatedGrid": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final itemBuilder = getValue(
          maps["itemBuilder"], datas, "AnimatedItemBuilder", vars, props);
      final gridDelegate = getValue(
          maps["gridDelegate"], datas, "SliverGridDelegate", vars, props);
      final findChildIndexCallback = getValue(maps["findChildIndexCallback"],
          datas, "ChildIndexGetter?", vars, props);
      final initialItemCount =
          getValue(maps["initialItemCount"], datas, "int", vars, props);
      if (itemBuilder == null || gridDelegate == null) {
        return null;
      }
      return SliverAnimatedGrid(
          key: key,
          itemBuilder: itemBuilder!,
          gridDelegate: gridDelegate!,
          findChildIndexCallback: findChildIndexCallback,
          initialItemCount: initialItemCount ?? 0);
    },
    "SliverAnimatedList": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final itemBuilder = getValue(
          maps["itemBuilder"], datas, "AnimatedItemBuilder", vars, props);
      final findChildIndexCallback = getValue(maps["findChildIndexCallback"],
          datas, "ChildIndexGetter?", vars, props);
      final initialItemCount =
          getValue(maps["initialItemCount"], datas, "int", vars, props);
      if (itemBuilder == null) {
        return null;
      }
      return SliverAnimatedList(
          key: key,
          itemBuilder: itemBuilder!,
          findChildIndexCallback: findChildIndexCallback,
          initialItemCount: initialItemCount ?? 0);
    },
    "SliverAnimatedOpacity": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final sliver = getValue(maps["sliver"], datas, "Widget?", vars, props);
      final opacity = getValue(maps["opacity"], datas, "double", vars, props);
      final curve = getValue(maps["curve"], datas, "Curve", vars, props);
      final duration =
          getValue(maps["duration"], datas, "Duration", vars, props);
      final onEnd =
          getValue(maps["onEnd"], datas, "VoidCallback?", vars, props);
      final alwaysIncludeSemantics =
          getValue(maps["alwaysIncludeSemantics"], datas, "bool", vars, props);
      if (opacity == null || duration == null) {
        return null;
      }
      return SliverAnimatedOpacity(
          key: key,
          sliver: sliver,
          opacity: opacity!,
          curve: curve ?? Curves.linear,
          duration: duration!,
          onEnd: onEnd,
          alwaysIncludeSemantics: alwaysIncludeSemantics ?? false);
    },
    "SliverAppBar": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final leading = getValue(maps["leading"], datas, "", vars, props);
      final automaticallyImplyLeading =
          getValue(maps["automaticallyImplyLeading"], datas, "", vars, props);
      final title = getValue(maps["title"], datas, "", vars, props);
      final actions = getValue(maps["actions"], datas, "", vars, props);
      final flexibleSpace =
          getValue(maps["flexibleSpace"], datas, "", vars, props);
      final bottom = getValue(maps["bottom"], datas, "", vars, props);
      final elevation = getValue(maps["elevation"], datas, "", vars, props);
      final scrolledUnderElevation =
          getValue(maps["scrolledUnderElevation"], datas, "", vars, props);
      final shadowColor = getValue(maps["shadowColor"], datas, "", vars, props);
      final surfaceTintColor =
          getValue(maps["surfaceTintColor"], datas, "", vars, props);
      final forceElevated =
          getValue(maps["forceElevated"], datas, "", vars, props);
      final backgroundColor =
          getValue(maps["backgroundColor"], datas, "", vars, props);
      final foregroundColor =
          getValue(maps["foregroundColor"], datas, "", vars, props);
      final iconTheme = getValue(maps["iconTheme"], datas, "", vars, props);
      final actionsIconTheme =
          getValue(maps["actionsIconTheme"], datas, "", vars, props);
      final primary = getValue(maps["primary"], datas, "", vars, props);
      final centerTitle = getValue(maps["centerTitle"], datas, "", vars, props);
      final excludeHeaderSemantics =
          getValue(maps["excludeHeaderSemantics"], datas, "", vars, props);
      final titleSpacing =
          getValue(maps["titleSpacing"], datas, "", vars, props);
      final collapsedHeight =
          getValue(maps["collapsedHeight"], datas, "", vars, props);
      final expandedHeight =
          getValue(maps["expandedHeight"], datas, "", vars, props);
      final floating = getValue(maps["floating"], datas, "", vars, props);
      final pinned = getValue(maps["pinned"], datas, "", vars, props);
      final snap = getValue(maps["snap"], datas, "", vars, props);
      final stretch = getValue(maps["stretch"], datas, "", vars, props);
      final stretchTriggerOffset =
          getValue(maps["stretchTriggerOffset"], datas, "", vars, props);
      final onStretchTrigger =
          getValue(maps["onStretchTrigger"], datas, "", vars, props);
      final shape = getValue(maps["shape"], datas, "", vars, props);
      final toolbarHeight =
          getValue(maps["toolbarHeight"], datas, "", vars, props);
      final leadingWidth =
          getValue(maps["leadingWidth"], datas, "", vars, props);
      final toolbarTextStyle =
          getValue(maps["toolbarTextStyle"], datas, "", vars, props);
      final titleTextStyle =
          getValue(maps["titleTextStyle"], datas, "", vars, props);
      final systemOverlayStyle =
          getValue(maps["systemOverlayStyle"], datas, "", vars, props);
      final forceMaterialTransparency =
          getValue(maps["forceMaterialTransparency"], datas, "", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "", vars, props);
      return SliverAppBar(
          key: key,
          leading: leading,
          automaticallyImplyLeading: automaticallyImplyLeading ?? true,
          title: title,
          actions: actions,
          flexibleSpace: flexibleSpace,
          bottom: bottom,
          elevation: elevation,
          scrolledUnderElevation: scrolledUnderElevation,
          shadowColor: shadowColor,
          surfaceTintColor: surfaceTintColor,
          forceElevated: forceElevated ?? false,
          backgroundColor: backgroundColor,
          foregroundColor: foregroundColor,
          iconTheme: iconTheme,
          actionsIconTheme: actionsIconTheme,
          primary: primary ?? true,
          centerTitle: centerTitle,
          excludeHeaderSemantics: excludeHeaderSemantics ?? false,
          titleSpacing: titleSpacing,
          collapsedHeight: collapsedHeight,
          expandedHeight: expandedHeight,
          floating: floating ?? false,
          pinned: pinned ?? false,
          snap: snap ?? false,
          stretch: stretch ?? false,
          stretchTriggerOffset: stretchTriggerOffset ?? 100.0,
          onStretchTrigger: onStretchTrigger,
          shape: shape,
          toolbarHeight: toolbarHeight ?? kToolbarHeight,
          leadingWidth: leadingWidth,
          toolbarTextStyle: toolbarTextStyle,
          titleTextStyle: titleTextStyle,
          systemOverlayStyle: systemOverlayStyle,
          forceMaterialTransparency: forceMaterialTransparency ?? false,
          clipBehavior: clipBehavior);
    },
    "SliverChildBuilderDelegate": () {
      final builder = getValue(
          maps["0"], datas, "NullableIndexedWidgetBuilder", vars, props);
      final findChildIndexCallback = getValue(maps["findChildIndexCallback"],
          datas, "ChildIndexGetter?", vars, props);
      final childCount =
          getValue(maps["childCount"], datas, "int?", vars, props);
      final addAutomaticKeepAlives =
          getValue(maps["addAutomaticKeepAlives"], datas, "bool", vars, props);
      final addRepaintBoundaries =
          getValue(maps["addRepaintBoundaries"], datas, "bool", vars, props);
      final addSemanticIndexes =
          getValue(maps["addSemanticIndexes"], datas, "bool", vars, props);
      final semanticIndexCallback = getValue(maps["semanticIndexCallback"],
          datas, "SemanticIndexCallback", vars, props);
      final semanticIndexOffset =
          getValue(maps["semanticIndexOffset"], datas, "int", vars, props);
      if (builder == null) {
        return null;
      }
      if (semanticIndexCallback != null) {
        return SliverChildBuilderDelegate(builder!,
            findChildIndexCallback: findChildIndexCallback,
            childCount: childCount,
            addAutomaticKeepAlives: addAutomaticKeepAlives ?? true,
            addRepaintBoundaries: addRepaintBoundaries ?? true,
            addSemanticIndexes: addSemanticIndexes ?? true,
            semanticIndexOffset: semanticIndexOffset ?? 0,
            semanticIndexCallback: semanticIndexCallback);
      }
      return SliverChildBuilderDelegate(builder!,
          findChildIndexCallback: findChildIndexCallback,
          childCount: childCount,
          addAutomaticKeepAlives: addAutomaticKeepAlives ?? true,
          addRepaintBoundaries: addRepaintBoundaries ?? true,
          addSemanticIndexes: addSemanticIndexes ?? true,
          semanticIndexOffset: semanticIndexOffset ?? 0);
    },
    "SliverChildListDelegate": () {
      final children = getValue(maps["0"], datas, "List<Widget>", vars, props);
      final addAutomaticKeepAlives =
          getValue(maps["addAutomaticKeepAlives"], datas, "bool", vars, props);
      final addRepaintBoundaries =
          getValue(maps["addRepaintBoundaries"], datas, "bool", vars, props);
      final addSemanticIndexes =
          getValue(maps["addSemanticIndexes"], datas, "bool", vars, props);
      final semanticIndexCallback = getValue(maps["semanticIndexCallback"],
          datas, "SemanticIndexCallback", vars, props);
      final semanticIndexOffset =
          getValue(maps["semanticIndexOffset"], datas, "int", vars, props);
      if (children == null) {
        return null;
      }
      if (semanticIndexCallback != null) {
        return SliverChildListDelegate(List<Widget>.from(children!),
            addAutomaticKeepAlives: addAutomaticKeepAlives ?? true,
            addRepaintBoundaries: addRepaintBoundaries ?? true,
            addSemanticIndexes: addSemanticIndexes ?? true,
            semanticIndexOffset: semanticIndexOffset ?? 0,
            semanticIndexCallback: semanticIndexCallback);
      }
      return SliverChildListDelegate(List<Widget>.from(children!),
          addAutomaticKeepAlives: addAutomaticKeepAlives ?? true,
          addRepaintBoundaries: addRepaintBoundaries ?? true,
          addSemanticIndexes: addSemanticIndexes ?? true,
          semanticIndexOffset: semanticIndexOffset ?? 0);
    },
    "SliverChildListDelegate.fixed": () {
      final children = getValue(maps["0"], datas, "List<Widget>", vars, props);
      final addAutomaticKeepAlives =
          getValue(maps["addAutomaticKeepAlives"], datas, "bool", vars, props);
      final addRepaintBoundaries =
          getValue(maps["addRepaintBoundaries"], datas, "bool", vars, props);
      final addSemanticIndexes =
          getValue(maps["addSemanticIndexes"], datas, "bool", vars, props);
      final semanticIndexCallback = getValue(maps["semanticIndexCallback"],
          datas, "SemanticIndexCallback", vars, props);
      final semanticIndexOffset =
          getValue(maps["semanticIndexOffset"], datas, "int", vars, props);
      if (children == null) {
        return null;
      }
      if (semanticIndexCallback != null) {
        return SliverChildListDelegate.fixed(List<Widget>.from(children!),
            addAutomaticKeepAlives: addAutomaticKeepAlives ?? true,
            addRepaintBoundaries: addRepaintBoundaries ?? true,
            addSemanticIndexes: addSemanticIndexes ?? true,
            semanticIndexOffset: semanticIndexOffset ?? 0,
            semanticIndexCallback: semanticIndexCallback);
      }
      return SliverChildListDelegate.fixed(List<Widget>.from(children!),
          addAutomaticKeepAlives: addAutomaticKeepAlives ?? true,
          addRepaintBoundaries: addRepaintBoundaries ?? true,
          addSemanticIndexes: addSemanticIndexes ?? true,
          semanticIndexOffset: semanticIndexOffset ?? 0);
    },
    "SliverConstraints": () {
      final axisDirection =
          getValue(maps["axisDirection"], datas, "AxisDirection", vars, props);
      final growthDirection = getValue(
          maps["growthDirection"], datas, "GrowthDirection", vars, props);
      final userScrollDirection = getValue(
          maps["userScrollDirection"], datas, "ScrollDirection", vars, props);
      final scrollOffset =
          getValue(maps["scrollOffset"], datas, "double", vars, props);
      final precedingScrollExtent =
          getValue(maps["precedingScrollExtent"], datas, "double", vars, props);
      final overlap = getValue(maps["overlap"], datas, "double", vars, props);
      final remainingPaintExtent =
          getValue(maps["remainingPaintExtent"], datas, "double", vars, props);
      final crossAxisExtent =
          getValue(maps["crossAxisExtent"], datas, "double", vars, props);
      final crossAxisDirection = getValue(
          maps["crossAxisDirection"], datas, "AxisDirection", vars, props);
      final viewportMainAxisExtent = getValue(
          maps["viewportMainAxisExtent"], datas, "double", vars, props);
      final remainingCacheExtent =
          getValue(maps["remainingCacheExtent"], datas, "double", vars, props);
      final cacheOrigin =
          getValue(maps["cacheOrigin"], datas, "double", vars, props);
      if (axisDirection == null ||
          growthDirection == null ||
          userScrollDirection == null ||
          scrollOffset == null ||
          precedingScrollExtent == null ||
          overlap == null ||
          remainingPaintExtent == null ||
          crossAxisExtent == null ||
          crossAxisDirection == null ||
          viewportMainAxisExtent == null ||
          remainingCacheExtent == null ||
          cacheOrigin == null) {
        return null;
      }
      return SliverConstraints(
          axisDirection: axisDirection!,
          growthDirection: growthDirection!,
          userScrollDirection: userScrollDirection!,
          scrollOffset: scrollOffset!,
          precedingScrollExtent: precedingScrollExtent!,
          overlap: overlap!,
          remainingPaintExtent: remainingPaintExtent!,
          crossAxisExtent: crossAxisExtent!,
          crossAxisDirection: crossAxisDirection!,
          viewportMainAxisExtent: viewportMainAxisExtent!,
          remainingCacheExtent: remainingCacheExtent!,
          cacheOrigin: cacheOrigin!);
    },
    "SliverFadeTransition": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final opacity =
          getValue(maps["opacity"], datas, "Animation<double>", vars, props);
      final alwaysIncludeSemantics =
          getValue(maps["alwaysIncludeSemantics"], datas, "bool", vars, props);
      final sliver = getValue(maps["sliver"], datas, "Widget?", vars, props);
      if (opacity == null) {
        return null;
      }
      return SliverFadeTransition(
          key: key,
          opacity: opacity!,
          alwaysIncludeSemantics: alwaysIncludeSemantics ?? false,
          sliver: sliver);
    },
    "SliverFillRemaining": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      final hasScrollBody =
          getValue(maps["hasScrollBody"], datas, "bool", vars, props);
      final fillOverscroll =
          getValue(maps["fillOverscroll"], datas, "bool", vars, props);
      return SliverFillRemaining(
          key: key,
          child: child,
          hasScrollBody: hasScrollBody ?? true,
          fillOverscroll: fillOverscroll ?? false);
    },
    "SliverFillViewport": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final delegate =
          getValue(maps["delegate"], datas, "SliverChildDelegate", vars, props);
      final viewportFraction =
          getValue(maps["viewportFraction"], datas, "double", vars, props);
      final padEnds = getValue(maps["padEnds"], datas, "bool", vars, props);
      if (delegate == null) {
        return null;
      }
      return SliverFillViewport(
          key: key,
          delegate: delegate!,
          viewportFraction: viewportFraction ?? 1.0,
          padEnds: padEnds ?? true);
    },
    "SliverFixedExtentList": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final delegate =
          getValue(maps["delegate"], datas, "SliverChildDelegate", vars, props);
      final itemExtent =
          getValue(maps["itemExtent"], datas, "double", vars, props);
      if (delegate == null || itemExtent == null) {
        return null;
      }
      return SliverFixedExtentList(
          key: key, delegate: delegate!, itemExtent: itemExtent!);
    },
    "SliverFixedExtentList.builder": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final itemBuilder = getValue(maps["itemBuilder"], datas,
          "NullableIndexedWidgetBuilder", vars, props);
      final itemExtent =
          getValue(maps["itemExtent"], datas, "double", vars, props);
      final findChildIndexCallback = getValue(maps["findChildIndexCallback"],
          datas, "ChildIndexGetter?", vars, props);
      final itemCount = getValue(maps["itemCount"], datas, "int?", vars, props);
      final addAutomaticKeepAlives =
          getValue(maps["addAutomaticKeepAlives"], datas, "bool", vars, props);
      final addRepaintBoundaries =
          getValue(maps["addRepaintBoundaries"], datas, "bool", vars, props);
      final addSemanticIndexes =
          getValue(maps["addSemanticIndexes"], datas, "bool", vars, props);
      if (itemBuilder == null || itemExtent == null) {
        return null;
      }
      return SliverFixedExtentList.builder(
          key: key,
          itemBuilder: itemBuilder!,
          itemExtent: itemExtent!,
          findChildIndexCallback: findChildIndexCallback,
          itemCount: itemCount,
          addAutomaticKeepAlives: addAutomaticKeepAlives ?? true,
          addRepaintBoundaries: addRepaintBoundaries ?? true,
          addSemanticIndexes: addSemanticIndexes ?? true);
    },
    "SliverFixedExtentList.list": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final children =
          getValue(maps["children"], datas, "List<Widget>", vars, props);
      final itemExtent =
          getValue(maps["itemExtent"], datas, "double", vars, props);
      final addAutomaticKeepAlives =
          getValue(maps["addAutomaticKeepAlives"], datas, "bool", vars, props);
      final addRepaintBoundaries =
          getValue(maps["addRepaintBoundaries"], datas, "bool", vars, props);
      final addSemanticIndexes =
          getValue(maps["addSemanticIndexes"], datas, "bool", vars, props);
      if (children == null || itemExtent == null) {
        return null;
      }
      return SliverFixedExtentList.list(
          key: key,
          itemExtent: itemExtent!,
          addAutomaticKeepAlives: addAutomaticKeepAlives ?? true,
          addRepaintBoundaries: addRepaintBoundaries ?? true,
          addSemanticIndexes: addSemanticIndexes ?? true,
          children: List<Widget>.from(children!));
    },
    "SliverGeometry": () {
      final scrollExtent =
          getValue(maps["scrollExtent"], datas, "double", vars, props);
      final paintExtent =
          getValue(maps["paintExtent"], datas, "double", vars, props);
      final paintOrigin =
          getValue(maps["paintOrigin"], datas, "double", vars, props);
      final layoutExtent =
          getValue(maps["layoutExtent"], datas, "double?", vars, props);
      final maxPaintExtent =
          getValue(maps["maxPaintExtent"], datas, "double", vars, props);
      final maxScrollObstructionExtent = getValue(
          maps["maxScrollObstructionExtent"], datas, "double", vars, props);
      final hitTestExtent =
          getValue(maps["hitTestExtent"], datas, "double?", vars, props);
      final visible = getValue(maps["visible"], datas, "bool?", vars, props);
      final hasVisualOverflow =
          getValue(maps["hasVisualOverflow"], datas, "bool", vars, props);
      final scrollOffsetCorrection = getValue(
          maps["scrollOffsetCorrection"], datas, "double?", vars, props);
      final cacheExtent =
          getValue(maps["cacheExtent"], datas, "double?", vars, props);
      return SliverGeometry(
          scrollExtent: scrollExtent ?? 0.0,
          paintExtent: paintExtent ?? 0.0,
          paintOrigin: paintOrigin ?? 0.0,
          layoutExtent: layoutExtent,
          maxPaintExtent: maxPaintExtent ?? 0.0,
          maxScrollObstructionExtent: maxScrollObstructionExtent ?? 0.0,
          hitTestExtent: hitTestExtent,
          visible: visible,
          hasVisualOverflow: hasVisualOverflow ?? false,
          scrollOffsetCorrection: scrollOffsetCorrection,
          cacheExtent: cacheExtent);
    },
    "SliverGrid": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final delegate =
          getValue(maps["delegate"], datas, "SliverChildDelegate", vars, props);
      final gridDelegate = getValue(
          maps["gridDelegate"], datas, "SliverGridDelegate", vars, props);
      if (delegate == null || gridDelegate == null) {
        return null;
      }
      return SliverGrid(
          key: key, delegate: delegate!, gridDelegate: gridDelegate!);
    },
    "SliverGrid.builder": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final gridDelegate = getValue(
          maps["gridDelegate"], datas, "SliverGridDelegate", vars, props);
      final itemBuilder = getValue(maps["itemBuilder"], datas,
          "NullableIndexedWidgetBuilder", vars, props);
      final findChildIndexCallback = getValue(maps["findChildIndexCallback"],
          datas, "ChildIndexGetter?", vars, props);
      final itemCount = getValue(maps["itemCount"], datas, "int?", vars, props);
      final addAutomaticKeepAlives =
          getValue(maps["addAutomaticKeepAlives"], datas, "bool", vars, props);
      final addRepaintBoundaries =
          getValue(maps["addRepaintBoundaries"], datas, "bool", vars, props);
      final addSemanticIndexes =
          getValue(maps["addSemanticIndexes"], datas, "bool", vars, props);
      if (gridDelegate == null || itemBuilder == null) {
        return null;
      }
      return SliverGrid.builder(
          key: key,
          gridDelegate: gridDelegate!,
          itemBuilder: itemBuilder!,
          findChildIndexCallback: findChildIndexCallback,
          itemCount: itemCount,
          addAutomaticKeepAlives: addAutomaticKeepAlives ?? true,
          addRepaintBoundaries: addRepaintBoundaries ?? true,
          addSemanticIndexes: addSemanticIndexes ?? true);
    },
    "SliverGrid.count": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final crossAxisCount =
          getValue(maps["crossAxisCount"], datas, "int", vars, props);
      final mainAxisSpacing =
          getValue(maps["mainAxisSpacing"], datas, "double", vars, props);
      final crossAxisSpacing =
          getValue(maps["crossAxisSpacing"], datas, "double", vars, props);
      final childAspectRatio =
          getValue(maps["childAspectRatio"], datas, "double", vars, props);
      final children =
          getValue(maps["children"], datas, "List<Widget>", vars, props);
      if (crossAxisCount == null) {
        return null;
      }
      return SliverGrid.count(
          key: key,
          crossAxisCount: crossAxisCount!,
          mainAxisSpacing: mainAxisSpacing ?? 0.0,
          crossAxisSpacing: crossAxisSpacing ?? 0.0,
          childAspectRatio: childAspectRatio ?? 1.0,
          children: List<Widget>.from(children ?? const <Widget>[]));
    },
    "SliverGrid.extent": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final maxCrossAxisExtent =
          getValue(maps["maxCrossAxisExtent"], datas, "double", vars, props);
      final mainAxisSpacing =
          getValue(maps["mainAxisSpacing"], datas, "double", vars, props);
      final crossAxisSpacing =
          getValue(maps["crossAxisSpacing"], datas, "double", vars, props);
      final childAspectRatio =
          getValue(maps["childAspectRatio"], datas, "double", vars, props);
      final children =
          getValue(maps["children"], datas, "List<Widget>", vars, props);
      if (maxCrossAxisExtent == null) {
        return null;
      }
      return SliverGrid.extent(
          key: key,
          maxCrossAxisExtent: maxCrossAxisExtent!,
          mainAxisSpacing: mainAxisSpacing ?? 0.0,
          crossAxisSpacing: crossAxisSpacing ?? 0.0,
          childAspectRatio: childAspectRatio ?? 1.0,
          children: List<Widget>.from(children ?? const <Widget>[]));
    },
    "SliverGridDelegateWithFixedCrossAxisCount": () {
      final crossAxisCount =
          getValue(maps["crossAxisCount"], datas, "int", vars, props);
      final mainAxisSpacing =
          getValue(maps["mainAxisSpacing"], datas, "double", vars, props);
      final crossAxisSpacing =
          getValue(maps["crossAxisSpacing"], datas, "double", vars, props);
      final childAspectRatio =
          getValue(maps["childAspectRatio"], datas, "double", vars, props);
      final mainAxisExtent =
          getValue(maps["mainAxisExtent"], datas, "double?", vars, props);
      if (crossAxisCount == null) {
        return null;
      }
      return SliverGridDelegateWithFixedCrossAxisCount(
          crossAxisCount: crossAxisCount!,
          mainAxisSpacing: mainAxisSpacing ?? 0.0,
          crossAxisSpacing: crossAxisSpacing ?? 0.0,
          childAspectRatio: childAspectRatio ?? 1.0,
          mainAxisExtent: mainAxisExtent);
    },
    "SliverGridDelegateWithMaxCrossAxisExtent": () {
      final maxCrossAxisExtent =
          getValue(maps["maxCrossAxisExtent"], datas, "double", vars, props);
      final mainAxisSpacing =
          getValue(maps["mainAxisSpacing"], datas, "double", vars, props);
      final crossAxisSpacing =
          getValue(maps["crossAxisSpacing"], datas, "double", vars, props);
      final childAspectRatio =
          getValue(maps["childAspectRatio"], datas, "double", vars, props);
      final mainAxisExtent =
          getValue(maps["mainAxisExtent"], datas, "double?", vars, props);
      if (maxCrossAxisExtent == null) {
        return null;
      }
      return SliverGridDelegateWithMaxCrossAxisExtent(
          maxCrossAxisExtent: maxCrossAxisExtent!,
          mainAxisSpacing: mainAxisSpacing ?? 0.0,
          crossAxisSpacing: crossAxisSpacing ?? 0.0,
          childAspectRatio: childAspectRatio ?? 1.0,
          mainAxisExtent: mainAxisExtent);
    },
    "SliverGridGeometry": () {
      final scrollOffset =
          getValue(maps["scrollOffset"], datas, "double", vars, props);
      final crossAxisOffset =
          getValue(maps["crossAxisOffset"], datas, "double", vars, props);
      final mainAxisExtent =
          getValue(maps["mainAxisExtent"], datas, "double", vars, props);
      final crossAxisExtent =
          getValue(maps["crossAxisExtent"], datas, "double", vars, props);
      if (scrollOffset == null ||
          crossAxisOffset == null ||
          mainAxisExtent == null ||
          crossAxisExtent == null) {
        return null;
      }
      return SliverGridGeometry(
          scrollOffset: scrollOffset!,
          crossAxisOffset: crossAxisOffset!,
          mainAxisExtent: mainAxisExtent!,
          crossAxisExtent: crossAxisExtent!);
    },
    "SliverGridRegularTileLayout": () {
      final crossAxisCount =
          getValue(maps["crossAxisCount"], datas, "int", vars, props);
      final mainAxisStride =
          getValue(maps["mainAxisStride"], datas, "double", vars, props);
      final crossAxisStride =
          getValue(maps["crossAxisStride"], datas, "double", vars, props);
      final childMainAxisExtent =
          getValue(maps["childMainAxisExtent"], datas, "double", vars, props);
      final childCrossAxisExtent =
          getValue(maps["childCrossAxisExtent"], datas, "double", vars, props);
      final reverseCrossAxis =
          getValue(maps["reverseCrossAxis"], datas, "bool", vars, props);
      if (crossAxisCount == null ||
          mainAxisStride == null ||
          crossAxisStride == null ||
          childMainAxisExtent == null ||
          childCrossAxisExtent == null ||
          reverseCrossAxis == null) {
        return null;
      }
      return SliverGridRegularTileLayout(
          crossAxisCount: crossAxisCount!,
          mainAxisStride: mainAxisStride!,
          crossAxisStride: crossAxisStride!,
          childMainAxisExtent: childMainAxisExtent!,
          childCrossAxisExtent: childCrossAxisExtent!,
          reverseCrossAxis: reverseCrossAxis!);
    },
    "SliverHitTestEntry": () {
      final target = getValue(maps["0"], datas, "T", vars, props);
      final mainAxisPosition =
          getValue(maps["mainAxisPosition"], datas, "double", vars, props);
      final crossAxisPosition =
          getValue(maps["crossAxisPosition"], datas, "double", vars, props);
      if (target == null ||
          mainAxisPosition == null ||
          crossAxisPosition == null) {
        return null;
      }
      return SliverHitTestEntry(target!,
          mainAxisPosition: mainAxisPosition!,
          crossAxisPosition: crossAxisPosition!);
    },
    "SliverHitTestResult": () {
      return SliverHitTestResult();
    },
    "SliverHitTestResult.wrap": () {
      final result = getValue(maps["0"], datas, "", vars, props);
      if (result == null) {
        return null;
      }
      return SliverHitTestResult.wrap(result!);
    },
    "SliverIgnorePointer": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final ignoring = getValue(maps["ignoring"], datas, "bool", vars, props);
      final ignoringSemantics =
          getValue(maps["ignoringSemantics"], datas, "bool?", vars, props);
      final sliver = getValue(maps["sliver"], datas, "Widget?", vars, props);
      return SliverIgnorePointer(
          key: key,
          ignoring: ignoring ?? true,
          ignoringSemantics: ignoringSemantics,
          sliver: sliver);
    },
    "SliverLayoutBuilder": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final builder = getValue(
          maps["builder"],
          datas,
          "Widget Function(BuildContext context, ConstraintType constraints)",
          vars,
          props);
      if (builder == null) {
        return null;
      }
      return SliverLayoutBuilder(key: key, builder: builder!);
    },
    "SliverList": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final delegate =
          getValue(maps["delegate"], datas, "SliverChildDelegate", vars, props);
      if (delegate == null) {
        return null;
      }
      return SliverList(key: key, delegate: delegate!);
    },
    "SliverList.builder": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final itemBuilder = getValue(maps["itemBuilder"], datas,
          "NullableIndexedWidgetBuilder", vars, props);
      final findChildIndexCallback = getValue(maps["findChildIndexCallback"],
          datas, "ChildIndexGetter?", vars, props);
      final itemCount = getValue(maps["itemCount"], datas, "int?", vars, props);
      final addAutomaticKeepAlives =
          getValue(maps["addAutomaticKeepAlives"], datas, "bool", vars, props);
      final addRepaintBoundaries =
          getValue(maps["addRepaintBoundaries"], datas, "bool", vars, props);
      final addSemanticIndexes =
          getValue(maps["addSemanticIndexes"], datas, "bool", vars, props);
      if (itemBuilder == null) {
        return null;
      }
      return SliverList.builder(
          key: key,
          itemBuilder: itemBuilder!,
          findChildIndexCallback: findChildIndexCallback,
          itemCount: itemCount,
          addAutomaticKeepAlives: addAutomaticKeepAlives ?? true,
          addRepaintBoundaries: addRepaintBoundaries ?? true,
          addSemanticIndexes: addSemanticIndexes ?? true);
    },
    "SliverList.separated": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final itemBuilder = getValue(maps["itemBuilder"], datas,
          "NullableIndexedWidgetBuilder", vars, props);
      final findChildIndexCallback = getValue(maps["findChildIndexCallback"],
          datas, "ChildIndexGetter?", vars, props);
      final separatorBuilder = getValue(maps["separatorBuilder"], datas,
          "NullableIndexedWidgetBuilder", vars, props);
      final itemCount = getValue(maps["itemCount"], datas, "int?", vars, props);
      final addAutomaticKeepAlives =
          getValue(maps["addAutomaticKeepAlives"], datas, "bool", vars, props);
      final addRepaintBoundaries =
          getValue(maps["addRepaintBoundaries"], datas, "bool", vars, props);
      final addSemanticIndexes =
          getValue(maps["addSemanticIndexes"], datas, "bool", vars, props);
      if (itemBuilder == null || separatorBuilder == null) {
        return null;
      }
      return SliverList.separated(
          key: key,
          itemBuilder: itemBuilder!,
          findChildIndexCallback: findChildIndexCallback,
          separatorBuilder: separatorBuilder!,
          itemCount: itemCount,
          addAutomaticKeepAlives: addAutomaticKeepAlives ?? true,
          addRepaintBoundaries: addRepaintBoundaries ?? true,
          addSemanticIndexes: addSemanticIndexes ?? true);
    },
    "SliverMultiBoxAdaptorElement": () {
      final widget = getValue(
          maps["0"], datas, "SliverMultiBoxAdaptorWidget", vars, props);
      final replaceMovedChildren =
          getValue(maps["replaceMovedChildren"], datas, "bool", vars, props);
      if (widget == null) {
        return null;
      }
      return SliverMultiBoxAdaptorElement(widget!,
          replaceMovedChildren: replaceMovedChildren ?? false);
    },
    "SliverOffstage": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final offstage = getValue(maps["offstage"], datas, "bool", vars, props);
      final sliver = getValue(maps["sliver"], datas, "Widget?", vars, props);
      return SliverOffstage(
          key: key, offstage: offstage ?? true, sliver: sliver);
    },
    "SliverOpacity": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final opacity = getValue(maps["opacity"], datas, "double", vars, props);
      final alwaysIncludeSemantics =
          getValue(maps["alwaysIncludeSemantics"], datas, "bool", vars, props);
      final sliver = getValue(maps["sliver"], datas, "Widget?", vars, props);
      if (opacity == null) {
        return null;
      }
      return SliverOpacity(
          key: key,
          opacity: opacity!,
          alwaysIncludeSemantics: alwaysIncludeSemantics ?? false,
          sliver: sliver);
    },
    "SliverOverlapInjector": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final handle = getValue(
          maps["handle"], datas, "SliverOverlapAbsorberHandle", vars, props);
      final sliver = getValue(maps["sliver"], datas, "Widget?", vars, props);
      if (handle == null) {
        return null;
      }
      return SliverOverlapInjector(key: key, handle: handle!, sliver: sliver);
    },
    "SliverPadding": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final padding =
          getValue(maps["padding"], datas, "EdgeInsetsGeometry", vars, props);
      final sliver = getValue(maps["sliver"], datas, "Widget?", vars, props);
      if (padding == null) {
        return null;
      }
      return SliverPadding(key: key, padding: padding!, sliver: sliver);
    },
    "SliverPersistentHeader": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final delegate = getValue(maps["delegate"], datas,
          "SliverPersistentHeaderDelegate", vars, props);
      final pinned = getValue(maps["pinned"], datas, "bool", vars, props);
      final floating = getValue(maps["floating"], datas, "bool", vars, props);
      if (delegate == null) {
        return null;
      }
      return SliverPersistentHeader(
          key: key,
          delegate: delegate!,
          pinned: pinned ?? false,
          floating: floating ?? false);
    },
    "SliverPrototypeExtentList": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final delegate =
          getValue(maps["delegate"], datas, "SliverChildDelegate", vars, props);
      final prototypeItem =
          getValue(maps["prototypeItem"], datas, "Widget", vars, props);
      if (delegate == null || prototypeItem == null) {
        return null;
      }
      return SliverPrototypeExtentList(
          key: key, delegate: delegate!, prototypeItem: prototypeItem!);
    },
    "SliverPrototypeExtentList.builder": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final itemBuilder = getValue(maps["itemBuilder"], datas,
          "NullableIndexedWidgetBuilder", vars, props);
      final prototypeItem =
          getValue(maps["prototypeItem"], datas, "Widget", vars, props);
      final findChildIndexCallback = getValue(maps["findChildIndexCallback"],
          datas, "ChildIndexGetter?", vars, props);
      final itemCount = getValue(maps["itemCount"], datas, "int?", vars, props);
      final addAutomaticKeepAlives =
          getValue(maps["addAutomaticKeepAlives"], datas, "bool", vars, props);
      final addRepaintBoundaries =
          getValue(maps["addRepaintBoundaries"], datas, "bool", vars, props);
      final addSemanticIndexes =
          getValue(maps["addSemanticIndexes"], datas, "bool", vars, props);
      if (itemBuilder == null || prototypeItem == null) {
        return null;
      }
      return SliverPrototypeExtentList.builder(
          key: key,
          itemBuilder: itemBuilder!,
          prototypeItem: prototypeItem!,
          findChildIndexCallback: findChildIndexCallback,
          itemCount: itemCount,
          addAutomaticKeepAlives: addAutomaticKeepAlives ?? true,
          addRepaintBoundaries: addRepaintBoundaries ?? true,
          addSemanticIndexes: addSemanticIndexes ?? true);
    },
    "SliverPrototypeExtentList.list": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final children =
          getValue(maps["children"], datas, "List<Widget>", vars, props);
      final prototypeItem =
          getValue(maps["prototypeItem"], datas, "Widget", vars, props);
      final addAutomaticKeepAlives =
          getValue(maps["addAutomaticKeepAlives"], datas, "bool", vars, props);
      final addRepaintBoundaries =
          getValue(maps["addRepaintBoundaries"], datas, "bool", vars, props);
      final addSemanticIndexes =
          getValue(maps["addSemanticIndexes"], datas, "bool", vars, props);
      if (children == null || prototypeItem == null) {
        return null;
      }
      return SliverPrototypeExtentList.list(
          key: key,
          prototypeItem: prototypeItem!,
          addAutomaticKeepAlives: addAutomaticKeepAlives ?? true,
          addRepaintBoundaries: addRepaintBoundaries ?? true,
          addSemanticIndexes: addSemanticIndexes ?? true,
          children: List<Widget>.from(children!));
    },
    "SliverReorderableList": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final itemBuilder = getValue(
          maps["itemBuilder"], datas, "IndexedWidgetBuilder", vars, props);
      final findChildIndexCallback = getValue(maps["findChildIndexCallback"],
          datas, "ChildIndexGetter?", vars, props);
      final itemCount = getValue(maps["itemCount"], datas, "int", vars, props);
      final onReorder =
          getValue(maps["onReorder"], datas, "ReorderCallback", vars, props);
      final onReorderStart =
          getValue(maps["onReorderStart"], datas, "", vars, props);
      final onReorderEnd =
          getValue(maps["onReorderEnd"], datas, "", vars, props);
      final itemExtent =
          getValue(maps["itemExtent"], datas, "double?", vars, props);
      final prototypeItem =
          getValue(maps["prototypeItem"], datas, "Widget?", vars, props);
      final proxyDecorator = getValue(maps["proxyDecorator"], datas,
          "ReorderItemProxyDecorator?", vars, props);
      if (itemBuilder == null || itemCount == null || onReorder == null) {
        return null;
      }
      return SliverReorderableList(
          key: key,
          itemBuilder: itemBuilder!,
          findChildIndexCallback: findChildIndexCallback,
          itemCount: itemCount!,
          onReorder: onReorder!,
          onReorderStart: onReorderStart,
          onReorderEnd: onReorderEnd,
          itemExtent: itemExtent,
          prototypeItem: prototypeItem,
          proxyDecorator: proxyDecorator);
    },
    "SliverSafeArea": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final left = getValue(maps["left"], datas, "bool", vars, props);
      final top = getValue(maps["top"], datas, "bool", vars, props);
      final right = getValue(maps["right"], datas, "bool", vars, props);
      final bottom = getValue(maps["bottom"], datas, "bool", vars, props);
      final minimum =
          getValue(maps["minimum"], datas, "EdgeInsets", vars, props);
      final sliver = getValue(maps["sliver"], datas, "Widget", vars, props);
      if (sliver == null) {
        return null;
      }
      return SliverSafeArea(
          key: key,
          left: left ?? true,
          top: top ?? true,
          right: right ?? true,
          bottom: bottom ?? true,
          minimum: minimum ?? EdgeInsets.zero,
          sliver: sliver!);
    },
    "SliverToBoxAdapter": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      return SliverToBoxAdapter(key: key, child: child);
    },
    "SliverVisibility": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final sliver = getValue(maps["sliver"], datas, "Widget", vars, props);
      final replacementSliver =
          getValue(maps["replacementSliver"], datas, "Widget", vars, props);
      final visible = getValue(maps["visible"], datas, "bool", vars, props);
      final maintainState =
          getValue(maps["maintainState"], datas, "bool", vars, props);
      final maintainAnimation =
          getValue(maps["maintainAnimation"], datas, "bool", vars, props);
      final maintainSize =
          getValue(maps["maintainSize"], datas, "bool", vars, props);
      final maintainSemantics =
          getValue(maps["maintainSemantics"], datas, "bool", vars, props);
      final maintainInteractivity =
          getValue(maps["maintainInteractivity"], datas, "bool", vars, props);
      if (sliver == null) {
        return null;
      }
      return SliverVisibility(
          key: key,
          sliver: sliver!,
          replacementSliver: replacementSliver ?? const SliverToBoxAdapter(),
          visible: visible ?? true,
          maintainState: maintainState ?? false,
          maintainAnimation: maintainAnimation ?? false,
          maintainSize: maintainSize ?? false,
          maintainSemantics: maintainSemantics ?? false,
          maintainInteractivity: maintainInteractivity ?? false);
    },
    "SliverVisibility.maintain": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final sliver = getValue(maps["sliver"], datas, "Widget", vars, props);
      final replacementSliver =
          getValue(maps["replacementSliver"], datas, "Widget", vars, props);
      final visible = getValue(maps["visible"], datas, "bool", vars, props);
      if (sliver == null) {
        return null;
      }
      return SliverVisibility.maintain(
          key: key,
          sliver: sliver!,
          replacementSliver: replacementSliver ?? const SliverToBoxAdapter(),
          visible: visible ?? true);
    },
    "SlottedRenderObjectElement": () {
      final widget = getValue(maps["0"], datas,
          "SlottedMultiChildRenderObjectWidgetMixin<S>", vars, props);
      if (widget == null) {
        return null;
      }
      return SlottedRenderObjectElement(widget!);
    },
    "SnackBar": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final content = getValue(maps["content"], datas, "", vars, props);
      final backgroundColor =
          getValue(maps["backgroundColor"], datas, "", vars, props);
      final elevation = getValue(maps["elevation"], datas, "", vars, props);
      final margin = getValue(maps["margin"], datas, "", vars, props);
      final padding = getValue(maps["padding"], datas, "", vars, props);
      final width = getValue(maps["width"], datas, "", vars, props);
      final shape = getValue(maps["shape"], datas, "", vars, props);
      final behavior = getValue(maps["behavior"], datas, "", vars, props);
      final action = getValue(maps["action"], datas, "", vars, props);
      final actionOverflowThreshold =
          getValue(maps["actionOverflowThreshold"], datas, "", vars, props);
      final showCloseIcon =
          getValue(maps["showCloseIcon"], datas, "", vars, props);
      final closeIconColor =
          getValue(maps["closeIconColor"], datas, "", vars, props);
      final duration = getValue(maps["duration"], datas, "", vars, props);
      final animation = getValue(maps["animation"], datas, "", vars, props);
      final onVisible = getValue(maps["onVisible"], datas, "", vars, props);
      final dismissDirection =
          getValue(maps["dismissDirection"], datas, "", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "", vars, props);
      if (content == null) {
        return null;
      }
      if (duration != null) {
        return SnackBar(
            key: key,
            content: content!,
            backgroundColor: backgroundColor,
            elevation: elevation,
            margin: margin,
            padding: padding,
            width: width,
            shape: shape,
            behavior: behavior,
            action: action,
            actionOverflowThreshold: actionOverflowThreshold,
            showCloseIcon: showCloseIcon,
            closeIconColor: closeIconColor,
            animation: animation,
            onVisible: onVisible,
            dismissDirection: dismissDirection ?? DismissDirection.down,
            clipBehavior: clipBehavior ?? Clip.hardEdge,
            duration: duration);
      }
      return SnackBar(
          key: key,
          content: content!,
          backgroundColor: backgroundColor,
          elevation: elevation,
          margin: margin,
          padding: padding,
          width: width,
          shape: shape,
          behavior: behavior,
          action: action,
          actionOverflowThreshold: actionOverflowThreshold,
          showCloseIcon: showCloseIcon,
          closeIconColor: closeIconColor,
          animation: animation,
          onVisible: onVisible,
          dismissDirection: dismissDirection ?? DismissDirection.down,
          clipBehavior: clipBehavior ?? Clip.hardEdge);
    },
    "SnackBarAction": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final textColor = getValue(maps["textColor"], datas, "", vars, props);
      final disabledTextColor =
          getValue(maps["disabledTextColor"], datas, "", vars, props);
      final backgroundColor =
          getValue(maps["backgroundColor"], datas, "", vars, props);
      final disabledBackgroundColor =
          getValue(maps["disabledBackgroundColor"], datas, "", vars, props);
      final label = getValue(maps["label"], datas, "", vars, props);
      final onPressed = getValue(maps["onPressed"], datas, "", vars, props);
      if (label == null || onPressed == null) {
        return null;
      }
      return SnackBarAction(
          key: key,
          textColor: textColor,
          disabledTextColor: disabledTextColor,
          backgroundColor: backgroundColor,
          disabledBackgroundColor: disabledBackgroundColor,
          label: label!,
          onPressed: onPressed!);
    },
    "SnackBarThemeData": () {
      final backgroundColor =
          getValue(maps["backgroundColor"], datas, "", vars, props);
      final actionTextColor =
          getValue(maps["actionTextColor"], datas, "", vars, props);
      final disabledActionTextColor =
          getValue(maps["disabledActionTextColor"], datas, "", vars, props);
      final contentTextStyle =
          getValue(maps["contentTextStyle"], datas, "", vars, props);
      final elevation = getValue(maps["elevation"], datas, "", vars, props);
      final shape = getValue(maps["shape"], datas, "", vars, props);
      final behavior = getValue(maps["behavior"], datas, "", vars, props);
      final width = getValue(maps["width"], datas, "", vars, props);
      final insetPadding =
          getValue(maps["insetPadding"], datas, "", vars, props);
      final showCloseIcon =
          getValue(maps["showCloseIcon"], datas, "", vars, props);
      final closeIconColor =
          getValue(maps["closeIconColor"], datas, "", vars, props);
      final actionOverflowThreshold =
          getValue(maps["actionOverflowThreshold"], datas, "", vars, props);
      final actionBackgroundColor =
          getValue(maps["actionBackgroundColor"], datas, "", vars, props);
      final disabledActionBackgroundColor = getValue(
          maps["disabledActionBackgroundColor"], datas, "", vars, props);
      return SnackBarThemeData(
          backgroundColor: backgroundColor,
          actionTextColor: actionTextColor,
          disabledActionTextColor: disabledActionTextColor,
          contentTextStyle: contentTextStyle,
          elevation: elevation,
          shape: shape,
          behavior: behavior,
          width: width,
          insetPadding: insetPadding,
          showCloseIcon: showCloseIcon,
          closeIconColor: closeIconColor,
          actionOverflowThreshold: actionOverflowThreshold,
          actionBackgroundColor: actionBackgroundColor,
          disabledActionBackgroundColor: disabledActionBackgroundColor);
    },
    "SnapshotController": () {
      final allowSnapshotting =
          getValue(maps["allowSnapshotting"], datas, "bool", vars, props);
      return SnapshotController(allowSnapshotting: allowSnapshotting ?? false);
    },
    "SnapshotWidget": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final mode = getValue(maps["mode"], datas, "SnapshotMode", vars, props);
      final painter =
          getValue(maps["painter"], datas, "SnapshotPainter", vars, props);
      final autoresize =
          getValue(maps["autoresize"], datas, "bool", vars, props);
      final controller = getValue(
          maps["controller"], datas, "SnapshotController", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      if (controller == null || child == null) {
        return null;
      }
      return SnapshotWidget(
          key: key,
          mode: mode ?? SnapshotMode.normal,
          painter: painter ?? const _DefaultSnapshotPainter(),
          autoresize: autoresize ?? false,
          controller: controller!,
          child: child!);
    },
    "Spacer": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final flex = getValue(maps["flex"], datas, "int", vars, props);
      return Spacer(key: key, flex: flex ?? 1);
    },
    "SpellCheckConfiguration": () {
      final spellCheckService = getValue(
          maps["spellCheckService"], datas, "SpellCheckService?", vars, props);
      final misspelledSelectionColor = getValue(
          maps["misspelledSelectionColor"], datas, "Color?", vars, props);
      final misspelledTextStyle = getValue(
          maps["misspelledTextStyle"], datas, "TextStyle?", vars, props);
      final spellCheckSuggestionsToolbarBuilder = getValue(
          maps["spellCheckSuggestionsToolbarBuilder"],
          datas,
          "EditableTextContextMenuBuilder?",
          vars,
          props);
      return SpellCheckConfiguration(
          spellCheckService: spellCheckService,
          misspelledSelectionColor: misspelledSelectionColor,
          misspelledTextStyle: misspelledTextStyle,
          spellCheckSuggestionsToolbarBuilder:
              spellCheckSuggestionsToolbarBuilder);
    },
    "SpellCheckConfiguration.disabled": () {
      return const SpellCheckConfiguration.disabled();
    },
    "SpellCheckResults": () {
      final spellCheckedText =
          getValue(maps["0"], datas, "String", vars, props);
      final suggestionSpans =
          getValue(maps["1"], datas, "List<SuggestionSpan>", vars, props);
      if (spellCheckedText == null || suggestionSpans == null) {
        return null;
      }
      return SpellCheckResults(
          spellCheckedText!, List<SuggestionSpan>.from(suggestionSpans!));
    },
    "SpellCheckSuggestionsToolbar": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final anchor = getValue(maps["anchor"], datas, "Offset", vars, props);
      final buttonItems = getValue(maps["buttonItems"], datas,
          "List<ContextMenuButtonItem>", vars, props);
      if (anchor == null || buttonItems == null) {
        return null;
      }
      return SpellCheckSuggestionsToolbar(
          key: key,
          anchor: anchor!,
          buttonItems: List<ContextMenuButtonItem>.from(buttonItems!));
    },
    "SpellCheckSuggestionsToolbar.editableText": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final editableTextState = getValue(
          maps["editableTextState"], datas, "EditableTextState", vars, props);
      if (editableTextState == null) {
        return null;
      }
      return SpellCheckSuggestionsToolbar.editableText(
          key: key, editableTextState: editableTextState!);
    },
    "SpellCheckSuggestionsToolbarLayoutDelegate": () {
      final anchor = getValue(maps["anchor"], datas, "Offset", vars, props);
      if (anchor == null) {
        return null;
      }
      return SpellCheckSuggestionsToolbarLayoutDelegate(anchor: anchor!);
    },
    "SpellOutStringAttribute": () {
      final range = getValue(maps["range"], datas, "TextRange", vars, props);
      if (range == null) {
        return null;
      }
      return SpellOutStringAttribute(range: range!);
    },
    "SpringDescription": () {
      final mass = getValue(maps["mass"], datas, "double", vars, props);
      final stiffness =
          getValue(maps["stiffness"], datas, "double", vars, props);
      final damping = getValue(maps["damping"], datas, "double", vars, props);
      if (mass == null || stiffness == null || damping == null) {
        return null;
      }
      return SpringDescription(
          mass: mass!, stiffness: stiffness!, damping: damping!);
    },
    "SpringDescription.withDampingRatio": () {
      final mass = getValue(maps["mass"], datas, "double", vars, props);
      final stiffness =
          getValue(maps["stiffness"], datas, "double", vars, props);
      final ratio = getValue(maps["ratio"], datas, "double", vars, props);
      if (mass == null || stiffness == null) {
        return null;
      }
      return SpringDescription.withDampingRatio(
          mass: mass!, stiffness: stiffness!, ratio: ratio ?? 1.0);
    },
    "Stack": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final alignment =
          getValue(maps["alignment"], datas, "AlignmentGeometry", vars, props);
      final textDirection =
          getValue(maps["textDirection"], datas, "TextDirection?", vars, props);
      final fit = getValue(maps["fit"], datas, "StackFit", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      final children =
          getValue(maps["children"], datas, "List<Widget>", vars, props);
      return Stack(
          key: key,
          alignment: alignment ?? AlignmentDirectional.topStart,
          textDirection: textDirection,
          fit: fit ?? StackFit.loose,
          clipBehavior: clipBehavior ?? Clip.hardEdge,
          children: List<Widget>.from(children ?? const <Widget>[]));
    },
    "StackFrame": () {
      final number = getValue(maps["number"], datas, "", vars, props);
      final column = getValue(maps["column"], datas, "", vars, props);
      final line = getValue(maps["line"], datas, "", vars, props);
      final packageScheme =
          getValue(maps["packageScheme"], datas, "", vars, props);
      final package = getValue(maps["package"], datas, "", vars, props);
      final packagePath = getValue(maps["packagePath"], datas, "", vars, props);
      final className = getValue(maps["className"], datas, "", vars, props);
      final method = getValue(maps["method"], datas, "", vars, props);
      final isConstructor =
          getValue(maps["isConstructor"], datas, "", vars, props);
      final source = getValue(maps["source"], datas, "", vars, props);
      if (number == null ||
          column == null ||
          line == null ||
          packageScheme == null ||
          package == null ||
          packagePath == null ||
          method == null ||
          source == null) {
        return null;
      }
      return StackFrame(
          number: number!,
          column: column!,
          line: line!,
          packageScheme: packageScheme!,
          package: package!,
          packagePath: packagePath!,
          className: className ?? '',
          method: method!,
          isConstructor: isConstructor ?? false,
          source: source!);
    },
    "StackOverflowError": () {
      return const StackOverflowError();
    },
    "StadiumBorder": () {
      final side = getValue(maps["side"], datas, "", vars, props);
      return StadiumBorder(side: side);
    },
    "StandardMessageCodec": () {
      return const StandardMessageCodec();
    },
    "StandardMethodCodec": () {
      final messageCodec =
          getValue(maps["0"], datas, "StandardMessageCodec", vars, props);
      return StandardMethodCodec(messageCodec ?? const StandardMessageCodec());
    },
    "StarBorder": () {
      final side = getValue(maps["side"], datas, "", vars, props);
      final points = getValue(maps["points"], datas, "", vars, props);
      final innerRadiusRatio =
          getValue(maps["innerRadiusRatio"], datas, "double", vars, props);
      final pointRounding =
          getValue(maps["pointRounding"], datas, "", vars, props);
      final valleyRounding =
          getValue(maps["valleyRounding"], datas, "", vars, props);
      final rotation = getValue(maps["rotation"], datas, "double", vars, props);
      final squash = getValue(maps["squash"], datas, "", vars, props);
      return StarBorder(
          side: side,
          points: points ?? 5,
          innerRadiusRatio: innerRadiusRatio ?? 0.4,
          pointRounding: pointRounding ?? 0,
          valleyRounding: valleyRounding ?? 0,
          rotation: rotation ?? 0,
          squash: squash ?? 0);
    },
    "StateError": () {
      final message = getValue(maps["0"], datas, "String", vars, props);
      if (message == null) {
        return null;
      }
      return StateError(message!);
    },
    "StatefulBuilder": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final builder = getValue(
          maps["builder"], datas, "StatefulWidgetBuilder", vars, props);
      if (builder == null) {
        return null;
      }
      return StatefulBuilder(key: key, builder: builder!);
    },
    "Step": () {
      final title = getValue(maps["title"], datas, "Widget", vars, props);
      final subtitle =
          getValue(maps["subtitle"], datas, "Widget?", vars, props);
      final content = getValue(maps["content"], datas, "Widget", vars, props);
      final state = getValue(maps["state"], datas, "StepState", vars, props);
      final isActive = getValue(maps["isActive"], datas, "bool", vars, props);
      final label = getValue(maps["label"], datas, "Widget?", vars, props);
      if (title == null || content == null) {
        return null;
      }
      return Step(
          title: title!,
          subtitle: subtitle,
          content: content!,
          state: state ?? StepState.indexed,
          isActive: isActive ?? false,
          label: label);
    },
    "StepTween": () {
      final begin = getValue(maps["begin"], datas, "T?", vars, props);
      final end = getValue(maps["end"], datas, "T?", vars, props);
      return StepTween(begin: begin, end: end);
    },
    "Stepper": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final steps = getValue(maps["steps"], datas, "List<Step>", vars, props);
      final physics =
          getValue(maps["physics"], datas, "ScrollPhysics?", vars, props);
      final type = getValue(maps["type"], datas, "StepperType", vars, props);
      final currentStep =
          getValue(maps["currentStep"], datas, "int", vars, props);
      final onStepTapped = getValue(
          maps["onStepTapped"], datas, "ValueChanged<int>?", vars, props);
      final onStepContinue =
          getValue(maps["onStepContinue"], datas, "VoidCallback?", vars, props);
      final onStepCancel =
          getValue(maps["onStepCancel"], datas, "VoidCallback?", vars, props);
      final controlsBuilder = getValue(maps["controlsBuilder"], datas,
          "ControlsWidgetBuilder?", vars, props);
      final elevation =
          getValue(maps["elevation"], datas, "double?", vars, props);
      final margin =
          getValue(maps["margin"], datas, "EdgeInsetsGeometry?", vars, props);
      final stepIconBuilder = getValue(
          maps["stepIconBuilder"], datas, "StepIconBuilder?", vars, props);
      if (steps == null) {
        return null;
      }
      return Stepper(
          key: key,
          steps: List<Step>.from(steps!),
          physics: physics,
          type: type ?? StepperType.vertical,
          currentStep: currentStep ?? 0,
          onStepTapped: onStepTapped,
          onStepContinue: onStepContinue,
          onStepCancel: onStepCancel,
          controlsBuilder: controlsBuilder,
          elevation: elevation,
          margin: margin,
          stepIconBuilder: stepIconBuilder);
    },
    "Stopwatch": () {
      return Stopwatch();
    },
    "StreamBuilder": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final initialData =
          getValue(maps["initialData"], datas, "T?", vars, props);
      final stream = getValue(maps["stream"], datas, "Stream<T>?", vars, props);
      final builder = getValue(
          maps["builder"], datas, "AsyncWidgetBuilder<T>", vars, props);
      if (builder == null) {
        return null;
      }
      return StreamBuilder(
          key: key,
          initialData: initialData,
          stream: stream,
          builder: builder!);
    },
    "StretchingOverscrollIndicator": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final axisDirection =
          getValue(maps["axisDirection"], datas, "AxisDirection", vars, props);
      final notificationPredicate = getValue(maps["notificationPredicate"],
          datas, "ScrollNotificationPredicate", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      if (axisDirection == null) {
        return null;
      }
      return StretchingOverscrollIndicator(
          key: key,
          axisDirection: axisDirection!,
          notificationPredicate:
              notificationPredicate ?? defaultScrollNotificationPredicate,
          clipBehavior: clipBehavior ?? Clip.hardEdge,
          child: child);
    },
    "String.fromCharCodes": () {
      final charCodes =
          getValue(maps["0"], datas, "Iterable<int>", vars, props);
      final start = getValue(maps["1"], datas, "int", vars, props);
      final end = getValue(maps["2"], datas, "int?", vars, props);
      if (charCodes == null) {
        return null;
      }
      return String.fromCharCodes(charCodes!, start ?? 0, end);
    },
    "String.fromCharCode": () {
      final charCode = getValue(maps["0"], datas, "int", vars, props);
      if (charCode == null) {
        return null;
      }
      return String.fromCharCode(charCode!);
    },
    "String.fromEnvironment": () {
      final name = getValue(maps["0"], datas, "String", vars, props);
      final defaultValue =
          getValue(maps["defaultValue"], datas, "String", vars, props);
      if (name == null) {
        return null;
      }
      return String.fromEnvironment(name!, defaultValue: defaultValue ?? "");
    },
    "StringBuffer": () {
      final content = getValue(maps["0"], datas, "Object", vars, props);
      return StringBuffer(content ?? "");
    },
    "StringCodec": () {
      return const StringCodec();
    },
    "StringProperty": () {
      final name = getValue(maps["0"], datas, "String", vars, props);
      final value = getValue(maps["1"], datas, "T?", vars, props);
      final description =
          getValue(maps["description"], datas, "String?", vars, props);
      final tooltip = getValue(maps["tooltip"], datas, "String?", vars, props);
      final showName = getValue(maps["showName"], datas, "", vars, props);
      final defaultValue =
          getValue(maps["defaultValue"], datas, "Object?", vars, props);
      final quoted = getValue(maps["quoted"], datas, "bool", vars, props);
      final ifEmpty = getValue(maps["ifEmpty"], datas, "String?", vars, props);
      final style =
          getValue(maps["style"], datas, "DiagnosticsTreeStyle", vars, props);
      final level =
          getValue(maps["level"], datas, "DiagnosticLevel", vars, props);
      if (name == null || value == null) {
        return null;
      }
      if (defaultValue != null) {
        return StringProperty(name!, value!,
            description: description,
            tooltip: tooltip,
            showName: showName,
            quoted: quoted ?? true,
            ifEmpty: ifEmpty,
            style: style ?? DiagnosticsTreeStyle.singleLine,
            level: level ?? DiagnosticLevel.info,
            defaultValue: defaultValue);
      }
      return StringProperty(name!, value!,
          description: description,
          tooltip: tooltip,
          showName: showName,
          quoted: quoted ?? true,
          ifEmpty: ifEmpty,
          style: style ?? DiagnosticsTreeStyle.singleLine,
          level: level ?? DiagnosticLevel.info);
    },
    "StrutStyle": () {
      final fontFamily =
          getValue(maps["fontFamily"], datas, "String?", vars, props);
      final fontFamilyFallback = getValue(
          maps["fontFamilyFallback"], datas, "List<String>?", vars, props);
      final fontSize =
          getValue(maps["fontSize"], datas, "double?", vars, props);
      final height = getValue(maps["height"], datas, "double?", vars, props);
      final leadingDistribution = getValue(maps["leadingDistribution"], datas,
          "TextLeadingDistribution?", vars, props);
      final leading = getValue(maps["leading"], datas, "double?", vars, props);
      final fontWeight =
          getValue(maps["fontWeight"], datas, "FontWeight?", vars, props);
      final fontStyle =
          getValue(maps["fontStyle"], datas, "FontStyle?", vars, props);
      final forceStrutHeight =
          getValue(maps["forceStrutHeight"], datas, "bool?", vars, props);
      return StrutStyle(
          fontFamily: fontFamily,
          fontFamilyFallback: fontFamilyFallback != null
              ? List<String>.from(fontFamilyFallback)
              : null,
          fontSize: fontSize,
          height: height,
          leadingDistribution: leadingDistribution,
          leading: leading,
          fontWeight: fontWeight,
          fontStyle: fontStyle,
          forceStrutHeight: forceStrutHeight);
    },
    "StrutStyle": () {
      final fontFamily =
          getValue(maps["fontFamily"], datas, "String?", vars, props);
      final fontFamilyFallback = getValue(
          maps["fontFamilyFallback"], datas, "List<String>?", vars, props);
      final fontSize =
          getValue(maps["fontSize"], datas, "double?", vars, props);
      final height = getValue(maps["height"], datas, "double?", vars, props);
      final leadingDistribution = getValue(maps["leadingDistribution"], datas,
          "TextLeadingDistribution?", vars, props);
      final leading = getValue(maps["leading"], datas, "double?", vars, props);
      final fontWeight =
          getValue(maps["fontWeight"], datas, "FontWeight?", vars, props);
      final fontStyle =
          getValue(maps["fontStyle"], datas, "FontStyle?", vars, props);
      final forceStrutHeight =
          getValue(maps["forceStrutHeight"], datas, "bool?", vars, props);
      return StrutStyle(
          fontFamily: fontFamily,
          fontFamilyFallback: fontFamilyFallback != null
              ? List<String>.from(fontFamilyFallback)
              : null,
          fontSize: fontSize,
          height: height,
          leadingDistribution: leadingDistribution,
          leading: leading,
          fontWeight: fontWeight,
          fontStyle: fontStyle,
          forceStrutHeight: forceStrutHeight);
    },
    "StrutStyle.fromTextStyle": () {
      final textStyle = getValue(maps["0"], datas, "TextStyle", vars, props);
      if (textStyle == null) {
        return null;
      }
      final fontFamily =
          getValue(maps["fontFamily"], datas, "String?", vars, props);
      final fontFamilyFallback = getValue(
          maps["fontFamilyFallback"], datas, "List<String>?", vars, props);
      final fontSize =
          getValue(maps["fontSize"], datas, "double?", vars, props);
      final height = getValue(maps["height"], datas, "double?", vars, props);
      final leadingDistribution = getValue(maps["leadingDistribution"], datas,
          "TextLeadingDistribution?", vars, props);
      final leading = getValue(maps["leading"], datas, "double?", vars, props);
      final fontWeight =
          getValue(maps["fontWeight"], datas, "FontWeight?", vars, props);
      final fontStyle =
          getValue(maps["fontStyle"], datas, "FontStyle?", vars, props);
      final forceStrutHeight =
          getValue(maps["forceStrutHeight"], datas, "bool?", vars, props);
      final debugLabel =
          getValue(maps["debugLabel"], datas, "String?", vars, props);
      final package = getValue(maps["package"], datas, "String?", vars, props);
      return StrutStyle.fromTextStyle(textStyle,
          fontFamily: fontFamily,
          fontFamilyFallback: fontFamilyFallback,
          fontSize: fontSize,
          height: height,
          leadingDistribution: leadingDistribution,
          leading: leading,
          fontWeight: fontWeight,
          fontStyle: fontStyle,
          forceStrutHeight: forceStrutHeight,
          debugLabel: debugLabel,
          package: package);
    },
    "SubmenuButton": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final onHover =
          getValue(maps["onHover"], datas, "ValueChanged<bool>?", vars, props);
      final onFocusChange = getValue(
          maps["onFocusChange"], datas, "ValueChanged<bool>?", vars, props);
      final onOpen =
          getValue(maps["onOpen"], datas, "VoidCallback?", vars, props);
      final onClose =
          getValue(maps["onClose"], datas, "VoidCallback?", vars, props);
      final style = getValue(maps["style"], datas, "ButtonStyle?", vars, props);
      final menuStyle =
          getValue(maps["menuStyle"], datas, "MenuStyle?", vars, props);
      final alignmentOffset =
          getValue(maps["alignmentOffset"], datas, "Offset?", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      final focusNode =
          getValue(maps["focusNode"], datas, "FocusNode?", vars, props);
      final statesController = getValue(maps["statesController"], datas,
          "MaterialStatesController?", vars, props);
      final leadingIcon =
          getValue(maps["leadingIcon"], datas, "Widget?", vars, props);
      final trailingIcon =
          getValue(maps["trailingIcon"], datas, "Widget?", vars, props);
      final menuChildren =
          getValue(maps["menuChildren"], datas, "List<Widget>", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      if (menuChildren == null || child == null) {
        return null;
      }
      return SubmenuButton(
          key: key,
          onHover: onHover,
          onFocusChange: onFocusChange,
          onOpen: onOpen,
          onClose: onClose,
          style: style,
          menuStyle: menuStyle,
          alignmentOffset: alignmentOffset,
          clipBehavior: clipBehavior ?? Clip.hardEdge,
          focusNode: focusNode,
          statesController: statesController,
          leadingIcon: leadingIcon,
          trailingIcon: trailingIcon,
          menuChildren: List<Widget>.from(menuChildren!),
          child: child!);
    },
    "SuggestionSpan": () {
      final range = getValue(maps["0"], datas, "TextRange", vars, props);
      final suggestions =
          getValue(maps["1"], datas, "List<String>", vars, props);
      if (range == null || suggestions == null) {
        return null;
      }
      return SuggestionSpan(range!, List<String>.from(suggestions!));
    },
    "Summary": () {
      final text = getValue(maps["0"], datas, "String", vars, props);
      if (text == null) {
        return null;
      }
      return Summary(text!);
    },
    "SweepGradient": () {
      final center =
          getValue(maps["center"], datas, "AlignmentGeometry", vars, props);
      final startAngle =
          getValue(maps["startAngle"], datas, "double", vars, props);
      final endAngle = getValue(maps["endAngle"], datas, "double", vars, props);
      final colors = getValue(maps["colors"], datas, "", vars, props);
      final stops = getValue(maps["stops"], datas, "", vars, props);
      final tileMode =
          getValue(maps["tileMode"], datas, "TileMode", vars, props);
      final transform = getValue(maps["transform"], datas, "", vars, props);
      if (colors == null) {
        return null;
      }
      return SweepGradient(
          center: center ?? Alignment.center,
          startAngle: startAngle ?? 0.0,
          endAngle: endAngle ?? math.pi * 2,
          colors: colors!,
          stops: stops,
          tileMode: tileMode ?? TileMode.clamp,
          transform: transform);
    },
    "Switch": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final value = getValue(maps["value"], datas, "bool", vars, props);
      final onChanged = getValue(
          maps["onChanged"], datas, "ValueChanged<bool>?", vars, props);
      final activeColor =
          getValue(maps["activeColor"], datas, "Color?", vars, props);
      final activeTrackColor =
          getValue(maps["activeTrackColor"], datas, "Color?", vars, props);
      final inactiveThumbColor =
          getValue(maps["inactiveThumbColor"], datas, "Color?", vars, props);
      final inactiveTrackColor =
          getValue(maps["inactiveTrackColor"], datas, "Color?", vars, props);
      final activeThumbImage = getValue(
          maps["activeThumbImage"], datas, "ImageProvider?", vars, props);
      final onActiveThumbImageError = getValue(maps["onActiveThumbImageError"],
          datas, "ImageErrorListener?", vars, props);
      final inactiveThumbImage = getValue(
          maps["inactiveThumbImage"], datas, "ImageProvider?", vars, props);
      final onInactiveThumbImageError = getValue(
          maps["onInactiveThumbImageError"],
          datas,
          "ImageErrorListener?",
          vars,
          props);
      final thumbColor = getValue(maps["thumbColor"], datas,
          "MaterialStateProperty<Color?>?", vars, props);
      final trackColor = getValue(maps["trackColor"], datas,
          "MaterialStateProperty<Color?>?", vars, props);
      final trackOutlineColor = getValue(maps["trackOutlineColor"], datas,
          "MaterialStateProperty<Color?>?", vars, props);
      final thumbIcon = getValue(maps["thumbIcon"], datas,
          "MaterialStateProperty<Icon?>?", vars, props);
      final materialTapTargetSize = getValue(maps["materialTapTargetSize"],
          datas, "MaterialTapTargetSize?", vars, props);
      final dragStartBehavior = getValue(
          maps["dragStartBehavior"], datas, "DragStartBehavior", vars, props);
      final mouseCursor =
          getValue(maps["mouseCursor"], datas, "MouseCursor?", vars, props);
      final focusColor =
          getValue(maps["focusColor"], datas, "Color?", vars, props);
      final hoverColor =
          getValue(maps["hoverColor"], datas, "Color?", vars, props);
      final overlayColor = getValue(maps["overlayColor"], datas,
          "MaterialStateProperty<Color?>?", vars, props);
      final splashRadius =
          getValue(maps["splashRadius"], datas, "double?", vars, props);
      final focusNode =
          getValue(maps["focusNode"], datas, "FocusNode?", vars, props);
      final onFocusChange = getValue(
          maps["onFocusChange"], datas, "ValueChanged<bool>?", vars, props);
      final autofocus = getValue(maps["autofocus"], datas, "bool", vars, props);
      if (value == null || onChanged == null) {
        return null;
      }
      return Switch(
          key: key,
          value: value!,
          onChanged: onChanged!,
          activeColor: activeColor,
          activeTrackColor: activeTrackColor,
          inactiveThumbColor: inactiveThumbColor,
          inactiveTrackColor: inactiveTrackColor,
          activeThumbImage: activeThumbImage,
          onActiveThumbImageError: onActiveThumbImageError,
          inactiveThumbImage: inactiveThumbImage,
          onInactiveThumbImageError: onInactiveThumbImageError,
          thumbColor: thumbColor,
          trackColor: trackColor,
          trackOutlineColor: trackOutlineColor,
          thumbIcon: thumbIcon,
          materialTapTargetSize: materialTapTargetSize,
          dragStartBehavior: dragStartBehavior ?? DragStartBehavior.start,
          mouseCursor: mouseCursor,
          focusColor: focusColor,
          hoverColor: hoverColor,
          overlayColor: overlayColor,
          splashRadius: splashRadius,
          focusNode: focusNode,
          onFocusChange: onFocusChange,
          autofocus: autofocus ?? false);
    },
    "Switch.adaptive": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final value = getValue(maps["value"], datas, "bool", vars, props);
      final onChanged = getValue(
          maps["onChanged"], datas, "ValueChanged<bool>?", vars, props);
      final activeColor =
          getValue(maps["activeColor"], datas, "Color?", vars, props);
      final activeTrackColor =
          getValue(maps["activeTrackColor"], datas, "Color?", vars, props);
      final inactiveThumbColor =
          getValue(maps["inactiveThumbColor"], datas, "Color?", vars, props);
      final inactiveTrackColor =
          getValue(maps["inactiveTrackColor"], datas, "Color?", vars, props);
      final activeThumbImage = getValue(
          maps["activeThumbImage"], datas, "ImageProvider?", vars, props);
      final onActiveThumbImageError = getValue(maps["onActiveThumbImageError"],
          datas, "ImageErrorListener?", vars, props);
      final inactiveThumbImage = getValue(
          maps["inactiveThumbImage"], datas, "ImageProvider?", vars, props);
      final onInactiveThumbImageError = getValue(
          maps["onInactiveThumbImageError"],
          datas,
          "ImageErrorListener?",
          vars,
          props);
      final materialTapTargetSize = getValue(maps["materialTapTargetSize"],
          datas, "MaterialTapTargetSize?", vars, props);
      final thumbColor = getValue(maps["thumbColor"], datas,
          "MaterialStateProperty<Color?>?", vars, props);
      final trackColor = getValue(maps["trackColor"], datas,
          "MaterialStateProperty<Color?>?", vars, props);
      final trackOutlineColor = getValue(maps["trackOutlineColor"], datas,
          "MaterialStateProperty<Color?>?", vars, props);
      final thumbIcon = getValue(maps["thumbIcon"], datas,
          "MaterialStateProperty<Icon?>?", vars, props);
      final dragStartBehavior = getValue(
          maps["dragStartBehavior"], datas, "DragStartBehavior", vars, props);
      final mouseCursor =
          getValue(maps["mouseCursor"], datas, "MouseCursor?", vars, props);
      final focusColor =
          getValue(maps["focusColor"], datas, "Color?", vars, props);
      final hoverColor =
          getValue(maps["hoverColor"], datas, "Color?", vars, props);
      final overlayColor = getValue(maps["overlayColor"], datas,
          "MaterialStateProperty<Color?>?", vars, props);
      final splashRadius =
          getValue(maps["splashRadius"], datas, "double?", vars, props);
      final focusNode =
          getValue(maps["focusNode"], datas, "FocusNode?", vars, props);
      final onFocusChange = getValue(
          maps["onFocusChange"], datas, "ValueChanged<bool>?", vars, props);
      final autofocus = getValue(maps["autofocus"], datas, "bool", vars, props);
      final applyCupertinoTheme =
          getValue(maps["applyCupertinoTheme"], datas, "bool?", vars, props);
      if (value == null || onChanged == null) {
        return null;
      }
      return Switch.adaptive(
          key: key,
          value: value!,
          onChanged: onChanged!,
          activeColor: activeColor,
          activeTrackColor: activeTrackColor,
          inactiveThumbColor: inactiveThumbColor,
          inactiveTrackColor: inactiveTrackColor,
          activeThumbImage: activeThumbImage,
          onActiveThumbImageError: onActiveThumbImageError,
          inactiveThumbImage: inactiveThumbImage,
          onInactiveThumbImageError: onInactiveThumbImageError,
          materialTapTargetSize: materialTapTargetSize,
          thumbColor: thumbColor,
          trackColor: trackColor,
          trackOutlineColor: trackOutlineColor,
          thumbIcon: thumbIcon,
          dragStartBehavior: dragStartBehavior ?? DragStartBehavior.start,
          mouseCursor: mouseCursor,
          focusColor: focusColor,
          hoverColor: hoverColor,
          overlayColor: overlayColor,
          splashRadius: splashRadius,
          focusNode: focusNode,
          onFocusChange: onFocusChange,
          autofocus: autofocus ?? false,
          applyCupertinoTheme: applyCupertinoTheme);
    },
    "SwitchListTile": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final value = getValue(maps["value"], datas, "bool", vars, props);
      final onChanged = getValue(
          maps["onChanged"], datas, "ValueChanged<bool>?", vars, props);
      final activeColor =
          getValue(maps["activeColor"], datas, "Color?", vars, props);
      final activeTrackColor =
          getValue(maps["activeTrackColor"], datas, "Color?", vars, props);
      final inactiveThumbColor =
          getValue(maps["inactiveThumbColor"], datas, "Color?", vars, props);
      final inactiveTrackColor =
          getValue(maps["inactiveTrackColor"], datas, "Color?", vars, props);
      final activeThumbImage = getValue(
          maps["activeThumbImage"], datas, "ImageProvider?", vars, props);
      final onActiveThumbImageError = getValue(maps["onActiveThumbImageError"],
          datas, "ImageErrorListener?", vars, props);
      final inactiveThumbImage = getValue(
          maps["inactiveThumbImage"], datas, "ImageProvider?", vars, props);
      final onInactiveThumbImageError = getValue(
          maps["onInactiveThumbImageError"],
          datas,
          "ImageErrorListener?",
          vars,
          props);
      final thumbColor = getValue(maps["thumbColor"], datas,
          "MaterialStateProperty<Color?>?", vars, props);
      final trackColor = getValue(maps["trackColor"], datas,
          "MaterialStateProperty<Color?>?", vars, props);
      final trackOutlineColor = getValue(maps["trackOutlineColor"], datas,
          "MaterialStateProperty<Color?>?", vars, props);
      final thumbIcon = getValue(maps["thumbIcon"], datas,
          "MaterialStateProperty<Icon?>?", vars, props);
      final materialTapTargetSize = getValue(maps["materialTapTargetSize"],
          datas, "MaterialTapTargetSize?", vars, props);
      final dragStartBehavior = getValue(
          maps["dragStartBehavior"], datas, "DragStartBehavior", vars, props);
      final mouseCursor =
          getValue(maps["mouseCursor"], datas, "MouseCursor?", vars, props);
      final overlayColor = getValue(maps["overlayColor"], datas,
          "MaterialStateProperty<Color?>?", vars, props);
      final splashRadius =
          getValue(maps["splashRadius"], datas, "double?", vars, props);
      final focusNode =
          getValue(maps["focusNode"], datas, "FocusNode?", vars, props);
      final onFocusChange = getValue(
          maps["onFocusChange"], datas, "ValueChanged<bool>?", vars, props);
      final autofocus = getValue(maps["autofocus"], datas, "bool", vars, props);
      final tileColor =
          getValue(maps["tileColor"], datas, "Color?", vars, props);
      final title = getValue(maps["title"], datas, "Widget?", vars, props);
      final subtitle =
          getValue(maps["subtitle"], datas, "Widget?", vars, props);
      final isThreeLine =
          getValue(maps["isThreeLine"], datas, "bool", vars, props);
      final dense = getValue(maps["dense"], datas, "bool?", vars, props);
      final contentPadding = getValue(
          maps["contentPadding"], datas, "EdgeInsetsGeometry?", vars, props);
      final secondary =
          getValue(maps["secondary"], datas, "Widget?", vars, props);
      final selected = getValue(maps["selected"], datas, "bool", vars, props);
      final controlAffinity = getValue(maps["controlAffinity"], datas,
          "ListTileControlAffinity", vars, props);
      final shape = getValue(maps["shape"], datas, "ShapeBorder?", vars, props);
      final selectedTileColor =
          getValue(maps["selectedTileColor"], datas, "Color?", vars, props);
      final visualDensity =
          getValue(maps["visualDensity"], datas, "VisualDensity?", vars, props);
      final enableFeedback =
          getValue(maps["enableFeedback"], datas, "bool?", vars, props);
      final hoverColor =
          getValue(maps["hoverColor"], datas, "Color?", vars, props);
      if (value == null || onChanged == null) {
        return null;
      }
      return SwitchListTile(
          key: key,
          value: value!,
          onChanged: onChanged!,
          activeColor: activeColor,
          activeTrackColor: activeTrackColor,
          inactiveThumbColor: inactiveThumbColor,
          inactiveTrackColor: inactiveTrackColor,
          activeThumbImage: activeThumbImage,
          onActiveThumbImageError: onActiveThumbImageError,
          inactiveThumbImage: inactiveThumbImage,
          onInactiveThumbImageError: onInactiveThumbImageError,
          thumbColor: thumbColor,
          trackColor: trackColor,
          trackOutlineColor: trackOutlineColor,
          thumbIcon: thumbIcon,
          materialTapTargetSize: materialTapTargetSize,
          dragStartBehavior: dragStartBehavior ?? DragStartBehavior.start,
          mouseCursor: mouseCursor,
          overlayColor: overlayColor,
          splashRadius: splashRadius,
          focusNode: focusNode,
          onFocusChange: onFocusChange,
          autofocus: autofocus ?? false,
          tileColor: tileColor,
          title: title,
          subtitle: subtitle,
          isThreeLine: isThreeLine ?? false,
          dense: dense,
          contentPadding: contentPadding,
          secondary: secondary,
          selected: selected ?? false,
          controlAffinity: controlAffinity ?? ListTileControlAffinity.platform,
          shape: shape,
          selectedTileColor: selectedTileColor,
          visualDensity: visualDensity,
          enableFeedback: enableFeedback,
          hoverColor: hoverColor);
    },
    "SwitchListTile.adaptive": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final value = getValue(maps["value"], datas, "bool", vars, props);
      final onChanged = getValue(
          maps["onChanged"], datas, "ValueChanged<bool>?", vars, props);
      final activeColor =
          getValue(maps["activeColor"], datas, "Color?", vars, props);
      final activeTrackColor =
          getValue(maps["activeTrackColor"], datas, "Color?", vars, props);
      final inactiveThumbColor =
          getValue(maps["inactiveThumbColor"], datas, "Color?", vars, props);
      final inactiveTrackColor =
          getValue(maps["inactiveTrackColor"], datas, "Color?", vars, props);
      final activeThumbImage = getValue(
          maps["activeThumbImage"], datas, "ImageProvider?", vars, props);
      final onActiveThumbImageError = getValue(maps["onActiveThumbImageError"],
          datas, "ImageErrorListener?", vars, props);
      final inactiveThumbImage = getValue(
          maps["inactiveThumbImage"], datas, "ImageProvider?", vars, props);
      final onInactiveThumbImageError = getValue(
          maps["onInactiveThumbImageError"],
          datas,
          "ImageErrorListener?",
          vars,
          props);
      final thumbColor = getValue(maps["thumbColor"], datas,
          "MaterialStateProperty<Color?>?", vars, props);
      final trackColor = getValue(maps["trackColor"], datas,
          "MaterialStateProperty<Color?>?", vars, props);
      final trackOutlineColor = getValue(maps["trackOutlineColor"], datas,
          "MaterialStateProperty<Color?>?", vars, props);
      final thumbIcon = getValue(maps["thumbIcon"], datas,
          "MaterialStateProperty<Icon?>?", vars, props);
      final materialTapTargetSize = getValue(maps["materialTapTargetSize"],
          datas, "MaterialTapTargetSize?", vars, props);
      final dragStartBehavior = getValue(
          maps["dragStartBehavior"], datas, "DragStartBehavior", vars, props);
      final mouseCursor =
          getValue(maps["mouseCursor"], datas, "MouseCursor?", vars, props);
      final overlayColor = getValue(maps["overlayColor"], datas,
          "MaterialStateProperty<Color?>?", vars, props);
      final splashRadius =
          getValue(maps["splashRadius"], datas, "double?", vars, props);
      final focusNode =
          getValue(maps["focusNode"], datas, "FocusNode?", vars, props);
      final onFocusChange = getValue(
          maps["onFocusChange"], datas, "ValueChanged<bool>?", vars, props);
      final autofocus = getValue(maps["autofocus"], datas, "bool", vars, props);
      final applyCupertinoTheme =
          getValue(maps["applyCupertinoTheme"], datas, "bool?", vars, props);
      final tileColor =
          getValue(maps["tileColor"], datas, "Color?", vars, props);
      final title = getValue(maps["title"], datas, "Widget?", vars, props);
      final subtitle =
          getValue(maps["subtitle"], datas, "Widget?", vars, props);
      final isThreeLine =
          getValue(maps["isThreeLine"], datas, "bool", vars, props);
      final dense = getValue(maps["dense"], datas, "bool?", vars, props);
      final contentPadding = getValue(
          maps["contentPadding"], datas, "EdgeInsetsGeometry?", vars, props);
      final secondary =
          getValue(maps["secondary"], datas, "Widget?", vars, props);
      final selected = getValue(maps["selected"], datas, "bool", vars, props);
      final controlAffinity = getValue(maps["controlAffinity"], datas,
          "ListTileControlAffinity", vars, props);
      final shape = getValue(maps["shape"], datas, "ShapeBorder?", vars, props);
      final selectedTileColor =
          getValue(maps["selectedTileColor"], datas, "Color?", vars, props);
      final visualDensity =
          getValue(maps["visualDensity"], datas, "VisualDensity?", vars, props);
      final enableFeedback =
          getValue(maps["enableFeedback"], datas, "bool?", vars, props);
      final hoverColor =
          getValue(maps["hoverColor"], datas, "Color?", vars, props);
      if (value == null || onChanged == null) {
        return null;
      }
      return SwitchListTile.adaptive(
          key: key,
          value: value!,
          onChanged: onChanged!,
          activeColor: activeColor,
          activeTrackColor: activeTrackColor,
          inactiveThumbColor: inactiveThumbColor,
          inactiveTrackColor: inactiveTrackColor,
          activeThumbImage: activeThumbImage,
          onActiveThumbImageError: onActiveThumbImageError,
          inactiveThumbImage: inactiveThumbImage,
          onInactiveThumbImageError: onInactiveThumbImageError,
          thumbColor: thumbColor,
          trackColor: trackColor,
          trackOutlineColor: trackOutlineColor,
          thumbIcon: thumbIcon,
          materialTapTargetSize: materialTapTargetSize,
          dragStartBehavior: dragStartBehavior ?? DragStartBehavior.start,
          mouseCursor: mouseCursor,
          overlayColor: overlayColor,
          splashRadius: splashRadius,
          focusNode: focusNode,
          onFocusChange: onFocusChange,
          autofocus: autofocus ?? false,
          applyCupertinoTheme: applyCupertinoTheme,
          tileColor: tileColor,
          title: title,
          subtitle: subtitle,
          isThreeLine: isThreeLine ?? false,
          dense: dense,
          contentPadding: contentPadding,
          secondary: secondary,
          selected: selected ?? false,
          controlAffinity: controlAffinity ?? ListTileControlAffinity.platform,
          shape: shape,
          selectedTileColor: selectedTileColor,
          visualDensity: visualDensity,
          enableFeedback: enableFeedback,
          hoverColor: hoverColor);
    },
    "SwitchTheme": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final data =
          getValue(maps["data"], datas, "SwitchThemeData", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (data == null || child == null) {
        return null;
      }
      return SwitchTheme(key: key, data: data!, child: child!);
    },
    "SwitchThemeData": () {
      final thumbColor = getValue(maps["thumbColor"], datas,
          "MaterialStateProperty<Color?>?", vars, props);
      final trackColor = getValue(maps["trackColor"], datas,
          "MaterialStateProperty<Color?>?", vars, props);
      final trackOutlineColor = getValue(maps["trackOutlineColor"], datas,
          "MaterialStateProperty<Color?>?", vars, props);
      final materialTapTargetSize = getValue(maps["materialTapTargetSize"],
          datas, "MaterialTapTargetSize?", vars, props);
      final mouseCursor = getValue(maps["mouseCursor"], datas,
          "MaterialStateProperty<MouseCursor?>?", vars, props);
      final overlayColor = getValue(maps["overlayColor"], datas,
          "MaterialStateProperty<Color?>?", vars, props);
      final splashRadius =
          getValue(maps["splashRadius"], datas, "double?", vars, props);
      final thumbIcon = getValue(maps["thumbIcon"], datas,
          "MaterialStateProperty<Icon?>?", vars, props);
      return SwitchThemeData(
          thumbColor: thumbColor,
          trackColor: trackColor,
          trackOutlineColor: trackOutlineColor,
          materialTapTargetSize: materialTapTargetSize,
          mouseCursor: mouseCursor,
          overlayColor: overlayColor,
          splashRadius: splashRadius,
          thumbIcon: thumbIcon);
    },
    "SynchronousFuture": () {
      final _value = getValue(maps["0"], datas, "T", vars, props);
      if (_value == null) {
        return null;
      }
      return SynchronousFuture(_value!);
    },
    "SystemUiOverlayStyle": () {
      final systemNavigationBarColor = getValue(
          maps["systemNavigationBarColor"], datas, "Color?", vars, props);
      final systemNavigationBarDividerColor = getValue(
          maps["systemNavigationBarDividerColor"],
          datas,
          "Color?",
          vars,
          props);
      final systemNavigationBarIconBrightness = getValue(
          maps["systemNavigationBarIconBrightness"],
          datas,
          "Brightness?",
          vars,
          props);
      final systemNavigationBarContrastEnforced = getValue(
          maps["systemNavigationBarContrastEnforced"],
          datas,
          "bool?",
          vars,
          props);
      final statusBarColor =
          getValue(maps["statusBarColor"], datas, "Color?", vars, props);
      final statusBarBrightness = getValue(
          maps["statusBarBrightness"], datas, "Brightness?", vars, props);
      final statusBarIconBrightness = getValue(
          maps["statusBarIconBrightness"], datas, "Brightness?", vars, props);
      final systemStatusBarContrastEnforced = getValue(
          maps["systemStatusBarContrastEnforced"], datas, "bool?", vars, props);
      return SystemUiOverlayStyle(
          systemNavigationBarColor: systemNavigationBarColor,
          systemNavigationBarDividerColor: systemNavigationBarDividerColor,
          systemNavigationBarIconBrightness: systemNavigationBarIconBrightness,
          systemNavigationBarContrastEnforced:
              systemNavigationBarContrastEnforced,
          statusBarColor: statusBarColor,
          statusBarBrightness: statusBarBrightness,
          statusBarIconBrightness: statusBarIconBrightness,
          systemStatusBarContrastEnforced: systemStatusBarContrastEnforced);
    },
    "Tab": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final text = getValue(maps["text"], datas, "String?", vars, props);
      final icon = getValue(maps["icon"], datas, "Widget?", vars, props);
      final iconMargin = getValue(
          maps["iconMargin"], datas, "EdgeInsetsGeometry", vars, props);
      final height = getValue(maps["height"], datas, "double?", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      return Tab(
          key: key,
          text: text,
          icon: icon,
          iconMargin: iconMargin ?? const EdgeInsets.only(bottom: 10.0),
          height: height,
          child: child);
    },
    "TabBar": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final tabs = getValue(maps["tabs"], datas, "List<Widget>", vars, props);
      final controller =
          getValue(maps["controller"], datas, "TabController?", vars, props);
      final isScrollable =
          getValue(maps["isScrollable"], datas, "bool", vars, props);
      final padding =
          getValue(maps["padding"], datas, "EdgeInsetsGeometry?", vars, props);
      final indicatorColor =
          getValue(maps["indicatorColor"], datas, "Color?", vars, props);
      final automaticIndicatorColorAdjustment = getValue(
          maps["automaticIndicatorColorAdjustment"],
          datas,
          "bool",
          vars,
          props);
      final indicatorWeight =
          getValue(maps["indicatorWeight"], datas, "double", vars, props);
      final indicatorPadding = getValue(
          maps["indicatorPadding"], datas, "EdgeInsetsGeometry", vars, props);
      final indicator =
          getValue(maps["indicator"], datas, "Color?", vars, props);
      final indicatorSize = getValue(
          maps["indicatorSize"], datas, "TabBarIndicatorSize?", vars, props);
      final dividerColor =
          getValue(maps["dividerColor"], datas, "Color?", vars, props);
      final labelColor =
          getValue(maps["labelColor"], datas, "Color?", vars, props);
      final labelStyle =
          getValue(maps["labelStyle"], datas, "TextStyle?", vars, props);
      final labelPadding = getValue(
          maps["labelPadding"], datas, "EdgeInsetsGeometry?", vars, props);
      final unselectedLabelColor =
          getValue(maps["unselectedLabelColor"], datas, "Color?", vars, props);
      final unselectedLabelStyle = getValue(
          maps["unselectedLabelStyle"], datas, "TextStyle?", vars, props);
      final dragStartBehavior = getValue(
          maps["dragStartBehavior"], datas, "DragStartBehavior", vars, props);
      final overlayColor = getValue(maps["overlayColor"], datas,
          "MaterialStateProperty<Color?>?", vars, props);
      final mouseCursor =
          getValue(maps["mouseCursor"], datas, "MouseCursor?", vars, props);
      final enableFeedback =
          getValue(maps["enableFeedback"], datas, "bool?", vars, props);
      final onTap =
          getValue(maps["onTap"], datas, "ValueChanged<int>?", vars, props);
      final physics =
          getValue(maps["physics"], datas, "ScrollPhysics?", vars, props);
      final splashFactory = getValue(maps["splashFactory"], datas,
          "InteractiveInkFeatureFactory?", vars, props);
      final splashBorderRadius = getValue(
          maps["splashBorderRadius"], datas, "BorderRadius?", vars, props);
      if (tabs == null) {
        return null;
      }
      return TabBar(
          key: key,
          tabs: List<Widget>.from(tabs!),
          controller: controller,
          isScrollable: isScrollable ?? false,
          padding: padding,
          indicatorColor: indicatorColor,
          automaticIndicatorColorAdjustment:
              automaticIndicatorColorAdjustment ?? true,
          indicatorWeight: indicatorWeight ?? 2.0,
          indicatorPadding: indicatorPadding ?? EdgeInsets.zero,
          indicator: indicator,
          indicatorSize: indicatorSize,
          dividerColor: dividerColor,
          labelColor: labelColor,
          labelStyle: labelStyle,
          labelPadding: labelPadding,
          unselectedLabelColor: unselectedLabelColor,
          unselectedLabelStyle: unselectedLabelStyle,
          dragStartBehavior: dragStartBehavior ?? DragStartBehavior.start,
          overlayColor: overlayColor,
          mouseCursor: mouseCursor,
          enableFeedback: enableFeedback,
          onTap: onTap,
          physics: physics,
          splashFactory: splashFactory,
          splashBorderRadius: splashBorderRadius);
    },
    "TabBar.secondary": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final tabs = getValue(maps["tabs"], datas, "List<Widget>", vars, props);
      final controller =
          getValue(maps["controller"], datas, "TabController?", vars, props);
      final isScrollable =
          getValue(maps["isScrollable"], datas, "bool", vars, props);
      final padding =
          getValue(maps["padding"], datas, "EdgeInsetsGeometry?", vars, props);
      final indicatorColor =
          getValue(maps["indicatorColor"], datas, "Color?", vars, props);
      final automaticIndicatorColorAdjustment = getValue(
          maps["automaticIndicatorColorAdjustment"],
          datas,
          "bool",
          vars,
          props);
      final indicatorWeight =
          getValue(maps["indicatorWeight"], datas, "double", vars, props);
      final indicatorPadding = getValue(
          maps["indicatorPadding"], datas, "EdgeInsetsGeometry", vars, props);
      final indicator =
          getValue(maps["indicator"], datas, "Color?", vars, props);
      final indicatorSize = getValue(
          maps["indicatorSize"], datas, "TabBarIndicatorSize?", vars, props);
      final dividerColor =
          getValue(maps["dividerColor"], datas, "Color?", vars, props);
      final labelColor =
          getValue(maps["labelColor"], datas, "Color?", vars, props);
      final labelStyle =
          getValue(maps["labelStyle"], datas, "TextStyle?", vars, props);
      final labelPadding = getValue(
          maps["labelPadding"], datas, "EdgeInsetsGeometry?", vars, props);
      final unselectedLabelColor =
          getValue(maps["unselectedLabelColor"], datas, "Color?", vars, props);
      final unselectedLabelStyle = getValue(
          maps["unselectedLabelStyle"], datas, "TextStyle?", vars, props);
      final dragStartBehavior = getValue(
          maps["dragStartBehavior"], datas, "DragStartBehavior", vars, props);
      final overlayColor = getValue(maps["overlayColor"], datas,
          "MaterialStateProperty<Color?>?", vars, props);
      final mouseCursor =
          getValue(maps["mouseCursor"], datas, "MouseCursor?", vars, props);
      final enableFeedback =
          getValue(maps["enableFeedback"], datas, "bool?", vars, props);
      final onTap =
          getValue(maps["onTap"], datas, "ValueChanged<int>?", vars, props);
      final physics =
          getValue(maps["physics"], datas, "ScrollPhysics?", vars, props);
      final splashFactory = getValue(maps["splashFactory"], datas,
          "InteractiveInkFeatureFactory?", vars, props);
      final splashBorderRadius = getValue(
          maps["splashBorderRadius"], datas, "BorderRadius?", vars, props);
      if (tabs == null) {
        return null;
      }
      return TabBar.secondary(
          key: key,
          tabs: List<Widget>.from(tabs!),
          controller: controller,
          isScrollable: isScrollable ?? false,
          padding: padding,
          indicatorColor: indicatorColor,
          automaticIndicatorColorAdjustment:
              automaticIndicatorColorAdjustment ?? true,
          indicatorWeight: indicatorWeight ?? 2.0,
          indicatorPadding: indicatorPadding ?? EdgeInsets.zero,
          indicator: indicator,
          indicatorSize: indicatorSize,
          dividerColor: dividerColor,
          labelColor: labelColor,
          labelStyle: labelStyle,
          labelPadding: labelPadding,
          unselectedLabelColor: unselectedLabelColor,
          unselectedLabelStyle: unselectedLabelStyle,
          dragStartBehavior: dragStartBehavior ?? DragStartBehavior.start,
          overlayColor: overlayColor,
          mouseCursor: mouseCursor,
          enableFeedback: enableFeedback,
          onTap: onTap,
          physics: physics,
          splashFactory: splashFactory,
          splashBorderRadius: splashBorderRadius);
    },
    "TabBarTheme": () {
      final indicator =
          getValue(maps["indicator"], datas, "Decoration?", vars, props);
      final indicatorColor =
          getValue(maps["indicatorColor"], datas, "Color?", vars, props);
      final indicatorSize = getValue(
          maps["indicatorSize"], datas, "TabBarIndicatorSize?", vars, props);
      final dividerColor =
          getValue(maps["dividerColor"], datas, "Color?", vars, props);
      final labelColor =
          getValue(maps["labelColor"], datas, "Color?", vars, props);
      final labelPadding = getValue(
          maps["labelPadding"], datas, "EdgeInsetsGeometry?", vars, props);
      final labelStyle =
          getValue(maps["labelStyle"], datas, "TextStyle?", vars, props);
      final unselectedLabelColor =
          getValue(maps["unselectedLabelColor"], datas, "Color?", vars, props);
      final unselectedLabelStyle = getValue(
          maps["unselectedLabelStyle"], datas, "TextStyle?", vars, props);
      final overlayColor = getValue(maps["overlayColor"], datas,
          "MaterialStateProperty<Color?>?", vars, props);
      final splashFactory = getValue(maps["splashFactory"], datas,
          "InteractiveInkFeatureFactory?", vars, props);
      final mouseCursor = getValue(maps["mouseCursor"], datas,
          "MaterialStateProperty<MouseCursor?>?", vars, props);
      return TabBarTheme(
          indicator: indicator,
          indicatorColor: indicatorColor,
          indicatorSize: indicatorSize,
          dividerColor: dividerColor,
          labelColor: labelColor,
          labelPadding: labelPadding,
          labelStyle: labelStyle,
          unselectedLabelColor: unselectedLabelColor,
          unselectedLabelStyle: unselectedLabelStyle,
          overlayColor: overlayColor,
          splashFactory: splashFactory,
          mouseCursor: mouseCursor);
    },
    "TabBarView": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final children =
          getValue(maps["children"], datas, "List<Widget>", vars, props);
      final controller =
          getValue(maps["controller"], datas, "TabController?", vars, props);
      final physics =
          getValue(maps["physics"], datas, "ScrollPhysics?", vars, props);
      final dragStartBehavior = getValue(
          maps["dragStartBehavior"], datas, "DragStartBehavior", vars, props);
      final viewportFraction =
          getValue(maps["viewportFraction"], datas, "double", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      if (children == null) {
        return null;
      }
      return TabBarView(
          key: key,
          controller: controller,
          physics: physics,
          dragStartBehavior: dragStartBehavior ?? DragStartBehavior.start,
          viewportFraction: viewportFraction ?? 1.0,
          clipBehavior: clipBehavior ?? Clip.hardEdge,
          children: List<Widget>.from(children!));
    },
    "TabController": () {
      final initialIndex =
          getValue(maps["initialIndex"], datas, "int", vars, props);
      final animationDuration =
          getValue(maps["animationDuration"], datas, "Duration?", vars, props);
      final length = getValue(maps["length"], datas, "int", vars, props);
      final vsync =
          getValue(maps["vsync"], datas, "TickerProvider", vars, props);
      if (length == null || vsync == null) {
        return null;
      }
      return TabController(
          initialIndex: initialIndex ?? 0,
          animationDuration: animationDuration,
          length: length!,
          vsync: vsync!);
    },
    "TabPageSelector": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final controller =
          getValue(maps["controller"], datas, "TabController?", vars, props);
      final indicatorSize =
          getValue(maps["indicatorSize"], datas, "double", vars, props);
      final color = getValue(maps["color"], datas, "Color?", vars, props);
      final selectedColor =
          getValue(maps["selectedColor"], datas, "Color?", vars, props);
      final borderStyle =
          getValue(maps["borderStyle"], datas, "BorderStyle?", vars, props);
      return TabPageSelector(
          key: key,
          controller: controller,
          indicatorSize: indicatorSize ?? 12.0,
          color: color,
          selectedColor: selectedColor,
          borderStyle: borderStyle);
    },
    "TabPageSelectorIndicator": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final backgroundColor =
          getValue(maps["backgroundColor"], datas, "Color", vars, props);
      final borderColor =
          getValue(maps["borderColor"], datas, "Color", vars, props);
      final size = getValue(maps["size"], datas, "double", vars, props);
      final borderStyle =
          getValue(maps["borderStyle"], datas, "BorderStyle", vars, props);
      if (backgroundColor == null || borderColor == null || size == null) {
        return null;
      }
      return TabPageSelectorIndicator(
          key: key,
          backgroundColor: backgroundColor!,
          borderColor: borderColor!,
          size: size!,
          borderStyle: borderStyle ?? BorderStyle.solid);
    },
    "Table": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final children = getValue(maps["children"], datas, "", vars, props);
      final columnWidths =
          getValue(maps["columnWidths"], datas, "", vars, props);
      final defaultColumnWidth =
          getValue(maps["defaultColumnWidth"], datas, "", vars, props);
      final textDirection =
          getValue(maps["textDirection"], datas, "", vars, props);
      final border = getValue(maps["border"], datas, "", vars, props);
      final defaultVerticalAlignment =
          getValue(maps["defaultVerticalAlignment"], datas, "", vars, props);
      final textBaseline =
          getValue(maps["textBaseline"], datas, "", vars, props);
      return Table(
          key: key,
          children: children ?? const <TableRow>[],
          columnWidths: columnWidths,
          defaultColumnWidth: defaultColumnWidth ?? const FlexColumnWidth(),
          textDirection: textDirection,
          border: border,
          defaultVerticalAlignment:
              defaultVerticalAlignment ?? TableCellVerticalAlignment.top,
          textBaseline: textBaseline);
    },
    "TableBorder": () {
      final top = getValue(maps["top"], datas, "BorderSide", vars, props);
      final right = getValue(maps["right"], datas, "BorderSide", vars, props);
      final bottom = getValue(maps["bottom"], datas, "BorderSide", vars, props);
      final left = getValue(maps["left"], datas, "BorderSide", vars, props);
      final horizontalInside =
          getValue(maps["horizontalInside"], datas, "BorderSide", vars, props);
      final verticalInside =
          getValue(maps["verticalInside"], datas, "BorderSide", vars, props);
      final borderRadius =
          getValue(maps["borderRadius"], datas, "BorderRadius", vars, props);
      return TableBorder(
          top: top ?? BorderSide.none,
          right: right ?? BorderSide.none,
          bottom: bottom ?? BorderSide.none,
          left: left ?? BorderSide.none,
          horizontalInside: horizontalInside ?? BorderSide.none,
          verticalInside: verticalInside ?? BorderSide.none,
          borderRadius: borderRadius ?? BorderRadius.zero);
    },
    "TableBorder.all": () {
      final color = getValue(maps["color"], datas, "Color", vars, props);
      final width = getValue(maps["width"], datas, "double", vars, props);
      final style = getValue(maps["style"], datas, "BorderStyle", vars, props);
      final borderRadius =
          getValue(maps["borderRadius"], datas, "BorderRadius", vars, props);
      return TableBorder.all(
          color: color ?? const Color(0xFF000000),
          width: width ?? 1.0,
          style: style ?? BorderStyle.solid,
          borderRadius: borderRadius ?? BorderRadius.zero);
    },
    "TableBorder.symmetric": () {
      final inside = getValue(maps["inside"], datas, "BorderSide", vars, props);
      final outside =
          getValue(maps["outside"], datas, "BorderSide", vars, props);
      return TableBorder.symmetric(
          inside: inside ?? BorderSide.none,
          outside: outside ?? BorderSide.none);
    },
    "TableCell": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final verticalAlignment = getValue(maps["verticalAlignment"], datas,
          "TableCellVerticalAlignment?", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (child == null) {
        return null;
      }
      return TableCell(
          key: key, verticalAlignment: verticalAlignment, child: child!);
    },
    "TableRow": () {
      final key = getValue(maps["key"], datas, "LocalKey?", vars, props);
      final decoration =
          getValue(maps["decoration"], datas, "Decoration?", vars, props);
      final children =
          getValue(maps["children"], datas, "List<Widget>", vars, props);
      return TableRow(
          key: key,
          decoration: decoration,
          children: List<Widget>.from(children ?? const <Widget>[]));
    },
    "TableRowInkWell": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      final onTap =
          getValue(maps["onTap"], datas, "GestureTapCallback?", vars, props);
      final onDoubleTap = getValue(
          maps["onDoubleTap"], datas, "GestureTapCallback?", vars, props);
      final onLongPress = getValue(
          maps["onLongPress"], datas, "GestureLongPressCallback?", vars, props);
      final onHighlightChanged = getValue(maps["onHighlightChanged"], datas,
          "ValueChanged<bool>?", vars, props);
      final onSecondaryTap = getValue(
          maps["onSecondaryTap"], datas, "GestureTapCallback?", vars, props);
      final onSecondaryTapDown = getValue(maps["onSecondaryTapDown"], datas,
          "GestureTapDownCallback?", vars, props);
      final overlayColor = getValue(maps["overlayColor"], datas,
          "MaterialStateProperty<Color?>?", vars, props);
      final mouseCursor =
          getValue(maps["mouseCursor"], datas, "MouseCursor?", vars, props);
      return TableRowInkWell(
          key: key,
          child: child,
          onTap: onTap,
          onDoubleTap: onDoubleTap,
          onLongPress: onLongPress,
          onHighlightChanged: onHighlightChanged,
          onSecondaryTap: onSecondaryTap,
          onSecondaryTapDown: onSecondaryTapDown,
          overlayColor: overlayColor,
          mouseCursor: mouseCursor);
    },
    "Tangent": () {
      final position = getValue(maps["0"], datas, "Offset", vars, props);
      final vector = getValue(maps["1"], datas, "Offset", vars, props);
      if (position == null || vector == null) {
        return null;
      }
      return ui.Tangent(position!, vector!);
    },
    "Tangent.fromAngle": () {
      final position = getValue(maps["0"], datas, "Offset", vars, props);
      final angle = getValue(maps["1"], datas, "double", vars, props);
      if (position == null || angle == null) {
        return null;
      }
      return ui.Tangent.fromAngle(position!, angle!);
    },
    "TapAndDragGestureRecognizer": () {
      final debugOwner = getValue(maps["debugOwner"], datas, "", vars, props);
      final supportedDevices =
          getValue(maps["supportedDevices"], datas, "", vars, props);
      return TapAndDragGestureRecognizer(
          debugOwner: debugOwner, supportedDevices: supportedDevices);
    },
    "TapAndHorizontalDragGestureRecognizer": () {
      final debugOwner = getValue(maps["debugOwner"], datas, "", vars, props);
      final supportedDevices =
          getValue(maps["supportedDevices"], datas, "", vars, props);
      return TapAndHorizontalDragGestureRecognizer(
          debugOwner: debugOwner, supportedDevices: supportedDevices);
    },
    "TapAndPanGestureRecognizer": () {
      final debugOwner = getValue(maps["debugOwner"], datas, "", vars, props);
      final supportedDevices =
          getValue(maps["supportedDevices"], datas, "", vars, props);
      return TapAndPanGestureRecognizer(
          debugOwner: debugOwner, supportedDevices: supportedDevices);
    },
    "TapDownDetails": () {
      final globalPosition =
          getValue(maps["globalPosition"], datas, "Offset", vars, props);
      final localPosition =
          getValue(maps["localPosition"], datas, "Offset?", vars, props);
      final kind =
          getValue(maps["kind"], datas, "PointerDeviceKind?", vars, props);
      return TapDownDetails(
          globalPosition: globalPosition ?? Offset.zero,
          localPosition: localPosition,
          kind: kind);
    },
    "TapDragDownDetails": () {
      final globalPosition =
          getValue(maps["globalPosition"], datas, "Offset", vars, props);
      final localPosition =
          getValue(maps["localPosition"], datas, "Offset", vars, props);
      final kind =
          getValue(maps["kind"], datas, "PointerDeviceKind?", vars, props);
      final consecutiveTapCount =
          getValue(maps["consecutiveTapCount"], datas, "int", vars, props);
      // final keysPressedOnDown = getValue(maps["keysPressedOnDown"], datas,
      //     },"Set<LogicalKeyboardKey>", vars, props);
      if (globalPosition == null ||
              localPosition == null ||
              consecutiveTapCount == null

          //||keysPressedOnDown == null
          ) {
        return null;
      }
      return TapDragDownDetails(
        globalPosition: globalPosition!,
        localPosition: localPosition!,
        kind: kind,
        consecutiveTapCount: consecutiveTapCount!,
        //keysPressedOnDown: Set<LogicalKeyboardKey>.from(keysPressedOnDown!),
      );
    },
    "TapDragEndDetails": () {
      final velocity =
          getValue(maps["velocity"], datas, "Velocity", vars, props);
      final primaryVelocity =
          getValue(maps["primaryVelocity"], datas, "double?", vars, props);
      final consecutiveTapCount =
          getValue(maps["consecutiveTapCount"], datas, "int", vars, props);
      // final keysPressedOnDown = getValue(maps["keysPressedOnDown"], datas,
      //     },"Set<LogicalKeyboardKey>", vars, props);
      //|| keysPressedOnDown == null
      if (consecutiveTapCount == null) {
        return null;
      }
      return TapDragEndDetails(
        velocity: velocity ?? Velocity.zero,
        primaryVelocity: primaryVelocity,
        consecutiveTapCount: consecutiveTapCount!,
        //keysPressedOnDown: Set<LogicalKeyboardKey>.from(keysPressedOnDown!),
      );
    },
    "TapDragStartDetails": () {
      final sourceTimeStamp =
          getValue(maps["sourceTimeStamp"], datas, "Duration?", vars, props);
      final globalPosition =
          getValue(maps["globalPosition"], datas, "Offset", vars, props);
      final localPosition =
          getValue(maps["localPosition"], datas, "Offset", vars, props);
      final kind =
          getValue(maps["kind"], datas, "PointerDeviceKind?", vars, props);
      final consecutiveTapCount =
          getValue(maps["consecutiveTapCount"], datas, "int", vars, props);
      // final keysPressedOnDown = getValue(maps["keysPressedOnDown"], datas,
      //     },"Set<LogicalKeyboardKey>", vars, props);
      if (globalPosition == null ||
              localPosition == null ||
              consecutiveTapCount == null
          // || keysPressedOnDown == null
          ) {
        return null;
      }
      return TapDragStartDetails(
        sourceTimeStamp: sourceTimeStamp,
        globalPosition: globalPosition!,
        localPosition: localPosition!,
        kind: kind,
        consecutiveTapCount: consecutiveTapCount!,
        //keysPressedOnDown: Set<LogicalKeyboardKey>.from(keysPressedOnDown!),
      );
    },
    "TapDragUpDetails": () {
      final kind =
          getValue(maps["kind"], datas, "PointerDeviceKind", vars, props);
      final globalPosition =
          getValue(maps["globalPosition"], datas, "Offset", vars, props);
      final localPosition =
          getValue(maps["localPosition"], datas, "Offset", vars, props);
      final consecutiveTapCount =
          getValue(maps["consecutiveTapCount"], datas, "int", vars, props);
      // final keysPressedOnDown = getValue(maps["keysPressedOnDown"], datas,
      //     },"Set<LogicalKeyboardKey>", vars, props);
      if (kind == null ||
              globalPosition == null ||
              localPosition == null ||
              consecutiveTapCount == null
          //||
          //  keysPressedOnDown == null,
          ) {
        return null;
      }
      return TapDragUpDetails(
        kind: kind!,
        globalPosition: globalPosition!,
        localPosition: localPosition!,
        consecutiveTapCount: consecutiveTapCount!,
        //keysPressedOnDown: Set<LogicalKeyboardKey>.from(keysPressedOnDown!),
      );
    },
    "TapDragUpdateDetails": () {
      final sourceTimeStamp =
          getValue(maps["sourceTimeStamp"], datas, "Duration?", vars, props);
      final delta = getValue(maps["delta"], datas, "Offset", vars, props);
      final primaryDelta =
          getValue(maps["primaryDelta"], datas, "double?", vars, props);
      final globalPosition =
          getValue(maps["globalPosition"], datas, "Offset", vars, props);
      final kind =
          getValue(maps["kind"], datas, "PointerDeviceKind?", vars, props);
      final localPosition =
          getValue(maps["localPosition"], datas, "Offset", vars, props);
      final offsetFromOrigin =
          getValue(maps["offsetFromOrigin"], datas, "Offset", vars, props);
      final localOffsetFromOrigin =
          getValue(maps["localOffsetFromOrigin"], datas, "Offset", vars, props);
      final consecutiveTapCount =
          getValue(maps["consecutiveTapCount"], datas, "int", vars, props);
      // final keysPressedOnDown = getValue(maps["keysPressedOnDown"], datas,
      //     },"Set<LogicalKeyboardKey>", vars, props);
      if (globalPosition == null ||
              localPosition == null ||
              offsetFromOrigin == null ||
              localOffsetFromOrigin == null ||
              consecutiveTapCount == null
          //|| keysPressedOnDown == null,
          ) {
        return null;
      }
      return TapDragUpdateDetails(
        sourceTimeStamp: sourceTimeStamp,
        delta: delta ?? Offset.zero,
        primaryDelta: primaryDelta,
        globalPosition: globalPosition!,
        kind: kind,
        localPosition: localPosition!,
        offsetFromOrigin: offsetFromOrigin!,
        localOffsetFromOrigin: localOffsetFromOrigin!,
        consecutiveTapCount: consecutiveTapCount!,
        // keysPressedOnDown: Set<LogicalKeyboardKey>.from(keysPressedOnDown!),
      );
    },
    "TapGestureRecognizer": () {
      final debugOwner = getValue(maps["debugOwner"], datas, "", vars, props);
      final supportedDevices =
          getValue(maps["supportedDevices"], datas, "", vars, props);
      final allowedButtonsFilter =
          getValue(maps["allowedButtonsFilter"], datas, "", vars, props);
      return TapGestureRecognizer(
          debugOwner: debugOwner,
          supportedDevices: supportedDevices,
          allowedButtonsFilter: allowedButtonsFilter);
    },
    "TapRegion": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      final enabled = getValue(maps["enabled"], datas, "bool", vars, props);
      final behavior =
          getValue(maps["behavior"], datas, "HitTestBehavior", vars, props);
      final onTapOutside = getValue(
          maps["onTapOutside"], datas, "TapRegionCallback?", vars, props);
      final onTapInside = getValue(
          maps["onTapInside"], datas, "TapRegionCallback?", vars, props);
      final groupId = getValue(maps["groupId"], datas, "Object?", vars, props);
      final debugLabel =
          getValue(maps["debugLabel"], datas, "String?", vars, props);
      if (child == null) {
        return null;
      }
      return TapRegion(
          key: key,
          child: child!,
          enabled: enabled ?? true,
          behavior: behavior ?? HitTestBehavior.deferToChild,
          onTapOutside: onTapOutside,
          onTapInside: onTapInside,
          groupId: groupId,
          debugLabel: debugLabel);
    },
    "TapRegionSurface": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (child == null) {
        return null;
      }
      return TapRegionSurface(key: key, child: child!);
    },
    "TapSemanticEvent": () {
      return const TapSemanticEvent();
    },
    "TapUpDetails": () {
      final kind =
          getValue(maps["kind"], datas, "PointerDeviceKind", vars, props);
      final globalPosition =
          getValue(maps["globalPosition"], datas, "Offset", vars, props);
      final localPosition =
          getValue(maps["localPosition"], datas, "Offset?", vars, props);
      if (kind == null) {
        return null;
      }
      return TapUpDetails(
          kind: kind!,
          globalPosition: globalPosition ?? Offset.zero,
          localPosition: localPosition);
    },
    "TargetImageSize": () {
      final width = getValue(maps["width"], datas, "int?", vars, props);
      final height = getValue(maps["height"], datas, "int?", vars, props);
      return ui.TargetImageSize(width: width, height: height);
    },
    "Text": () {
      final data = getValue(maps["0"], datas, "String", vars, props);
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final style = getValue(maps["style"], datas, "TextStyle?", vars, props);
      final strutStyle =
          getValue(maps["strutStyle"], datas, "StrutStyle?", vars, props);
      final textAlign =
          getValue(maps["textAlign"], datas, "TextAlign?", vars, props);
      final textDirection =
          getValue(maps["textDirection"], datas, "TextDirection?", vars, props);
      final locale = getValue(maps["locale"], datas, "Locale?", vars, props);
      final softWrap = getValue(maps["softWrap"], datas, "bool?", vars, props);
      final overflow =
          getValue(maps["overflow"], datas, "TextOverflow?", vars, props);
      final textScaleFactor =
          getValue(maps["textScaleFactor"], datas, "double?", vars, props);
      final maxLines = getValue(maps["maxLines"], datas, "int?", vars, props);
      final semanticsLabel =
          getValue(maps["semanticsLabel"], datas, "String?", vars, props);
      final textWidthBasis = getValue(
          maps["textWidthBasis"], datas, "TextWidthBasis?", vars, props);
      final textHeightBehavior = getValue(maps["textHeightBehavior"], datas,
          "TextHeightBehavior?", vars, props);
      final selectionColor =
          getValue(maps["selectionColor"], datas, "Color?", vars, props);
      if (data == null) {
        return null;
      }
      return Text(data!,
          key: key,
          style: style,
          strutStyle: strutStyle,
          textAlign: textAlign,
          textDirection: textDirection,
          locale: locale,
          softWrap: softWrap,
          overflow: overflow,
          textScaleFactor: textScaleFactor,
          maxLines: maxLines,
          semanticsLabel: semanticsLabel,
          textWidthBasis: textWidthBasis,
          textHeightBehavior: textHeightBehavior,
          selectionColor: selectionColor);
    },
    "Text.rich": () {
      final textSpan = getValue(maps["0"], datas, "InlineSpan", vars, props);
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final style = getValue(maps["style"], datas, "TextStyle?", vars, props);
      final strutStyle =
          getValue(maps["strutStyle"], datas, "StrutStyle?", vars, props);
      final textAlign =
          getValue(maps["textAlign"], datas, "TextAlign?", vars, props);
      final textDirection =
          getValue(maps["textDirection"], datas, "TextDirection?", vars, props);
      final locale = getValue(maps["locale"], datas, "Locale?", vars, props);
      final softWrap = getValue(maps["softWrap"], datas, "bool?", vars, props);
      final overflow =
          getValue(maps["overflow"], datas, "TextOverflow?", vars, props);
      final textScaleFactor =
          getValue(maps["textScaleFactor"], datas, "double?", vars, props);
      final maxLines = getValue(maps["maxLines"], datas, "int?", vars, props);
      final semanticsLabel =
          getValue(maps["semanticsLabel"], datas, "String?", vars, props);
      final textWidthBasis = getValue(
          maps["textWidthBasis"], datas, "TextWidthBasis?", vars, props);
      final textHeightBehavior = getValue(maps["textHeightBehavior"], datas,
          "TextHeightBehavior?", vars, props);
      final selectionColor =
          getValue(maps["selectionColor"], datas, "Color?", vars, props);
      if (textSpan == null) {
        return null;
      }
      return Text.rich(textSpan!,
          key: key,
          style: style,
          strutStyle: strutStyle,
          textAlign: textAlign,
          textDirection: textDirection,
          locale: locale,
          softWrap: softWrap,
          overflow: overflow,
          textScaleFactor: textScaleFactor,
          maxLines: maxLines,
          semanticsLabel: semanticsLabel,
          textWidthBasis: textWidthBasis,
          textHeightBehavior: textHeightBehavior,
          selectionColor: selectionColor);
    },
    "TextAlignVertical": () {
      final y = getValue(maps["y"], datas, "double", vars, props);
      if (y == null) {
        return null;
      }
      return TextAlignVertical(y: y!);
    },
    "TextBox.fromLTRBD": () {
      final left = getValue(maps["0"], datas, "double", vars, props);
      final top = getValue(maps["1"], datas, "double", vars, props);
      final right = getValue(maps["2"], datas, "double", vars, props);
      final bottom = getValue(maps["3"], datas, "double", vars, props);
      final direction =
          getValue(maps["4"], datas, "TextDirection", vars, props);
      if (left == null ||
          top == null ||
          right == null ||
          bottom == null ||
          direction == null) {
        return null;
      }
      return TextBox.fromLTRBD(left!, top!, right!, bottom!, direction!);
    },
    "TextButton": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final onPressed =
          getValue(maps["onPressed"], datas, "VoidCallback?", vars, props);
      final onLongPress =
          getValue(maps["onLongPress"], datas, "VoidCallback?", vars, props);
      final onHover =
          getValue(maps["onHover"], datas, "ValueChanged<bool>?", vars, props);
      final onFocusChange = getValue(
          maps["onFocusChange"], datas, "ValueChanged<bool>?", vars, props);
      final style = getValue(maps["style"], datas, "ButtonStyle?", vars, props);
      final focusNode =
          getValue(maps["focusNode"], datas, "FocusNode?", vars, props);
      final autofocus = getValue(maps["autofocus"], datas, "bool", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      final statesController = getValue(maps["statesController"], datas,
          "MaterialStatesController?", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (onPressed == null || child == null) {
        return null;
      }
      return TextButton(
          key: key,
          onPressed: onPressed!,
          onLongPress: onLongPress,
          onHover: onHover,
          onFocusChange: onFocusChange,
          style: style,
          focusNode: focusNode,
          autofocus: autofocus ?? false,
          clipBehavior: clipBehavior ?? Clip.none,
          statesController: statesController,
          child: child!);
    },
    "TextButton.icon": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final onPressed =
          getValue(maps["onPressed"], datas, "VoidCallback?", vars, props);
      final onLongPress =
          getValue(maps["onLongPress"], datas, "VoidCallback?", vars, props);
      final onHover =
          getValue(maps["onHover"], datas, "ValueChanged<bool>?", vars, props);
      final onFocusChange = getValue(
          maps["onFocusChange"], datas, "ValueChanged<bool>?", vars, props);
      final style = getValue(maps["style"], datas, "ButtonStyle?", vars, props);
      final focusNode =
          getValue(maps["focusNode"], datas, "FocusNode?", vars, props);
      final autofocus =
          getValue(maps["autofocus"], datas, "bool?", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip?", vars, props);
      final statesController = getValue(maps["statesController"], datas,
          "MaterialStatesController?", vars, props);
      final icon = getValue(maps["icon"], datas, "Widget", vars, props);
      final label = getValue(maps["label"], datas, "Widget", vars, props);
      if (onPressed == null || icon == null || label == null) {
        return null;
      }
      return TextButton.icon(
          key: key,
          onPressed: onPressed!,
          onLongPress: onLongPress,
          onHover: onHover,
          onFocusChange: onFocusChange,
          style: style,
          focusNode: focusNode,
          autofocus: autofocus,
          clipBehavior: clipBehavior,
          statesController: statesController,
          icon: icon!,
          label: label!);
    },
    "TextButtonTheme": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final data =
          getValue(maps["data"], datas, "TextButtonThemeData", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (data == null || child == null) {
        return null;
      }
      return TextButtonTheme(key: key, data: data!, child: child!);
    },
    "TextButtonThemeData": () {
      final style = getValue(maps["style"], datas, "ButtonStyle?", vars, props);
      return TextButtonThemeData(style: style);
    },
    "TextDecoration.combine": () {
      final decorations =
          getValue(maps["0"], datas, "List<TextDecoration>", vars, props);
      if (decorations == null) {
        return null;
      }
      return TextDecoration.combine(List<TextDecoration>.from(decorations!));
    },
    "TextEditingController": () {
      final text = getValue(maps["text"], datas, "String?", vars, props);
      return TextEditingController(text: text);
    },
    "TextEditingController.fromValue": () {
      final value =
          getValue(maps["0"], datas, "TextEditingValue?", vars, props);
      if (value == null) {
        return null;
      }
      return TextEditingController.fromValue(value!);
    },
    "TextEditingDelta.fromJSON": () {
      final encoded =
          getValue(maps["0"], datas, "Map<String,   dynamic>", vars, props);
      if (encoded == null) {
        return null;
      }
      return TextEditingDelta.fromJSON(Map<String, dynamic>.from(encoded!));
    },
    "TextEditingDeltaDeletion": () {
      final oldText = getValue(maps["oldText"], datas, "String", vars, props);
      final deletedRange =
          getValue(maps["deletedRange"], datas, "TextRange", vars, props);
      final selection =
          getValue(maps["selection"], datas, "TextSelection", vars, props);
      final composing =
          getValue(maps["composing"], datas, "TextRange", vars, props);
      if (oldText == null ||
          deletedRange == null ||
          selection == null ||
          composing == null) {
        return null;
      }
      return TextEditingDeltaDeletion(
          oldText: oldText!,
          deletedRange: deletedRange!,
          selection: selection!,
          composing: composing!);
    },
    "TextEditingDeltaInsertion": () {
      final oldText = getValue(maps["oldText"], datas, "String", vars, props);
      final textInserted =
          getValue(maps["textInserted"], datas, "String", vars, props);
      final insertionOffset =
          getValue(maps["insertionOffset"], datas, "int", vars, props);
      final selection =
          getValue(maps["selection"], datas, "TextSelection", vars, props);
      final composing =
          getValue(maps["composing"], datas, "TextRange", vars, props);
      if (oldText == null ||
          textInserted == null ||
          insertionOffset == null ||
          selection == null ||
          composing == null) {
        return null;
      }
      return TextEditingDeltaInsertion(
          oldText: oldText!,
          textInserted: textInserted!,
          insertionOffset: insertionOffset!,
          selection: selection!,
          composing: composing!);
    },
    "TextEditingDeltaNonTextUpdate": () {
      final oldText = getValue(maps["oldText"], datas, "String", vars, props);
      final selection =
          getValue(maps["selection"], datas, "TextSelection", vars, props);
      final composing =
          getValue(maps["composing"], datas, "TextRange", vars, props);
      if (oldText == null || selection == null || composing == null) {
        return null;
      }
      return TextEditingDeltaNonTextUpdate(
          oldText: oldText!, selection: selection!, composing: composing!);
    },
    "TextEditingDeltaReplacement": () {
      final oldText = getValue(maps["oldText"], datas, "String", vars, props);
      final replacementText =
          getValue(maps["replacementText"], datas, "String", vars, props);
      final replacedRange =
          getValue(maps["replacedRange"], datas, "TextRange", vars, props);
      final selection =
          getValue(maps["selection"], datas, "TextSelection", vars, props);
      final composing =
          getValue(maps["composing"], datas, "TextRange", vars, props);
      if (oldText == null ||
          replacementText == null ||
          replacedRange == null ||
          selection == null ||
          composing == null) {
        return null;
      }
      return TextEditingDeltaReplacement(
          oldText: oldText!,
          replacementText: replacementText!,
          replacedRange: replacedRange!,
          selection: selection!,
          composing: composing!);
    },
    "TextEditingValue": () {
      final text = getValue(maps["text"], datas, "String", vars, props);
      final selection =
          getValue(maps["selection"], datas, "TextSelection", vars, props);
      final composing =
          getValue(maps["composing"], datas, "TextRange", vars, props);
      return TextEditingValue(
          text: text ?? '',
          selection: selection ?? const TextSelection.collapsed(offset: -1),
          composing: composing ?? TextRange.empty);
    },
    "TextEditingValue.fromJSON": () {
      final encoded =
          getValue(maps["0"], datas, "Map<String,   dynamic>", vars, props);
      if (encoded == null) {
        return null;
      }
      return TextEditingValue.fromJSON(Map<String, dynamic>.from(encoded!));
    },
    "TextField": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final controller = getValue(maps["controller"], datas, "", vars, props);
      final focusNode = getValue(maps["focusNode"], datas, "", vars, props);
      final undoController =
          getValue(maps["undoController"], datas, "", vars, props);
      final decoration = getValue(maps["decoration"], datas, "", vars, props);
      final keyboardType =
          getValue(maps["keyboardType"], datas, "TextInputType?", vars, props);
      final textInputAction =
          getValue(maps["textInputAction"], datas, "", vars, props);
      final textCapitalization =
          getValue(maps["textCapitalization"], datas, "", vars, props);
      final style = getValue(maps["style"], datas, "", vars, props);
      final strutStyle = getValue(maps["strutStyle"], datas, "", vars, props);
      final textAlign = getValue(maps["textAlign"], datas, "", vars, props);
      final textAlignVertical =
          getValue(maps["textAlignVertical"], datas, "", vars, props);
      final textDirection =
          getValue(maps["textDirection"], datas, "", vars, props);
      final readOnly = getValue(maps["readOnly"], datas, "", vars, props);
      final toolbarOptions =
          getValue(maps["toolbarOptions"], datas, "", vars, props);
      final showCursor = getValue(maps["showCursor"], datas, "", vars, props);
      final autofocus = getValue(maps["autofocus"], datas, "", vars, props);
      final obscuringCharacter =
          getValue(maps["obscuringCharacter"], datas, "", vars, props);
      final obscureText = getValue(maps["obscureText"], datas, "", vars, props);
      final autocorrect = getValue(maps["autocorrect"], datas, "", vars, props);
      final smartDashesType = getValue(
          maps["smartDashesType"], datas, "SmartDashesType?", vars, props);
      final smartQuotesType = getValue(
          maps["smartQuotesType"], datas, "SmartQuotesType?", vars, props);
      final enableSuggestions =
          getValue(maps["enableSuggestions"], datas, "", vars, props);
      final maxLines = getValue(maps["maxLines"], datas, "", vars, props);
      final minLines = getValue(maps["minLines"], datas, "", vars, props);
      final expands = getValue(maps["expands"], datas, "", vars, props);
      final maxLength = getValue(maps["maxLength"], datas, "", vars, props);
      final maxLengthEnforcement =
          getValue(maps["maxLengthEnforcement"], datas, "", vars, props);
      final onChanged = getValue(maps["onChanged"], datas, "", vars, props);
      final onEditingComplete =
          getValue(maps["onEditingComplete"], datas, "", vars, props);
      final onSubmitted = getValue(maps["onSubmitted"], datas, "", vars, props);
      final onAppPrivateCommand =
          getValue(maps["onAppPrivateCommand"], datas, "", vars, props);
      final inputFormatters =
          getValue(maps["inputFormatters"], datas, "", vars, props);
      final enabled = getValue(maps["enabled"], datas, "", vars, props);
      final cursorWidth = getValue(maps["cursorWidth"], datas, "", vars, props);
      final cursorHeight =
          getValue(maps["cursorHeight"], datas, "", vars, props);
      final cursorRadius =
          getValue(maps["cursorRadius"], datas, "", vars, props);
      final cursorOpacityAnimates =
          getValue(maps["cursorOpacityAnimates"], datas, "", vars, props);
      final cursorColor = getValue(maps["cursorColor"], datas, "", vars, props);
      final selectionHeightStyle =
          getValue(maps["selectionHeightStyle"], datas, "", vars, props);
      final selectionWidthStyle =
          getValue(maps["selectionWidthStyle"], datas, "", vars, props);
      final keyboardAppearance =
          getValue(maps["keyboardAppearance"], datas, "", vars, props);
      final scrollPadding =
          getValue(maps["scrollPadding"], datas, "", vars, props);
      final dragStartBehavior =
          getValue(maps["dragStartBehavior"], datas, "", vars, props);
      final enableInteractiveSelection = getValue(
          maps["enableInteractiveSelection"], datas, "bool?", vars, props);
      final selectionControls =
          getValue(maps["selectionControls"], datas, "", vars, props);
      final onTap = getValue(maps["onTap"], datas, "", vars, props);
      final onTapOutside =
          getValue(maps["onTapOutside"], datas, "", vars, props);
      final mouseCursor = getValue(maps["mouseCursor"], datas, "", vars, props);
      final buildCounter =
          getValue(maps["buildCounter"], datas, "", vars, props);
      final scrollController =
          getValue(maps["scrollController"], datas, "", vars, props);
      final scrollPhysics =
          getValue(maps["scrollPhysics"], datas, "", vars, props);
      final autofillHints =
          getValue(maps["autofillHints"], datas, "", vars, props);
      final contentInsertionConfiguration = getValue(
          maps["contentInsertionConfiguration"], datas, "", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "", vars, props);
      final restorationId =
          getValue(maps["restorationId"], datas, "", vars, props);
      final scribbleEnabled =
          getValue(maps["scribbleEnabled"], datas, "", vars, props);
      final enableIMEPersonalizedLearning = getValue(
          maps["enableIMEPersonalizedLearning"], datas, "", vars, props);
      final contextMenuBuilder =
          getValue(maps["contextMenuBuilder"], datas, "", vars, props);
      final canRequestFocus =
          getValue(maps["canRequestFocus"], datas, "", vars, props);
      final spellCheckConfiguration =
          getValue(maps["spellCheckConfiguration"], datas, "", vars, props);
      final magnifierConfiguration =
          getValue(maps["magnifierConfiguration"], datas, "", vars, props);
      return TextField(
          key: key,
          controller: controller,
          focusNode: focusNode,
          undoController: undoController,
          decoration: decoration ?? const InputDecoration(),
          keyboardType: keyboardType,
          textInputAction: textInputAction,
          textCapitalization: textCapitalization ?? TextCapitalization.none,
          style: style,
          strutStyle: strutStyle,
          textAlign: textAlign ?? TextAlign.start,
          textAlignVertical: textAlignVertical,
          textDirection: textDirection,
          readOnly: readOnly ?? false,
          toolbarOptions: toolbarOptions,
          showCursor: showCursor,
          autofocus: autofocus ?? false,
          obscuringCharacter: obscuringCharacter ?? '•',
          obscureText: obscureText ?? false,
          autocorrect: autocorrect ?? true,
          smartDashesType: smartDashesType,
          smartQuotesType: smartQuotesType,
          enableSuggestions: enableSuggestions ?? true,
          maxLines: maxLines ?? 1,
          minLines: minLines,
          expands: expands ?? false,
          maxLength: maxLength,
          maxLengthEnforcement: maxLengthEnforcement,
          onChanged: onChanged,
          onEditingComplete: onEditingComplete,
          onSubmitted: onSubmitted,
          onAppPrivateCommand: onAppPrivateCommand,
          inputFormatters: inputFormatters,
          enabled: enabled,
          cursorWidth: cursorWidth ?? 2.0,
          cursorHeight: cursorHeight,
          cursorRadius: cursorRadius,
          cursorOpacityAnimates: cursorOpacityAnimates,
          cursorColor: cursorColor,
          selectionHeightStyle: selectionHeightStyle ?? ui.BoxHeightStyle.tight,
          selectionWidthStyle: selectionWidthStyle ?? ui.BoxWidthStyle.tight,
          keyboardAppearance: keyboardAppearance,
          scrollPadding: scrollPadding ?? const EdgeInsets.all(20.0),
          dragStartBehavior: dragStartBehavior ?? DragStartBehavior.start,
          enableInteractiveSelection: enableInteractiveSelection,
          selectionControls: selectionControls,
          onTap: onTap,
          onTapOutside: onTapOutside,
          mouseCursor: mouseCursor,
          buildCounter: buildCounter,
          scrollController: scrollController,
          scrollPhysics: scrollPhysics,
          autofillHints: autofillHints ?? const <String>[],
          contentInsertionConfiguration: contentInsertionConfiguration,
          clipBehavior: clipBehavior ?? Clip.hardEdge,
          restorationId: restorationId,
          scribbleEnabled: scribbleEnabled ?? true,
          enableIMEPersonalizedLearning: enableIMEPersonalizedLearning ?? true,
          contextMenuBuilder: contextMenuBuilder ?? _defaultContextMenuBuilder,
          canRequestFocus: canRequestFocus ?? true,
          spellCheckConfiguration: spellCheckConfiguration,
          magnifierConfiguration: magnifierConfiguration);
    },
    "TextFieldTapRegion": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      final enabled = getValue(maps["enabled"], datas, "bool", vars, props);
      final onTapOutside = getValue(
          maps["onTapOutside"], datas, "TapRegionCallback?", vars, props);
      final onTapInside = getValue(
          maps["onTapInside"], datas, "TapRegionCallback?", vars, props);
      final debugLabel =
          getValue(maps["debugLabel"], datas, "String?", vars, props);
      if (child == null) {
        return null;
      }
      return TextFieldTapRegion(
          key: key,
          child: child!,
          enabled: enabled ?? true,
          onTapOutside: onTapOutside,
          onTapInside: onTapInside,
          debugLabel: debugLabel);
    },
    "TextFormField": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final controller = getValue(maps["controller"], datas, "", vars, props);
      final initialValue =
          getValue(maps["initialValue"], datas, "String?", vars, props);
      final focusNode =
          getValue(maps["focusNode"], datas, "FocusNode?", vars, props);
      final decoration =
          getValue(maps["decoration"], datas, "InputDecoration?", vars, props);
      final keyboardType =
          getValue(maps["keyboardType"], datas, "TextInputType?", vars, props);
      final textCapitalization = getValue(
          maps["textCapitalization"], datas, "TextCapitalization", vars, props);
      final textInputAction = getValue(
          maps["textInputAction"], datas, "TextInputAction?", vars, props);
      final style = getValue(maps["style"], datas, "TextStyle?", vars, props);
      final strutStyle =
          getValue(maps["strutStyle"], datas, "StrutStyle?", vars, props);
      final textDirection =
          getValue(maps["textDirection"], datas, "TextDirection?", vars, props);
      final textAlign =
          getValue(maps["textAlign"], datas, "TextAlign", vars, props);
      final textAlignVertical = getValue(
          maps["textAlignVertical"], datas, "TextAlignVertical?", vars, props);
      final autofocus = getValue(maps["autofocus"], datas, "bool", vars, props);
      final readOnly = getValue(maps["readOnly"], datas, "bool", vars, props);
      final toolbarOptions = getValue(
          maps["toolbarOptions"], datas, "ToolbarOptions?", vars, props);
      final showCursor =
          getValue(maps["showCursor"], datas, "bool?", vars, props);
      final obscuringCharacter =
          getValue(maps["obscuringCharacter"], datas, "String", vars, props);
      final obscureText =
          getValue(maps["obscureText"], datas, "bool", vars, props);
      final autocorrect =
          getValue(maps["autocorrect"], datas, "bool", vars, props);
      final smartDashesType = getValue(
          maps["smartDashesType"], datas, "SmartDashesType?", vars, props);
      final smartQuotesType = getValue(
          maps["smartQuotesType"], datas, "SmartQuotesType?", vars, props);
      final enableSuggestions =
          getValue(maps["enableSuggestions"], datas, "bool", vars, props);
      final maxLengthEnforcement = getValue(maps["maxLengthEnforcement"], datas,
          "MaxLengthEnforcement?", vars, props);
      final maxLines = getValue(maps["maxLines"], datas, "int?", vars, props);
      final minLines = getValue(maps["minLines"], datas, "int?", vars, props);
      final expands = getValue(maps["expands"], datas, "bool", vars, props);
      final maxLength = getValue(maps["maxLength"], datas, "int?", vars, props);
      final onChanged = getValue(
          maps["onChanged"], datas, "ValueChanged<String>?", vars, props);
      final onTap =
          getValue(maps["onTap"], datas, "GestureTapCallback?", vars, props);
      final onTapOutside = getValue(
          maps["onTapOutside"], datas, "TapRegionCallback?", vars, props);
      final onEditingComplete = getValue(
          maps["onEditingComplete"], datas, "VoidCallback?", vars, props);
      final onFieldSubmitted = getValue(maps["onFieldSubmitted"], datas,
          "ValueChanged<String>?", vars, props);
      final onSaved =
          getValue(maps["onSaved"], datas, "FormFieldSetter<T>?", vars, props);
      final validator = getValue(
          maps["validator"], datas, "FormFieldValidator<T>?", vars, props);
      final inputFormatters = getValue(maps["inputFormatters"], datas,
          "List<TextInputFormatter>?", vars, props);
      final enabled = getValue(maps["enabled"], datas, "bool?", vars, props);
      final cursorWidth =
          getValue(maps["cursorWidth"], datas, "double", vars, props);
      final cursorHeight =
          getValue(maps["cursorHeight"], datas, "double?", vars, props);
      final cursorRadius =
          getValue(maps["cursorRadius"], datas, "Radius?", vars, props);
      final cursorColor =
          getValue(maps["cursorColor"], datas, "Color?", vars, props);
      final keyboardAppearance = getValue(
          maps["keyboardAppearance"], datas, "Brightness?", vars, props);
      final scrollPadding =
          getValue(maps["scrollPadding"], datas, "EdgeInsets", vars, props);
      final enableInteractiveSelection = getValue(
          maps["enableInteractiveSelection"], datas, "bool?", vars, props);
      final selectionControls = getValue(maps["selectionControls"], datas,
          "TextSelectionControls?", vars, props);
      final buildCounter = getValue(maps["buildCounter"], datas,
          "InputCounterWidgetBuilder?", vars, props);
      final scrollPhysics =
          getValue(maps["scrollPhysics"], datas, "ScrollPhysics?", vars, props);
      final autofillHints = getValue(
          maps["autofillHints"], datas, "Iterable<String>?", vars, props);
      final autovalidateMode = getValue(
          maps["autovalidateMode"], datas, "AutovalidateMode?", vars, props);
      final scrollController = getValue(
          maps["scrollController"], datas, "ScrollController?", vars, props);
      final restorationId =
          getValue(maps["restorationId"], datas, "String?", vars, props);
      final enableIMEPersonalizedLearning = getValue(
          maps["enableIMEPersonalizedLearning"], datas, "bool", vars, props);
      final mouseCursor =
          getValue(maps["mouseCursor"], datas, "MouseCursor?", vars, props);
      final contextMenuBuilder = getValue(maps["contextMenuBuilder"], datas,
          "EditableTextContextMenuBuilder?", vars, props);
      final spellCheckConfiguration = getValue(maps["spellCheckConfiguration"],
          datas, "SpellCheckConfiguration?", vars, props);
      final magnifierConfiguration = getValue(maps["magnifierConfiguration"],
          datas, "TextMagnifierConfiguration?", vars, props);
      return TextFormField(
          key: key,
          controller: controller,
          initialValue: initialValue,
          focusNode: focusNode,
          decoration: decoration ?? const InputDecoration(),
          keyboardType: keyboardType,
          textCapitalization: textCapitalization ?? TextCapitalization.none,
          textInputAction: textInputAction,
          style: style,
          strutStyle: strutStyle,
          textDirection: textDirection,
          textAlign: textAlign ?? TextAlign.start,
          textAlignVertical: textAlignVertical,
          autofocus: autofocus ?? false,
          readOnly: readOnly ?? false,
          toolbarOptions: toolbarOptions,
          showCursor: showCursor,
          obscuringCharacter: obscuringCharacter ?? '•',
          obscureText: obscureText ?? false,
          autocorrect: autocorrect ?? true,
          smartDashesType: smartDashesType,
          smartQuotesType: smartQuotesType,
          enableSuggestions: enableSuggestions ?? true,
          maxLengthEnforcement: maxLengthEnforcement,
          maxLines: maxLines ?? 1,
          minLines: minLines,
          expands: expands ?? false,
          maxLength: maxLength,
          onChanged: onChanged,
          onTap: onTap,
          onTapOutside: onTapOutside,
          onEditingComplete: onEditingComplete,
          onFieldSubmitted: onFieldSubmitted,
          onSaved: onSaved,
          validator: validator,
          inputFormatters: inputFormatters != null
              ? List<TextInputFormatter>.from(inputFormatters)
              : null,
          enabled: enabled,
          cursorWidth: cursorWidth ?? 2.0,
          cursorHeight: cursorHeight,
          cursorRadius: cursorRadius,
          cursorColor: cursorColor,
          keyboardAppearance: keyboardAppearance,
          scrollPadding: scrollPadding ?? const EdgeInsets.all(20.0),
          enableInteractiveSelection: enableInteractiveSelection,
          selectionControls: selectionControls,
          buildCounter: buildCounter,
          scrollPhysics: scrollPhysics,
          autofillHints: autofillHints,
          autovalidateMode: autovalidateMode,
          scrollController: scrollController,
          restorationId: restorationId,
          enableIMEPersonalizedLearning: enableIMEPersonalizedLearning ?? true,
          mouseCursor: mouseCursor,
          contextMenuBuilder: contextMenuBuilder ?? _defaultContextMenuBuilder,
          spellCheckConfiguration: spellCheckConfiguration,
          magnifierConfiguration: magnifierConfiguration);
    },
    "TextHeightBehavior": () {
      final applyHeightToFirstAscent = getValue(
          maps["applyHeightToFirstAscent"], datas, "bool", vars, props);
      final applyHeightToLastDescent = getValue(
          maps["applyHeightToLastDescent"], datas, "bool", vars, props);
      final leadingDistribution = getValue(maps["leadingDistribution"], datas,
          "TextLeadingDistribution", vars, props);
      return TextHeightBehavior(
          applyHeightToFirstAscent: applyHeightToFirstAscent ?? true,
          applyHeightToLastDescent: applyHeightToLastDescent ?? true,
          leadingDistribution:
              leadingDistribution ?? TextLeadingDistribution.proportional);
    },
    "TextInputConfiguration": () {
      final inputType =
          getValue(maps["inputType"], datas, "TextInputType", vars, props);
      final readOnly = getValue(maps["readOnly"], datas, "bool", vars, props);
      final obscureText =
          getValue(maps["obscureText"], datas, "bool", vars, props);
      final autocorrect =
          getValue(maps["autocorrect"], datas, "bool", vars, props);
      final smartDashesType = getValue(
          maps["smartDashesType"], datas, "SmartDashesType?", vars, props);
      final smartQuotesType = getValue(
          maps["smartQuotesType"], datas, "SmartQuotesType?", vars, props);
      final enableSuggestions =
          getValue(maps["enableSuggestions"], datas, "bool", vars, props);
      final enableInteractiveSelection = getValue(
          maps["enableInteractiveSelection"], datas, "bool", vars, props);
      final actionLabel =
          getValue(maps["actionLabel"], datas, "String?", vars, props);
      final inputAction =
          getValue(maps["inputAction"], datas, "TextInputAction", vars, props);
      final keyboardAppearance = getValue(
          maps["keyboardAppearance"], datas, "Brightness", vars, props);
      final textCapitalization = getValue(
          maps["textCapitalization"], datas, "TextCapitalization", vars, props);
      final autofillConfiguration = getValue(maps["autofillConfiguration"],
          datas, "AutofillConfiguration", vars, props);
      final enableIMEPersonalizedLearning = getValue(
          maps["enableIMEPersonalizedLearning"], datas, "bool", vars, props);
      final allowedMimeTypes = getValue(
          maps["allowedMimeTypes"], datas, "List<String>", vars, props);
      final enableDeltaModel =
          getValue(maps["enableDeltaModel"], datas, "bool", vars, props);
      return TextInputConfiguration(
          inputType: inputType ?? TextInputType.text,
          readOnly: readOnly ?? false,
          obscureText: obscureText ?? false,
          autocorrect: autocorrect ?? true,
          smartDashesType: smartDashesType,
          smartQuotesType: smartQuotesType,
          enableSuggestions: enableSuggestions ?? true,
          enableInteractiveSelection: enableInteractiveSelection ?? true,
          actionLabel: actionLabel,
          inputAction: inputAction ?? TextInputAction.done,
          keyboardAppearance: keyboardAppearance ?? Brightness.light,
          textCapitalization: textCapitalization ?? TextCapitalization.none,
          autofillConfiguration:
              autofillConfiguration ?? AutofillConfiguration.disabled,
          enableIMEPersonalizedLearning: enableIMEPersonalizedLearning ?? true,
          allowedMimeTypes:
              List<String>.from(allowedMimeTypes ?? const <String>[]),
          enableDeltaModel: enableDeltaModel ?? false);
    },
    "TextInputType.numberWithOptions": () {
      final signed = getValue(maps["signed"], datas, "bool?", vars, props);
      final decimal = getValue(maps["decimal"], datas, "bool?", vars, props);
      return TextInputType.numberWithOptions(
          signed: signed ?? false, decimal: decimal ?? false);
    },
    "TextMagnifier": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final magnifierInfo = getValue(maps["magnifierInfo"], datas,
          "ValueNotifier<MagnifierInfo>", vars, props);
      if (magnifierInfo == null) {
        return null;
      }
      return TextMagnifier(key: key, magnifierInfo: magnifierInfo!);
    },
    "TextMagnifierConfiguration": () {
      final magnifierBuilder = getValue(
          maps["magnifierBuilder"], datas, "MagnifierBuilder?", vars, props);
      final shouldDisplayHandlesInMagnifier = getValue(
          maps["shouldDisplayHandlesInMagnifier"], datas, "bool", vars, props);
      return TextMagnifierConfiguration(
          magnifierBuilder: magnifierBuilder,
          shouldDisplayHandlesInMagnifier:
              shouldDisplayHandlesInMagnifier ?? true);
    },
    "TextPainter": () {
      final text = getValue(maps["text"], datas, "InlineSpan?", vars, props);
      final textAlign =
          getValue(maps["textAlign"], datas, "TextAlign", vars, props);
      final textDirection =
          getValue(maps["textDirection"], datas, "TextDirection?", vars, props);
      final textScaleFactor =
          getValue(maps["textScaleFactor"], datas, "double", vars, props);
      final maxLines = getValue(maps["maxLines"], datas, "int?", vars, props);
      final ellipsis =
          getValue(maps["ellipsis"], datas, "String?", vars, props);
      final locale = getValue(maps["locale"], datas, "Locale?", vars, props);
      final strutStyle =
          getValue(maps["strutStyle"], datas, "StrutStyle?", vars, props);
      final textWidthBasis = getValue(
          maps["textWidthBasis"], datas, "TextWidthBasis", vars, props);
      final textHeightBehavior = getValue(maps["textHeightBehavior"], datas,
          "TextHeightBehavior?", vars, props);
      return TextPainter(
          text: text,
          textAlign: textAlign ?? TextAlign.start,
          textDirection: textDirection,
          textScaleFactor: textScaleFactor ?? 1.0,
          maxLines: maxLines,
          ellipsis: ellipsis,
          locale: locale,
          strutStyle: strutStyle,
          textWidthBasis: textWidthBasis ?? TextWidthBasis.parent,
          textHeightBehavior: textHeightBehavior);
    },
    "TextPosition": () {
      final offset = getValue(maps["offset"], datas, "int", vars, props);
      final affinity =
          getValue(maps["affinity"], datas, "TextAffinity", vars, props);
      if (offset == null) {
        return null;
      }
      return TextPosition(
          offset: offset!, affinity: affinity ?? TextAffinity.downstream);
    },
    "TextRange": () {
      final start = getValue(maps["start"], datas, "int", vars, props);
      final end = getValue(maps["end"], datas, "int", vars, props);
      if (start == null || end == null) {
        return null;
      }
      return TextRange(start: start!, end: end!);
    },
    "TextRange.collapsed": () {
      final offset = getValue(maps["0"], datas, "int", vars, props);
      if (offset == null) {
        return null;
      }
      return TextRange.collapsed(offset!);
    },
    "TextSelection": () {
      final baseOffset =
          getValue(maps["baseOffset"], datas, "int", vars, props);
      final extentOffset =
          getValue(maps["extentOffset"], datas, "int", vars, props);
      final affinity =
          getValue(maps["affinity"], datas, "TextAffinity", vars, props);
      final isDirectional =
          getValue(maps["isDirectional"], datas, "bool", vars, props);
      if (baseOffset == null || extentOffset == null) {
        return null;
      }
      return TextSelection(
          baseOffset: baseOffset!,
          extentOffset: extentOffset!,
          affinity: affinity ?? TextAffinity.downstream,
          isDirectional: isDirectional ?? false);
    },
    "TextSelection.collapsed": () {
      final offset = getValue(maps["offset"], datas, "int", vars, props);
      final affinity =
          getValue(maps["affinity"], datas, "TextAffinity", vars, props);
      if (offset == null) {
        return null;
      }
      return TextSelection.collapsed(
          offset: offset!, affinity: affinity ?? TextAffinity.downstream);
    },
    "TextSelection.fromPosition": () {
      final position = getValue(maps["0"], datas, "TextPosition", vars, props);
      if (position == null) {
        return null;
      }
      return TextSelection.fromPosition(position!);
    },
    "TextSelectionGestureDetector": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final onTapDown = getValue(
          maps["onTapDown"], datas, "GestureTapDragDownCallback?", vars, props);
      final onForcePressStart = getValue(maps["onForcePressStart"], datas,
          "GestureForcePressStartCallback?", vars, props);
      final onForcePressEnd = getValue(maps["onForcePressEnd"], datas,
          "GestureForcePressEndCallback?", vars, props);
      final onSecondaryTap = getValue(
          maps["onSecondaryTap"], datas, "GestureTapCallback?", vars, props);
      final onSecondaryTapDown = getValue(maps["onSecondaryTapDown"], datas,
          "GestureTapDownCallback?", vars, props);
      final onSingleTapUp = getValue(maps["onSingleTapUp"], datas,
          "GestureTapDragUpCallback?", vars, props);
      final onSingleTapCancel = getValue(maps["onSingleTapCancel"], datas,
          "GestureCancelCallback?", vars, props);
      final onSingleLongTapStart = getValue(maps["onSingleLongTapStart"], datas,
          "GestureLongPressStartCallback?", vars, props);
      final onSingleLongTapMoveUpdate = getValue(
          maps["onSingleLongTapMoveUpdate"],
          datas,
          "GestureLongPressMoveUpdateCallback?",
          vars,
          props);
      final onSingleLongTapEnd = getValue(maps["onSingleLongTapEnd"], datas,
          "GestureLongPressEndCallback?", vars, props);
      final onDoubleTapDown = getValue(maps["onDoubleTapDown"], datas,
          "GestureTapDragDownCallback?", vars, props);
      final onTripleTapDown = getValue(maps["onTripleTapDown"], datas,
          "GestureTapDragDownCallback?", vars, props);
      final onDragSelectionStart = getValue(maps["onDragSelectionStart"], datas,
          "GestureTapDragStartCallback?", vars, props);
      final onDragSelectionUpdate = getValue(maps["onDragSelectionUpdate"],
          datas, "GestureTapDragUpdateCallback?", vars, props);
      final onDragSelectionEnd = getValue(maps["onDragSelectionEnd"], datas,
          "GestureTapDragEndCallback?", vars, props);
      final behavior =
          getValue(maps["behavior"], datas, "HitTestBehavior?", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (child == null) {
        return null;
      }
      return TextSelectionGestureDetector(
          key: key,
          onTapDown: onTapDown,
          onForcePressStart: onForcePressStart,
          onForcePressEnd: onForcePressEnd,
          onSecondaryTap: onSecondaryTap,
          onSecondaryTapDown: onSecondaryTapDown,
          onSingleTapUp: onSingleTapUp,
          onSingleTapCancel: onSingleTapCancel,
          onSingleLongTapStart: onSingleLongTapStart,
          onSingleLongTapMoveUpdate: onSingleLongTapMoveUpdate,
          onSingleLongTapEnd: onSingleLongTapEnd,
          onDoubleTapDown: onDoubleTapDown,
          onTripleTapDown: onTripleTapDown,
          onDragSelectionStart: onDragSelectionStart,
          onDragSelectionUpdate: onDragSelectionUpdate,
          onDragSelectionEnd: onDragSelectionEnd,
          behavior: behavior,
          child: child!);
    },
    "TextSelectionGestureDetectorBuilder": () {
      final delegate = getValue(maps["delegate"], datas,
          "TextSelectionGestureDetectorBuilderDelegate", vars, props);
      if (delegate == null) {
        return null;
      }
      return TextSelectionGestureDetectorBuilder(delegate: delegate!);
    },
    "TextSelectionOverlay": () {
      final value =
          getValue(maps["value"], datas, "TextEditingValue", vars, props);
      final context =
          getValue(maps["context"], datas, "BuildContext", vars, props);
      final debugRequiredFor =
          getValue(maps["debugRequiredFor"], datas, "Widget?", vars, props);
      final toolbarLayerLink =
          getValue(maps["toolbarLayerLink"], datas, "LayerLink", vars, props);
      final startHandleLayerLink = getValue(
          maps["startHandleLayerLink"], datas, "LayerLink", vars, props);
      final endHandleLayerLink =
          getValue(maps["endHandleLayerLink"], datas, "LayerLink", vars, props);
      final renderObject =
          getValue(maps["renderObject"], datas, "RenderEditable", vars, props);
      final selectionControls = getValue(maps["selectionControls"], datas,
          "TextSelectionControls?", vars, props);
      final handlesVisible =
          getValue(maps["handlesVisible"], datas, "bool", vars, props);
      final selectionDelegate = getValue(maps["selectionDelegate"], datas,
          "TextSelectionDelegate", vars, props);
      final dragStartBehavior = getValue(
          maps["dragStartBehavior"], datas, "DragStartBehavior", vars, props);
      final onSelectionHandleTapped = getValue(
          maps["onSelectionHandleTapped"], datas, "VoidCallback?", vars, props);
      final clipboardStatus = getValue(maps["clipboardStatus"], datas,
          "ClipboardStatusNotifier?", vars, props);
      final contextMenuBuilder = getValue(
          maps["contextMenuBuilder"], datas, "WidgetBuilder?", vars, props);
      final magnifierConfiguration = getValue(maps["magnifierConfiguration"],
          datas, "TextMagnifierConfiguration", vars, props);
      if (value == null ||
          context == null ||
          toolbarLayerLink == null ||
          startHandleLayerLink == null ||
          endHandleLayerLink == null ||
          renderObject == null ||
          selectionDelegate == null ||
          magnifierConfiguration == null) {
        return null;
      }
      return TextSelectionOverlay(
          value: value!,
          context: context!,
          debugRequiredFor: debugRequiredFor,
          toolbarLayerLink: toolbarLayerLink!,
          startHandleLayerLink: startHandleLayerLink!,
          endHandleLayerLink: endHandleLayerLink!,
          renderObject: renderObject!,
          selectionControls: selectionControls,
          handlesVisible: handlesVisible ?? false,
          selectionDelegate: selectionDelegate!,
          dragStartBehavior: dragStartBehavior ?? DragStartBehavior.start,
          onSelectionHandleTapped: onSelectionHandleTapped,
          clipboardStatus: clipboardStatus,
          contextMenuBuilder: contextMenuBuilder,
          magnifierConfiguration: magnifierConfiguration!);
    },
    "TextSelectionPoint": () {
      final point = getValue(maps["0"], datas, "Offset", vars, props);
      final direction =
          getValue(maps["1"], datas, "TextDirection?", vars, props);
      if (point == null || direction == null) {
        return null;
      }
      return TextSelectionPoint(point!, direction!);
    },
    "TextSelectionTheme": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final data =
          getValue(maps["data"], datas, "TextSelectionThemeData", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (data == null || child == null) {
        return null;
      }
      return TextSelectionTheme(key: key, data: data!, child: child!);
    },
    "TextSelectionThemeData": () {
      final cursorColor =
          getValue(maps["cursorColor"], datas, "Color?", vars, props);
      final selectionColor =
          getValue(maps["selectionColor"], datas, "Color?", vars, props);
      final selectionHandleColor =
          getValue(maps["selectionHandleColor"], datas, "Color?", vars, props);
      return TextSelectionThemeData(
          cursorColor: cursorColor,
          selectionColor: selectionColor,
          selectionHandleColor: selectionHandleColor);
    },
    "TextSelectionToolbar": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final anchorAbove =
          getValue(maps["anchorAbove"], datas, "Offset", vars, props);
      final anchorBelow =
          getValue(maps["anchorBelow"], datas, "Offset", vars, props);
      final toolbarBuilder = getValue(
          maps["toolbarBuilder"], datas, "ToolbarBuilder", vars, props);
      final children =
          getValue(maps["children"], datas, "List<Widget>", vars, props);
      if (anchorAbove == null || anchorBelow == null || children == null) {
        return null;
      }
      if (toolbarBuilder != null) {
        return TextSelectionToolbar(
            key: key,
            anchorAbove: anchorAbove!,
            anchorBelow: anchorBelow!,
            toolbarBuilder: toolbarBuilder,
            children: List<Widget>.from(children!));
      }
      return TextSelectionToolbar(
          key: key,
          anchorAbove: anchorAbove!,
          anchorBelow: anchorBelow!,
          children: List<Widget>.from(children!));
    },
    "TextSelectionToolbarAnchors": () {
      final primaryAnchor =
          getValue(maps["primaryAnchor"], datas, "Offset", vars, props);
      final secondaryAnchor =
          getValue(maps["secondaryAnchor"], datas, "Offset?", vars, props);
      if (primaryAnchor == null) {
        return null;
      }
      return TextSelectionToolbarAnchors(
          primaryAnchor: primaryAnchor!, secondaryAnchor: secondaryAnchor);
    },
    "TextSelectionToolbarAnchors.fromSelection": () {
      final renderBox =
          getValue(maps["renderBox"], datas, "RenderBox", vars, props);
      final startGlyphHeight =
          getValue(maps["startGlyphHeight"], datas, "double", vars, props);
      final endGlyphHeight =
          getValue(maps["endGlyphHeight"], datas, "double", vars, props);
      final selectionEndpoints = getValue(maps["selectionEndpoints"], datas,
          "List<TextSelectionPoint>", vars, props);
      if (renderBox == null ||
          startGlyphHeight == null ||
          endGlyphHeight == null ||
          selectionEndpoints == null) {
        return null;
      }
      return TextSelectionToolbarAnchors.fromSelection(
          renderBox: renderBox!,
          startGlyphHeight: startGlyphHeight!,
          endGlyphHeight: endGlyphHeight!,
          selectionEndpoints:
              List<TextSelectionPoint>.from(selectionEndpoints!));
    },
    "TextSelectionToolbarLayoutDelegate": () {
      final anchorAbove =
          getValue(maps["anchorAbove"], datas, "Offset", vars, props);
      final anchorBelow =
          getValue(maps["anchorBelow"], datas, "Offset", vars, props);
      final fitsAbove =
          getValue(maps["fitsAbove"], datas, "bool?", vars, props);
      if (anchorAbove == null || anchorBelow == null) {
        return null;
      }
      return TextSelectionToolbarLayoutDelegate(
          anchorAbove: anchorAbove!,
          anchorBelow: anchorBelow!,
          fitsAbove: fitsAbove);
    },
    "TextSelectionToolbarTextButton": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      final padding =
          getValue(maps["padding"], datas, "EdgeInsets", vars, props);
      final onPressed =
          getValue(maps["onPressed"], datas, "VoidCallback?", vars, props);
      final alignment =
          getValue(maps["alignment"], datas, "AlignmentGeometry?", vars, props);
      if (child == null || padding == null) {
        return null;
      }
      return TextSelectionToolbarTextButton(
          key: key,
          child: child!,
          padding: padding!,
          onPressed: onPressed,
          alignment: alignment);
    },
    "TextSpan": () {
      final text = getValue(maps["text"], datas, "String?", vars, props);
      final children =
          getValue(maps["children"], datas, "List<InlineSpan>?", vars, props);
      final style = getValue(maps["style"], datas, "TextStyle?", vars, props);
      final recognizer = getValue(
          maps["recognizer"], datas, "GestureRecognizer?", vars, props);
      final mouseCursor =
          getValue(maps["mouseCursor"], datas, "MouseCursor?", vars, props);
      final onEnter = getValue(
          maps["onEnter"], datas, "PointerEnterEventListener?", vars, props);
      final onExit = getValue(
          maps["onExit"], datas, "PointerExitEventListener?", vars, props);
      final semanticsLabel =
          getValue(maps["semanticsLabel"], datas, "String?", vars, props);
      final locale = getValue(maps["locale"], datas, "Locale?", vars, props);
      final spellOut = getValue(maps["spellOut"], datas, "bool?", vars, props);
      return TextSpan(
          text: text,
          children: children != null ? List<InlineSpan>.from(children) : null,
          style: style,
          recognizer: recognizer,
          mouseCursor: mouseCursor,
          onEnter: onEnter,
          onExit: onExit,
          semanticsLabel: semanticsLabel,
          locale: locale,
          spellOut: spellOut);
    },
    "TextStyle": () {
      final color = getValue(maps["color"], datas, "Color?", vars, props);
      final decoration =
          getValue(maps["decoration"], datas, "TextDecoration?", vars, props);
      final decorationColor =
          getValue(maps["decorationColor"], datas, "Color?", vars, props);
      final decorationStyle = getValue(
          maps["decorationStyle"], datas, "TextDecorationStyle?", vars, props);
      final decorationThickness =
          getValue(maps["decorationThickness"], datas, "double?", vars, props);
      final fontWeight =
          getValue(maps["fontWeight"], datas, "FontWeight?", vars, props);
      final fontStyle =
          getValue(maps["fontStyle"], datas, "FontStyle?", vars, props);
      final textBaseline =
          getValue(maps["textBaseline"], datas, "TextBaseline?", vars, props);
      final fontFamily =
          getValue(maps["fontFamily"], datas, "String?", vars, props);
      final fontFamilyFallback = getValue(
          maps["fontFamilyFallback"], datas, "List<String>?", vars, props);
      final fontSize =
          getValue(maps["fontSize"], datas, "double?", vars, props);
      final letterSpacing =
          getValue(maps["letterSpacing"], datas, "double?", vars, props);
      final wordSpacing =
          getValue(maps["wordSpacing"], datas, "double?", vars, props);
      final height = getValue(maps["height"], datas, "double?", vars, props);
      final leadingDistribution = getValue(maps["leadingDistribution"], datas,
          "TextLeadingDistribution?", vars, props);
      final locale = getValue(maps["locale"], datas, "Locale?", vars, props);
      final background =
          getValue(maps["background"], datas, "Paint?", vars, props);
      final foreground =
          getValue(maps["foreground"], datas, "Paint?", vars, props);
      final shadows =
          getValue(maps["shadows"], datas, "List<Shadow>?", vars, props);
      final fontFeatures = getValue(
          maps["fontFeatures"], datas, "List<FontFeature>?", vars, props);
      final fontVariations = getValue(
          maps["fontVariations"], datas, "List<FontVariation>?", vars, props);
      return TextStyle(
          color: color,
          decoration: decoration,
          decorationColor: decorationColor,
          decorationStyle: decorationStyle,
          decorationThickness: decorationThickness,
          fontWeight: fontWeight,
          fontStyle: fontStyle,
          textBaseline: textBaseline,
          fontFamily: fontFamily,
          fontFamilyFallback: fontFamilyFallback != null
              ? List<String>.from(fontFamilyFallback)
              : null,
          fontSize: fontSize,
          letterSpacing: letterSpacing,
          wordSpacing: wordSpacing,
          height: height,
          leadingDistribution: leadingDistribution,
          locale: locale,
          background: background,
          foreground: foreground,
          shadows: shadows != null ? List<Shadow>.from(shadows) : null,
          fontFeatures: fontFeatures != null
              ? List<ui.FontFeature>.from(fontFeatures)
              : null,
          fontVariations: fontVariations != null
              ? List<ui.FontVariation>.from(fontVariations)
              : null);
    },
    "TextStyle": () {
      final color = getValue(maps["color"], datas, "Color?", vars, props);
      final decoration =
          getValue(maps["decoration"], datas, "TextDecoration?", vars, props);
      final decorationColor =
          getValue(maps["decorationColor"], datas, "Color?", vars, props);
      final decorationStyle = getValue(
          maps["decorationStyle"], datas, "TextDecorationStyle?", vars, props);
      final decorationThickness =
          getValue(maps["decorationThickness"], datas, "double?", vars, props);
      final fontWeight =
          getValue(maps["fontWeight"], datas, "FontWeight?", vars, props);
      final fontStyle =
          getValue(maps["fontStyle"], datas, "FontStyle?", vars, props);
      final textBaseline =
          getValue(maps["textBaseline"], datas, "TextBaseline?", vars, props);
      final fontFamily =
          getValue(maps["fontFamily"], datas, "String?", vars, props);
      final fontFamilyFallback = getValue(
          maps["fontFamilyFallback"], datas, "List<String>?", vars, props);
      final fontSize =
          getValue(maps["fontSize"], datas, "double?", vars, props);
      final letterSpacing =
          getValue(maps["letterSpacing"], datas, "double?", vars, props);
      final wordSpacing =
          getValue(maps["wordSpacing"], datas, "double?", vars, props);
      final height = getValue(maps["height"], datas, "double?", vars, props);
      final leadingDistribution = getValue(maps["leadingDistribution"], datas,
          "TextLeadingDistribution?", vars, props);
      final locale = getValue(maps["locale"], datas, "Locale?", vars, props);
      final background =
          getValue(maps["background"], datas, "Paint?", vars, props);
      final foreground =
          getValue(maps["foreground"], datas, "Paint?", vars, props);
      final shadows =
          getValue(maps["shadows"], datas, "List<Shadow>?", vars, props);
      final fontFeatures = getValue(
          maps["fontFeatures"], datas, "List<FontFeature>?", vars, props);
      final fontVariations = getValue(
          maps["fontVariations"], datas, "List<FontVariation>?", vars, props);
      return TextStyle(
          color: color,
          decoration: decoration,
          decorationColor: decorationColor,
          decorationStyle: decorationStyle,
          decorationThickness: decorationThickness,
          fontWeight: fontWeight,
          fontStyle: fontStyle,
          textBaseline: textBaseline,
          fontFamily: fontFamily,
          fontFamilyFallback: fontFamilyFallback != null
              ? List<String>.from(fontFamilyFallback)
              : null,
          fontSize: fontSize,
          letterSpacing: letterSpacing,
          wordSpacing: wordSpacing,
          height: height,
          leadingDistribution: leadingDistribution,
          locale: locale,
          background: background,
          foreground: foreground,
          shadows: shadows != null ? List<Shadow>.from(shadows) : null,
          fontFeatures: fontFeatures != null
              ? List<ui.FontFeature>.from(fontFeatures)
              : null,
          fontVariations: fontVariations != null
              ? List<ui.FontVariation>.from(fontVariations)
              : null);
    },
    "TextStyleTween": () {
      final begin = getValue(maps["begin"], datas, "T?", vars, props);
      final end = getValue(maps["end"], datas, "T?", vars, props);
      return TextStyleTween(begin: begin, end: end);
    },
    "TextTheme": () {
      final displayLarge =
          getValue(maps["displayLarge"], datas, "TextStyle?", vars, props);
      final displayMedium =
          getValue(maps["displayMedium"], datas, "TextStyle?", vars, props);
      final displaySmall =
          getValue(maps["displaySmall"], datas, "TextStyle?", vars, props);
      final headlineLarge =
          getValue(maps["headlineLarge"], datas, "TextStyle?", vars, props);
      final headlineMedium =
          getValue(maps["headlineMedium"], datas, "TextStyle?", vars, props);
      final headlineSmall =
          getValue(maps["headlineSmall"], datas, "TextStyle?", vars, props);
      final titleLarge =
          getValue(maps["titleLarge"], datas, "TextStyle?", vars, props);
      final titleMedium =
          getValue(maps["titleMedium"], datas, "TextStyle?", vars, props);
      final titleSmall =
          getValue(maps["titleSmall"], datas, "TextStyle?", vars, props);
      final bodyLarge =
          getValue(maps["bodyLarge"], datas, "TextStyle?", vars, props);
      final bodyMedium =
          getValue(maps["bodyMedium"], datas, "TextStyle?", vars, props);
      final bodySmall =
          getValue(maps["bodySmall"], datas, "TextStyle?", vars, props);
      final labelLarge =
          getValue(maps["labelLarge"], datas, "TextStyle?", vars, props);
      final labelMedium =
          getValue(maps["labelMedium"], datas, "TextStyle?", vars, props);
      final labelSmall =
          getValue(maps["labelSmall"], datas, "TextStyle?", vars, props);
      final headline1 =
          getValue(maps["headline1"], datas, "TextStyle?", vars, props);
      final headline2 =
          getValue(maps["headline2"], datas, "TextStyle?", vars, props);
      final headline3 =
          getValue(maps["headline3"], datas, "TextStyle?", vars, props);
      final headline4 =
          getValue(maps["headline4"], datas, "TextStyle?", vars, props);
      final headline5 =
          getValue(maps["headline5"], datas, "TextStyle?", vars, props);
      final headline6 =
          getValue(maps["headline6"], datas, "TextStyle?", vars, props);
      final subtitle1 =
          getValue(maps["subtitle1"], datas, "TextStyle?", vars, props);
      final subtitle2 =
          getValue(maps["subtitle2"], datas, "TextStyle?", vars, props);
      final bodyText1 =
          getValue(maps["bodyText1"], datas, "TextStyle?", vars, props);
      final bodyText2 =
          getValue(maps["bodyText2"], datas, "TextStyle?", vars, props);
      final caption =
          getValue(maps["caption"], datas, "TextStyle?", vars, props);
      final button = getValue(maps["button"], datas, "TextStyle?", vars, props);
      final overline =
          getValue(maps["overline"], datas, "TextStyle?", vars, props);
      return TextTheme(
        displayLarge: displayLarge,
        displayMedium: displayMedium,
        displaySmall: displaySmall,
        headlineLarge: headlineLarge,
        headlineMedium: headlineMedium,
        headlineSmall: headlineSmall,
        titleLarge: titleLarge,
        titleMedium: titleMedium,
        titleSmall: titleSmall,
        bodyLarge: bodyLarge,
        bodyMedium: bodyMedium,
        bodySmall: bodySmall,
        labelLarge: labelLarge,
        labelMedium: labelMedium,
        labelSmall: labelSmall,
        // headline1: headline1,
        // headline2: headline2,
        // headline3: headline3,
        // headline4: headline4,
        // headline5: headline5,
        // headline6: headline6,
        // subtitle1: subtitle1,
        // subtitle2: subtitle2,
        // bodyText1: bodyText1,
        // bodyText2: bodyText2,
        // caption: caption,
        // button: button,
        // overline: overline,
      );
    },
    "TextTreeConfiguration": () {
      final prefixLineOne =
          getValue(maps["prefixLineOne"], datas, "String", vars, props);
      final prefixOtherLines =
          getValue(maps["prefixOtherLines"], datas, "String", vars, props);
      final prefixLastChildLineOne = getValue(
          maps["prefixLastChildLineOne"], datas, "String", vars, props);
      final prefixOtherLinesRootNode = getValue(
          maps["prefixOtherLinesRootNode"], datas, "String", vars, props);
      final linkCharacter =
          getValue(maps["linkCharacter"], datas, "String", vars, props);
      final propertyPrefixIfChildren = getValue(
          maps["propertyPrefixIfChildren"], datas, "String", vars, props);
      final propertyPrefixNoChildren = getValue(
          maps["propertyPrefixNoChildren"], datas, "String", vars, props);
      final lineBreak =
          getValue(maps["lineBreak"], datas, "String", vars, props);
      final lineBreakProperties =
          getValue(maps["lineBreakProperties"], datas, "bool", vars, props);
      final afterName =
          getValue(maps["afterName"], datas, "String", vars, props);
      final afterDescriptionIfBody = getValue(
          maps["afterDescriptionIfBody"], datas, "String", vars, props);
      final afterDescription =
          getValue(maps["afterDescription"], datas, "String", vars, props);
      final beforeProperties =
          getValue(maps["beforeProperties"], datas, "String", vars, props);
      final afterProperties =
          getValue(maps["afterProperties"], datas, "String", vars, props);
      final mandatoryAfterProperties = getValue(
          maps["mandatoryAfterProperties"], datas, "String", vars, props);
      final propertySeparator =
          getValue(maps["propertySeparator"], datas, "String", vars, props);
      final bodyIndent =
          getValue(maps["bodyIndent"], datas, "String", vars, props);
      final footer = getValue(maps["footer"], datas, "String", vars, props);
      final showChildren =
          getValue(maps["showChildren"], datas, "bool", vars, props);
      final addBlankLineIfNoChildren = getValue(
          maps["addBlankLineIfNoChildren"], datas, "bool", vars, props);
      final isNameOnOwnLine =
          getValue(maps["isNameOnOwnLine"], datas, "bool", vars, props);
      final isBlankLineBetweenPropertiesAndChildren = getValue(
          maps["isBlankLineBetweenPropertiesAndChildren"],
          datas,
          "bool",
          vars,
          props);
      final beforeName =
          getValue(maps["beforeName"], datas, "String", vars, props);
      final suffixLineOne =
          getValue(maps["suffixLineOne"], datas, "String", vars, props);
      final mandatoryFooter =
          getValue(maps["mandatoryFooter"], datas, "String", vars, props);
      if (prefixLineOne == null ||
          prefixOtherLines == null ||
          prefixLastChildLineOne == null ||
          prefixOtherLinesRootNode == null ||
          linkCharacter == null ||
          propertyPrefixIfChildren == null ||
          propertyPrefixNoChildren == null) {
        return null;
      }
      return TextTreeConfiguration(
          prefixLineOne: prefixLineOne!,
          prefixOtherLines: prefixOtherLines!,
          prefixLastChildLineOne: prefixLastChildLineOne!,
          prefixOtherLinesRootNode: prefixOtherLinesRootNode!,
          linkCharacter: linkCharacter!,
          propertyPrefixIfChildren: propertyPrefixIfChildren!,
          propertyPrefixNoChildren: propertyPrefixNoChildren!,
          lineBreak: lineBreak ?? '\n',
          lineBreakProperties: lineBreakProperties ?? true,
          afterName: afterName ?? ':',
          afterDescriptionIfBody: afterDescriptionIfBody ?? '',
          afterDescription: afterDescription ?? '',
          beforeProperties: beforeProperties ?? '',
          afterProperties: afterProperties ?? '',
          mandatoryAfterProperties: mandatoryAfterProperties ?? '',
          propertySeparator: propertySeparator ?? '',
          bodyIndent: bodyIndent ?? '',
          footer: footer ?? '',
          showChildren: showChildren ?? true,
          addBlankLineIfNoChildren: addBlankLineIfNoChildren ?? true,
          isNameOnOwnLine: isNameOnOwnLine ?? false,
          isBlankLineBetweenPropertiesAndChildren:
              isBlankLineBetweenPropertiesAndChildren ?? true,
          beforeName: beforeName ?? '',
          suffixLineOne: suffixLineOne ?? '',
          mandatoryFooter: mandatoryFooter ?? '');
    },
    "TextTreeRenderer": () {
      final minLevel =
          getValue(maps["minLevel"], datas, "DiagnosticLevel", vars, props);
      final wrapWidth = getValue(maps["wrapWidth"], datas, "int", vars, props);
      final wrapWidthProperties =
          getValue(maps["wrapWidthProperties"], datas, "int", vars, props);
      final maxDescendentsTruncatableNode = getValue(
          maps["maxDescendentsTruncatableNode"], datas, "int", vars, props);
      return TextTreeRenderer(
          minLevel: minLevel ?? DiagnosticLevel.debug,
          wrapWidth: wrapWidth ?? 100,
          wrapWidthProperties: wrapWidthProperties ?? 65,
          maxDescendentsTruncatableNode: maxDescendentsTruncatableNode ?? -1);
    },
    "Texture": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final textureId = getValue(maps["textureId"], datas, "int", vars, props);
      final freeze = getValue(maps["freeze"], datas, "bool", vars, props);
      final filterQuality =
          getValue(maps["filterQuality"], datas, "FilterQuality", vars, props);
      if (textureId == null) {
        return null;
      }
      return Texture(
          key: key,
          textureId: textureId!,
          freeze: freeze ?? false,
          filterQuality: filterQuality ?? FilterQuality.low);
    },
    "TextureBox": () {
      final textureId = getValue(maps["textureId"], datas, "int", vars, props);
      final freeze = getValue(maps["freeze"], datas, "bool", vars, props);
      final filterQuality =
          getValue(maps["filterQuality"], datas, "FilterQuality", vars, props);
      if (textureId == null) {
        return null;
      }
      return TextureBox(
          textureId: textureId!,
          freeze: freeze ?? false,
          filterQuality: filterQuality ?? FilterQuality.low);
    },
    "TextureLayer": () {
      final rect = getValue(maps["rect"], datas, "Rect", vars, props);
      final textureId = getValue(maps["textureId"], datas, "int", vars, props);
      final freeze = getValue(maps["freeze"], datas, "bool", vars, props);
      final filterQuality =
          getValue(maps["filterQuality"], datas, "FilterQuality", vars, props);
      if (rect == null || textureId == null) {
        return null;
      }
      return TextureLayer(
          rect: rect!,
          textureId: textureId!,
          freeze: freeze ?? false,
          filterQuality: filterQuality ?? ui.FilterQuality.low);
    },
    "Theme": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final data = getValue(maps["data"], datas, "ThemeData", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (data == null || child == null) {
        return null;
      }
      return Theme(key: key, data: data!, child: child!);
    },
    "ThemeData": () {
      final applyElevationOverlayColor = getValue(
          maps["applyElevationOverlayColor"], datas, "bool?", vars, props);
      final cupertinoOverrideTheme = getValue(maps["cupertinoOverrideTheme"],
          datas, "NoDefaultCupertinoThemeData?", vars, props);
      final extensions = getValue(maps["extensions"], datas,
          "Iterable<ThemeExtension<dynamic>>?", vars, props);
      final inputDecorationTheme = getValue(maps["inputDecorationTheme"], datas,
          "InputDecorationTheme?", vars, props);
      final materialTapTargetSize = getValue(maps["materialTapTargetSize"],
          datas, "MaterialTapTargetSize?", vars, props);
      final pageTransitionsTheme = getValue(maps["pageTransitionsTheme"], datas,
          "PageTransitionsTheme?", vars, props);
      final platform =
          getValue(maps["platform"], datas, "TargetPlatform?", vars, props);
      final scrollbarTheme = getValue(
          maps["scrollbarTheme"], datas, "ScrollbarThemeData?", vars, props);
      final splashFactory = getValue(maps["splashFactory"], datas,
          "InteractiveInkFeatureFactory?", vars, props);
      final useMaterial3 =
          getValue(maps["useMaterial3"], datas, "bool?", vars, props);
      final visualDensity =
          getValue(maps["visualDensity"], datas, "VisualDensity?", vars, props);
      final brightness =
          getValue(maps["brightness"], datas, "Brightness?", vars, props);
      final canvasColor =
          getValue(maps["canvasColor"], datas, "Color?", vars, props);
      final cardColor =
          getValue(maps["cardColor"], datas, "Color?", vars, props);
      final colorScheme =
          getValue(maps["colorScheme"], datas, "ColorScheme?", vars, props);
      final colorSchemeSeed =
          getValue(maps["colorSchemeSeed"], datas, "Color?", vars, props);
      final dialogBackgroundColor =
          getValue(maps["dialogBackgroundColor"], datas, "Color?", vars, props);
      final disabledColor =
          getValue(maps["disabledColor"], datas, "Color?", vars, props);
      final dividerColor =
          getValue(maps["dividerColor"], datas, "Color?", vars, props);
      final focusColor =
          getValue(maps["focusColor"], datas, "Color?", vars, props);
      final highlightColor =
          getValue(maps["highlightColor"], datas, "Color?", vars, props);
      final hintColor =
          getValue(maps["hintColor"], datas, "Color?", vars, props);
      final hoverColor =
          getValue(maps["hoverColor"], datas, "Color?", vars, props);
      final indicatorColor =
          getValue(maps["indicatorColor"], datas, "Color?", vars, props);
      final primaryColor =
          getValue(maps["primaryColor"], datas, "Color?", vars, props);
      final primaryColorDark =
          getValue(maps["primaryColorDark"], datas, "Color?", vars, props);
      final primaryColorLight =
          getValue(maps["primaryColorLight"], datas, "Color?", vars, props);
      final primarySwatch =
          getValue(maps["primarySwatch"], datas, "MaterialColor?", vars, props);
      final scaffoldBackgroundColor = getValue(
          maps["scaffoldBackgroundColor"], datas, "Color?", vars, props);
      final secondaryHeaderColor =
          getValue(maps["secondaryHeaderColor"], datas, "Color?", vars, props);
      final shadowColor =
          getValue(maps["shadowColor"], datas, "Color?", vars, props);
      final splashColor =
          getValue(maps["splashColor"], datas, "Color?", vars, props);
      final unselectedWidgetColor =
          getValue(maps["unselectedWidgetColor"], datas, "Color?", vars, props);
      final fontFamily =
          getValue(maps["fontFamily"], datas, "String?", vars, props);
      final fontFamilyFallback = getValue(
          maps["fontFamilyFallback"], datas, "List<String>?", vars, props);
      final package = getValue(maps["package"], datas, "String?", vars, props);
      final iconTheme =
          getValue(maps["iconTheme"], datas, "IconThemeData?", vars, props);
      final primaryIconTheme = getValue(
          maps["primaryIconTheme"], datas, "IconThemeData?", vars, props);
      final primaryTextTheme =
          getValue(maps["primaryTextTheme"], datas, "TextTheme?", vars, props);
      final textTheme =
          getValue(maps["textTheme"], datas, "TextTheme?", vars, props);
      final typography =
          getValue(maps["typography"], datas, "Typography?", vars, props);
      final actionIconTheme = getValue(
          maps["actionIconTheme"], datas, "ActionIconThemeData?", vars, props);
      final appBarTheme =
          getValue(maps["appBarTheme"], datas, "AppBarTheme?", vars, props);
      final badgeTheme =
          getValue(maps["badgeTheme"], datas, "BadgeThemeData?", vars, props);
      final bannerTheme = getValue(
          maps["bannerTheme"], datas, "MaterialBannerThemeData?", vars, props);
      final bottomAppBarTheme = getValue(
          maps["bottomAppBarTheme"], datas, "BottomAppBarTheme?", vars, props);
      final bottomNavigationBarTheme = getValue(
          maps["bottomNavigationBarTheme"],
          datas,
          "BottomNavigationBarThemeData?",
          vars,
          props);
      final bottomSheetTheme = getValue(maps["bottomSheetTheme"], datas,
          "BottomSheetThemeData?", vars, props);
      final buttonBarTheme = getValue(
          maps["buttonBarTheme"], datas, "ButtonBarThemeData?", vars, props);
      final buttonTheme =
          getValue(maps["buttonTheme"], datas, "ButtonThemeData?", vars, props);
      final cardTheme =
          getValue(maps["cardTheme"], datas, "CardTheme?", vars, props);
      final checkboxTheme = getValue(
          maps["checkboxTheme"], datas, "CheckboxThemeData?", vars, props);
      final chipTheme =
          getValue(maps["chipTheme"], datas, "ChipThemeData?", vars, props);
      final dataTableTheme = getValue(
          maps["dataTableTheme"], datas, "DataTableThemeData?", vars, props);
      final datePickerTheme = getValue(
          maps["datePickerTheme"], datas, "DatePickerThemeData?", vars, props);
      final dialogTheme =
          getValue(maps["dialogTheme"], datas, "DialogTheme?", vars, props);
      final dividerTheme = getValue(
          maps["dividerTheme"], datas, "DividerThemeData?", vars, props);
      final drawerTheme =
          getValue(maps["drawerTheme"], datas, "DrawerThemeData?", vars, props);
      final dropdownMenuTheme = getValue(maps["dropdownMenuTheme"], datas,
          "DropdownMenuThemeData?", vars, props);
      final elevatedButtonTheme = getValue(maps["elevatedButtonTheme"], datas,
          "ElevatedButtonThemeData?", vars, props);
      final expansionTileTheme = getValue(maps["expansionTileTheme"], datas,
          "ExpansionTileThemeData?", vars, props);
      final filledButtonTheme = getValue(maps["filledButtonTheme"], datas,
          "FilledButtonThemeData?", vars, props);
      final floatingActionButtonTheme = getValue(
          maps["floatingActionButtonTheme"],
          datas,
          "FloatingActionButtonThemeData?",
          vars,
          props);
      final iconButtonTheme = getValue(
          maps["iconButtonTheme"], datas, "IconButtonThemeData?", vars, props);
      final listTileTheme = getValue(
          maps["listTileTheme"], datas, "ListTileThemeData?", vars, props);
      final menuBarTheme = getValue(
          maps["menuBarTheme"], datas, "MenuBarThemeData?", vars, props);
      final menuButtonTheme = getValue(
          maps["menuButtonTheme"], datas, "MenuButtonThemeData?", vars, props);
      final menuTheme =
          getValue(maps["menuTheme"], datas, "MenuThemeData?", vars, props);
      final navigationBarTheme = getValue(maps["navigationBarTheme"], datas,
          "NavigationBarThemeData?", vars, props);
      final navigationDrawerTheme = getValue(maps["navigationDrawerTheme"],
          datas, "NavigationDrawerThemeData?", vars, props);
      final navigationRailTheme = getValue(maps["navigationRailTheme"], datas,
          "NavigationRailThemeData?", vars, props);
      final outlinedButtonTheme = getValue(maps["outlinedButtonTheme"], datas,
          "OutlinedButtonThemeData?", vars, props);
      final popupMenuTheme = getValue(
          maps["popupMenuTheme"], datas, "PopupMenuThemeData?", vars, props);
      final progressIndicatorTheme = getValue(maps["progressIndicatorTheme"],
          datas, "ProgressIndicatorThemeData?", vars, props);
      final radioTheme =
          getValue(maps["radioTheme"], datas, "RadioThemeData?", vars, props);
      final searchBarTheme = getValue(
          maps["searchBarTheme"], datas, "SearchBarThemeData?", vars, props);
      final searchViewTheme = getValue(
          maps["searchViewTheme"], datas, "SearchViewThemeData?", vars, props);
      final segmentedButtonTheme = getValue(maps["segmentedButtonTheme"], datas,
          "SegmentedButtonThemeData?", vars, props);
      final sliderTheme =
          getValue(maps["sliderTheme"], datas, "SliderThemeData?", vars, props);
      final snackBarTheme = getValue(
          maps["snackBarTheme"], datas, "SnackBarThemeData?", vars, props);
      final switchTheme =
          getValue(maps["switchTheme"], datas, "SwitchThemeData?", vars, props);
      final tabBarTheme =
          getValue(maps["tabBarTheme"], datas, "TabBarTheme?", vars, props);
      final textButtonTheme = getValue(
          maps["textButtonTheme"], datas, "TextButtonThemeData?", vars, props);
      final textSelectionTheme = getValue(maps["textSelectionTheme"], datas,
          "TextSelectionThemeData?", vars, props);
      final timePickerTheme = getValue(
          maps["timePickerTheme"], datas, "TimePickerThemeData?", vars, props);
      final toggleButtonsTheme = getValue(maps["toggleButtonsTheme"], datas,
          "ToggleButtonsThemeData?", vars, props);
      final tooltipTheme = getValue(
          maps["tooltipTheme"], datas, "TooltipThemeData?", vars, props);
      final fixTextFieldOutlineLabel = getValue(
          maps["fixTextFieldOutlineLabel"], datas, "bool?", vars, props);
      final primaryColorBrightness = getValue(
          maps["primaryColorBrightness"], datas, "Brightness?", vars, props);
      final androidOverscrollIndicator = getValue(
          maps["androidOverscrollIndicator"],
          datas,
          "AndroidOverscrollIndicator?",
          vars,
          props);
      final toggleableActiveColor =
          getValue(maps["toggleableActiveColor"], datas, "Color?", vars, props);
      final selectedRowColor =
          getValue(maps["selectedRowColor"], datas, "Color?", vars, props);
      final errorColor =
          getValue(maps["errorColor"], datas, "Color?", vars, props);
      final backgroundColor =
          getValue(maps["backgroundColor"], datas, "Color?", vars, props);
      final bottomAppBarColor =
          getValue(maps["bottomAppBarColor"], datas, "Color?", vars, props);
      return ThemeData(
        applyElevationOverlayColor: applyElevationOverlayColor,
        cupertinoOverrideTheme: cupertinoOverrideTheme,
        extensions: extensions,
        inputDecorationTheme: inputDecorationTheme,
        materialTapTargetSize: materialTapTargetSize,
        pageTransitionsTheme: pageTransitionsTheme,
        platform: platform,
        scrollbarTheme: scrollbarTheme,
        splashFactory: splashFactory,
        useMaterial3: useMaterial3,
        visualDensity: visualDensity,
        brightness: brightness,
        canvasColor: canvasColor,
        cardColor: cardColor,
        colorScheme: colorScheme,
        colorSchemeSeed: colorSchemeSeed,
        dialogBackgroundColor: dialogBackgroundColor,
        disabledColor: disabledColor,
        dividerColor: dividerColor,
        focusColor: focusColor,
        highlightColor: highlightColor,
        hintColor: hintColor,
        hoverColor: hoverColor,
        indicatorColor: indicatorColor,
        primaryColor: primaryColor,
        primaryColorDark: primaryColorDark,
        primaryColorLight: primaryColorLight,
        primarySwatch: primarySwatch,
        scaffoldBackgroundColor: scaffoldBackgroundColor,
        secondaryHeaderColor: secondaryHeaderColor,
        shadowColor: shadowColor,
        splashColor: splashColor,
        unselectedWidgetColor: unselectedWidgetColor,
        fontFamily: fontFamily,
        fontFamilyFallback: fontFamilyFallback != null
            ? List<String>.from(fontFamilyFallback)
            : null,
        package: package,
        iconTheme: iconTheme,
        primaryIconTheme: primaryIconTheme,
        primaryTextTheme: primaryTextTheme,
        textTheme: textTheme,
        typography: typography,
        actionIconTheme: actionIconTheme,
        appBarTheme: appBarTheme,
        badgeTheme: badgeTheme,
        bannerTheme: bannerTheme,
        bottomAppBarTheme: bottomAppBarTheme,
        bottomNavigationBarTheme: bottomNavigationBarTheme,
        bottomSheetTheme: bottomSheetTheme,
        buttonBarTheme: buttonBarTheme,
        buttonTheme: buttonTheme,
        cardTheme: cardTheme,
        checkboxTheme: checkboxTheme,
        chipTheme: chipTheme,
        dataTableTheme: dataTableTheme,
        datePickerTheme: datePickerTheme,
        dialogTheme: dialogTheme,
        dividerTheme: dividerTheme,
        drawerTheme: drawerTheme,
        dropdownMenuTheme: dropdownMenuTheme,
        elevatedButtonTheme: elevatedButtonTheme,
        expansionTileTheme: expansionTileTheme,
        filledButtonTheme: filledButtonTheme,
        floatingActionButtonTheme: floatingActionButtonTheme,
        iconButtonTheme: iconButtonTheme,
        listTileTheme: listTileTheme,
        menuBarTheme: menuBarTheme,
        menuButtonTheme: menuButtonTheme,
        menuTheme: menuTheme,
        navigationBarTheme: navigationBarTheme,
        navigationDrawerTheme: navigationDrawerTheme,
        navigationRailTheme: navigationRailTheme,
        outlinedButtonTheme: outlinedButtonTheme,
        popupMenuTheme: popupMenuTheme,
        progressIndicatorTheme: progressIndicatorTheme,
        radioTheme: radioTheme,
        searchBarTheme: searchBarTheme,
        searchViewTheme: searchViewTheme,
        segmentedButtonTheme: segmentedButtonTheme,
        sliderTheme: sliderTheme,
        snackBarTheme: snackBarTheme,
        switchTheme: switchTheme,
        tabBarTheme: tabBarTheme,
        textButtonTheme: textButtonTheme,
        textSelectionTheme: textSelectionTheme,
        timePickerTheme: timePickerTheme,
        toggleButtonsTheme: toggleButtonsTheme,
        tooltipTheme: tooltipTheme,
        // fixTextFieldOutlineLabel: fixTextFieldOutlineLabel,
        // primaryColorBrightness: primaryColorBrightness,
        // androidOverscrollIndicator: androidOverscrollIndicator,
        // toggleableActiveColor: toggleableActiveColor,
        // selectedRowColor: selectedRowColor,
        // errorColor: errorColor,
        // backgroundColor: backgroundColor,
        // bottomAppBarColor: bottomAppBarColor,
      );
    },
    "ThemeData.raw": () {
      final applyElevationOverlayColor = getValue(
          maps["applyElevationOverlayColor"], datas, "bool", vars, props);
      final cupertinoOverrideTheme = getValue(maps["cupertinoOverrideTheme"],
          datas, "NoDefaultCupertinoThemeData?", vars, props);
      final extensions = getValue(maps["extensions"], datas,
          "Map<Object, ThemeExtension<dynamic>>", vars, props);
      final inputDecorationTheme = getValue(maps["inputDecorationTheme"], datas,
          "InputDecorationTheme", vars, props);
      final materialTapTargetSize = getValue(maps["materialTapTargetSize"],
          datas, "MaterialTapTargetSize", vars, props);
      final pageTransitionsTheme = getValue(maps["pageTransitionsTheme"], datas,
          "PageTransitionsTheme", vars, props);
      final platform =
          getValue(maps["platform"], datas, "TargetPlatform", vars, props);
      final scrollbarTheme = getValue(
          maps["scrollbarTheme"], datas, "ScrollbarThemeData", vars, props);
      final splashFactory = getValue(maps["splashFactory"], datas,
          "InteractiveInkFeatureFactory", vars, props);
      final useMaterial3 =
          getValue(maps["useMaterial3"], datas, "bool", vars, props);
      final visualDensity =
          getValue(maps["visualDensity"], datas, "VisualDensity", vars, props);
      final canvasColor =
          getValue(maps["canvasColor"], datas, "Color", vars, props);
      final cardColor =
          getValue(maps["cardColor"], datas, "Color", vars, props);
      final colorScheme =
          getValue(maps["colorScheme"], datas, "ColorScheme", vars, props);
      final dialogBackgroundColor =
          getValue(maps["dialogBackgroundColor"], datas, "Color", vars, props);
      final disabledColor =
          getValue(maps["disabledColor"], datas, "Color", vars, props);
      final dividerColor =
          getValue(maps["dividerColor"], datas, "Color", vars, props);
      final focusColor =
          getValue(maps["focusColor"], datas, "Color", vars, props);
      final highlightColor =
          getValue(maps["highlightColor"], datas, "Color", vars, props);
      final hintColor =
          getValue(maps["hintColor"], datas, "Color", vars, props);
      final hoverColor =
          getValue(maps["hoverColor"], datas, "Color", vars, props);
      final indicatorColor =
          getValue(maps["indicatorColor"], datas, "Color", vars, props);
      final primaryColor =
          getValue(maps["primaryColor"], datas, "Color", vars, props);
      final primaryColorDark =
          getValue(maps["primaryColorDark"], datas, "Color", vars, props);
      final primaryColorLight =
          getValue(maps["primaryColorLight"], datas, "Color", vars, props);
      final scaffoldBackgroundColor = getValue(
          maps["scaffoldBackgroundColor"], datas, "Color", vars, props);
      final secondaryHeaderColor =
          getValue(maps["secondaryHeaderColor"], datas, "Color", vars, props);
      final shadowColor =
          getValue(maps["shadowColor"], datas, "Color", vars, props);
      final splashColor =
          getValue(maps["splashColor"], datas, "Color", vars, props);
      final unselectedWidgetColor =
          getValue(maps["unselectedWidgetColor"], datas, "Color", vars, props);
      final iconTheme =
          getValue(maps["iconTheme"], datas, "IconThemeData", vars, props);
      final primaryIconTheme = getValue(
          maps["primaryIconTheme"], datas, "IconThemeData", vars, props);
      final primaryTextTheme =
          getValue(maps["primaryTextTheme"], datas, "TextTheme", vars, props);
      final textTheme =
          getValue(maps["textTheme"], datas, "TextTheme", vars, props);
      final typography =
          getValue(maps["typography"], datas, "Typography", vars, props);
      final actionIconTheme = getValue(
          maps["actionIconTheme"], datas, "ActionIconThemeData?", vars, props);
      final appBarTheme =
          getValue(maps["appBarTheme"], datas, "AppBarTheme", vars, props);
      final badgeTheme =
          getValue(maps["badgeTheme"], datas, "BadgeThemeData", vars, props);
      final bannerTheme = getValue(
          maps["bannerTheme"], datas, "MaterialBannerThemeData", vars, props);
      final bottomAppBarTheme = getValue(
          maps["bottomAppBarTheme"], datas, "BottomAppBarTheme", vars, props);
      final bottomNavigationBarTheme = getValue(
          maps["bottomNavigationBarTheme"],
          datas,
          "BottomNavigationBarThemeData",
          vars,
          props);
      final bottomSheetTheme = getValue(
          maps["bottomSheetTheme"], datas, "BottomSheetThemeData", vars, props);
      final buttonBarTheme = getValue(
          maps["buttonBarTheme"], datas, "ButtonBarThemeData", vars, props);
      final buttonTheme =
          getValue(maps["buttonTheme"], datas, "ButtonThemeData", vars, props);
      final cardTheme =
          getValue(maps["cardTheme"], datas, "CardTheme", vars, props);
      final checkboxTheme = getValue(
          maps["checkboxTheme"], datas, "CheckboxThemeData", vars, props);
      final chipTheme =
          getValue(maps["chipTheme"], datas, "ChipThemeData", vars, props);
      final dataTableTheme = getValue(
          maps["dataTableTheme"], datas, "DataTableThemeData", vars, props);
      final datePickerTheme = getValue(
          maps["datePickerTheme"], datas, "DatePickerThemeData", vars, props);
      final dialogTheme =
          getValue(maps["dialogTheme"], datas, "DialogTheme", vars, props);
      final dividerTheme = getValue(
          maps["dividerTheme"], datas, "DividerThemeData", vars, props);
      final drawerTheme =
          getValue(maps["drawerTheme"], datas, "DrawerThemeData", vars, props);
      final dropdownMenuTheme = getValue(maps["dropdownMenuTheme"], datas,
          "DropdownMenuThemeData", vars, props);
      final elevatedButtonTheme = getValue(maps["elevatedButtonTheme"], datas,
          "ElevatedButtonThemeData", vars, props);
      final expansionTileTheme = getValue(maps["expansionTileTheme"], datas,
          "ExpansionTileThemeData", vars, props);
      final filledButtonTheme = getValue(maps["filledButtonTheme"], datas,
          "FilledButtonThemeData", vars, props);
      final floatingActionButtonTheme = getValue(
          maps["floatingActionButtonTheme"],
          datas,
          "FloatingActionButtonThemeData",
          vars,
          props);
      final iconButtonTheme = getValue(
          maps["iconButtonTheme"], datas, "IconButtonThemeData", vars, props);
      final listTileTheme = getValue(
          maps["listTileTheme"], datas, "ListTileThemeData", vars, props);
      final menuBarTheme = getValue(
          maps["menuBarTheme"], datas, "MenuBarThemeData", vars, props);
      final menuButtonTheme = getValue(
          maps["menuButtonTheme"], datas, "MenuButtonThemeData", vars, props);
      final menuTheme =
          getValue(maps["menuTheme"], datas, "MenuThemeData", vars, props);
      final navigationBarTheme = getValue(maps["navigationBarTheme"], datas,
          "NavigationBarThemeData", vars, props);
      final navigationDrawerTheme = getValue(maps["navigationDrawerTheme"],
          datas, "NavigationDrawerThemeData", vars, props);
      final navigationRailTheme = getValue(maps["navigationRailTheme"], datas,
          "NavigationRailThemeData", vars, props);
      final outlinedButtonTheme = getValue(maps["outlinedButtonTheme"], datas,
          "OutlinedButtonThemeData", vars, props);
      final popupMenuTheme = getValue(
          maps["popupMenuTheme"], datas, "PopupMenuThemeData", vars, props);
      final progressIndicatorTheme = getValue(maps["progressIndicatorTheme"],
          datas, "ProgressIndicatorThemeData", vars, props);
      final radioTheme =
          getValue(maps["radioTheme"], datas, "RadioThemeData", vars, props);
      final searchBarTheme = getValue(
          maps["searchBarTheme"], datas, "SearchBarThemeData", vars, props);
      final searchViewTheme = getValue(
          maps["searchViewTheme"], datas, "SearchViewThemeData", vars, props);
      final segmentedButtonTheme = getValue(maps["segmentedButtonTheme"], datas,
          "SegmentedButtonThemeData", vars, props);
      final sliderTheme =
          getValue(maps["sliderTheme"], datas, "SliderThemeData", vars, props);
      final snackBarTheme = getValue(
          maps["snackBarTheme"], datas, "SnackBarThemeData", vars, props);
      final switchTheme =
          getValue(maps["switchTheme"], datas, "SwitchThemeData", vars, props);
      final tabBarTheme =
          getValue(maps["tabBarTheme"], datas, "TabBarTheme", vars, props);
      final textButtonTheme = getValue(
          maps["textButtonTheme"], datas, "TextButtonThemeData", vars, props);
      final textSelectionTheme = getValue(maps["textSelectionTheme"], datas,
          "TextSelectionThemeData", vars, props);
      final timePickerTheme = getValue(
          maps["timePickerTheme"], datas, "TimePickerThemeData", vars, props);
      final toggleButtonsTheme = getValue(maps["toggleButtonsTheme"], datas,
          "ToggleButtonsThemeData", vars, props);
      final tooltipTheme = getValue(
          maps["tooltipTheme"], datas, "TooltipThemeData", vars, props);
      final fixTextFieldOutlineLabel = getValue(
          maps["fixTextFieldOutlineLabel"], datas, "bool?", vars, props);
      final primaryColorBrightness = getValue(
          maps["primaryColorBrightness"], datas, "Brightness?", vars, props);
      final androidOverscrollIndicator = getValue(
          maps["androidOverscrollIndicator"],
          datas,
          "AndroidOverscrollIndicator?",
          vars,
          props);
      final toggleableActiveColor =
          getValue(maps["toggleableActiveColor"], datas, "Color?", vars, props);
      final selectedRowColor =
          getValue(maps["selectedRowColor"], datas, "Color?", vars, props);
      final errorColor =
          getValue(maps["errorColor"], datas, "Color?", vars, props);
      final backgroundColor =
          getValue(maps["backgroundColor"], datas, "Color?", vars, props);
      final bottomAppBarColor =
          getValue(maps["bottomAppBarColor"], datas, "Color?", vars, props);
      final adaptationMap = getValue(maps["adaptationMap"], datas,
          "Map<Type, Adaptation<Object>>?", vars, props);

      if (applyElevationOverlayColor == null ||
          cupertinoOverrideTheme == null ||
          extensions == null ||
          inputDecorationTheme == null ||
          materialTapTargetSize == null ||
          pageTransitionsTheme == null ||
          platform == null ||
          scrollbarTheme == null ||
          splashFactory == null ||
          useMaterial3 == null ||
          visualDensity == null ||
          canvasColor == null ||
          cardColor == null ||
          colorScheme == null ||
          dialogBackgroundColor == null ||
          disabledColor == null ||
          dividerColor == null ||
          focusColor == null ||
          highlightColor == null ||
          hintColor == null ||
          hoverColor == null ||
          indicatorColor == null ||
          primaryColor == null ||
          primaryColorDark == null ||
          primaryColorLight == null ||
          scaffoldBackgroundColor == null ||
          secondaryHeaderColor == null ||
          shadowColor == null ||
          splashColor == null ||
          unselectedWidgetColor == null ||
          iconTheme == null ||
          primaryIconTheme == null ||
          primaryTextTheme == null ||
          textTheme == null ||
          typography == null ||
          actionIconTheme == null ||
          appBarTheme == null ||
          badgeTheme == null ||
          bannerTheme == null ||
          bottomAppBarTheme == null ||
          bottomNavigationBarTheme == null ||
          bottomSheetTheme == null ||
          buttonBarTheme == null ||
          buttonTheme == null ||
          cardTheme == null ||
          checkboxTheme == null ||
          chipTheme == null ||
          dataTableTheme == null ||
          datePickerTheme == null ||
          dialogTheme == null ||
          dividerTheme == null ||
          drawerTheme == null ||
          dropdownMenuTheme == null ||
          elevatedButtonTheme == null ||
          expansionTileTheme == null ||
          filledButtonTheme == null ||
          floatingActionButtonTheme == null ||
          iconButtonTheme == null ||
          listTileTheme == null ||
          menuBarTheme == null ||
          menuButtonTheme == null ||
          menuTheme == null ||
          navigationBarTheme == null ||
          navigationDrawerTheme == null ||
          navigationRailTheme == null ||
          outlinedButtonTheme == null ||
          popupMenuTheme == null ||
          progressIndicatorTheme == null ||
          radioTheme == null ||
          searchBarTheme == null ||
          searchViewTheme == null ||
          segmentedButtonTheme == null ||
          sliderTheme == null ||
          snackBarTheme == null ||
          switchTheme == null ||
          tabBarTheme == null ||
          textButtonTheme == null ||
          textSelectionTheme == null ||
          timePickerTheme == null ||
          toggleButtonsTheme == null ||
          tooltipTheme == null ||
          adaptationMap == null) {
        return null;
      }
      return ThemeData.raw(
        applyElevationOverlayColor: applyElevationOverlayColor!,
        cupertinoOverrideTheme: cupertinoOverrideTheme!,
        extensions: Map<Object, ThemeExtension<dynamic>>.from(extensions!),
        inputDecorationTheme: inputDecorationTheme!,
        materialTapTargetSize: materialTapTargetSize!,
        pageTransitionsTheme: pageTransitionsTheme!,
        platform: platform!,
        scrollbarTheme: scrollbarTheme!,
        splashFactory: splashFactory!,
        useMaterial3: useMaterial3!,
        visualDensity: visualDensity!,
        canvasColor: canvasColor!,
        cardColor: cardColor!,
        colorScheme: colorScheme!,
        dialogBackgroundColor: dialogBackgroundColor!,
        disabledColor: disabledColor!,
        dividerColor: dividerColor!,
        focusColor: focusColor!,
        highlightColor: highlightColor!,
        hintColor: hintColor!,
        hoverColor: hoverColor!,
        indicatorColor: indicatorColor!,
        primaryColor: primaryColor!,
        primaryColorDark: primaryColorDark!,
        primaryColorLight: primaryColorLight!,
        scaffoldBackgroundColor: scaffoldBackgroundColor!,
        secondaryHeaderColor: secondaryHeaderColor!,
        shadowColor: shadowColor!,
        splashColor: splashColor!,
        unselectedWidgetColor: unselectedWidgetColor!,
        iconTheme: iconTheme!,
        primaryIconTheme: primaryIconTheme!,
        primaryTextTheme: primaryTextTheme!,
        textTheme: textTheme!,
        typography: typography!,
        actionIconTheme: actionIconTheme!,
        appBarTheme: appBarTheme!,
        badgeTheme: badgeTheme!,
        bannerTheme: bannerTheme!,
        bottomAppBarTheme: bottomAppBarTheme!,
        bottomNavigationBarTheme: bottomNavigationBarTheme!,
        bottomSheetTheme: bottomSheetTheme!,
        buttonBarTheme: buttonBarTheme!,
        buttonTheme: buttonTheme!,
        cardTheme: cardTheme!,
        checkboxTheme: checkboxTheme!,
        chipTheme: chipTheme!,
        dataTableTheme: dataTableTheme!,
        datePickerTheme: datePickerTheme!,
        dialogTheme: dialogTheme!,
        dividerTheme: dividerTheme!,
        drawerTheme: drawerTheme!,
        dropdownMenuTheme: dropdownMenuTheme!,
        elevatedButtonTheme: elevatedButtonTheme!,
        expansionTileTheme: expansionTileTheme!,
        filledButtonTheme: filledButtonTheme!,
        floatingActionButtonTheme: floatingActionButtonTheme!,
        iconButtonTheme: iconButtonTheme!,
        listTileTheme: listTileTheme!,
        menuBarTheme: menuBarTheme!,
        menuButtonTheme: menuButtonTheme!,
        menuTheme: menuTheme!,
        navigationBarTheme: navigationBarTheme!,
        navigationDrawerTheme: navigationDrawerTheme!,
        navigationRailTheme: navigationRailTheme!,
        outlinedButtonTheme: outlinedButtonTheme!,
        popupMenuTheme: popupMenuTheme!,
        progressIndicatorTheme: progressIndicatorTheme!,
        radioTheme: radioTheme!,
        searchBarTheme: searchBarTheme!,
        searchViewTheme: searchViewTheme!,
        segmentedButtonTheme: segmentedButtonTheme!,
        sliderTheme: sliderTheme!,
        snackBarTheme: snackBarTheme!,
        switchTheme: switchTheme!,
        tabBarTheme: tabBarTheme!,
        textButtonTheme: textButtonTheme!,
        textSelectionTheme: textSelectionTheme!,
        timePickerTheme: timePickerTheme!,
        toggleButtonsTheme: toggleButtonsTheme!,
        tooltipTheme: tooltipTheme!,
        adaptationMap: adaptationMap,
        // fixTextFieldOutlineLabel: fixTextFieldOutlineLabel,
        // primaryColorBrightness: primaryColorBrightness,
        // androidOverscrollIndicator: androidOverscrollIndicator,
        // toggleableActiveColor: toggleableActiveColor,
        // selectedRowColor: selectedRowColor,
        // errorColor: errorColor,
        // backgroundColor: backgroundColor,
        // bottomAppBarColor: bottomAppBarColor,
      );
    },
    "ThemeData.from": () {
      final colorScheme =
          getValue(maps["colorScheme"], datas, "ColorScheme", vars, props);
      final textTheme =
          getValue(maps["textTheme"], datas, "TextTheme?", vars, props);
      final useMaterial3 =
          getValue(maps["useMaterial3"], datas, "bool?", vars, props);
      if (colorScheme == null) {
        return null;
      }
      return ThemeData.from(
          colorScheme: colorScheme!,
          textTheme: textTheme,
          useMaterial3: useMaterial3);
    },
    "ThemeData.light": () {
      final useMaterial3 =
          getValue(maps["useMaterial3"], datas, "bool?", vars, props);
      return ThemeData.light(useMaterial3: useMaterial3);
    },
    "ThemeData.dark": () {
      final useMaterial3 =
          getValue(maps["useMaterial3"], datas, "bool?", vars, props);
      return ThemeData.dark(useMaterial3: useMaterial3);
    },
    "ThemeData.fallback": () {
      final useMaterial3 =
          getValue(maps["useMaterial3"], datas, "bool?", vars, props);
      return ThemeData.fallback(useMaterial3: useMaterial3);
    },
    "ThemeDataTween": () {
      final begin = getValue(maps["begin"], datas, "T?", vars, props);
      final end = getValue(maps["end"], datas, "T?", vars, props);
      return ThemeDataTween(begin: begin, end: end);
    },
    "Ticker": () {
      final _onTick = getValue(maps["0"], datas, "TickerCallback", vars, props);
      final debugLabel =
          getValue(maps["debugLabel"], datas, "String?", vars, props);
      if (_onTick == null) {
        return null;
      }
      return Ticker(_onTick!, debugLabel: debugLabel);
    },
    "TickerMode": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final enabled = getValue(maps["enabled"], datas, "bool", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (enabled == null || child == null) {
        return null;
      }
      return TickerMode(key: key, enabled: enabled!, child: child!);
    },
    "TimeOfDay": () {
      final hour = getValue(maps["hour"], datas, "int", vars, props);
      final minute = getValue(maps["minute"], datas, "int", vars, props);
      if (hour == null || minute == null) {
        return null;
      }
      return TimeOfDay(hour: hour!, minute: minute!);
    },
    "TimeOfDay.fromDateTime": () {
      final time = getValue(maps["0"], datas, "DateTime", vars, props);
      if (time == null) {
        return null;
      }
      return TimeOfDay.fromDateTime(time!);
    },
    "TimeOfDay.now": () {
      return TimeOfDay.now();
    },
    "TimePickerDialog": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final initialTime =
          getValue(maps["initialTime"], datas, "TimeOfDay", vars, props);
      final cancelText =
          getValue(maps["cancelText"], datas, "String?", vars, props);
      final confirmText =
          getValue(maps["confirmText"], datas, "String?", vars, props);
      final helpText =
          getValue(maps["helpText"], datas, "String?", vars, props);
      final errorInvalidText =
          getValue(maps["errorInvalidText"], datas, "String?", vars, props);
      final hourLabelText =
          getValue(maps["hourLabelText"], datas, "String?", vars, props);
      final minuteLabelText =
          getValue(maps["minuteLabelText"], datas, "String?", vars, props);
      final restorationId =
          getValue(maps["restorationId"], datas, "String?", vars, props);
      final initialEntryMode = getValue(
          maps["initialEntryMode"], datas, "TimePickerEntryMode", vars, props);
      final orientation =
          getValue(maps["orientation"], datas, "Orientation?", vars, props);
      final onEntryModeChanged = getValue(maps["onEntryModeChanged"], datas,
          "EntryModeChangeCallback?", vars, props);
      if (initialTime == null) {
        return null;
      }
      return TimePickerDialog(
          key: key,
          initialTime: initialTime!,
          cancelText: cancelText,
          confirmText: confirmText,
          helpText: helpText,
          errorInvalidText: errorInvalidText,
          hourLabelText: hourLabelText,
          minuteLabelText: minuteLabelText,
          restorationId: restorationId,
          initialEntryMode: initialEntryMode ?? TimePickerEntryMode.dial,
          orientation: orientation,
          onEntryModeChanged: onEntryModeChanged);
    },
    "TimePickerTheme": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final data =
          getValue(maps["data"], datas, "TimePickerThemeData", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (data == null || child == null) {
        return null;
      }
      return TimePickerTheme(key: key, data: data!, child: child!);
    },
    "TimePickerThemeData": () {
      final backgroundColor =
          getValue(maps["backgroundColor"], datas, "Color?", vars, props);
      final cancelButtonStyle = getValue(
          maps["cancelButtonStyle"], datas, "ButtonStyle?", vars, props);
      final confirmButtonStyle = getValue(
          maps["confirmButtonStyle"], datas, "ButtonStyle?", vars, props);
      final dayPeriodBorderSide = getValue(
          maps["dayPeriodBorderSide"], datas, "BorderSide?", vars, props);
      final dayPeriodColor =
          getValue(maps["dayPeriodColor"], datas, "Color?", vars, props);
      final dayPeriodShape = getValue(
          maps["dayPeriodShape"], datas, "OutlinedBorder?", vars, props);
      final dayPeriodTextColor =
          getValue(maps["dayPeriodTextColor"], datas, "Color?", vars, props);
      final dayPeriodTextStyle = getValue(
          maps["dayPeriodTextStyle"], datas, "TextStyle?", vars, props);
      final dialBackgroundColor =
          getValue(maps["dialBackgroundColor"], datas, "Color?", vars, props);
      final dialHandColor =
          getValue(maps["dialHandColor"], datas, "Color?", vars, props);
      final dialTextColor =
          getValue(maps["dialTextColor"], datas, "Color?", vars, props);
      final dialTextStyle =
          getValue(maps["dialTextStyle"], datas, "TextStyle?", vars, props);
      final elevation =
          getValue(maps["elevation"], datas, "double?", vars, props);
      final entryModeIconColor =
          getValue(maps["entryModeIconColor"], datas, "Color?", vars, props);
      final helpTextStyle =
          getValue(maps["helpTextStyle"], datas, "TextStyle?", vars, props);
      final hourMinuteColor =
          getValue(maps["hourMinuteColor"], datas, "Color?", vars, props);
      final hourMinuteShape =
          getValue(maps["hourMinuteShape"], datas, "ShapeBorder?", vars, props);
      final hourMinuteTextColor =
          getValue(maps["hourMinuteTextColor"], datas, "Color?", vars, props);
      final hourMinuteTextStyle = getValue(
          maps["hourMinuteTextStyle"], datas, "TextStyle?", vars, props);
      final inputDecorationTheme = getValue(maps["inputDecorationTheme"], datas,
          "InputDecorationTheme?", vars, props);
      final padding =
          getValue(maps["padding"], datas, "EdgeInsetsGeometry?", vars, props);
      final shape = getValue(maps["shape"], datas, "ShapeBorder?", vars, props);
      return TimePickerThemeData(
          backgroundColor: backgroundColor,
          cancelButtonStyle: cancelButtonStyle,
          confirmButtonStyle: confirmButtonStyle,
          dayPeriodBorderSide: dayPeriodBorderSide,
          dayPeriodColor: dayPeriodColor,
          dayPeriodShape: dayPeriodShape,
          dayPeriodTextColor: dayPeriodTextColor,
          dayPeriodTextStyle: dayPeriodTextStyle,
          dialBackgroundColor: dialBackgroundColor,
          dialHandColor: dialHandColor,
          dialTextColor: dialTextColor,
          dialTextStyle: dialTextStyle,
          elevation: elevation,
          entryModeIconColor: entryModeIconColor,
          helpTextStyle: helpTextStyle,
          hourMinuteColor: hourMinuteColor,
          hourMinuteShape: hourMinuteShape,
          hourMinuteTextColor: hourMinuteTextColor,
          hourMinuteTextStyle: hourMinuteTextStyle,
          inputDecorationTheme: inputDecorationTheme,
          padding: padding,
          shape: shape);
    },
    "Title": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final title = getValue(maps["title"], datas, "String", vars, props);
      final color = getValue(maps["color"], datas, "Color", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (color == null || child == null) {
        return null;
      }
      return Title(key: key, title: title ?? '', color: color!, child: child!);
    },
    "ToggleButtons": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final children =
          getValue(maps["children"], datas, "List<Widget>", vars, props);
      final isSelected =
          getValue(maps["isSelected"], datas, "List<bool>", vars, props);
      final onPressed = getValue(maps["onPressed"], datas, "", vars, props);
      final mouseCursor =
          getValue(maps["mouseCursor"], datas, "MouseCursor?", vars, props);
      final tapTargetSize = getValue(
          maps["tapTargetSize"], datas, "MaterialTapTargetSize?", vars, props);
      final textStyle =
          getValue(maps["textStyle"], datas, "TextStyle?", vars, props);
      final constraints =
          getValue(maps["constraints"], datas, "BoxConstraints?", vars, props);
      final color = getValue(maps["color"], datas, "Color?", vars, props);
      final selectedColor =
          getValue(maps["selectedColor"], datas, "Color?", vars, props);
      final disabledColor =
          getValue(maps["disabledColor"], datas, "Color?", vars, props);
      final fillColor =
          getValue(maps["fillColor"], datas, "Color?", vars, props);
      final focusColor =
          getValue(maps["focusColor"], datas, "Color?", vars, props);
      final highlightColor =
          getValue(maps["highlightColor"], datas, "Color?", vars, props);
      final hoverColor =
          getValue(maps["hoverColor"], datas, "Color?", vars, props);
      final splashColor =
          getValue(maps["splashColor"], datas, "Color?", vars, props);
      final focusNodes =
          getValue(maps["focusNodes"], datas, "List<FocusNode>?", vars, props);
      final renderBorder =
          getValue(maps["renderBorder"], datas, "bool", vars, props);
      final borderColor =
          getValue(maps["borderColor"], datas, "Color?", vars, props);
      final selectedBorderColor =
          getValue(maps["selectedBorderColor"], datas, "Color?", vars, props);
      final disabledBorderColor =
          getValue(maps["disabledBorderColor"], datas, "Color?", vars, props);
      final borderRadius =
          getValue(maps["borderRadius"], datas, "BorderRadius?", vars, props);
      final borderWidth =
          getValue(maps["borderWidth"], datas, "double?", vars, props);
      final direction = getValue(maps["direction"], datas, "Axis", vars, props);
      final verticalDirection = getValue(
          maps["verticalDirection"], datas, "VerticalDirection", vars, props);
      if (children == null || isSelected == null) {
        return null;
      }
      return ToggleButtons(
          key: key,
          isSelected: List<bool>.from(isSelected!),
          onPressed: onPressed,
          mouseCursor: mouseCursor,
          tapTargetSize: tapTargetSize,
          textStyle: textStyle,
          constraints: constraints,
          color: color,
          selectedColor: selectedColor,
          disabledColor: disabledColor,
          fillColor: fillColor,
          focusColor: focusColor,
          highlightColor: highlightColor,
          hoverColor: hoverColor,
          splashColor: splashColor,
          focusNodes:
              focusNodes != null ? List<FocusNode>.from(focusNodes) : null,
          renderBorder: renderBorder ?? true,
          borderColor: borderColor,
          selectedBorderColor: selectedBorderColor,
          disabledBorderColor: disabledBorderColor,
          borderRadius: borderRadius,
          borderWidth: borderWidth,
          direction: direction ?? Axis.horizontal,
          verticalDirection: verticalDirection ?? VerticalDirection.down,
          children: List<Widget>.from(children!));
    },
    "ToggleButtonsTheme": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final data =
          getValue(maps["data"], datas, "ToggleButtonsThemeData", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (data == null || child == null) {
        return null;
      }
      return ToggleButtonsTheme(key: key, data: data!, child: child!);
    },
    "ToggleButtonsThemeData": () {
      final textStyle =
          getValue(maps["textStyle"], datas, "TextStyle?", vars, props);
      final constraints =
          getValue(maps["constraints"], datas, "BoxConstraints?", vars, props);
      final color = getValue(maps["color"], datas, "Color?", vars, props);
      final selectedColor =
          getValue(maps["selectedColor"], datas, "Color?", vars, props);
      final disabledColor =
          getValue(maps["disabledColor"], datas, "Color?", vars, props);
      final fillColor =
          getValue(maps["fillColor"], datas, "Color?", vars, props);
      final focusColor =
          getValue(maps["focusColor"], datas, "Color?", vars, props);
      final highlightColor =
          getValue(maps["highlightColor"], datas, "Color?", vars, props);
      final hoverColor =
          getValue(maps["hoverColor"], datas, "Color?", vars, props);
      final splashColor =
          getValue(maps["splashColor"], datas, "Color?", vars, props);
      final borderColor =
          getValue(maps["borderColor"], datas, "Color?", vars, props);
      final selectedBorderColor =
          getValue(maps["selectedBorderColor"], datas, "Color?", vars, props);
      final disabledBorderColor =
          getValue(maps["disabledBorderColor"], datas, "Color?", vars, props);
      final borderRadius =
          getValue(maps["borderRadius"], datas, "BorderRadius?", vars, props);
      final borderWidth =
          getValue(maps["borderWidth"], datas, "double?", vars, props);
      return ToggleButtonsThemeData(
          textStyle: textStyle,
          constraints: constraints,
          color: color,
          selectedColor: selectedColor,
          disabledColor: disabledColor,
          fillColor: fillColor,
          focusColor: focusColor,
          highlightColor: highlightColor,
          hoverColor: hoverColor,
          splashColor: splashColor,
          borderColor: borderColor,
          selectedBorderColor: selectedBorderColor,
          disabledBorderColor: disabledBorderColor,
          borderRadius: borderRadius,
          borderWidth: borderWidth);
    },
    "Tolerance": () {
      final distance = getValue(maps["distance"], datas, "double", vars, props);
      final time = getValue(maps["time"], datas, "double", vars, props);
      final velocity = getValue(maps["velocity"], datas, "double", vars, props);
      if (distance != null && time != null && velocity != null) {
        return Tolerance(distance: distance, time: time, velocity: velocity);
      }
      if (distance != null && time != null) {
        return Tolerance(distance: distance, time: time);
      }
      if (distance != null && velocity != null) {
        return Tolerance(distance: distance, velocity: velocity);
      }
      if (time != null && velocity != null) {
        return Tolerance(time: time, velocity: velocity);
      }
      if (distance != null) {
        return Tolerance(distance: distance);
      }
      if (time != null) {
        return Tolerance(time: time);
      }
      if (velocity != null) {
        return Tolerance(velocity: velocity);
      }
      return const Tolerance();
    },
    "ToolbarOptions": () {
      final copy = getValue(maps["copy"], datas, "bool", vars, props);
      final cut = getValue(maps["cut"], datas, "bool", vars, props);
      final paste = getValue(maps["paste"], datas, "bool", vars, props);
      final selectAll = getValue(maps["selectAll"], datas, "bool", vars, props);
      return ToolbarOptions(
          copy: copy ?? false,
          cut: cut ?? false,
          paste: paste ?? false,
          selectAll: selectAll ?? false);
    },
    "Tooltip": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final message = getValue(maps["message"], datas, "", vars, props);
      final richMessage = getValue(maps["richMessage"], datas, "", vars, props);
      final height = getValue(maps["height"], datas, "", vars, props);
      final padding = getValue(maps["padding"], datas, "", vars, props);
      final margin = getValue(maps["margin"], datas, "", vars, props);
      final verticalOffset =
          getValue(maps["verticalOffset"], datas, "", vars, props);
      final preferBelow = getValue(maps["preferBelow"], datas, "", vars, props);
      final excludeFromSemantics =
          getValue(maps["excludeFromSemantics"], datas, "", vars, props);
      final decoration = getValue(maps["decoration"], datas, "", vars, props);
      final textStyle = getValue(maps["textStyle"], datas, "", vars, props);
      final textAlign = getValue(maps["textAlign"], datas, "", vars, props);
      final waitDuration =
          getValue(maps["waitDuration"], datas, "", vars, props);
      final showDuration =
          getValue(maps["showDuration"], datas, "", vars, props);
      final triggerMode = getValue(maps["triggerMode"], datas, "", vars, props);
      final enableFeedback =
          getValue(maps["enableFeedback"], datas, "", vars, props);
      final onTriggered = getValue(maps["onTriggered"], datas, "", vars, props);
      final child = getValue(maps["child"], datas, "", vars, props);
      return Tooltip(
          key: key,
          message: message,
          richMessage: richMessage,
          height: height,
          padding: padding,
          margin: margin,
          verticalOffset: verticalOffset,
          preferBelow: preferBelow,
          excludeFromSemantics: excludeFromSemantics,
          decoration: decoration,
          textStyle: textStyle,
          textAlign: textAlign,
          waitDuration: waitDuration,
          showDuration: showDuration,
          triggerMode: triggerMode,
          enableFeedback: enableFeedback,
          onTriggered: onTriggered,
          child: child);
    },
    "TooltipSemanticsEvent": () {
      final message = getValue(maps["0"], datas, "String", vars, props);
      if (message == null) {
        return null;
      }
      return TooltipSemanticsEvent(message!);
    },
    "TooltipTheme": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final data =
          getValue(maps["data"], datas, "TooltipThemeData", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (data == null || child == null) {
        return null;
      }
      return TooltipTheme(key: key, data: data!, child: child!);
    },
    "TooltipThemeData": () {
      final height = getValue(maps["height"], datas, "double?", vars, props);
      final padding =
          getValue(maps["padding"], datas, "EdgeInsetsGeometry?", vars, props);
      final margin =
          getValue(maps["margin"], datas, "EdgeInsetsGeometry?", vars, props);
      final verticalOffset =
          getValue(maps["verticalOffset"], datas, "double?", vars, props);
      final preferBelow =
          getValue(maps["preferBelow"], datas, "bool?", vars, props);
      final excludeFromSemantics =
          getValue(maps["excludeFromSemantics"], datas, "bool?", vars, props);
      final decoration =
          getValue(maps["decoration"], datas, "Decoration?", vars, props);
      final textStyle =
          getValue(maps["textStyle"], datas, "TextStyle?", vars, props);
      final textAlign =
          getValue(maps["textAlign"], datas, "TextAlign?", vars, props);
      final waitDuration =
          getValue(maps["waitDuration"], datas, "Duration?", vars, props);
      final showDuration =
          getValue(maps["showDuration"], datas, "Duration?", vars, props);
      final triggerMode = getValue(
          maps["triggerMode"], datas, "TooltipTriggerMode?", vars, props);
      final enableFeedback =
          getValue(maps["enableFeedback"], datas, "bool?", vars, props);
      return TooltipThemeData(
          height: height,
          padding: padding,
          margin: margin,
          verticalOffset: verticalOffset,
          preferBelow: preferBelow,
          excludeFromSemantics: excludeFromSemantics,
          decoration: decoration,
          textStyle: textStyle,
          textAlign: textAlign,
          waitDuration: waitDuration,
          showDuration: showDuration,
          triggerMode: triggerMode,
          enableFeedback: enableFeedback);
    },
    "TooltipVisibility": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final visible = getValue(maps["visible"], datas, "bool", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (visible == null || child == null) {
        return null;
      }
      return TooltipVisibility(key: key, visible: visible!, child: child!);
    },
    "TrackingScrollController": () {
      final initialScrollOffset =
          getValue(maps["initialScrollOffset"], datas, "double", vars, props);
      final keepScrollOffset =
          getValue(maps["keepScrollOffset"], datas, "bool", vars, props);
      final debugLabel =
          getValue(maps["debugLabel"], datas, "String?", vars, props);
      return TrackingScrollController(
          initialScrollOffset: initialScrollOffset ?? 0.0,
          keepScrollOffset: keepScrollOffset ?? true,
          debugLabel: debugLabel);
    },
    "TrainHoppingAnimation": () {
      final _currentTrain =
          getValue(maps["0"], datas, "Animation<double>", vars, props);
      final _nextTrain =
          getValue(maps["1"], datas, "Animation<double>?", vars, props);
      final onSwitchedTrain = getValue(
          maps["onSwitchedTrain"], datas, "VoidCallback?", vars, props);
      if (_currentTrain == null || _nextTrain == null) {
        return null;
      }
      return TrainHoppingAnimation(_currentTrain!, _nextTrain!,
          onSwitchedTrain: onSwitchedTrain);
    },
    "Transform": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final transform = getValue(maps["transform"], datas, "", vars, props);
      final origin = getValue(maps["origin"], datas, "", vars, props);
      final alignment = getValue(maps["alignment"], datas, "", vars, props);
      final transformHitTests =
          getValue(maps["transformHitTests"], datas, "", vars, props);
      final filterQuality =
          getValue(maps["filterQuality"], datas, "", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      if (transform == null) {
        return null;
      }
      return Transform(
          key: key,
          transform: transform!,
          origin: origin,
          alignment: alignment,
          transformHitTests: transformHitTests ?? true,
          filterQuality: filterQuality,
          child: child);
    },
    "Transform.rotate": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final angle = getValue(maps["angle"], datas, "double", vars, props);
      final origin = getValue(maps["origin"], datas, "", vars, props);
      final alignment = getValue(maps["alignment"], datas, "", vars, props);
      final transformHitTests =
          getValue(maps["transformHitTests"], datas, "", vars, props);
      final filterQuality =
          getValue(maps["filterQuality"], datas, "", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      if (angle == null) {
        return null;
      }
      return Transform.rotate(
          key: key,
          angle: angle!,
          origin: origin,
          alignment: alignment ?? Alignment.center,
          transformHitTests: transformHitTests ?? true,
          filterQuality: filterQuality,
          child: child);
    },
    "Transform.translate": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final offset = getValue(maps["offset"], datas, "Offset", vars, props);
      final transformHitTests =
          getValue(maps["transformHitTests"], datas, "", vars, props);
      final filterQuality =
          getValue(maps["filterQuality"], datas, "", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      if (offset == null) {
        return null;
      }
      return Transform.translate(
          key: key,
          offset: offset!,
          transformHitTests: transformHitTests ?? true,
          filterQuality: filterQuality,
          child: child);
    },
    "Transform.scale": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final scale = getValue(maps["scale"], datas, "double?", vars, props);
      final scaleX = getValue(maps["scaleX"], datas, "double?", vars, props);
      final scaleY = getValue(maps["scaleY"], datas, "double?", vars, props);
      final origin = getValue(maps["origin"], datas, "", vars, props);
      final alignment = getValue(maps["alignment"], datas, "", vars, props);
      final transformHitTests =
          getValue(maps["transformHitTests"], datas, "", vars, props);
      final filterQuality =
          getValue(maps["filterQuality"], datas, "", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      return Transform.scale(
          key: key,
          scale: scale,
          scaleX: scaleX,
          scaleY: scaleY,
          origin: origin,
          alignment: alignment ?? Alignment.center,
          transformHitTests: transformHitTests ?? true,
          filterQuality: filterQuality,
          child: child);
    },
    "TransformLayer": () {
      final transform =
          getValue(maps["transform"], datas, "Matrix4?", vars, props);
      final offset = getValue(maps["offset"], datas, "Offset", vars, props);
      return TransformLayer(
          transform: transform, offset: offset ?? Offset.zero);
    },
    "TransformProperty": () {
      final name = getValue(maps["0"], datas, "String", vars, props);
      final value = getValue(maps["1"], datas, "T?", vars, props);
      final showName = getValue(maps["showName"], datas, "", vars, props);
      final defaultValue =
          getValue(maps["defaultValue"], datas, "Object?", vars, props);
      final level =
          getValue(maps["level"], datas, "DiagnosticLevel", vars, props);
      if (name == null || value == null) {
        return null;
      }
      return TransformProperty(name!, value!,
          showName: showName,
          defaultValue: defaultValue ?? kNoDefaultValue,
          level: level ?? DiagnosticLevel.info);
    },
    "TransformationController": () {
      final value = getValue(maps["0"], datas, "Matrix4?", vars, props);
      return TransformationController(value);
    },
    "TransposeCharactersIntent": () {
      return const TransposeCharactersIntent();
    },
    "Tween": () {
      final begin = getValue(maps["begin"], datas, "T?", vars, props);
      final end = getValue(maps["end"], datas, "T?", vars, props);
      return Tween(begin: begin, end: end);
    },
    "TweenAnimationBuilder": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final tween = getValue(maps["tween"], datas, "Tween<T>", vars, props);
      final duration =
          getValue(maps["duration"], datas, "Duration", vars, props);
      final curve = getValue(maps["curve"], datas, "Curve", vars, props);
      final builder = getValue(
          maps["builder"], datas, "ValueWidgetBuilder<T>", vars, props);
      final onEnd =
          getValue(maps["onEnd"], datas, "VoidCallback?", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      if (tween == null || duration == null || builder == null) {
        return null;
      }
      return TweenAnimationBuilder(
          key: key,
          tween: tween!,
          duration: duration!,
          curve: curve ?? Curves.linear,
          builder: builder!,
          onEnd: onEnd,
          child: child);
    },
    "TweenSequence": () {
      final items =
          getValue(maps["0"], datas, "List<TweenSequenceItem<T>>", vars, props);
      if (items == null) {
        return null;
      }
      return TweenSequence(List<TweenSequenceItem<T>>.from(items!));
    },
    "TweenSequenceItem": () {
      final tween =
          getValue(maps["tween"], datas, "Animatable<T>", vars, props);
      final weight = getValue(maps["weight"], datas, "double", vars, props);
      if (tween == null || weight == null) {
        return null;
      }
      return TweenSequenceItem(tween: tween!, weight: weight!);
    },
    "Typography": () {
      final platform =
          getValue(maps["platform"], datas, "TargetPlatform?", vars, props);
      final black = getValue(maps["black"], datas, "TextTheme?", vars, props);
      final white = getValue(maps["white"], datas, "TextTheme?", vars, props);
      final englishLike =
          getValue(maps["englishLike"], datas, "TextTheme?", vars, props);
      final dense = getValue(maps["dense"], datas, "TextTheme?", vars, props);
      final tall = getValue(maps["tall"], datas, "TextTheme?", vars, props);
      return Typography(
          platform: platform,
          black: black,
          white: white,
          englishLike: englishLike,
          dense: dense,
          tall: tall);
    },
    "Typography.material2014": () {
      final platform =
          getValue(maps["platform"], datas, "TargetPlatform?", vars, props);
      final black = getValue(maps["black"], datas, "TextTheme?", vars, props);
      final white = getValue(maps["white"], datas, "TextTheme?", vars, props);
      final englishLike =
          getValue(maps["englishLike"], datas, "TextTheme?", vars, props);
      final dense = getValue(maps["dense"], datas, "TextTheme?", vars, props);
      final tall = getValue(maps["tall"], datas, "TextTheme?", vars, props);
      return Typography.material2014(
          platform: platform ?? TargetPlatform.android,
          black: black,
          white: white,
          englishLike: englishLike,
          dense: dense,
          tall: tall);
    },
    "Typography.material2018": () {
      final platform =
          getValue(maps["platform"], datas, "TargetPlatform?", vars, props);
      final black = getValue(maps["black"], datas, "TextTheme?", vars, props);
      final white = getValue(maps["white"], datas, "TextTheme?", vars, props);
      final englishLike =
          getValue(maps["englishLike"], datas, "TextTheme?", vars, props);
      final dense = getValue(maps["dense"], datas, "TextTheme?", vars, props);
      final tall = getValue(maps["tall"], datas, "TextTheme?", vars, props);
      return Typography.material2018(
          platform: platform ?? TargetPlatform.android,
          black: black,
          white: white,
          englishLike: englishLike,
          dense: dense,
          tall: tall);
    },
    "Typography.material2021": () {
      final platform =
          getValue(maps["platform"], datas, "TargetPlatform?", vars, props);
      final colorScheme =
          getValue(maps["colorScheme"], datas, "ColorScheme", vars, props);
      final black = getValue(maps["black"], datas, "TextTheme?", vars, props);
      final white = getValue(maps["white"], datas, "TextTheme?", vars, props);
      final englishLike =
          getValue(maps["englishLike"], datas, "TextTheme?", vars, props);
      final dense = getValue(maps["dense"], datas, "TextTheme?", vars, props);
      final tall = getValue(maps["tall"], datas, "TextTheme?", vars, props);
      return Typography.material2021(
          platform: platform ?? TargetPlatform.android,
          colorScheme: colorScheme ?? const ColorScheme.light(),
          black: black,
          white: white,
          englishLike: englishLike,
          dense: dense,
          tall: tall);
    },
    "UiKitView": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final viewType = getValue(maps["viewType"], datas, "String", vars, props);
      final onPlatformViewCreated = getValue(maps["onPlatformViewCreated"],
          datas, "PlatformViewCreatedCallback?", vars, props);
      final hitTestBehavior = getValue(maps["hitTestBehavior"], datas,
          "PlatformViewHitTestBehavior", vars, props);
      final layoutDirection = getValue(
          maps["layoutDirection"], datas, "TextDirection?", vars, props);
      final creationParams =
          getValue(maps["creationParams"], datas, "dynamic", vars, props);
      final creationParamsCodec = getValue(maps["creationParamsCodec"], datas,
          "MessageCodec<dynamic>?", vars, props);
      final gestureRecognizers = getValue(maps["gestureRecognizers"], datas,
          "Set<Factory<OneSequenceGestureRecognizer>>?", vars, props);
      if (viewType == null) {
        return null;
      }
      return UiKitView(
          key: key,
          viewType: viewType!,
          onPlatformViewCreated: onPlatformViewCreated,
          hitTestBehavior:
              hitTestBehavior ?? PlatformViewHitTestBehavior.opaque,
          layoutDirection: layoutDirection,
          creationParams: creationParams,
          creationParamsCodec: creationParamsCodec,
          gestureRecognizers: gestureRecognizers
              ? Set<Factory<OneSequenceGestureRecognizer>>.from(
                  gestureRecognizers)
              : null);
    },
    "UnconstrainedBox": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      final textDirection =
          getValue(maps["textDirection"], datas, "TextDirection?", vars, props);
      final alignment =
          getValue(maps["alignment"], datas, "AlignmentGeometry", vars, props);
      final constrainedAxis =
          getValue(maps["constrainedAxis"], datas, "Axis?", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      return UnconstrainedBox(
          key: key,
          child: child,
          textDirection: textDirection,
          alignment: alignment ?? Alignment.center,
          constrainedAxis: constrainedAxis,
          clipBehavior: clipBehavior ?? Clip.none);
    },
    "UnderlineInputBorder": () {
      final borderSide =
          getValue(maps["borderSide"], datas, "BorderSide", vars, props);
      final borderRadius =
          getValue(maps["borderRadius"], datas, "BorderRadius", vars, props);
      return UnderlineInputBorder(
          borderSide: borderSide ?? const BorderSide(),
          borderRadius: borderRadius ??
              const BorderRadius.only(
                topLeft: Radius.circular(4.0),
                topRight: Radius.circular(4.0),
              ));
    },
    "UnderlineTabIndicator": () {
      final borderRadius =
          getValue(maps["borderRadius"], datas, "BorderRadius?", vars, props);
      final borderSide =
          getValue(maps["borderSide"], datas, "BorderSide", vars, props);
      final insets =
          getValue(maps["insets"], datas, "EdgeInsetsGeometry", vars, props);
      return UnderlineTabIndicator(
          borderRadius: borderRadius,
          borderSide:
              borderSide ?? const BorderSide(width: 2.0, color: Colors.white),
          insets: insets ?? EdgeInsets.zero);
    },
    "UndoHistory": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final shouldChangeUndoStack = getValue(maps["shouldChangeUndoStack"],
          datas, "bool Function(T? oldValue, T newValue)?", vars, props);
      final value =
          getValue(maps["value"], datas, "ValueNotifier<T>", vars, props);
      final onTriggered = getValue(maps["onTriggered"], datas, "", vars, props);
      final focusNode =
          getValue(maps["focusNode"], datas, "FocusNode", vars, props);
      final controller = getValue(
          maps["controller"], datas, "UndoHistoryController?", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (value == null ||
          onTriggered == null ||
          focusNode == null ||
          child == null) {
        return null;
      }
      return UndoHistory(
          key: key,
          shouldChangeUndoStack: shouldChangeUndoStack,
          value: value!,
          onTriggered: onTriggered!,
          focusNode: focusNode!,
          controller: controller,
          child: child!);
    },
    "UndoHistoryValue": () {
      final canUndo = getValue(maps["canUndo"], datas, "bool", vars, props);
      final canRedo = getValue(maps["canRedo"], datas, "bool", vars, props);
      return UndoHistoryValue(
          canUndo: canUndo ?? false, canRedo: canRedo ?? false);
    },
    "UndoTextIntent": () {
      final cause =
          getValue(maps["0"], datas, "SelectionChangedCause", vars, props);
      if (cause == null) {
        return null;
      }
      return UndoTextIntent(cause!);
    },
    "UnimplementedError": () {
      final message = getValue(maps["0"], datas, "String?", vars, props);
      return UnimplementedError(message);
    },
    "UniqueKey": () {
      return UniqueKey();
    },
    "UnmanagedRestorationScope": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final bucket =
          getValue(maps["bucket"], datas, "RestorationBucket?", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (child == null) {
        return null;
      }
      return UnmanagedRestorationScope(key: key, bucket: bucket, child: child!);
    },
    "UnsupportedError": () {
      final message = getValue(maps["0"], datas, "String", vars, props);
      if (message == null) {
        return null;
      }
      return UnsupportedError(message!);
    },
    "UpdateSelectionIntent": () {
      final currentTextEditingValue =
          getValue(maps["0"], datas, "TextEditingValue", vars, props);
      final newSelection =
          getValue(maps["1"], datas, "TextSelection", vars, props);
      final cause =
          getValue(maps["2"], datas, "SelectionChangedCause", vars, props);
      if (currentTextEditingValue == null ||
          newSelection == null ||
          cause == null) {
        return null;
      }
      return UpdateSelectionIntent(
          currentTextEditingValue!, newSelection!, cause!);
    },
    "Uri.http": () {
      final authority = getValue(maps["0"], datas, "String", vars, props);
      final unencodedPath = getValue(maps["1"], datas, "String", vars, props);
      final queryParameters =
          getValue(maps["2"], datas, "Map<String,   dynamic >?", vars, props);
      if (authority == null) {
        return null;
      }
      return Uri.http(authority!, unencodedPath,
          queryParameters ? Map<String, dynamic>.from(queryParameters) : null);
    },
    "Uri.https": () {
      final authority = getValue(maps["0"], datas, "String", vars, props);
      final unencodedPath = getValue(maps["1"], datas, "String", vars, props);
      final queryParameters =
          getValue(maps["2"], datas, "Map<String,   dynamic>?", vars, props);
      if (authority == null) {
        return null;
      }
      return Uri.https(authority!, unencodedPath,
          queryParameters ? Map<String, dynamic>.from(queryParameters) : null);
    },
    "Uri.file": () {
      final path = getValue(maps["0"], datas, "String", vars, props);
      final windows = getValue(maps["windows"], datas, "bool?", vars, props);
      if (path == null) {
        return null;
      }
      return Uri.file(path!, windows: windows);
    },
    "Uri.directory": () {
      final path = getValue(maps["0"], datas, "String", vars, props);
      final windows = getValue(maps["windows"], datas, "bool?", vars, props);
      if (path == null) {
        return null;
      }
      return Uri.directory(path!, windows: windows);
    },
    "Uri.dataFromString": () {
      final content = getValue(maps["0"], datas, "String", vars, props);
      final mimeType =
          getValue(maps["mimeType"], datas, "String?", vars, props);
      final encoding =
          getValue(maps["encoding"], datas, "Encoding?", vars, props);
      final parameters = getValue(
          maps["parameters"], datas, "Map<String,   String>?", vars, props);
      final base64 = getValue(maps["base64"], datas, "bool", vars, props);
      if (content == null) {
        return null;
      }
      return Uri.dataFromString(content!,
          mimeType: mimeType,
          encoding: encoding,
          parameters: parameters ? Map<String, String>.from(parameters) : null,
          base64: base64 ?? false);
    },
    "Uri.dataFromBytes": () {
      final bytes = getValue(maps["0"], datas, "List<int>", vars, props);
      final mimeType = getValue(maps["mimeType"], datas, "String", vars, props);
      final parameters = getValue(
          maps["parameters"], datas, "Map<String,   String>?", vars, props);
      final percentEncoded =
          getValue(maps["percentEncoded"], datas, "bool", vars, props);
      if (bytes == null) {
        return null;
      }
      return Uri.dataFromBytes(List<int>.from(bytes!),
          mimeType: mimeType ?? "application/octet-stream",
          parameters: parameters ? Map<String, String>.from(parameters) : null,
          percentEncoded: percentEncoded ?? false);
    },
    "UserAccountsDrawerHeader": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final decoration =
          getValue(maps["decoration"], datas, "Decoration?", vars, props);
      final margin =
          getValue(maps["margin"], datas, "EdgeInsetsGeometry?", vars, props);
      final currentAccountPicture = getValue(
          maps["currentAccountPicture"], datas, "Widget?", vars, props);
      final otherAccountsPictures = getValue(
          maps["otherAccountsPictures"], datas, "List<Widget>?", vars, props);
      final currentAccountPictureSize = getValue(
          maps["currentAccountPictureSize"], datas, "Size", vars, props);
      final otherAccountsPicturesSize = getValue(
          maps["otherAccountsPicturesSize"], datas, "Size", vars, props);
      final accountName =
          getValue(maps["accountName"], datas, "Widget?", vars, props);
      final accountEmail =
          getValue(maps["accountEmail"], datas, "Widget?", vars, props);
      final onDetailsPressed = getValue(
          maps["onDetailsPressed"], datas, "VoidCallback?", vars, props);
      final arrowColor =
          getValue(maps["arrowColor"], datas, "Color", vars, props);
      if (accountName == null || accountEmail == null) {
        return null;
      }
      return UserAccountsDrawerHeader(
          key: key,
          decoration: decoration,
          margin: margin ?? const EdgeInsets.only(bottom: 8.0),
          currentAccountPicture: currentAccountPicture,
          otherAccountsPictures: otherAccountsPictures != null
              ? List<Widget>.from(otherAccountsPictures)
              : null,
          currentAccountPictureSize:
              currentAccountPictureSize ?? const Size.square(72.0),
          otherAccountsPicturesSize:
              otherAccountsPicturesSize ?? const Size.square(40.0),
          accountName: accountName!,
          accountEmail: accountEmail!,
          onDetailsPressed: onDetailsPressed,
          arrowColor: arrowColor ?? Colors.white);
    },
    "UserScrollNotification": () {
      final metrics =
          getValue(maps["metrics"], datas, "ScrollMetrics", vars, props);
      final context =
          getValue(maps["context"], datas, "BuildContext", vars, props);
      final direction =
          getValue(maps["direction"], datas, "ScrollDirection", vars, props);
      if (metrics == null || context == null || direction == null) {
        return null;
      }
      return UserScrollNotification(
          metrics: metrics!, context: context!, direction: direction!);
    },
    "ValueKey": () {
      final value = getValue(maps["0"], datas, "T", vars, props);
      if (value == null) {
        return null;
      }
      return ValueKey(value!);
    },
    "ValueListenableBuilder": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final valueListenable = getValue(
          maps["valueListenable"], datas, "ValueListenable<T>", vars, props);
      final builder = getValue(
          maps["builder"], datas, "ValueWidgetBuilder<T>", vars, props);
      final child = getValue(maps["child"], datas, "Widget?", vars, props);
      if (valueListenable == null || builder == null) {
        return null;
      }
      return ValueListenableBuilder(
          key: key,
          valueListenable: valueListenable!,
          builder: builder!,
          child: child);
    },
    "ValueNotifier": () {
      final _value = getValue(maps["0"], datas, "T", vars, props);
      if (_value == null) {
        return null;
      }
      return ValueNotifier(_value!);
    },
    "Velocity": () {
      final pixelsPerSecond =
          getValue(maps["pixelsPerSecond"], datas, "Offset", vars, props);
      if (pixelsPerSecond == null) {
        return null;
      }
      return Velocity(pixelsPerSecond: pixelsPerSecond!);
    },
    "VelocityEstimate": () {
      final pixelsPerSecond =
          getValue(maps["pixelsPerSecond"], datas, "Offset", vars, props);
      final confidence =
          getValue(maps["confidence"], datas, "double", vars, props);
      final duration =
          getValue(maps["duration"], datas, "Duration", vars, props);
      final offset = getValue(maps["offset"], datas, "Offset", vars, props);
      if (pixelsPerSecond == null ||
          confidence == null ||
          duration == null ||
          offset == null) {
        return null;
      }
      return VelocityEstimate(
          pixelsPerSecond: pixelsPerSecond!,
          confidence: confidence!,
          duration: duration!,
          offset: offset!);
    },
    "VelocityTracker.withKind": () {
      final kind = getValue(maps["0"], datas, "PointerDeviceKind", vars, props);
      if (kind == null) {
        return null;
      }
      return VelocityTracker.withKind(kind!);
    },
    "VerticalDivider": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final width = getValue(maps["width"], datas, "double?", vars, props);
      final thickness =
          getValue(maps["thickness"], datas, "double?", vars, props);
      final indent = getValue(maps["indent"], datas, "double?", vars, props);
      final endIndent =
          getValue(maps["endIndent"], datas, "double?", vars, props);
      final color = getValue(maps["color"], datas, "Color?", vars, props);
      return VerticalDivider(
          key: key,
          width: width,
          thickness: thickness,
          indent: indent,
          endIndent: endIndent,
          color: color);
    },
    "VerticalDragGestureRecognizer": () {
      final debugOwner = getValue(maps["debugOwner"], datas, "", vars, props);
      final supportedDevices =
          getValue(maps["supportedDevices"], datas, "", vars, props);
      final allowedButtonsFilter = getValue(maps["allowedButtonsFilter"], datas,
          "AllowedButtonsFilter?", vars, props);
      return VerticalDragGestureRecognizer(
          debugOwner: debugOwner,
          supportedDevices: supportedDevices,
          allowedButtonsFilter: allowedButtonsFilter);
    },
    "VerticalMultiDragGestureRecognizer": () {
      final debugOwner =
          getValue(maps["debugOwner"], datas, "Object?", vars, props);
      final supportedDevices = getValue(maps["supportedDevices"], datas,
          "Set<PointerDeviceKind>?", vars, props);
      final allowedButtonsFilter = getValue(maps["allowedButtonsFilter"], datas,
          "AllowedButtonsFilter?", vars, props);
      return VerticalMultiDragGestureRecognizer(
          debugOwner: debugOwner,
          supportedDevices: supportedDevices
              ? Set<PointerDeviceKind>.from(supportedDevices)
              : null,
          allowedButtonsFilter: allowedButtonsFilter);
    },
    "Vertices": () {
      final mode = getValue(maps["0"], datas, "VertexMode", vars, props);
      final positions = getValue(maps["1"], datas, "List<Offset>", vars, props);
      final colors =
          getValue(maps["colors"], datas, "List<Color>?", vars, props);
      final textureCoordinates = getValue(
          maps["textureCoordinates"], datas, "List<Offset>?", vars, props);
      final indices =
          getValue(maps["indices"], datas, "List<int>?", vars, props);
      if (mode == null || positions == null) {
        return null;
      }
      return ui.Vertices(mode!, List<Offset>.from(positions!),
          colors: colors != null ? List<Color>.from(colors) : null,
          textureCoordinates: textureCoordinates != null
              ? List<Offset>.from(textureCoordinates)
              : null,
          indices: indices != null ? List<int>.from(indices) : null);
    },
    "Vertices.raw": () {
      final mode = getValue(maps["0"], datas, "VertexMode", vars, props);
      final positions = getValue(maps["1"], datas, "Float32List", vars, props);
      final colors = getValue(maps["colors"], datas, "Int32List?", vars, props);
      final textureCoordinates = getValue(
          maps["textureCoordinates"], datas, "Float32List?", vars, props);
      final indices =
          getValue(maps["indices"], datas, "Uint16List?", vars, props);
      if (mode == null || positions == null) {
        return null;
      }
      return ui.Vertices.raw(mode!, positions!,
          colors: colors,
          textureCoordinates: textureCoordinates,
          indices: indices);
    },
    "View": () {
      final view = getValue(maps["view"], datas, "FlutterView", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      if (view == null || child == null) {
        return null;
      }
      return View(view: view!, child: child!);
    },
    "ViewConfiguration": () {
      final physicalConstraints =
          getValue(maps["physicalConstraints"], datas, "Size", vars, props);
      final devicePixelRatio =
          getValue(maps["devicePixelRatio"], datas, "double", vars, props);
      return ViewConfiguration(
        //  physicalConstraints: physicalConstraints,
          devicePixelRatio: devicePixelRatio ?? 1.0);
    },
    "Viewport": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final axisDirection =
          getValue(maps["axisDirection"], datas, "AxisDirection", vars, props);
      final crossAxisDirection = getValue(
          maps["crossAxisDirection"], datas, "AxisDirection?", vars, props);
      final anchor = getValue(maps["anchor"], datas, "double", vars, props);
      final offset =
          getValue(maps["offset"], datas, "ViewportOffset", vars, props);
      final center = getValue(maps["center"], datas, "Key?", vars, props);
      final cacheExtent =
          getValue(maps["cacheExtent"], datas, "double?", vars, props);
      final cacheExtentStyle = getValue(
          maps["cacheExtentStyle"], datas, "CacheExtentStyle", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      final slivers =
          getValue(maps["slivers"], datas, "List<Widget>", vars, props);
      if (offset == null) {
        return null;
      }
      return Viewport(
          key: key,
          axisDirection: axisDirection ?? AxisDirection.down,
          crossAxisDirection: crossAxisDirection,
          anchor: anchor ?? 0.0,
          offset: offset!,
          center: center,
          cacheExtent: cacheExtent,
          cacheExtentStyle: cacheExtentStyle ?? CacheExtentStyle.pixel,
          clipBehavior: clipBehavior ?? Clip.hardEdge,
          slivers: List<Widget>.from(slivers ?? const <Widget>[]));
    },
    "ViewportOffset.fixed": () {
      final value = getValue(maps["0"], datas, "double", vars, props);
      if (value == null) {
        return null;
      }
      return ViewportOffset.fixed(value!);
    },
    "ViewportOffset.zero": () {
      return ViewportOffset.zero();
    },
    "Visibility": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      final replacement =
          getValue(maps["replacement"], datas, "Widget", vars, props);
      final visible = getValue(maps["visible"], datas, "bool", vars, props);
      final maintainState =
          getValue(maps["maintainState"], datas, "bool", vars, props);
      final maintainAnimation =
          getValue(maps["maintainAnimation"], datas, "bool", vars, props);
      final maintainSize =
          getValue(maps["maintainSize"], datas, "bool", vars, props);
      final maintainSemantics =
          getValue(maps["maintainSemantics"], datas, "bool", vars, props);
      final maintainInteractivity =
          getValue(maps["maintainInteractivity"], datas, "bool", vars, props);
      if (child == null) {
        return null;
      }
      return Visibility(
          key: key,
          child: child!,
          replacement: replacement ?? const SizedBox.shrink(),
          visible: visible ?? true,
          maintainState: maintainState ?? false,
          maintainAnimation: maintainAnimation ?? false,
          maintainSize: maintainSize ?? false,
          maintainSemantics: maintainSemantics ?? false,
          maintainInteractivity: maintainInteractivity ?? false);
    },
    "Visibility.maintain": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      final visible = getValue(maps["visible"], datas, "bool", vars, props);
      if (child == null) {
        return null;
      }
      return Visibility.maintain(
          key: key, child: child!, visible: visible ?? true);
    },
    "VisualDensity": () {
      final horizontal =
          getValue(maps["horizontal"], datas, "double", vars, props);
      final vertical = getValue(maps["vertical"], datas, "double", vars, props);
      return VisualDensity(
          horizontal: horizontal ?? 0.0, vertical: vertical ?? 0.0);
    },
    "VoidCallbackIntent": () {
      final callback = getValue(maps["0"], datas, "VoidCallback", vars, props);
      if (callback == null) {
        return null;
      }
      return VoidCallbackIntent(callback!);
    },
    "WidgetInspector": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      final selectButtonBuilder = getValue(maps["selectButtonBuilder"], datas,
          "InspectorSelectButtonBuilder?", vars, props);
      if (child == null || selectButtonBuilder == null) {
        return null;
      }
      return WidgetInspector(
          key: key, child: child!, selectButtonBuilder: selectButtonBuilder!);
    },
    "WidgetSpan": () {
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      final alignment = getValue(
          maps["alignment"], datas, "PlaceholderAlignment", vars, props);
      final baseline =
          getValue(maps["baseline"], datas, "TextBaseline?", vars, props);
      final style = getValue(maps["style"], datas, "TextStyle?", vars, props);
      if (child == null) {
        return null;
      }
      return WidgetSpan(
          child: child!,
          alignment: alignment ?? ui.PlaceholderAlignment.bottom,
          baseline: baseline,
          style: style);
    },
    "WidgetToRenderBoxAdapter": () {
      final renderBox =
          getValue(maps["renderBox"], datas, "RenderBox", vars, props);
      final onBuild =
          getValue(maps["onBuild"], datas, "VoidCallback?", vars, props);
      final onUnmount =
          getValue(maps["onUnmount"], datas, "VoidCallback?", vars, props);
      if (renderBox == null) {
        return null;
      }
      return WidgetToRenderBoxAdapter(
          renderBox: renderBox!, onBuild: onBuild, onUnmount: onUnmount);
    },
    "WidgetsApp": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final navigatorKey =
          getValue(maps["navigatorKey"], datas, "", vars, props);
      final onGenerateRoute =
          getValue(maps["onGenerateRoute"], datas, "", vars, props);
      final onGenerateInitialRoutes =
          getValue(maps["onGenerateInitialRoutes"], datas, "", vars, props);
      final onUnknownRoute =
          getValue(maps["onUnknownRoute"], datas, "", vars, props);
      final navigatorObservers = getValue(maps["navigatorObservers"], datas,
          "List<NavigatorObserver>", vars, props);
      final initialRoute =
          getValue(maps["initialRoute"], datas, "", vars, props);
      final pageRouteBuilder =
          getValue(maps["pageRouteBuilder"], datas, "", vars, props);
      final home = getValue(maps["home"], datas, "", vars, props);
      final routes = getValue(
          maps["routes"], datas, "Map<String, WidgetBuilder>", vars, props);
      final builder = getValue(maps["builder"], datas, "", vars, props);
      final title = getValue(maps["title"], datas, "", vars, props);
      final onGenerateTitle =
          getValue(maps["onGenerateTitle"], datas, "", vars, props);
      final textStyle = getValue(maps["textStyle"], datas, "", vars, props);
      final color = getValue(maps["color"], datas, "", vars, props);
      final locale = getValue(maps["locale"], datas, "", vars, props);
      final localizationsDelegates =
          getValue(maps["localizationsDelegates"], datas, "", vars, props);
      final localeListResolutionCallback = getValue(
          maps["localeListResolutionCallback"], datas, "", vars, props);
      final localeResolutionCallback =
          getValue(maps["localeResolutionCallback"], datas, "", vars, props);
      final supportedLocales =
          getValue(maps["supportedLocales"], datas, "", vars, props);
      final showPerformanceOverlay =
          getValue(maps["showPerformanceOverlay"], datas, "", vars, props);
      final checkerboardRasterCacheImages = getValue(
          maps["checkerboardRasterCacheImages"], datas, "", vars, props);
      final checkerboardOffscreenLayers =
          getValue(maps["checkerboardOffscreenLayers"], datas, "", vars, props);
      final showSemanticsDebugger =
          getValue(maps["showSemanticsDebugger"], datas, "", vars, props);
      final debugShowWidgetInspector =
          getValue(maps["debugShowWidgetInspector"], datas, "", vars, props);
      final debugShowCheckedModeBanner =
          getValue(maps["debugShowCheckedModeBanner"], datas, "", vars, props);
      final inspectorSelectButtonBuilder = getValue(
          maps["inspectorSelectButtonBuilder"], datas, "", vars, props);
      final shortcuts = getValue(maps["shortcuts"], datas, "", vars, props);
      final actions = getValue(maps["actions"], datas, "", vars, props);
      final restorationScopeId =
          getValue(maps["restorationScopeId"], datas, "", vars, props);
      final useInheritedMediaQuery =
          getValue(maps["useInheritedMediaQuery"], datas, "", vars, props);
      if (color == null) {
        return null;
      }
      return WidgetsApp(
          key: key,
          navigatorKey: navigatorKey,
          onGenerateRoute: onGenerateRoute,
          onGenerateInitialRoutes: onGenerateInitialRoutes,
          onUnknownRoute: onUnknownRoute,
          navigatorObservers: List<NavigatorObserver>.from(
              navigatorObservers ?? const <NavigatorObserver>[]),
          initialRoute: initialRoute,
          pageRouteBuilder: pageRouteBuilder,
          home: home,
          routes: Map<String, WidgetBuilder>.from(
              routes ?? const <String, WidgetBuilder>{}),
          builder: builder,
          title: title ?? '',
          onGenerateTitle: onGenerateTitle,
          textStyle: textStyle,
          color: color!,
          locale: locale,
          localizationsDelegates: localizationsDelegates,
          localeListResolutionCallback: localeListResolutionCallback,
          localeResolutionCallback: localeResolutionCallback,
          supportedLocales:
              supportedLocales ?? const <Locale>[Locale('en', 'US')],
          showPerformanceOverlay: showPerformanceOverlay ?? false,
          checkerboardRasterCacheImages: checkerboardRasterCacheImages ?? false,
          checkerboardOffscreenLayers: checkerboardOffscreenLayers ?? false,
          showSemanticsDebugger: showSemanticsDebugger ?? false,
          debugShowWidgetInspector: debugShowWidgetInspector ?? false,
          debugShowCheckedModeBanner: debugShowCheckedModeBanner ?? true,
          inspectorSelectButtonBuilder: inspectorSelectButtonBuilder,
          shortcuts: shortcuts,
          actions: actions,
          restorationScopeId: restorationScopeId,
          useInheritedMediaQuery: useInheritedMediaQuery ?? false);
    },
    "WidgetsApp.router": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final routeInformationProvider =
          getValue(maps["routeInformationProvider"], datas, "", vars, props);
      final routeInformationParser =
          getValue(maps["routeInformationParser"], datas, "", vars, props);
      final routerDelegate =
          getValue(maps["routerDelegate"], datas, "", vars, props);
      final routerConfig =
          getValue(maps["routerConfig"], datas, "", vars, props);
      final backButtonDispatcher =
          getValue(maps["backButtonDispatcher"], datas, "", vars, props);
      final builder = getValue(maps["builder"], datas, "", vars, props);
      final title = getValue(maps["title"], datas, "", vars, props);
      final onGenerateTitle =
          getValue(maps["onGenerateTitle"], datas, "", vars, props);
      final textStyle = getValue(maps["textStyle"], datas, "", vars, props);
      final color = getValue(maps["color"], datas, "", vars, props);
      final locale = getValue(maps["locale"], datas, "", vars, props);
      final localizationsDelegates =
          getValue(maps["localizationsDelegates"], datas, "", vars, props);
      final localeListResolutionCallback = getValue(
          maps["localeListResolutionCallback"], datas, "", vars, props);
      final localeResolutionCallback =
          getValue(maps["localeResolutionCallback"], datas, "", vars, props);
      final supportedLocales =
          getValue(maps["supportedLocales"], datas, "", vars, props);
      final showPerformanceOverlay =
          getValue(maps["showPerformanceOverlay"], datas, "", vars, props);
      final checkerboardRasterCacheImages = getValue(
          maps["checkerboardRasterCacheImages"], datas, "", vars, props);
      final checkerboardOffscreenLayers =
          getValue(maps["checkerboardOffscreenLayers"], datas, "", vars, props);
      final showSemanticsDebugger =
          getValue(maps["showSemanticsDebugger"], datas, "", vars, props);
      final debugShowWidgetInspector =
          getValue(maps["debugShowWidgetInspector"], datas, "", vars, props);
      final debugShowCheckedModeBanner =
          getValue(maps["debugShowCheckedModeBanner"], datas, "", vars, props);
      final inspectorSelectButtonBuilder = getValue(
          maps["inspectorSelectButtonBuilder"], datas, "", vars, props);
      final shortcuts = getValue(maps["shortcuts"], datas, "", vars, props);
      final actions = getValue(maps["actions"], datas, "", vars, props);
      final restorationScopeId =
          getValue(maps["restorationScopeId"], datas, "", vars, props);
      final useInheritedMediaQuery =
          getValue(maps["useInheritedMediaQuery"], datas, "", vars, props);
      if (color == null) {
        return null;
      }
      return WidgetsApp.router(
          key: key,
          routeInformationProvider: routeInformationProvider,
          routeInformationParser: routeInformationParser,
          routerDelegate: routerDelegate,
          routerConfig: routerConfig,
          backButtonDispatcher: backButtonDispatcher,
          builder: builder,
          title: title ?? '',
          onGenerateTitle: onGenerateTitle,
          textStyle: textStyle,
          color: color!,
          locale: locale,
          localizationsDelegates: localizationsDelegates,
          localeListResolutionCallback: localeListResolutionCallback,
          localeResolutionCallback: localeResolutionCallback,
          supportedLocales:
              supportedLocales ?? const <Locale>[Locale('en', 'US')],
          showPerformanceOverlay: showPerformanceOverlay ?? false,
          checkerboardRasterCacheImages: checkerboardRasterCacheImages ?? false,
          checkerboardOffscreenLayers: checkerboardOffscreenLayers ?? false,
          showSemanticsDebugger: showSemanticsDebugger ?? false,
          debugShowWidgetInspector: debugShowWidgetInspector ?? false,
          debugShowCheckedModeBanner: debugShowCheckedModeBanner ?? true,
          inspectorSelectButtonBuilder: inspectorSelectButtonBuilder,
          shortcuts: shortcuts,
          actions: actions,
          restorationScopeId: restorationScopeId,
          useInheritedMediaQuery: useInheritedMediaQuery ?? false);
    },
    "WillPopScope": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final child = getValue(maps["child"], datas, "Widget", vars, props);
      final onWillPop =
          getValue(maps["onWillPop"], datas, "WillPopCallback?", vars, props);
      if (child == null || onWillPop == null) {
        return null;
      }
      return WillPopScope(key: key, child: child!, onWillPop: onWillPop!);
    },
    "Wrap": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final direction = getValue(maps["direction"], datas, "Axis", vars, props);
      final alignment =
          getValue(maps["alignment"], datas, "WrapAlignment", vars, props);
      final spacing = getValue(maps["spacing"], datas, "double", vars, props);
      final runAlignment =
          getValue(maps["runAlignment"], datas, "WrapAlignment", vars, props);
      final runSpacing =
          getValue(maps["runSpacing"], datas, "double", vars, props);
      final crossAxisAlignment = getValue(
          maps["crossAxisAlignment"], datas, "WrapCrossAlignment", vars, props);
      final textDirection =
          getValue(maps["textDirection"], datas, "TextDirection?", vars, props);
      final verticalDirection = getValue(
          maps["verticalDirection"], datas, "VerticalDirection", vars, props);
      final clipBehavior =
          getValue(maps["clipBehavior"], datas, "Clip", vars, props);
      final children =
          getValue(maps["children"], datas, "List<Widget>", vars, props);
      return Wrap(
          key: key,
          direction: direction ?? Axis.horizontal,
          alignment: alignment ?? WrapAlignment.start,
          spacing: spacing ?? 0.0,
          runAlignment: runAlignment ?? WrapAlignment.start,
          runSpacing: runSpacing ?? 0.0,
          crossAxisAlignment: crossAxisAlignment ?? WrapCrossAlignment.start,
          textDirection: textDirection,
          verticalDirection: verticalDirection ?? VerticalDirection.down,
          clipBehavior: clipBehavior ?? Clip.none,
          children: List<Widget>.from(children ?? const <Widget>[]));
    },
    "WriteBuffer": () {
      final startCapacity =
          getValue(maps["startCapacity"], datas, "int", vars, props);
      return WriteBuffer(startCapacity: startCapacity ?? 8);
    },
    "YearPicker": () {
      final key = getValue(maps["key"], datas, "Key?", vars, props);
      final currentDate =
          getValue(maps["currentDate"], datas, "DateTime?", vars, props);
      final firstDate =
          getValue(maps["firstDate"], datas, "DateTime", vars, props);
      final lastDate =
          getValue(maps["lastDate"], datas, "DateTime", vars, props);
      final initialDate =
          getValue(maps["initialDate"], datas, "DateTime?", vars, props);
      final selectedDate =
          getValue(maps["selectedDate"], datas, "DateTime", vars, props);
      final onChanged = getValue(
          maps["onChanged"], datas, "ValueChanged<DateTime>", vars, props);
      final dragStartBehavior = getValue(
          maps["dragStartBehavior"], datas, "DragStartBehavior", vars, props);
      if (firstDate == null ||
          lastDate == null ||
          selectedDate == null ||
          onChanged == null) {
        return null;
      }
      return YearPicker(
          key: key,
          currentDate: currentDate,
          firstDate: firstDate!,
          lastDate: lastDate!,
          initialDate: initialDate,
          selectedDate: selectedDate!,
          onChanged: onChanged!,
          dragStartBehavior: dragStartBehavior ?? DragStartBehavior.start);
    },
    "ZoomPageTransitionsBuilder": () {
      final allowSnapshotting =
          getValue(maps["allowSnapshotting"], datas, "bool", vars, props);
      final allowEnterRouteSnapshotting = getValue(
          maps["allowEnterRouteSnapshotting"], datas, "bool", vars, props);
      return ZoomPageTransitionsBuilder(
          allowSnapshotting: allowSnapshotting ?? true,
          allowEnterRouteSnapshotting: allowEnterRouteSnapshotting ?? true);
    },
    "bool.fromEnvironment": () {
      final name = getValue(maps["0"], datas, "String", vars, props);
      final defaultValue =
          getValue(maps["defaultValue"], datas, "bool", vars, props);
      if (name == null) {
        return null;
      }
      return bool.fromEnvironment(name!, defaultValue: defaultValue ?? false);
    },
    "bool.hasEnvironment": () {
      final name = getValue(maps["0"], datas, "String", vars, props);
      if (name == null) {
        return null;
      }
      return bool.hasEnvironment(name!);
    },
    "int.fromEnvironment": () {
      final name = getValue(maps["0"], datas, "String", vars, props);
      final defaultValue =
          getValue(maps["defaultValue"], datas, "int", vars, props);
      if (name == null) {
        return null;
      }
      return int.fromEnvironment(name!, defaultValue: defaultValue ?? 0);
    },
  }[className]
      ?.call();
}
